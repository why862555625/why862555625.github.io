<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>http2升级</title>
      <link href="/posts/d9795d88.html"/>
      <url>/posts/d9795d88.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/why862555625/images/main/image-20231008102528048.png" alt="image-20231008102528048"></p><span id="more"></span><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p><strong>使用http1时的情况：</strong></p><p>假设我们有36个请求需要发送（真实情况160+），由于浏览器的tcp链接限制，最多只能建立6个链接。也就是一次只能发送6个请求，那剩下的30个请求都需要在请求队列中等待。如果这6个请求都是较为耗时的任务（资源大，server处理耗时较长等），那请求队列中的请求等待时间会进一步加长。（项目中累计队列等待时间约为9秒）</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/image-20231007153433034.png" alt="6"></p><p><strong>使用http2时的情况：</strong></p><p>使用http2会对tcp链接进行复用，可以通过一个tcp链接同时发送多个请求。并且可以通过 请求头<code>weight</code>、 <code>depends-on</code>、<code>X-Priority</code>等字段确定优先级，让服务器根据请求头来调整处理顺序。</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/image-20231007155045429.png" alt="image-20231007155045429"></p><blockquote><p>http2优势：</p><ol><li><strong>多路复用（Multiplexing）</strong>：HTTP/2 支持在同一个连接上同时传输多个请求和响应。这样，多个请求可以并行处理，不需要等待之前的请求响应完成，大幅提高了页面加载速度。</li><li><strong>头部压缩（Header Compression）</strong>：HTTP/2 使用 HPACK 算法对头部信息进行压缩，减小了数据包的大小，降低了网络传输的延迟。这种压缩机制减少了带宽的使用，尤其对于大型网页或者请求头很大的场景效果显著。</li><li><strong>二进制分帧（Binary Framing）</strong>：HTTP/2 将所有的传输信息分割为更小的帧（Frames），并且每个帧都被赋予一个唯一的标识符，这种二进制分帧的机制使得协议更加高效，也更容易实现。</li><li><strong>服务器推送（Server Push）</strong>：HTTP/2 允许服务器在客户端请求之前将额外的响应数据推送给客户端，提高了页面加载的速度。这种特性可以避免客户端发送了一个请求后，服务器又返回一个推送的资源。</li><li><strong>优先级（Priority）</strong>：HTTP/2 允许客户端为每个请求设置优先级，确保关键资源首先被传输，提高了页面的渲染速度和用户体验。</li><li><strong>流量控制（Flow Control）</strong>：HTTP/2 支持流量控制，可以防止高速的生产者压倒了较慢的消费者，确保了资源的合理利用。</li><li><strong>支持请求和响应的取消（Request and Response Cancellation）</strong>：HTTP/2 允许取消不需要的请求和响应，提高了灵活性和效率。</li></ol></blockquote><h1 id="计算机网络基本知识"><a href="#计算机网络基本知识" class="headerlink" title="计算机网络基本知识"></a>计算机网络基本知识</h1><h2 id="经典的网络7层协议"><a href="#经典的网络7层协议" class="headerlink" title="经典的网络7层协议"></a>经典的网络7层协议</h2><p><img src="https://raw.githubusercontent.com/why862555625/images/main/MBXY-CR-f2718999645d536b524ca3aaefb9de86.png" alt="img"></p><h2 id="数据传输过程"><a href="#数据传输过程" class="headerlink" title="数据传输过程"></a><strong>数据传输过程</strong></h2><p><img src="https://raw.githubusercontent.com/why862555625/images/main/image-20231007150948424.png" alt="image-20231007150948424"></p><p><strong>（1）应用层传输过程（将其他信息翻译成二进制数据）</strong></p><p>在应用层，数据被”翻译”为网络世界使用的语言——二进制编码数据。大家可以试想一下，人们需要通过计算机传输的数据形式千变万化、各式各样，有字母、数字汉字、图片、声音等。这些信息对于单纯通过弱电流传输的计算机来说太过于”复杂”，因此这些方便人类识别的信息被应用层通过各种特殊的编码过程转换成二进制数据。这就是上面所描述的”翻译”过程，也是应用层在网络数据传输过程中最为核心的贡献。</p><p><strong>（2）传输层传输过程（分割：避免出错代价；标识应用层端口：找到对应应用）</strong></p><p>在传输层，上层数据被分割成小的数据段，并为每个分段后的数据封装TCP报文头部。应用层将人们需要传输的信息转换成计算机能够识别的二进制数据后，这些数据往往都是海量的。例如，一张高清晰的图片转换成二进制数据可能会有几百万甚至几千万位比特，一次性传输如此庞大的数据，一旦网络出现问题而导致数据出错就要重新传输，数据量过大也会增加出错的概率，最终可能导致网络资源耗尽。因此，将数据先分割成小段再逐段传输，一旦数据传输出现错误只需重传这一小段数据即可。</p><p>在TCP头部有一个关键的字段信息——端口号，它用于标识上层的协议或应用程序，确保上层应用数据的正常通信。计算机是可以多进程并发运行的，在通过QQ发送信息的同时也可以通过IE浏览Web页面。但是对于传输层而言，它是不可能”看懂”应用层传输数据的具体内容的，因此只能借助一种标识来确定接收到的数据对应的应用程序，这种标识就是端口号。</p><p><strong>（3）网络层传输过程（寻址ip,标识自己ip）</strong></p><p>在网络层，上层数据被封装上新的报文头部——IP头部。值得注意的是，这里所说的上层数据包括TCP头部，也就是说，这里的上层是指传输层。对于网络层而言，它是”看不懂”TCP包头中的内容的，无论是应用层的应用数据，还是TCP头部信息都属于上层数据。　　　　</p><p>在IP头部中有一个关键的字段信息——IP地址，它是由一组32位的二进制数组成的，用于标识网络的逻辑地址。回想刚才寄信的例子，我们在信封上填写了对方的详细地址和本地的详细地址，以保证收件人能够顺利收到信件。网络层的传输过程与其类似，在IP头部中包含目标IP地址和源IP地址，在网络传输过程中的一些中间设备，如路由器，会根据目标IP地址来进行逻辑寻址，找到正确的路径将数据转发到目的端主机。如果中间的路由设备发现目标的IP地址是不可能到达的，它将会把该消息传回发送端主机，因此在网络层需要同时封装目标 IP和源IP。</p><p><strong>（4）数据链路层传输过程（标识唯一主机）</strong></p><p>在数据链路层，上层数据被封装一个MAC头部，其内部有一个关键的字段信息——MAC地址，它由一组48位的二进制数组成。在目前阶段，我们可以先把它理解为固化在硬件设备中的物理地址，具有全球唯一性。例如，之前讲解的网卡就有属于自己的唯一的MAC地址。和IP头部类似，在MAC头部也同时封装着目标MAC地址和源MAC 地址。</p><p><strong>（5）物理层传输过程（转换成好传输的介质）</strong></p><p>无论在之前封装的报文头部还是上层的数据信息都是由二进制数组成的，在物理层，将这些二进制数字组成的比特流转换成电信号在网络中传输。</p><h2 id="TCP链接建立过程"><a href="#TCP链接建立过程" class="headerlink" title="TCP链接建立过程"></a>TCP链接建立过程</h2><p><img src="https://raw.githubusercontent.com/why862555625/images/main/dev-network-tcpip-4.jpg" alt="img"></p><blockquote><p>一般来说，SYN报文的格式如下：</p><ul><li>源端口号：用于标识发送方的端口号。</li><li>目标端口号：用于标识接收方的端口号。</li><li>序列号（Sequence Number）：用于标识报文的顺序，SYN报文中的序列号表示数据起始位置。</li><li>确认号（Acknowledgment Number）：用于确认已经收到的数据，SYN报文中的确认号表示期望收到的下一个数据的位置。</li><li>数据偏移和保留位（Data Offset and Reserved）：用于指示TCP头部的长度和保留字段，通常为20字节。</li><li>标志位（Flags）：用于标识TCP报文的类型和属性，SYN报文中的SYN标志被置为1。</li><li>窗口大小（Window Size）：用于指示发送方的接收窗口大小。</li><li>校验和（Checksum）：用于校验TCP头部和数据的完整性。</li><li>紧急指针（Urgent Pointer）：用于指示紧急数据的末尾位置。</li><li>选项（Options）：可选字段，包含TCP的一些额外信息。</li></ul></blockquote><p><strong>为什么要四次挥手：因为可能还有数据没有发完。</strong></p><h3 id="TCP协议的慢启动"><a href="#TCP协议的慢启动" class="headerlink" title="TCP协议的慢启动"></a>TCP协议的慢启动</h3><blockquote><p>TCP慢启动（Slow Start）是一种TCP拥塞控制算法，用于在TCP连接刚刚建立或者在拥塞发生后进行连接恢复时，逐渐增加发送窗口大小，以有效地利用网络带宽并避免拥塞引起的数据丢失。</p><p>当一个TCP连接建立时，初始时发送窗口大小（即允许发送的数据量）会被设置为一个较小的值，以避免在网络刚开始使用时可能出现的拥塞。具体而言，TCP慢启动的机制如下：</p><ol><li><strong>初始拥塞窗口（Congestion Window）：</strong> 在TCP连接刚建立时，初始拥塞窗口被设置为一个较小的值，通常为1个或几个段（Segment）的大小。这是为了避免在网络刚开始使用时就发送大量数据，可能引发拥塞。</li><li><strong>指数增长：</strong> 在慢启动阶段，每次接收到一个确认（ACK）时，发送方的拥塞窗口会指数增长。具体地说，拥塞窗口的大小会加倍。例如，如果初始拥塞窗口为1个段，每次接收到一个确认后，窗口大小会变成2，然后4，8，依此类推。这种指数增长的方式使得发送方可以逐渐增加发送的数据量。</li><li><strong>拥塞窗口的调整：</strong> 当拥塞窗口达到一个阈值（通常由网络延迟和带宽决定）或者检测到网络拥塞时，TCP发送方会转入拥塞避免（Congestion Avoidance）阶段，此时拥塞窗口的增长将变得线性而不再是指数增长。</li></ol><p>TCP慢启动的目的是在网络刚开始使用时，逐渐增加发送窗口，测试网络的容量，确保不会引发拥塞。一旦连接稳定，TCP的拥塞窗口逐渐增大，以更好地利用可用带宽，提高数据传输效率。</p></blockquote><p><strong>为什么会慢启动</strong></p><blockquote><p>发送大的窗口在高带宽高延迟网络环境中可以提高数据传输的效率，但如果不合理地设置，可能导致网络拥塞，引发一系列问题。网络拥塞通常发生在网络容量无法满足当前数据传输需求的情况下。以下是发送大的窗口可能引发的问题：</p><ol><li><strong>数据包丢失：</strong> 在网络拥塞时，路由器或交换机可能会丢弃数据包，导致数据传输中断或者丢失部分数据。这会引发需要重新传输数据的情况，增加了网络的负担。</li><li><strong>队头阻塞：</strong> 在网络拥塞时，数据包可能会在网络中形成堆积，这种情况被称为队头阻塞。这会导致后续的数据包等待在队列中，延迟传输，影响了实时性要求高的应用，如在线游戏、语音通话等。</li><li><strong>延迟增加：</strong> 网络拥塞会导致数据包在网络中的传输延迟增加。当发送方没有及时收到确认信息时，它会认为数据包丢失，触发重传机制，这会引起更大的延迟。</li><li><strong>吞吐量下降：</strong> 当网络拥塞发生时，各个连接之间的竞争增加，导致每个连接的吞吐量减少。这意味着网络上的所有数据传输都变慢，影响用户体验。</li><li><strong>不公平性：</strong> 在网络拥塞时，可能会出现不公平性，即某些连接的数据传输速度较快，而其他连接的数据传输速度较慢。这可能会导致某些用户或应用受到不公平待遇。</li></ol></blockquote><h1 id="http协议"><a href="#http协议" class="headerlink" title="http协议"></a>http协议</h1><p>超文本传输协议（HTTP）用于通过超文本链接加载网页。HTTP是应用层协议的一种，在联网设备之间传输信息，并在网络协议堆栈的其他层之上运行。HTTP是基于TCP / IP的通信协议，默认端口是TCP 80，但也可以使用其他端口。</p><h2 id="1-基本特性"><a href="#1-基本特性" class="headerlink" title="1. 基本特性"></a>1. 基本特性</h2><p>HTTP 协议基本特性：</p><ul><li><strong>HTTP 是无连接的：</strong> HTTP客户端，即浏览器发出请求后，客户端等待响应。服务器处理该请求并发送回响应，然后客户端断开连接。客户端和服务器仅在当次请求中互相了解，至于上一次是否有连接或者连接的信息是无从得知的。</li><li><strong>HTTP是独立于媒体的：</strong> 这意味着，只要客户端和服务器都知道如何处理数据内容，任何类型的数据都可以通过HTTP发送。客户端和服务器都需要使用适当的 MIME(多用途互联网邮件扩展) 类型 指定内容类型。</li><li><strong>HTTP是无状态的：</strong> 如上所述，HTTP 是无连接的，这是 HTTP 是无状态协议的直接结果。服务器和客户端仅在当前请求期间彼此知道，之后他们俩彼此忘记。由于协议的这种性质，客户端和浏览器都无法在整个网页的不同请求之间保留信息。</li></ul><h2 id="2-http协议的发展过程"><a href="#2-http协议的发展过程" class="headerlink" title="2. http协议的发展过程"></a>2. <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/Evolution_of_HTTP">http协议的发展过程</a></h2><h4 id="万维网的发明"><a href="#万维网的发明" class="headerlink" title="万维网的发明"></a>万维网的发明</h4><p>1989 年，当时在 CERN 工作的 Tim Berners-Lee 博士写了一份关于建立一个通过网络传输超文本系统的报告。这个系统起初被命名为 <em>Mesh</em>，在随后的 1990 年项目实施期间被更名为<em>万维网</em>（World Wide Web）。它在现有的 TCP 和 IP 协议基础之上建立，由四个部分组成：</p><ul><li>一个用来表示超文本文档的文本格式，*<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML">超文本标记语言</a>*（HTML）。</li><li>一个用来交换超文本文档的简单协议，超文本传输协议（HTTP）。</li><li>一个显示（以及编辑）超文本文档的客户端，即网络浏览器。第一个网络浏览器被称为 <em>WorldWideWeb。</em></li><li>一个服务器用于提供可访问的文档，即 <em>httpd</em> 的前身。</li></ul><p>这四个部分完成于 1990 年底，且第一批服务器已经在 1991 年初在 CERN 以外的地方运行了。1991 年 8 月 16 日，Tim Berners-Lee 在公开的超文本新闻组上<a href="https://www.w3.org/People/Berners-Lee/1991/08/art-6484.txt">发表</a>的文章被视为是万维网公共项目的开始。</p><p>HTTP 在应用的早期阶段非常简单，后来被称为 HTTP/0.9，有时也叫做单行（one-line）协议。</p><h4 id="HTTP-0-9——单行协议"><a href="#HTTP-0-9——单行协议" class="headerlink" title="HTTP/0.9——单行协议"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/Evolution_of_HTTP#http0.9%E2%80%94%E2%80%94%E5%8D%95%E8%A1%8C%E5%8D%8F%E8%AE%AE">HTTP/0.9——单行协议</a></h4><p>最初版本的 HTTP 协议并没有版本号，后来它的版本号被定位在 0.9 以区分后来的版本。HTTP/0.9 极其简单：请求由单行指令构成，以唯一可用方法 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/GET"><code>GET</code></a> 开头，其后跟目标资源的路径（一旦连接到服务器，协议、服务器、端口号这些都不是必须的）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /mypage.html</span><br></pre></td></tr></table></figure><p>响应也极其简单的：只包含响应文档本身。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  这是一个非常简单的 HTML 页面</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>跟后来的版本不同，HTTP/0.9 的响应内容并不包含 HTTP 头。这意味着只有 HTML 文件可以传送，无法传输其他类型的文件。也没有状态码或错误代码。一旦出现问题，一个特殊的包含问题描述信息的 HTML 文件将被发回，供人们查看。</p><h4 id="HTTP-1-0——构建可扩展性"><a href="#HTTP-1-0——构建可扩展性" class="headerlink" title="HTTP/1.0——构建可扩展性"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/Evolution_of_HTTP#http1.0%E2%80%94%E2%80%94%E6%9E%84%E5%BB%BA%E5%8F%AF%E6%89%A9%E5%B1%95%E6%80%A7">HTTP/1.0——构建可扩展性</a></h4><p>由于 HTTP/0.9 协议的应用十分有限，浏览器和服务器迅速扩展内容使其用途更广：</p><ul><li>协议版本信息现在会随着每个请求发送（<code>HTTP/1.0</code> 被追加到了 <code>GET</code> 行）。</li><li>状态码会在响应开始时发送，使浏览器能了解请求执行成功或失败，并相应调整行为（如更新或使用本地缓存）。</li><li>引入了 HTTP 标头的概念，无论是对于请求还是响应，允许传输元数据，使协议变得非常灵活，更具扩展性。</li><li>在新 HTTP 标头的帮助下，具备了传输除纯文本 HTML 文件以外其他类型文档的能力（凭借 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Type"><code>Content-Type</code></a> 标头）。</li></ul><h4 id="HTTP-1-1——标准化的协议"><a href="#HTTP-1-1——标准化的协议" class="headerlink" title="HTTP/1.1——标准化的协议"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/Evolution_of_HTTP#http1.1%E2%80%94%E2%80%94%E6%A0%87%E5%87%86%E5%8C%96%E7%9A%84%E5%8D%8F%E8%AE%AE">HTTP/1.1——标准化的协议</a></h4><p>HTTP/1.1 消除了大量歧义内容并引入了多项改进：</p><ul><li>连接可以复用，节省了多次打开 TCP 连接加载网页文档资源的时间。</li><li>支持响应分块。</li><li>引入额外的缓存控制机制。</li><li>引入内容协商机制，包括语言、编码、类型等。并允许客户端和服务器之间约定以最合适的内容进行交换。</li><li>凭借 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Host"><code>Host</code></a> 标头，能够使不同域名配置在同一个 IP 地址的服务器上。</li></ul><h4 id="HTTP-2——为了更优异的表现"><a href="#HTTP-2——为了更优异的表现" class="headerlink" title="HTTP/2——为了更优异的表现"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/Evolution_of_HTTP#http2%E2%80%94%E2%80%94%E4%B8%BA%E4%BA%86%E6%9B%B4%E4%BC%98%E5%BC%82%E7%9A%84%E8%A1%A8%E7%8E%B0">HTTP/2——为了更优异的表现</a></h4><p>这些年来，网页愈渐变得的复杂，甚至演变成了独有的应用，可见媒体的播放量，增进交互的脚本大小也增加了许多：更多的数据通过 HTTP 请求被传输。HTTP/1.1 链接需要请求以正确的顺序发送，理论上可以用一些并行的链接（尤其是 5 到 8 个），带来的成本和复杂性堪忧。比如，HTTP 管线化（pipelining）就成为了 Web 开发的负担。为此，在 2010 年早期，谷歌通过实践了一个实验性的 SPDY 协议。这种在客户端和服务器端交换数据的替代方案引起了在浏览器和服务器上工作的开发人员的兴趣。明确了响应数量的增加和解决复杂的数据传输，SPDY 成为了 HTTP/2 协议的基础。</p><p>HTTP/2 在 HTTP/1.1 有几处基本的不同：</p><ul><li>HTTP/2 是二进制协议而不是文本协议。不再可读，也不可无障碍的手动创建，改善的优化技术现在可被实施。</li><li>这是一个多路复用协议。并行的请求能在同一个链接中处理，移除了 HTTP/1.x 中顺序和阻塞的约束。</li><li>压缩了标头。因为标头在一系列请求中常常是相似的，其移除了重复和传输重复数据的成本。</li><li>其允许服务器在客户端缓存中填充数据，通过一个叫服务器推送的机制来提前请求。</li></ul><p>在 2015 年 5 月正式标准化后，HTTP/2 取得了极大的成功，在 2022 年 1 月达到峰值，占所有网站的 46.9%（见<a href="https://w3techs.com/technologies/details/ce-http2">这些统计数据</a>）。高流量的站点最迅速的普及，在数据传输上节省了可观的成本和支出。</p><p>这种迅速的普及率很可能是因为 HTTP2 不需要站点和应用做出改变：使用 HTTP/1.1 和 HTTP/2 对他们来说是透明的。拥有一个最新的服务器和新点的浏览器进行交互就足够了。只有一小部分群体需要做出改变，而且随着陈旧的浏览器和服务器的更新，而不需 Web 开发者做什么，用的人自然就增加了。</p><h2 id="3-协议头"><a href="#3-协议头" class="headerlink" title="3. 协议头"></a>3. 协议头</h2><p><strong>协议头的重要性（协议头的大小通常在几K到数十K之间）：</strong></p><blockquote><p>HTTP协议头具有以下几个重要的作用：</p><ol><li><strong>传递元数据：</strong> 协议头中可以包含各种元数据，如数据类型、字符编码、内容长度、响应状态等。这些信息有助于客户端和服务器了解所传输数据的特性，以正确地解析和处理数据。</li><li><strong>控制缓存和缓存策略：</strong> 协议头中的Cache-Control、Expires等字段可以指示浏览器或代理服务器如何缓存响应数据，以及缓存的有效期。这些信息有助于提高性能，减少不必要的网络请求。</li><li><strong>进行身份验证：</strong> HTTP协议头中的Authorization字段允许客户端向服务器发送身份验证信息，例如用户名和密码，以便访问受保护的资源。</li><li><strong>处理请求方法：</strong> 请求中的HTTP方法（GET、POST、PUT、DELETE等）通常通过HTTP头部中的请求行指定，告诉服务器客户端希望执行的操作。</li><li><strong>重定向：</strong> 通过HTTP响应头的Location字段，服务器可以告知客户端进行重定向，将请求重定向到其他URL。</li><li><strong>传递Cookie信息：</strong> HTTP请求头中的Cookie字段可以用于传递客户端的身份认证信息，服务器可以根据这些信息识别用户。</li><li><strong>提供安全性：</strong> HTTP头部中的一些字段，例如Strict-Transport-Security（严格传输安全性策略）等，可以增强通信的安全性。</li></ol></blockquote><h3 id="报文示例："><a href="#报文示例：" class="headerlink" title="报文示例："></a>报文示例：</h3><p><strong>请求头报文</strong>（<a href="https://juejin.cn/post/6844903745004765198">常见请求头响应头</a>）</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/20180926095056907" alt="img"></p><p><strong>响应头报文</strong></p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/20180926113041788" alt="img"></p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="4-详解HTTP2"><a href="#4-详解HTTP2" class="headerlink" title="4. 详解HTTP2"></a>4. 详解HTTP2</h2><blockquote><p>http2优势：</p><ol><li><strong>多路复用（Multiplexing）</strong>：HTTP/2 支持在同一个连接上同时传输多个请求和响应。这样，多个请求可以并行处理，不需要等待之前的请求响应完成，大幅提高了页面加载速度。</li><li><strong>头部压缩（Header Compression）</strong>：HTTP/2 使用 HPACK 算法对头部信息进行压缩，减小了数据包的大小，降低了网络传输的延迟。这种压缩机制减少了带宽的使用，尤其对于大型网页或者请求头很大的场景效果显著。</li><li><strong>二进制分帧（Binary Framing）</strong>：HTTP/2 将所有的传输信息分割为更小的帧（Frames），并且每个帧都被赋予一个唯一的标识符，这种二进制分帧的机制使得协议更加高效，也更容易实现。</li><li><strong>服务器推送（Server Push）</strong>：HTTP/2 允许服务器在客户端请求之前将额外的响应数据推送给客户端，提高了页面加载的速度。这种特性可以避免客户端发送了一个请求后，服务器又返回一个推送的资源。</li><li><strong>优先级（Priority）</strong>：HTTP/2 允许客户端为每个请求设置优先级，确保关键资源首先被传输，提高了页面的渲染速度和用户体验。</li><li><strong>流量控制（Flow Control）</strong>：HTTP/2 支持流量控制，可以防止高速的生产者压倒了较慢的消费者，确保了资源的合理利用。</li><li><strong>支持请求和响应的取消（Request and Response Cancellation）</strong>：HTTP/2 允许取消不需要的请求和响应，提高了灵活性和效率。</li></ol></blockquote><h3 id="1、二进制分帧层-Binary-Framing-Layer"><a href="#1、二进制分帧层-Binary-Framing-Layer" class="headerlink" title="1、二进制分帧层 (Binary Framing Layer)"></a>1、二进制分帧层 (Binary Framing Layer)</h3><blockquote><p>优点：</p><ol><li><strong>更高的效率：</strong> 二进制帧的结构更加紧凑，相比于文本协议更加高效。这减少了在网络上传输的数据量，特别是在带宽受限的情况下，可以提高传输速度。</li><li><strong>多路复用（Multiplexing）：</strong> HTTP/2 支持多路复用，即可以在一个连接上同时传输多个请求和响应，而不需要按照顺序等待前一个请求的响应。这是通过在一个连接上使用二进制帧实现的，每个帧都被标识为属于哪个流（Stream），从而实现了并发传输，提高了网络利用率。</li><li><strong>头部压缩（Header Compression）：</strong> HTTP/2 使用 HPACK 算法对请求和响应的头部进行压缩，减小了每个帧的头部大小，节省了带宽。因为二进制帧的结构更加紧凑，压缩后的数据传输效率更高。</li><li><strong>优先级和依赖关系（Priority and Dependency）：</strong> HTTP/2 允许在帧中设置优先级和依赖关系，使得服务器和客户端可以更好地控制数据流的优先级，确保关键资源的优先传输。</li><li><strong>更好的错误处理：</strong> HTTP/2 的二进制帧结构允许更细致地标识错误，例如在一个响应的头部中指定错误码，而不必等到整个响应体传输完毕才能得知错误</li></ol></blockquote><blockquote><p>二进制帧更加紧凑的原因：</p><ol><li><strong>固定长度的帧头：</strong> 在 HTTP/2 中，帧头的长度是固定的，相比于 HTTP/1.x 的文本头部，这种结构更加简单，减少了额外的信息传输。每个帧的帧头固定占用9个字节（8字节的帧长度和1字节的帧类型），相较于 HTTP/1.x 的文本头部，这是一个很小的开销。</li><li><strong>二进制压缩：</strong> HTTP/2 使用了 HPACK 算法对请求和响应的头部进行二进制压缩，将头部字段名和字段值映射为索引，用更小的二进制表示，减少了传输的数据量。这种二进制压缩的头部信息更加紧凑，节省了带宽。</li><li><strong>优先级和依赖关系：</strong> HTTP/2 允许在帧中设置优先级和依赖关系，这样服务器和客户端可以更精细地控制数据流的传输顺序。这种信息也可以更紧凑地编码，避免了传输额外的文本信息。</li><li><strong>数据帧和头部帧分离：</strong> 在 HTTP/2 中，请求和响应的数据（Data）和头部（Headers）被分开传输，每种类型的帧专注于传输特定类型的数据。这样的分离可以提高帧的结构紧凑性，因为每个帧只需要携带特定类型的信息。</li></ol></blockquote><h5 id="帧-Frame（选读）"><a href="#帧-Frame（选读）" class="headerlink" title="帧 - Frame（选读）"></a>帧 - Frame（选读）</h5><p>所有帧都是一个固定的 9 字节头部 (payload 之前) 跟一个指定长度的负载 (payload):</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+-----------------------------------------------+</span><br><span class="line">|                 Length (24)                   |</span><br><span class="line">+---------------+---------------+---------------+</span><br><span class="line">|   Type (8)    |   Flags (8)   |</span><br><span class="line">+-+-------------+---------------+-------------------------------+</span><br><span class="line">|R|                 Stream Identifier (31)                      |</span><br><span class="line">+=+=============================================================+</span><br><span class="line">|                   Frame Payload (0...)                      ...</span><br><span class="line">+---------------------------------------------------------------+</span><br></pre></td></tr></table></figure><blockquote><ul><li><code>Length</code> 代表整个 frame 的长度，用一个 24 位无符号整数表示。除非接收者在 SETTINGS_MAX_FRAME_SIZE 设置了更大的值 (大小可以是 2^14(16384) 字节到 2^24-1(16777215) 字节之间的任意值)，否则数据长度不应超过 2^14(16384) 字节。头部的 9 字节不算在这个长度里</li><li><code>Type</code> 定义 frame 的类型，用 8 bits 表示。帧类型决定了帧主体的格式和语义，如果 type 为 unknown 应该忽略或抛弃。</li><li><code>Flags</code> 是为帧类型相关而预留的布尔标识。标识对于不同的帧类型赋予了不同的语义。如果该标识对于某种帧类型没有定义语义，则它必须被忽略且发送的时候应该赋值为 (0x0)</li><li><code>R</code> 是一个保留的比特位。这个比特的语义没有定义，发送时它必须被设置为 (0x0), 接收时需要忽略。</li><li><a href="https://link.juejin.cn/?target=https://httpwg.org/specs/rfc7540.html%23StreamIdentifiers">Stream Identifier</a> 用作流控制，用 31 位无符号整数表示。客户端建立的 sid 必须为奇数，服务端建立的 sid 必须为偶数，值 (0x0) 保留给与整个连接相关联的帧 (连接控制消息)，而不是单个流</li><li><code>Frame Payload</code> 是主体内容，由帧类型决定</li></ul></blockquote><p>共分为十种类型的帧:</p><blockquote><ul><li><code>HEADERS</code>: 报头帧 (type=0x1)，用来打开一个流或者携带一个首部块片段</li><li><code>DATA</code>: 数据帧 (type=0x0)，装填主体信息，可以用一个或多个 DATA 帧来返回一个请求的响应主体</li><li><code>PRIORITY</code>: 优先级帧 (type=0x2)，指定发送者建议的流优先级，可以在任何流状态下发送 PRIORITY 帧，包括空闲 (idle) 和关闭 (closed) 的流</li><li><code>RST_STREAM</code>: 流终止帧 (type=0x3)，用来请求取消一个流，或者表示发生了一个错误，payload 带有一个 32 位无符号整数的错误码 (<a href="https://link.juejin.cn/?target=https://httpwg.org/specs/rfc7540.html%23ErrorCodes">Error Codes</a>)，不能在处于空闲 (idle) 状态的流上发送 RST_STREAM 帧</li><li><code>SETTINGS</code>: 设置帧 (type=0x4)，设置此 <code>连接</code> 的参数，作用于整个连接</li><li><code>PUSH_PROMISE</code>: 推送帧 (type=0x5)，服务端推送，客户端可以返回一个 RST_STREAM 帧来选择拒绝推送的流</li><li><code>PING</code>: PING 帧 (type=0x6)，判断一个空闲的连接是否仍然可用，也可以测量最小往返时间 (RTT)</li><li><code>GOAWAY</code>: GOWAY 帧 (type=0x7)，用于发起关闭连接的请求，或者警示严重错误。GOAWAY 会停止接收新流，并且关闭连接前会处理完先前建立的流</li><li><code>WINDOW_UPDATE</code>: 窗口更新帧 (type=0x8)，用于执行流量控制功能，可以作用在单独某个流上 (指定具体 Stream Identifier) 也可以作用整个连接 (Stream Identifier 为 0x0)，只有 DATA 帧受流量控制影响。初始化流量窗口后，发送多少负载，流量窗口就减少多少，如果流量窗口不足就无法发送，WINDOW_UPDATE 帧可以增加流量窗口大小</li><li><code>CONTINUATION</code>: 延续帧 (type=0x9)，用于继续传送首部块片段序列</li></ul></blockquote><p><strong>DATA 帧格式</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+---------------+</span><br><span class="line">|Pad Length? (8)|</span><br><span class="line">+---------------+-----------------------------------------------+</span><br><span class="line">|                            Data (*)                         ...</span><br><span class="line">+---------------------------------------------------------------+</span><br><span class="line">|                           Padding (*)                       ...</span><br><span class="line">+---------------------------------------------------------------+</span><br></pre></td></tr></table></figure><blockquote><ul><li><code>Pad Length</code>: ? 表示此字段的出现时有条件的，需要设置相应标识 (set flag)，指定 Padding 长度，存在则代表 PADDING flag 被设置</li><li><code>Data</code>: 传递的数据，其长度上限等于帧的 payload 长度减去其他出现的字段长度</li><li><code>Padding</code>: 填充字节，没有具体语义，发送时必须设为 0，作用是混淆报文长度，与 TLS 中 CBC 块加密类似</li></ul></blockquote><p>DATA 帧有如下标识 (flags):</p><blockquote><ul><li>END_STREAM: bit 0 设为 1 代表当前流的最后一帧</li><li>PADDED: bit 3 设为 1 代表存在 Padding</li></ul></blockquote><p><strong>HEADERS 帧格式</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+---------------+</span><br><span class="line"> |Pad Length? (8)|</span><br><span class="line"> +-+-------------+-----------------------------------------------+</span><br><span class="line"> |E|                 Stream Dependency? (31)                     |</span><br><span class="line"> +-+-------------+-----------------------------------------------+</span><br><span class="line"> |  Weight? (8)  |</span><br><span class="line"> +-+-------------+-----------------------------------------------+</span><br><span class="line"> |                   Header Block Fragment (*)                 ...</span><br><span class="line"> +---------------------------------------------------------------+</span><br><span class="line"> |                           Padding (*)                       ...</span><br><span class="line"> +---------------------------------------------------------------+</span><br></pre></td></tr></table></figure><blockquote><ul><li><code>Pad Length</code>: 指定 Padding 长度，存在则代表 PADDING flag 被设置</li><li><code>E</code>: 一个比特位声明流的依赖性是否是排他的，存在则代表 PRIORITY flag 被设置</li><li><code>Stream Dependency</code>: 指定一个 stream identifier，代表当前流所依赖的流的 id，存在则代表 PRIORITY flag 被设置</li><li><code>Weight</code>: 一个无符号 8 为整数，代表当前流的优先级权重值 (1~256)，存在则代表 PRIORITY flag 被设置</li><li><code>Header Block Fragment</code>: header 块片段</li><li><code>Padding</code>: 填充字节，没有具体语义，作用与 DATA 的 Padding 一样，存在则代表 PADDING flag 被设置</li></ul></blockquote><p>HEADERS 帧有以下标识 (flags):</p><blockquote><ul><li>END_STREAM: bit 0 设为 1 代表当前 header 块是发送的最后一块，但是带有 END_STREAM 标识的 HEADERS 帧后面还可以跟 CONTINUATION 帧 (这里可以把 CONTINUATION 看作 HEADERS 的一部分)</li><li>END_HEADERS: bit 2 设为 1 代表 header 块结束</li><li>PADDED: bit 3 设为 1 代表 Pad 被设置，存在 Pad Length 和 Padding</li><li>PRIORITY: bit 5 设为 1 表示存在 Exclusive Flag (E), Stream Dependency, 和 Weight</li></ul></blockquote><h3 id="2-Header-压缩-HPACK"><a href="#2-Header-压缩-HPACK" class="headerlink" title="2. Header 压缩 (HPACK)"></a>2. Header 压缩 (HPACK)</h3><p>HTTP/2 中的头部压缩是指使用 HPACK 算法对请求和响应的头部信息进行压缩，从而减小传输的数据量。在传统的 HTTP/1.x 中，每次请求和响应都要携带大量的头部信息，这些信息包括请求方法、URL、Cookie、User-Agent 等等。在 HTTP/1.x 中，这些头部信息通常是文本形式，相对繁琐，而且重复的信息较多。</p><p>HTTP/2 引入了头部压缩的机制，通过以下步骤来减小头部信息的传输量：</p><ol><li><strong>索引（Indexing）：</strong> HTTP/2 的头部压缩使用了索引的概念。在通信的双方维护一个头部字段表（Header Table），每个字段都有一个唯一的整数索引号（KEY,value,都在表中）。当发送方需要发送一个头部字段时，如果该字段在表中已经存在，发送的只是这个字段的索引号，而不是完整的字段名和字段值。接收方根据索引号在本地的表中查找对应的字段，从而还原出完整的头部信息。</li><li><strong>字面量和索引结合（Literal with Incremental Indexing）：</strong> 如果头部字段不在表中，发送方可以选择将字段的字面量（Literal）和索引号同时发送给接收方，接收方将字段添加到本地的头部字段表中，以备将来的引用。</li><li><strong>去除冗余字段（Duplicate Fields Elimination）：</strong> 在 HTTP/2 中，相同字段名的多个字段值可以合并成一个字段，这样就避免了重复传输相同字段名的问题。</li><li><strong>动态表大小调整（Dynamic Table Size Update）：</strong> 头部字段表的大小是可以动态调整的。发送方可以通过发送特定帧（SETTINGS Frame）来通知接收方动态表的最大大小，接收方根据这个信息来调整本地的头部字段表大小。</li></ol><p>通过以上机制，HTTP/2 的头部压缩有效地减小了头部信息的传输量，提高了性能。这种压缩机制在实际应用中，特别是对于带宽受限的移动网络环境，显著减少了请求和响应的传输时间，提高了页面加载速度和用户体验。</p><h5 id="-1"><a href="#-1" class="headerlink" title=""></a></h5><h3 id="3-多路复用-MultiPlexing-（最重要：解决队列堵塞问题，提高网络利用率）"><a href="#3-多路复用-MultiPlexing-（最重要：解决队列堵塞问题，提高网络利用率）" class="headerlink" title="3. 多路复用 (MultiPlexing)（最重要：解决队列堵塞问题，提高网络利用率）"></a>3. 多路复用 (MultiPlexing)（最重要：解决队列堵塞问题，提高网络利用率）</h3><p>在一个 TCP 连接上，我们可以向对方不断发送帧，每帧的 stream identifier 的标明这一帧属于哪个流，然后在对方接收时，根据 stream identifier 拼接每个流的所有帧组成一整块数据。 把 HTTP/1.1 每个请求都当作一个流，那么多个请求变成多个流，请求响应数据分成多个帧，不同流中的帧交错地发送给对方，这就是 HTTP/2 中的多路复用。</p><h4 id="流-Stream（选读）"><a href="#流-Stream（选读）" class="headerlink" title="流 - Stream（选读）"></a>流 - Stream（选读）</h4><p>流只是一个逻辑上的概念，代表 HTTP/2 连接中在客户端和服务器之间交换的独立双向帧序列，每个帧的 Stream Identifier 字段指明了它属于哪个流。</p><p>流有以下特性:</p><ul><li>单个 h2 连接可以包含多个并发的流，两端之间可以交叉发送不同流的帧</li><li>流可以由客户端或服务器来单方面地建立和使用，或者共享</li><li>流可以由任一方关闭</li><li>帧在流上发送的顺序非常重要，最后接收方会把相同 Stream Identifier (同一个流) 的帧重新组装成完整消息报文</li></ul><p><strong>流的状态</strong></p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/1658dc4f199f3191%7Etplv-t2oaga2asx-jj-mark%3A3024%3A0%3A0%3A0%3Aq75.png" alt="image"></p><blockquote><p>注意图中的 send 和 recv 对象是指端点，不是指当前的流</p></blockquote><p><strong>idle</strong></p><p>所有流以“空闲”状态开始。在这种状态下，没有任何帧的交换</p><p>其状态转换:</p><ul><li><p>发送或者接收一个 HEADERS 帧会使空闲 <code>idle</code> 流变成打开 <code>open</code> 状态，其中 HEADERS 帧的 Stream Identifier 字段指明了流 id。同样的 HEADERS 帧(带有 END_STREAM )也可以使一个流立即进入 half-closed 状态。</p></li><li><p>服务端必须在一个打开 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open</span><br></pre></td></tr></table></figure><p> 或者半关闭 (远端) </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">half-closed(remote)</span><br></pre></td></tr></table></figure><p> 状态的流 (由客户端发起的) 上发送 PUSH_PROMISE 帧，其中 PUSH_PROMISE 帧的 Promised Stream ID 字段指定了一个预示的新流 (由服务端发起)，</p><ul><li>在服务端该新流会由空闲 <code>idle</code> 状态进入被保留的 (本地) <code>reserved(local)</code> 状态</li><li>在客户端该新流会由空闲 <code>idle</code> 状态进入被保留的 (远端) <code>reserved(remote)</code> 状态</li></ul></li></ul><blockquote><p>在 <a href="https://link.juejin.cn/?target=https://httpwg.org/specs/rfc7540.html%23discover-http">3.2 - Starting HTTP/2 for “http” URIs</a> 中介绍了一种特殊情况:</p><blockquote><p>客户端发起一个 HTTP/1.1 请求，请求带有 Upgrade 机制，想创建 h2c 连接，服务端同意升级返回 101 响应。 升级之前发送的 HTTP/1.1 请求被分配一个流标识符 0x1，并被赋予默认优先级值。从客户端到服务端这个流 1 隐式地转为 “half-closed” 状态，因为作为 HTTP/1.1 请求它已经完成了。HTTP/2 连接开始后，流 1 用于响应。详细过程可以看下文的 <a href="#HTTP-2-%E7%9A%84%E5%8D%8F%E8%AE%AE%E5%8D%8F%E5%95%86%E6%9C%BA%E5%88%B6">HTTP/2 的协议协商机制</a></p></blockquote></blockquote><p>此状态下接收到 HEADERS 和 PRIORITY 以外的帧被视为 PROTOCOL_ERROR</p><p>状态图中 <code>send PP</code> 和 <code>recv PP</code> 是指连接的双方端点发送或接收了 PUSH_PROMISE，不是指某个空闲流发送或接收了 PUSH_PROMISE，是 PUSH_PROMISE 的出现促使一个预示的流从 <code>idle</code> 状态转为 <code>reserved</code></p><blockquote><p>在下文 <a href="#Server-Push">Server-Push</a> 中会详细介绍服务端推送的内容和 PUSH_PROMISE 的使用情形</p></blockquote><p><strong>reserved (local) / reserved (remote)</strong></p><p>PUSH_PROMISE 预示的流由 <code>idle</code> 状态进入此状态，代表准备进行 Server push</p><p>其状态转换:</p><ul><li>PUSH_PROMISE 帧预示的流的响应以 HEADERS 帧开始，这会立即将该流在服务端置于半关闭 (远端) <code>half-closed(remote)</code> 状态，在客户端置于半关闭 (本地) <code>half-closed(local)</code> 状态，最后以携带 END_STREAM 的帧结束，这会将流置于关闭 <code>closed</code> 状态</li><li>任一端点都可以发送 RST_STREAM 帧来终止这个流，其状态由 <code>reserved</code> 转为 <code>closed</code></li></ul><p><code>reserved(local)</code> 状态下的流不能发送 HEADERS、RST_STREAM、PRIORITY 以外的帧，接收到 RST_STREAM、PRIORITY、WINDOW_UPDATE 以外的帧被视为 PROTOCOL_ERROR</p><p><code>reserved(remote)</code> 状态下的流不能发送 RST_STREAM、WINDOW_UPDATE、PRIORITY 以外的帧，接收到 HEADERS、RST_STREAM、PRIORITY 以外的帧被视为 PROTOCOL_ERROR</p><p><strong>open</strong></p><p>处于 <code>open</code> 状态的流可以被两个对端用来发送任何类型的帧</p><p>其状态转换:</p><ul><li>任一端都可以发送带有 END_STREAM 标识的帧，发送方会转入 <code>half-closed(local)</code> 状态；接收方会转入 <code>half-closed(remote)</code> 状态</li><li>任一端都可以发送 RST_STREAM 帧，这会使流立即进入 <code>closed</code> 状态</li></ul><p><strong>half-closed (local)</strong></p><p>流是双向的，半关闭表示这个流单向关闭了，local 代表本端到对端的方向关闭了，remote 代表对端到本端的方向关闭了</p><p>此状态下的流不能发送 WINDOW_UPDATE、PRIORITY、RST_STREAM 以外的帧</p><p>当此状态下的流收到带有 END_STREAM 标识的帧或者任一方发送 RST_STREAM 帧，会转为 <code>closed</code> 状态</p><p>此状态下的流收到的 PRIORITY 帧用以调整流的依赖关系顺序，可以看下文的流优先级</p><p><strong>half-closed (remote)</strong></p><p>此状态下的流不会被对端用于发送帧，执行流量控制的端点不再有义务维护接收方的流控制窗口。</p><p>一个端点在此状态的流上接收到 WINDOW_UPDATE、PRIORITY、RST_STREAM 以外的帧，应该响应一个 STREAM_CLOSED 流错误</p><p>此状态下的流可以被端点用于发送任意类型的帧，且此状态下该端点仍会观察流级别的流控制的限制</p><p>当此状态下的流发送带有 END_STREAM 标识的帧或者任一方发送 RST_STREAM 帧，会转为 <code>closed</code> 状态</p><p><strong>closed</strong></p><p>代表流已关闭</p><p>此状态下的流不能发送 PRIORITY 以外的帧，发送 PRIORITY 帧是调整那些依赖这个已关闭的流的流优先级，端点都应该处理 PRIORITY 帧，尽管如果该流从依赖关系树中移除了也可以忽略优先级帧</p><p>此状态下在收到带有 END_STREAM 标识的 DATA 或 HEADERS 帧后的一小段时间内 (period) 仍可能接收到 WINDOW_UPDATE 或 RST_STREAM 帧，因为在远程对端接收并处理 RST_STREAM 或带有 END_STREAM 标志的帧之前，它可能会发送这些类型的帧。但是端点必须忽略接收到的 WINDOW_UPDATE 或 RST_STREAM</p><p>如果一个流发送了 RST_STREAM 帧后转入此状态，而对端接收到 RST_STREAM 帧时可能已经发送了或者处在发送队列中，这些帧是不可撤销的，发送 RST_STREAM 帧的端点必须忽略这些帧。</p><p>一个端点可以限制 period 的长短，在 period 内接受的帧会忽略，超出 period 的帧被视为错误。</p><p>一个端点发送了 RST_STREAM 帧后接收到流控制帧(比如 DATA)，仍会计入流量窗口，即使这些帧会被忽略，因为对端肯定是在接收到 RST_STREAM 帧前发送的流控制帧，对端会认为流控制已生效</p><p>一个端点可能会在发送了 RST_STREAM 帧后收到 PUSH_PROMISE 帧，即便预示的流已经被重置 (reset)，PUSH_PROMISE 帧也能使预示流变成 <code>reserved</code> 状态。因此，需要 RST_STREAM 来关闭一个不想要的预示流。</p><blockquote><p>PRIORITY 帧可以被任意状态的流发送和接收，未知类型的帧会被忽略</p></blockquote><p><strong>流状态的转换</strong></p><p>下面看两个例子来理解流状态:</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/1658dc4f32767fb6%7Etplv-t2oaga2asx-jj-mark%3A3024%3A0%3A0%3A0%3Aq75.png" alt="image"></p><p>(1)、Server 在 Client 发起的一个流上发送 PUSH_PROMISE 帧，其 Promised Stream ID 指定一个预示流用于后续推送，send PP 后这个预示流在服务端从 idle 状态转为 reserve(local) 状态，客户端 recv PP 后这个流从 idle 状态转为 reserve(remote) 状态</p><p>(2)(3)、此时预示流处于保留状态，客户端如果选择拒绝接受推送，可以发送 RST 帧关闭这个流；服务端如果此时出问题了也可以发送 RST 帧取消推送。不管哪一方发送或接收到 RST，此状态都转为 closed</p><p>(4)、没有出现重置说明推送仍有效，则服务端开始推送，首先发送的肯定是响应的 HEADERS 首部块，此时流状态转为半关闭 half-closed(remote)；客户端接收到 HEADERS 后流状态转为半关闭 half-closed(local)</p><p>(5)(6)、半关闭状态下的流应该还会继续推送诸如 DATA 帧、CONTINUATION 帧这样的数据帧，如果这个过程碰到任一方发起重置，则流会关闭进入 closed 状态</p><p>(7)、如果一切顺利，资源随着数据帧响应完毕，最后一帧会带上 END_STREAM 标识代表这个流结束了，此时流转为 closed 状态</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/1658dc4f58e6679e%7Etplv-t2oaga2asx-jj-mark%3A3024%3A0%3A0%3A0%3Aq75.png" alt="image"></p><p>(1)、客户端发起请求，首先发送一个 HEADERS 帧，其 Stream Identifier 创建一个新流，此流从 idle 状态转为 open 状态</p><p>(2)(3)、如果客户端取消请求可以发送 RST 帧，服务端出错也可以发送 RST 帧，不管哪一方接收或发送 RST，流关闭进入 closed 状态；</p><p>(4)、如果请求结束(END_STREAM)，流转为半关闭状态。假如是 GET 请求，一般 HEADERS 帧就是最后一帧，send H 后流会立即进入半关闭状态。假如是 POST 请求，待数据传完，最后一帧带上 END_STREAM 标识，流转为半关闭</p><p>(5)(6)、客户端半关闭后服务端开始返回响应，此时任一方接收或发送 RST，流关闭；</p><p>(7)、如果一切顺利，等待响应结束(END_STREAM)，流关闭</p><p><strong>流的标识符</strong></p><p>流 ID 是 31 位无符号整数，客户端发起的流必须是奇数，服务端发起的流必须是偶数，0x0 保留为连接控制消息不能用于建立新流。</p><p>HTTP/1.1 Upgrade to HTTP/2 时响应的流 ID 是 0x1，在升级完成之后，流 0x1 在客户端会转为 <code>half-closed (local)</code> 状态，因此这种情况下客户端不能用 0x1 初始化一个流</p><p>新建立的流的 ID 必须大于所有已使用过的数字，接收到一个错误大小的 ID 应该返回 PROTOCOL_ERROR 响应</p><p>使用一个新流时隐式地关闭了对端发起的 ID 小于当前流的且处于 <code>idle</code> 状态的流，比如一个流发送一个 HEADERS 帧打开了 ID 为 7 的流，但还从未向 ID 为 5 的流发送过帧，则流 0x5 会在 0x7 发送完或接收完第一帧后转为 <code>closed</code> 状态</p><p>一个连接内的流 ID 不能重用</p><p><strong>流的优先级</strong></p><p>客户端可以通过 HEADERS 帧的 PRIORITY 信息指定一个新建立流的优先级，其他期间也可以发送 PRIORITY 帧调整流优先级</p><p>设置优先级的目的是为了让端点表达它所期望对端在并发的多个流之间如何分配资源的行为。更重要的是，当发送容量有限时，可以使用优先级来选择用于发送帧的流。</p><p>流可以被标记为依赖其他流，所依赖的流完成后再处理当前流。每个依赖 (dependency) 后都跟着一个权重 (weight)，这一数字是用来确定依赖于相同的流的可分配可用资源的相对比例</p><p><strong>流依赖(Stream Dependencies)</strong></p><p>每个流都可以显示地依赖另一个流，包含依赖关系表示优先将资源分配给指定的流(上层节点)而不是依赖流</p><p>一个不依赖于其他流的流会指定 stream dependency 为 0x0 值，因为不存在的 0x0 流代表依赖树的根</p><p>一个依赖于其他流的流叫做<strong>依赖流</strong>，被依赖的流是当前流的父级。如果被依赖的流不在当前依赖树中(比如状态为 <code>idle</code> 的流)，被依赖的流会使用一个默认优先级</p><p>当依赖一个流时，该流会添加进父级的依赖关系中，共享相同父级的依赖流不会相对于彼此进行排序，比如 B 和 C 依赖 A，新添加一个依赖流 D，BCD 的顺序是不固定的:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  A                 A</span><br><span class="line"> / \      ==&gt;      /|\</span><br><span class="line">B   C             B D C</span><br></pre></td></tr></table></figure><p>独占标识 (exclusive) 允许插入一个新层级(新的依赖关系)，独占标识导致该流成为父级的唯一依赖流，而其他依赖流变为其子级，比如同样插入一个新依赖流 E (带有 exclusive):</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">                    A</span><br><span class="line">  A                 |</span><br><span class="line"> /|\      ==&gt;       E</span><br><span class="line">B D C              /|\</span><br><span class="line">                  B D C</span><br></pre></td></tr></table></figure><p>在依赖关系树中，只有当一个依赖流所依赖的所有流(父级最高为 0x0 的链)被关闭或者无法继续在上面执行，这个依赖流才应该被分配资源</p><p><strong>依赖权重</strong></p><p>所有依赖流都会分配一个 1~256 权重值</p><p>相同父级的依赖流按权重比例分配资源，比如流 B 依赖于 A 且权重值为 4，流 C 依赖于 A 且权重值为 12，当 A 不再执行时，B 理论上能分配的资源只有 C 的三分之一</p><p><strong>优先级调整 (Reprioritization)</strong></p><p>使用 PRIORITY 帧可以调整流优先级</p><p>PRIORITY 帧内容与 HEADERS 帧的优先级模块相同:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+-+-------------------------------------------------------------+</span><br><span class="line">|E|                  Stream Dependency (31)                     |</span><br><span class="line">+-+-------------+-----------------------------------------------+</span><br><span class="line">|   Weight (8)  |</span><br><span class="line">+-+-------------+</span><br></pre></td></tr></table></figure><ul><li>如果父级重新设置了优先级，则依赖流会随其父级流一起移动。若调整优先级的流带有独占标识，会导致新的父流的所有子级依赖于这个流</li><li>如果一个流调整为依赖自己的一个子级，则这个将被依赖的子级首先移至调整流的父级之下(即同一层)，再移动那个调整流的整棵子树，移动的依赖关系保持其权重</li></ul><p>看下面这个例子: 第一个图是初始关系树，现在 A 要调整为依赖 D，根据第二点，现将 D 移至 x 之下，再把 A 调整为 D 的子树(图 3)，如果 A 调整时带有独占标识根据第一点 F 也归为 A 子级(图 4)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  x                x                x                 x</span><br><span class="line">  |               / \               |                 |</span><br><span class="line">  A              D   A              D                 D</span><br><span class="line"> / \            /   / \            / \                |</span><br><span class="line">B   C     ==&gt;  F   B   C   ==&gt;    F   A       OR      A</span><br><span class="line">   / \                 |             / \             /|\</span><br><span class="line">  D   E                E            B   C           B C F</span><br><span class="line">  |                                     |             |</span><br><span class="line">  F                                     E             E</span><br><span class="line">             (intermediate)   (non-exclusive)    (exclusive)</span><br></pre></td></tr></table></figure><p><strong>流优先级的状态管理</strong></p><p>当一个流从依赖树中移除，它的子级可以调整为依赖被关闭流的父级(应该就是连接上一层节点)，新的依赖权重将根据关闭流的权重以及流自身的权重重新计算。</p><p>从依赖树中移除流会导致某些优先级信息丢失。资源在具有相同父级的流之间共享，这意味着如果这个集合中的某个流关闭或者阻塞，任何空闲容量将分配给最近的相邻流。然而，如果此集合的共有依赖(即父级节点)从树中移除，这些子流将与更上一层的流共享资源</p><p>一个例子: 流 A 和流 B 依赖相同父级节点，而流 C 和流 D 都依赖 A，在移除流 A 之前的一段时间内，A 和 D 都无法执行(可能任务阻塞了)，则 C 会分配到 A 的所有资源； 如果 A 被移除出树了，A 的权重按比重新计算分配给 C 和 D，此时 D 仍旧阻塞，C 分配的资源相较之前变少了。对于同等的初始权重，C 获取到的可用资源是三分之一而不是二分之一(为什么是三分之一?文档中没有说明细节，权重如何重新分配也不太清楚，下面是按我的理解解释的)</p><p>X 的资源为 1，ABCD 初始权重均为 16，*号代表节点当前不可用，图一中 C 和 B 各占一半资源，而 A 移除后 CD 的权重重新分配变为 8，所以图二中 C 和 B 占比变为 1:2，R(C) 变为 1/3</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">        X(v:1.0)               X(v:1.0)</span><br><span class="line">        / \                    /|\</span><br><span class="line">       /   \                  / | \</span><br><span class="line">     *A     B       ==&gt;      /  |  \</span><br><span class="line">   (w:16) (w:16)            /   |   \</span><br><span class="line">     / \                   C   *D    B</span><br><span class="line">    /   \                (w:8)(w:8)(w:16)</span><br><span class="line">   C    *D</span><br><span class="line">(w:16) (w:16)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R(C)=16/(16+16)=1/2 ==&gt;  R(C)=8/(8+16)=1/3</span><br></pre></td></tr></table></figure><p>可能向一个流创建依赖关系的优先级信息还在传输中，那个流就已经关闭了。如果一个依赖流的依赖指向没有相关优先级信息(即父节点无效)，则这个依赖流会分配默认优先级，这可能会造成不理想的优先级，因为给流分配了不在预期的优先级。</p><p>为了避免上述问题，一个端点应该在流关闭后的一段时间内保留流的优先级调整状态信息，此状态保留时间越长，流被分配错误的或者默认的优先级可能性越低。</p><p>类似地，处于“空闲”状态的流可以被分配优先级或成为其他流的父节点。这允许在依赖关系树中创建分组节点，从而实现更灵活的优先级表达式。空闲流以默认优先级开始</p><p>流优先级状态信息的保留可能增加终端的负担，因此这种状态可以被限制。终端可能根据负荷来决定保留的额外的状态的数目；在高负荷下，可以丢弃额外的优先级状态来限制资源的任务。在极端情况下，终端甚至可以丢弃激活或者保留状态流的优先级信息。如果使用了固定的限制，终端应当至少保留跟 SETTINGS_MAX_CONCURRENT_STREAMS 设置一样大小的流状态</p><p><strong>默认优先级</strong></p><p>所有流都是初始为非独占地依赖于流 0x0。</p><p>Pushed 流初始依赖于相关的流(见 Server-Push)。</p><p>以上两种情况，流的权重都指定为 16。</p><h3 id="3-服务端推送-Server-Push"><a href="#3-服务端推送-Server-Push" class="headerlink" title="3. 服务端推送 (Server Push)"></a>3. 服务端推送 (Server Push)</h3><p>浏览器发送一个请求，服务器主动向浏览器推送与这个请求相关的资源，这样浏览器就不用发起后续请求。</p><p>Server-Push 主要是针对资源内联做出的优化，相较于 http/1.1 资源内联的优势:</p><ul><li>客户端可以缓存推送的资源</li><li>客户端可以拒收推送过来的资源</li><li>推送资源可以由不同页面共享</li><li>服务器可以按照优先级推送资源</li></ul><h5 id="Server-Push详解（选读）"><a href="#Server-Push详解（选读）" class="headerlink" title="Server Push详解（选读）"></a>Server Push详解（选读）</h5><p><strong>PUSH_PROMISE 帧格式</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+---------------+</span><br><span class="line"> |Pad Length? (8)|</span><br><span class="line"> +-+-------------+-----------------------------------------------+</span><br><span class="line"> |R|                  Promised Stream ID (31)                    |</span><br><span class="line"> +-+-----------------------------+-------------------------------+</span><br><span class="line"> |                   Header Block Fragment (*)                 ...</span><br><span class="line"> +---------------------------------------------------------------+</span><br><span class="line"> |                           Padding (*)                       ...</span><br><span class="line"> +---------------------------------------------------------------+</span><br></pre></td></tr></table></figure><blockquote><ul><li><code>Pad Length</code>: 指定 Padding 长度，存在则代表 PADDING flag 被设置</li><li><code>R</code>: 保留的1bit位</li><li><code>Promised Stream ID</code>: 31 位的无符号整数，代表 PUSH_PROMISE 帧保留的流，对于发送者来说该流标识符必须是可用于下一个流的有效值</li><li><code>Header Block Fragment</code>: 包含请求首部域的首部块片段</li><li><code>Padding</code>: 填充字节，没有具体语义，作用与 DATA 的 Padding 一样，存在则代表 PADDING flag 被设置</li></ul></blockquote><p>PUSH_PROMISE 帧有以下标识 (flags):</p><blockquote><ul><li>END_HEADERS: bit 2 置 1 代表 header 块结束</li><li>PADDED: bit 3 置 1 代表 Pad 被设置，存在 Pad Length 和 Padding</li></ul></blockquote><p><strong>Push 的过程</strong></p><p>结合上文关于 Server-Push 的流状态转换</p><p>PUSH_PROMISE 帧只能在对端(客户端)发起的且流状态为 open 或者 half-closed (remote) 的流上发送</p><p>PUSH_PROMISE 帧准备推送的响应总是和来自于客户端的请求相关联。服务端在该请求所在的流上发送 PUSH_PROMISE 帧。PUSH_PROMISE 帧包含一个 Promised Stream ID，该流标识符是从服务端可用的流标识符里选出来的。</p><p>如果服务端收到了一个对文档的请求，该文档包含内嵌的指向多个图片文件的链接，且服务端选择向客户端推送那些额外的图片，那么在发送包含图片链接的 DATA 帧之前发送 PUSH_PROMISE 帧可以确保客户端在发现内嵌的链接之前，能够知道有一个资源将要被推送过来。同样地，如果服务端准备推送被首部块引用的响应 (比如，在 <a href="https://link.juejin.cn/?target=https://www.w3.org/wiki/LinkHeader">Link 首部字段</a> 里的)，在发送首部块之前发送一个 PUSH_PROMISE 帧，可以确保客户端不再请求那些资源</p><p>一旦客户端收到了 PUSH_PROMISE 帧，并选择接收被推送的响应，客户端就不应该为准备推送的响应发起任何请求，直到预示的流被关闭以后。</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/1658dc4fef38d8bd%7Etplv-t2oaga2asx-jj-mark%3A3024%3A0%3A0%3A0%3Aq75.png" alt="image"></p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/1658dc5033242dae%7Etplv-t2oaga2asx-jj-mark%3A3024%3A0%3A0%3A0%3Aq75.png" alt="image"></p><blockquote><p>注意图中推送的四个资源各预示了一个流 (Promised Stream ID)，而发送 PUSH_PROMISE 帧的还是在客户端发起的请求流 (Stream Identifier = 1) 上，客户端收到 PUSH_PROMISE 帧并选择接收便不会对这四个资源发起请求，之后服务端会发起预示的流然后推送资源相关的响应</p></blockquote><p>不管出于什么原因，如果客户端决定不再从服务端接收准备推送的响应，或者如果服务端花费了太长时间准备发送被预示的响应，客户端可以发送一个 RST_STREAM 帧，该帧可以使用 CANCEL 或者 REFUSED_STEAM 码，并引用被推送的流标识符。</p><p><strong>nginx 配置 Server-Push</strong></p><blockquote><p>server-push 需要服务端设置，并不是说浏览器发起请求，与此请求相关的资源服务端就会自动推送</p></blockquote><p>以 nginx 为例，从版本 1.13.9 开始正式支持 hppt2 serverpush 功能，</p><p>在相应 server 或 location 模块中加入 <code>http2_push</code> 字段加上相对路径的文件即可在请求该资源时推送相关资源，比如我的博客设置如下，访问首页时有四个文件会由服务器主动推送过去而不需要客户端请求:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">复制代码  server_name  blog.wangriyu.wang;</span><br><span class="line">  root /blog;</span><br><span class="line">  index index.html index.htm;</span><br><span class="line"></span><br><span class="line">  location = /index.html &#123;</span><br><span class="line">    http2_push /css/style.css;</span><br><span class="line">    http2_push /js/main.js;</span><br><span class="line">    http2_push /img/yule.jpg;</span><br><span class="line">    http2_push /img/avatar.jpg;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>通过浏览器控制台可以查看 <code>Push</code> 响应:</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/8/31/1658dc510af263a8~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png" alt="image"></p><p>也可以用 <code>nghttp</code> 测试 push 响应 (* 号代表是服务端推送的):</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/8/31/1658dc4fa7d18e24~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png" alt="image"></p><p>上面 <code>http2_push</code> 的设置适合静态资源，服务端事先知道哪些文件是客户端需要的，然后选择性推送</p><p>假如是后台应用动态生成的文件(比如 json 文件)，服务器事先不知道要推送什么，可以用 <code>Link</code> 响应头来做自动推送</p><p>在 server 模块中添加 <code>http2_push_preload on;</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server_name  blog.wangriyu.wang;</span><br><span class="line">  root /blog;</span><br><span class="line">  index index.html index.htm;</span><br><span class="line"></span><br><span class="line">  http2_push_preload on;</span><br></pre></td></tr></table></figure><p>然后设置响应头 (add_header) 或者后台程序生成数据文件返回时带上响应头 Link 标签，比如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Link: &lt;/style.css&gt;; as=style; rel=preload, &lt;/main.js&gt;; as=script; rel=preload, &lt;/image.jpg&gt;; as=image; rel=preload</span><br></pre></td></tr></table></figure><p>nginx 会根据 Link 响应头主动推送这些资源</p><h3 id="4-请求优先级设置"><a href="#4-请求优先级设置" class="headerlink" title="4. 请求优先级设置"></a>4. 请求优先级设置</h3><p>HTTP/2 里的每个 stream 都可以设置依赖 (Dependency) 和权重，可以按依赖树分配优先级，解决了关键请求被阻塞的问题</p><h3 id="5-流量控制"><a href="#5-流量控制" class="headerlink" title="5. 流量控制"></a>5. 流量控制</h3><p>HTTP/2 使用流量控制（Flow Control）来确保在网络连接上传输的数据量不超出接收端的处理能力。流量控制的主要目标是防止发送者发送过多的数据，导致接收者无法及时处理，从而引发拥塞或性能下降。HTTP/2 中的流量控制是基于帧（Frames）的，每个流（Stream）都有一个关联的流量控制窗口（Flow Control Window）。</p><blockquote><p>以下是 HTTP/2 中流量控制的基本原理和机制：</p><ol><li><strong>流量控制窗口：</strong> 每个流都有一个流量控制窗口，用于表示该流上可以发送的数据量。初始时，流量控制窗口的大小是由 SETTINGS 帧中的初始窗口大小（Initial Window Size）指定的。接收方会定期向发送方发送 WINDOW_UPDATE 帧来扩大流量控制窗口的大小，通知发送方可以发送更多的数据。</li><li><strong>连接级流量控制：</strong> HTTP/2 还定义了连接级的流量控制窗口，它用于限制整个连接上的数据流量。连接级窗口的大小也是由 SETTINGS 帧中的初始窗口大小指定，并可以通过 WINDOW_UPDATE 帧来调整。</li><li><strong>帧的流量控制：</strong> 每个 DATA 帧（携带请求和响应的主体数据）都有一个与之关联的流量控制窗口。发送方必须确保发送的 DATA 帧的大小不超过流量控制窗口的大小，接收方在接收到 DATA 帧后，会相应地减小流量控制窗口的大小。</li><li><strong>WINDOW_UPDATE 帧：</strong> 发送方可以发送 WINDOW_UPDATE 帧，来通知接收方可以扩大流量控制窗口的大小。WINDOW_UPDATE 帧携带了增加的窗口大小，可以是流量控制窗口或者连接级窗口的增量。</li></ol></blockquote><p>通过以上机制，HTTP/2 中的流量控制确保了数据的有序传输，并防止了发送过多数据导致接收方无法处理的情况。流量控制的灵活性和精细度使得 HTTP/2 能够更好地适应不同网络条件和接收方处理能力，提高了网络性能和用户体验。</p><h3 id="6-应用层的重置连接"><a href="#6-应用层的重置连接" class="headerlink" title="6. 应用层的重置连接"></a>6. 应用层的重置连接</h3><p>对于 HTTP/1 来说，是通过设置 tcp segment 里的 reset flag 来通知对端关闭连接的。这种方式会直接断开连接，下次再发请求就必须重新建立连接。HTTP/2 引入 RST_STREAM 类型的 frame，可以在不断开连接的前提下取消某个 request 的 stream，表现更好。</p><h3 id="7-HTTP-1-的几种优化可以弃用"><a href="#7-HTTP-1-的几种优化可以弃用" class="headerlink" title="7. HTTP/1 的几种优化可以弃用"></a>7. HTTP/1 的几种优化可以弃用</h3><p>1、域名分片</p><p>HTTP/2 对于同一域名使用一个 TCP 连接足矣，过多 TCP 连接浪费资源而且效果不见得一定好</p><p>而且资源分域会破坏 HTTP/2 的优先级特性，还会降低头部压缩效果</p><p>2、资源合并</p><p>资源合并会不利于缓存机制，而且单文件过大对于 HTTP/2 的传输不好，尽量做到细粒化更有利于 HTTP/2 传输</p><p>3、资源内联</p><p>HTTP/2 支持 Server-Push，相比较内联优势更大效果更好</p><p>而且内联的资源不能有效缓存</p><p>如果有共用，多页面内联也会造成浪费</p><h2 id="升级HTTP-2的优劣"><a href="#升级HTTP-2的优劣" class="headerlink" title="升级HTTP/2的优劣"></a>升级HTTP/2的优劣</h2><h2 id="劣"><a href="#劣" class="headerlink" title="劣"></a>劣</h2><p>升级到HTTP/2并不是一种适用于所有情况的通用解决方案。虽然HTTP/2在许多方面都提供了性能优势，但也有一些特定的情况，可能不适合升级到HTTP/2，或者需要谨慎考虑：</p><ol><li><strong>老旧的服务器和客户端：</strong> 一些老旧的服务器软件和客户端应用程序可能不支持HTTP/2协议。在这种情况下，升级可能会引发兼容性问题。</li><li><strong>简单的静态网站：</strong> 如果网站内容非常简单，主要由静态文件组成，并且对性能要求不高，升级到HTTP/2的收益可能较小。HTTP/1.1对于简单的静态网站来说通常足够了。</li><li><strong>资源优化不足：</strong> 如果网站的性能问题主要源于资源优化不足，例如未压缩的图片、未合并的脚本和样式表等，那么升级到HTTP/2并不会根本解决这些问题。在升级之前，应该先优化网站的资源。</li><li><strong>服务器性能限制：</strong> 如果服务器的性能受限，无法处理大量的并发请求，那么HTTP/2的多路复用特性可能会导致服务器过载，反而降低性能。</li><li><strong>特殊网络环境：</strong> 在某些网络环境下，例如高延迟、高丢包率的网络，HTTP/2的多路复用特性可能会导致丢失的数据包需要重新传输，从而增加了网络负担。</li><li><strong>过于复杂的配置：</strong> 如果HTTP/2的配置比较复杂，或者在现有的基础设施中引入HTTP/2会带来很大的复杂性，那么在考虑升级时需要慎重评估成本和收益。</li></ol><p>在决定是否升级到HTTP/2时，需要综合考虑网站的性能需求、服务器和客户端的兼容性、网络环境以及现有基础设施的情况。在一些特定场景下，HTTP/1.1仍然可能是一个合适的选择。</p><p>什么时候HTTP/2会比HTTP1.1慢</p><blockquote><ol><li><strong>小文件的传输：</strong> 当需要传输大量非常小的文件时（1k&lt;），HTTP/2 的多路复用机制可能会导致头部信息在传输中占用较大比例，从而增加了总体的传输量。在这种情况下，HTTP/1.1 的多个并行连接可能更加高效。</li><li><strong>连接复用受限：</strong> 在某些网络环境下，连接的复用可能受到限制，例如高延迟、高丢包率的网络。在这种情况下，HTTP/2 的连接复用特性可能会受到影响，甚至导致性能下降。</li><li><strong>服务器性能不足：</strong> 如果服务器性能不足以处理大量并发的请求，HTTP/2 的多路复用可能导致服务器过载，从而增加了响应时间。HTTP/1.1 的多个连接可能分散了请求，减轻了服务器的负担。</li><li><strong>头部压缩开销：</strong> HTTP/2 使用 HPACK 算法对头部信息进行压缩，但解压缩头部信息也需要计算资源。在某些情况下，特别是在移动设备上，解压缩可能会增加处理的复杂性和开销。</li><li><strong>代理服务器和防火墙限制：</strong> 一些代理服务器和防火墙可能不正确地处理或者不支持HTTP/2，导致在这些设备上的传输性能下降。</li></ol></blockquote><h2 id="优"><a href="#优" class="headerlink" title="优"></a>优</h2><ol><li><strong>提高网站性能</strong>：HTTP/2引入了多路复用（Multiplexing）功能，可以同时传输多个请求和响应，减少了网络延迟，提高了网站加载速度。如果您的网站有很多资源（例如图片、样式表、脚本等），并且希望提供更快的加载时间，升级到HTTP/2可能是一个不错的选择。</li><li><strong>支持移动设备</strong>：HTTP/2对于移动设备的性能优化效果显著。移动网络通常具有较高的延迟，HTTP/2的多路复用特性能够更好地利用网络带宽，提供更快的加载速度，从而提高了移动设备用户的体验。</li><li><strong>提高SEO排名</strong>：Google已经确认，网站加载速度是搜索引擎排名的一个因素。更快的网站加载速度可能对SEO产生积极影响，因此，如果您关注网站的搜索引擎可见性，升级到HTTP/2可能是一个好的策略。</li><li><strong>支持新的Web功能</strong>：一些现代的Web功能，例如服务端推送（Server Push），在HTTP/2中得到了良好的支持。如果您计划使用这些新功能，升级到HTTP/2是必要的。</li><li><strong>提供更好的安全性</strong>：HTTP/2通常与TLS（HTTPS）一起使用，因此可以提供更好的数据安全性。如果您的网站处理用户敏感信息，使用HTTPS和HTTP/2可以增加数据传输的安全性。</li></ol><h1 id="升级方案"><a href="#升级方案" class="headerlink" title="升级方案"></a>升级方案</h1><p>目前我们网站的运行流程：</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/image-20231008154140054.png" alt="image-20231008154140054"></p><h2 id="1-哪些NG需要升级？"><a href="#1-哪些NG需要升级？" class="headerlink" title="1. 哪些NG需要升级？"></a>1. 哪些NG需要升级？</h2><p><strong>前端静态资源托管NG，目前前端首页资源请求超过160个,适合升级成http/2</strong></p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/image-20231008155549620.png" alt="image-20231008155549620"></p><p><strong>图片服务请求数量超30，适合升级成http/2</strong></p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/image-20231008160102350.png" alt="image-20231008160102350"></p><p>后端请求较少，只有9个可以选择不升级</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/image-20231008160230467.png" alt="image-20231008160230467"></p><h2 id="2-怎么升级"><a href="#2-怎么升级" class="headerlink" title="2. 怎么升级"></a>2. 怎么升级</h2><h3 id="前端静态资源托管NG升级HTTP-2"><a href="#前端静态资源托管NG升级HTTP-2" class="headerlink" title="前端静态资源托管NG升级HTTP/2"></a>前端静态资源托管NG升级HTTP/2</h3><p>要将Chrome浏览器的网站请求改为使用HTTP/2，需要确保网站支持HTTP/2，并且浏览器和服务器之间的连接是安全的（即使用HTTPS协议）。HTTP/2通常与TLS（Transport Layer Security）一起使用，以确保数据的安全传输。</p><p>以下是确保Chrome浏览器请求网站使用HTTP/2的步骤：</p><ol><li><p><strong>确保您的网站支持HTTP/2</strong>：在服务器端配置中启用HTTP/2。大多数现代的Web服务器（例如Apache、Nginx）已经支持HTTP/2。请参考您所使用服务器的文档，以了解如何启用HTTP/2。</p></li><li><p><strong>使用HTTPS协议</strong>：HTTP/2通常与TLS（即HTTPS）一起使用。要启用HTTP/2，您的网站必须使用安全套接字层（SSL/TLS）加密。您需要在服务器上配置SSL证书。您可以从证书颁发机构（CA）获取SSL证书，或者使用免费的证书颁发机构，例如Let’s Encrypt。</p></li><li><p><strong>配置服务器</strong>：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">vbnetCopy</span> codeserver &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">443</span> ssl http2;</span><br><span class="line">    <span class="attribute">ssl_certificate</span> /path/to/your/certificate.crt;</span><br><span class="line">    <span class="attribute">ssl_certificate_key</span> /path/to/your/private.key;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>验证设置</strong>：确保服务器已经配置正确，并且网站可以通过HTTPS访问。您可以使用在线工具，例如<a href="https://www.ssllabs.com/ssltest/">SSL Labs</a>，来检查您的SSL/TLS配置。</p></li></ol><p>一旦您的网站已经配置为支持HTTP/2并且可以通过HTTPS访问，当用户使用Chrome浏览器访问该网站时，浏览器会自动使用HTTP/2进行请求。Chrome会自动选择使用最新的协议版本，而无需手动配置。Chrome会根据标准的协议选择HTTP/2来提高网站性能。</p><h2 id="阿里图库升级HTTP2"><a href="#阿里图库升级HTTP2" class="headerlink" title="阿里图库升级HTTP2"></a>阿里图库升级HTTP2</h2><p><a href="https://help.aliyun.com/document_detail/65103.html">https://help.aliyun.com/document_detail/65103.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js正则</title>
      <link href="/posts/3b5d9717.html"/>
      <url>/posts/3b5d9717.html</url>
      
        <content type="html"><![CDATA[<p>js 正则</p><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">验证数字：/^[0-9]*$/</span><br><span class="line">验证n位的数字：/^\d&#123;n&#125;$/</span><br><span class="line">验证至少n位数字：/^\d&#123;n,&#125;$/</span><br><span class="line">验证m-n位的数字：/^\d&#123;m,n&#125;$/</span><br><span class="line">验证零和非零开头的数字：/^(0|[1-9][0-9]*)$/</span><br><span class="line">验证有两位小数的正实数：/^[0-9]+(.[0-9]&#123;2&#125;)?$/</span><br><span class="line">验证有1-3位小数的正实数：/^[0-9]+(.[0-9]&#123;1,3&#125;)?$/</span><br><span class="line">验证非零的正整数：/^\+?[1-9][0-9]*$/</span><br><span class="line">验证非零的负整数：/^\-[1-9][0-9]*$/</span><br><span class="line">验证非负整数（正整数 + 0）/ ^\d+$/</span><br><span class="line">验证非正整数（负整数 + 0） /^((-\d+)|(0+))$/</span><br><span class="line">验证长度为3的字符：/^.&#123;3&#125;$/</span><br><span class="line">验证由26个英文字母组成的字符串：/^[A-Za-z]+$/</span><br><span class="line">验证由26个大写英文字母组成的字符串：/^[A-Z]+$/</span><br><span class="line">验证由26个小写英文字母组成的字符串：/^[a-z]+$/</span><br><span class="line">验证由数字和26个英文字母组成的字符串：/^[A-Za-z0-9]+$/</span><br><span class="line">验证由数字、26个英文字母或者下划线组成的字符串：/^\w+$/</span><br><span class="line">验证用户密码:^[a-zA-Z]\w&#123;5,17&#125;$ 正确格式为：以字母开头，长度在6-18之间，只能包含字符、数字和下划线。</span><br><span class="line">验证是否含有 ^%&amp;&#x27;,;=?$\&quot; 等字符：[^%&amp;&#x27;,;=?$\x22]+</span><br><span class="line">验证汉字：/^[\u4e00-\u9fa5],&#123;0,&#125;$/</span><br><span class="line">验证Email地址：/^([a-zA-Z0-9]+[_|\_|\.]?)*[a-zA-Z0-9]+@([a-zA-Z0-9]+[_|\_|\.]?)*[a-zA-Z0-9]+\.[a-zA-Z]&#123;2,3&#125;$/</span><br><span class="line">验证InternetURL：/^http://([\w-]+\.)+[\w-]+(/[\w-./?%&amp;=]*)?$ ；^[a-zA-z]+://(w+(-w+)*)(.(w+(-w+)*))*(?S*)?$/</span><br><span class="line">验证电话号码：/^(\(\d&#123;3,4&#125;\)|\d&#123;3,4&#125;-)?\d&#123;7,8&#125;$/</span><br><span class="line">验证身份证号（15位或18位数字）：/^\d&#123;15&#125;|\d&#123;&#125;18$/</span><br><span class="line">验证一年的12个月：/^(0?[1-9]|1[0-2])$/</span><br><span class="line">验证一个月的31天：/^((0?[1-9])|((1|2)[0-9])|30|31)$ /</span><br><span class="line">整数：/^-?\d+$/</span><br><span class="line">非负浮点数（正浮点数 + 0）：/^\d+(\.\d+)?$/</span><br><span class="line">正浮点数： /^(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*))$/</span><br><span class="line">非正浮点数（负浮点数 + 0）：/ ^((-\d+(\.\d+)?)|(0+(\.0+)?))$/</span><br><span class="line">负浮点数：/ ^(-(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*)))$/</span><br><span class="line">浮点数： /^(-?\d+)(\.\d+)?$/</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础 - SPI机制详解</title>
      <link href="/posts/6ed0bfbd.html"/>
      <url>/posts/6ed0bfbd.html</url>
      
        <content type="html"><![CDATA[<p>摘要</p><span id="more"></span><h2 id="什么是SPI机制"><a href="#什么是SPI机制" class="headerlink" title="什么是SPI机制"></a>什么是SPI机制</h2><p>SPI（Service Provider Interface），是JDK内置的一种 服务提供发现机制，可以用来启用框架扩展和替换组件，主要是被框架的开发人员使用，比如java.sql.Driver接口，其他不同厂商可以针对同一接口做出不同的实现，MySQL和PostgreSQL都有不同的实现提供给用户，而Java的SPI机制可以为某个接口寻找服务实现。Java中SPI机制主要思想是将装配的控制权移到程序之外，在模块化设计中这个机制尤其重要，其核心思想就是 <strong>解耦</strong>。</p><p>SPI整体机制图如下：</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230821134526945.png" alt="image-20230821134526945"></p><p>当服务的提供者提供了一种接口的实现之后，需要在classpath下的<code>META-INF/services/</code>目录里创建一个以服务接口命名的文件，这个文件里的内容就是这个接口的具体的实现类。当其他的程序需要这个服务的时候，就可以通过查找这个jar包（一般都是以jar包做依赖）的<code>META-INF/services/</code>中的配置文件，配置文件中有接口的具体实现类名，可以根据这个类名进行加载实例化，就可以使用该服务了。JDK中查找服务的实现的工具类是：<code>java.util.ServiceLoader</code>。</p><h2 id="SPI机制的简单示例"><a href="#SPI机制的简单示例" class="headerlink" title="# SPI机制的简单示例"></a><a href="#spi%E6%9C%BA%E5%88%B6%E7%9A%84%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B">#</a> SPI机制的简单示例</h2><blockquote><p>网上找了个例子：<a href="https://zhuanlan.zhihu.com/p/28909673">这里在新窗口打开</a></p></blockquote><p>我们现在需要使用一个内容搜索接口，搜索的实现可能是基于文件系统的搜索，也可能是基于数据库的搜索。</p><ul><li>先定义好接口</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Search</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">searchDoc</span><span class="params">(String keyword)</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>文件搜索实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileSearch</span> <span class="keyword">implements</span> <span class="title class_">Search</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">searchDoc</span><span class="params">(String keyword)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;文件搜索 &quot;</span>+keyword);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>数据库搜索实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DatabaseSearch</span> <span class="keyword">implements</span> <span class="title class_">Search</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">searchDoc</span><span class="params">(String keyword)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;数据搜索 &quot;</span>+keyword);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>resources 接下来可以在resources下新建META-INF/services/目录，然后新建接口全限定名的文件：<code>com.cainiao.ys.spi.learn.Search</code>，里面加上我们需要用到的实现类</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.cainiao.ys.spi.learn.FileSearch</span><br></pre></td></tr></table></figure><ul><li>测试方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCase</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ServiceLoader&lt;Search&gt; s = ServiceLoader.load(Search.class);</span><br><span class="line">        Iterator&lt;Search&gt; iterator = s.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">           <span class="type">Search</span> <span class="variable">search</span> <span class="operator">=</span>  iterator.next();</span><br><span class="line">           search.searchDoc(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到输出结果：文件搜索 hello world</p><p>如果在<code>com.cainiao.ys.spi.learn.Search</code>文件里写上两个实现类，那最后的输出结果就是两行了。</p><p>这就是因为<code>ServiceLoader.load(Search.class)</code>在加载某接口时，会去<code>META-INF/services</code>下找接口的全限定名文件，再根据里面的内容加载相应的实现类。</p><p>这就是spi的思想，接口的实现由provider实现，provider只用在提交的jar包里的<code>META-INF/services</code>下根据平台定义的接口新建文件，并添加进相应的实现类内容就好。</p><h2 id="SPI机制的广泛应用"><a href="#SPI机制的广泛应用" class="headerlink" title="# SPI机制的广泛应用"></a><a href="#spi%E6%9C%BA%E5%88%B6%E7%9A%84%E5%B9%BF%E6%B3%9B%E5%BA%94%E7%94%A8">#</a> SPI机制的广泛应用</h2><h3 id="SPI机制-JDBC-DriverManager"><a href="#SPI机制-JDBC-DriverManager" class="headerlink" title="# SPI机制 - JDBC DriverManager"></a><a href="#spi%E6%9C%BA%E5%88%B6-jdbc-drivermanager">#</a> SPI机制 - JDBC DriverManager</h3><blockquote><p>在JDBC4.0之前，我们开发有连接数据库的时候，通常会用Class.forName(“com.mysql.jdbc.Driver”)这句先加载数据库相关的驱动，然后再进行获取连接等的操作。<strong>而JDBC4.0之后不需要用Class.forName(“com.mysql.jdbc.Driver”)来加载驱动，直接获取连接就可以了，现在这种方式就是使用了Java的SPI扩展机制来实现</strong>。</p></blockquote><h4 id="JDBC接口定义"><a href="#JDBC接口定义" class="headerlink" title="# JDBC接口定义"></a><a href="#jdbc%E6%8E%A5%E5%8F%A3%E5%AE%9A%E4%B9%89">#</a> JDBC接口定义</h4><p>首先在java中定义了接口<code>java.sql.Driver</code>，并没有具体的实现，具体的实现都是由不同厂商来提供的。</p><h4 id="mysql实现"><a href="#mysql实现" class="headerlink" title="# mysql实现"></a><a href="#mysql%E5%AE%9E%E7%8E%B0">#</a> mysql实现</h4><p>在mysql的jar包<code>mysql-connector-java-6.0.6.jar</code>中，可以找到<code>META-INF/services</code>目录，该目录下会有一个名字为<code>java.sql.Driver</code>的文件，文件内容是<code>com.mysql.cj.jdbc.Driver</code>，这里面的内容就是针对Java中定义的接口的实现。</p><h4 id="postgresql实现"><a href="#postgresql实现" class="headerlink" title="# postgresql实现"></a><a href="#postgresql%E5%AE%9E%E7%8E%B0">#</a> postgresql实现</h4><p>同样在postgresql的jar包<code>postgresql-42.0.0.jar</code>中，也可以找到同样的配置文件，文件内容是<code>org.postgresql.Driver</code>，这是postgresql对Java的<code>java.sql.Driver</code>的实现。</p><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="# 使用方法"></a><a href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95">#</a> 使用方法</h4><p>上面说了，现在使用SPI扩展来加载具体的驱动，我们在Java中写连接数据库的代码的时候，不需要再使用<code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;)</code>来加载驱动了，而是直接使用如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:xxxx://xxxx:xxxx/xxxx&quot;</span>;</span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(url,username,password);</span><br><span class="line">.....</span><br></pre></td></tr></table></figure><p>这里并没有涉及到spi的使用，接着看下面的解析。</p><h4 id="源码实现"><a href="#源码实现" class="headerlink" title="# 源码实现"></a><a href="#%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0">#</a> 源码实现</h4><p>上面的使用方法，就是我们普通的连接数据库的代码，并没有涉及到SPI的东西，但是有一点我们可以确定的是，我们没有写有关具体驱动的硬编码<code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;)</code>！</p><p>上面的代码可以直接获取数据库连接进行操作，但是跟SPI有啥关系呢？上面代码没有了加载驱动的代码，我们怎么去确定使用哪个数据库连接的驱动呢？这里就涉及到使用Java的SPI扩展机制来查找相关驱动的东西了，关于驱动的查找其实都在<code>DriverManager</code>中，<code>DriverManager</code>是Java中的实现，用来获取数据库连接，在<code>DriverManager</code>中有一个静态代码块如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    loadInitialDrivers();</span><br><span class="line">    println(<span class="string">&quot;JDBC DriverManager initialized&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到是加载实例化驱动的，接着看loadInitialDrivers方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">loadInitialDrivers</span><span class="params">()</span> &#123;</span><br><span class="line">    String drivers;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        drivers = AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;String&gt;() &#123;</span><br><span class="line">            <span class="keyword">public</span> String <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> System.getProperty(<span class="string">&quot;jdbc.drivers&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        drivers = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;Void&gt;() &#123;</span><br><span class="line">        <span class="keyword">public</span> Void <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//使用SPI的ServiceLoader来加载接口的实现</span></span><br><span class="line">            ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver.class);</span><br><span class="line">            Iterator&lt;Driver&gt; driversIterator = loadedDrivers.iterator();</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(driversIterator.hasNext()) &#123;</span><br><span class="line">                    driversIterator.next();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span>(Throwable t) &#123;</span><br><span class="line">            <span class="comment">// Do nothing</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;DriverManager.initialize: jdbc.drivers = &quot;</span> + drivers);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (drivers == <span class="literal">null</span> || drivers.equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    String[] driversList = drivers.split(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">    println(<span class="string">&quot;number of Drivers:&quot;</span> + driversList.length);</span><br><span class="line">    <span class="keyword">for</span> (String aDriver : driversList) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            println(<span class="string">&quot;DriverManager.Initialize: loading &quot;</span> + aDriver);</span><br><span class="line">            Class.forName(aDriver, <span class="literal">true</span>,</span><br><span class="line">                    ClassLoader.getSystemClassLoader());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            println(<span class="string">&quot;DriverManager.Initialize: load failed: &quot;</span> + ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码主要步骤是：</p><ul><li>从系统变量中获取有关驱动的定义。</li><li>使用SPI来获取驱动的实现。</li><li>遍历使用SPI获取到的具体实现，实例化各个实现类。</li><li>根据第一步获取到的驱动列表来实例化具体实现类。</li></ul><p>我们主要关注2,3步，这两步是SPI的用法，首先看第二步，使用SPI来获取驱动的实现，对应的代码是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver.class);</span><br></pre></td></tr></table></figure><p>这里没有去<code>META-INF/services</code>目录下查找配置文件，也没有加载具体实现类，做的事情就是封装了我们的接口类型和类加载器，并初始化了一个迭代器。</p><p>接着看第三步，遍历使用SPI获取到的具体实现，实例化各个实现类，对应的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取迭代器</span></span><br><span class="line">Iterator&lt;Driver&gt; driversIterator = loadedDrivers.iterator();</span><br><span class="line"><span class="comment">//遍历所有的驱动实现</span></span><br><span class="line"><span class="keyword">while</span>(driversIterator.hasNext()) &#123;</span><br><span class="line">    driversIterator.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在遍历的时候，首先调用<code>driversIterator.hasNext()</code>方法，这里会搜索classpath下以及jar包中所有的<code>META-INF/services</code>目录下的<code>java.sql.Driver</code>文件，并找到文件中的实现类的名字，此时并没有实例化具体的实现类（ServiceLoader具体的源码实现在下面）。</p><p>然后是调用<code>driversIterator.next();</code>方法，此时就会根据驱动名字具体实例化各个实现类了。现在驱动就被找到并实例化了。</p><p>可以看下截图，我在测试项目中添加了两个jar包，<code>mysql-connector-java-6.0.6.jar</code>和<code>postgresql-42.0.0.0.jar</code>，跟踪到DriverManager中之后：</p><p><img src="images/java/java-advanced-spi-1.png" alt="img"></p><p>可以看到此时迭代器中有两个驱动，mysql和postgresql的都被加载了。</p><h3 id="SPI机制-Common-Logging"><a href="#SPI机制-Common-Logging" class="headerlink" title="# SPI机制 - Common-Logging"></a><a href="#spi%E6%9C%BA%E5%88%B6-common-logging">#</a> SPI机制 - Common-Logging</h3><blockquote><p>common-logging（也称Jakarta Commons Logging，缩写 JCL）是常用的日志库门面，具体<a href="">日志库相关可以看这篇</a>。我们看下它是怎么解耦的。</p></blockquote><p>首先，日志实例是通过LogFactory的getLog(String)方法创建的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title function_">getLog</span><span class="params">(Class clazz)</span> <span class="keyword">throws</span> LogConfigurationException &#123;</span><br><span class="line">    <span class="keyword">return</span> getFactory().getInstance(clazz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LogFatory是一个抽象类，它负责加载具体的日志实现，分析其Factory getFactory()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> org.apache.commons.logging.LogFactory <span class="title function_">getFactory</span><span class="params">()</span> <span class="keyword">throws</span> LogConfigurationException &#123;</span><br><span class="line">    <span class="comment">// Identify the class loader we will be using</span></span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">contextClassLoader</span> <span class="operator">=</span> getContextClassLoaderInternal();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (contextClassLoader == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// This is an odd enough situation to report about. This</span></span><br><span class="line">        <span class="comment">// output will be a nuisance on JDK1.1, as the system</span></span><br><span class="line">        <span class="comment">// classloader is null in that environment.</span></span><br><span class="line">        <span class="keyword">if</span> (isDiagnosticsEnabled()) &#123;</span><br><span class="line">            logDiagnostic(<span class="string">&quot;Context classloader is null.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return any previously registered factory for this class loader</span></span><br><span class="line">    org.apache.commons.logging.<span class="type">LogFactory</span> <span class="variable">factory</span> <span class="operator">=</span> getCachedFactory(contextClassLoader);</span><br><span class="line">    <span class="keyword">if</span> (factory != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> factory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isDiagnosticsEnabled()) &#123;</span><br><span class="line">        logDiagnostic(</span><br><span class="line">                <span class="string">&quot;[LOOKUP] LogFactory implementation requested for the first time for context classloader &quot;</span> +</span><br><span class="line">                        objectId(contextClassLoader));</span><br><span class="line">        logHierarchy(<span class="string">&quot;[LOOKUP] &quot;</span>, contextClassLoader);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Load properties file.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// If the properties file exists, then its contents are used as</span></span><br><span class="line">    <span class="comment">// &quot;attributes&quot; on the LogFactory implementation class. One particular</span></span><br><span class="line">    <span class="comment">// property may also control which LogFactory concrete subclass is</span></span><br><span class="line">    <span class="comment">// used, but only if other discovery mechanisms fail..</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// As the properties file (if it exists) will be used one way or</span></span><br><span class="line">    <span class="comment">// another in the end we may as well look for it first.</span></span><br><span class="line">    <span class="comment">// classpath根目录下寻找commons-logging.properties</span></span><br><span class="line">    <span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> getConfigurationFile(contextClassLoader, FACTORY_PROPERTIES);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Determine whether we will be using the thread context class loader to</span></span><br><span class="line">    <span class="comment">// load logging classes or not by checking the loaded properties file (if any).</span></span><br><span class="line">    <span class="comment">// classpath根目录下commons-logging.properties是否配置use_tccl</span></span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">baseClassLoader</span> <span class="operator">=</span> contextClassLoader;</span><br><span class="line">    <span class="keyword">if</span> (props != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">useTCCLStr</span> <span class="operator">=</span> props.getProperty(TCCL_KEY);</span><br><span class="line">        <span class="keyword">if</span> (useTCCLStr != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// The Boolean.valueOf(useTCCLStr).booleanValue() formulation</span></span><br><span class="line">            <span class="comment">// is required for Java 1.2 compatibility.</span></span><br><span class="line">            <span class="keyword">if</span> (Boolean.valueOf(useTCCLStr).booleanValue() == <span class="literal">false</span>) &#123;</span><br><span class="line">                <span class="comment">// Don&#x27;t use current context classloader when locating any</span></span><br><span class="line">                <span class="comment">// LogFactory or Log classes, just use the class that loaded</span></span><br><span class="line">                <span class="comment">// this abstract class. When this class is deployed in a shared</span></span><br><span class="line">                <span class="comment">// classpath of a container, it means webapps cannot deploy their</span></span><br><span class="line">                <span class="comment">// own logging implementations. It also means that it is up to the</span></span><br><span class="line">                <span class="comment">// implementation whether to load library-specific config files</span></span><br><span class="line">                <span class="comment">// from the TCCL or not.</span></span><br><span class="line">                baseClassLoader = thisClassLoader;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里真正开始决定使用哪个factory</span></span><br><span class="line">    <span class="comment">// 首先，尝试查找vm系统属性org.apache.commons.logging.LogFactory，其是否指定factory</span></span><br><span class="line">    <span class="comment">// Determine which concrete LogFactory subclass to use.</span></span><br><span class="line">    <span class="comment">// First, try a global system property</span></span><br><span class="line">    <span class="keyword">if</span> (isDiagnosticsEnabled()) &#123;</span><br><span class="line">        logDiagnostic(<span class="string">&quot;[LOOKUP] Looking for system property [&quot;</span> + FACTORY_PROPERTY +</span><br><span class="line">                <span class="string">&quot;] to define the LogFactory subclass to use...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">factoryClass</span> <span class="operator">=</span> getSystemProperty(FACTORY_PROPERTY, <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (factoryClass != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isDiagnosticsEnabled()) &#123;</span><br><span class="line">                logDiagnostic(<span class="string">&quot;[LOOKUP] Creating an instance of LogFactory class &#x27;&quot;</span> + factoryClass +</span><br><span class="line">                        <span class="string">&quot;&#x27; as specified by system property &quot;</span> + FACTORY_PROPERTY);</span><br><span class="line">            &#125;</span><br><span class="line">            factory = newFactory(factoryClass, baseClassLoader, contextClassLoader);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (isDiagnosticsEnabled()) &#123;</span><br><span class="line">                logDiagnostic(<span class="string">&quot;[LOOKUP] No system property [&quot;</span> + FACTORY_PROPERTY + <span class="string">&quot;] defined.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SecurityException e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isDiagnosticsEnabled()) &#123;</span><br><span class="line">            logDiagnostic(<span class="string">&quot;[LOOKUP] A security exception occurred while trying to create an&quot;</span> +</span><br><span class="line">                    <span class="string">&quot; instance of the custom factory class&quot;</span> + <span class="string">&quot;: [&quot;</span> + trim(e.getMessage()) +</span><br><span class="line">                    <span class="string">&quot;]. Trying alternative implementations...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ignore</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">        <span class="comment">// This is not consistent with the behaviour when a bad LogFactory class is</span></span><br><span class="line">        <span class="comment">// specified in a services file.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// One possible exception that can occur here is a ClassCastException when</span></span><br><span class="line">        <span class="comment">// the specified class wasn&#x27;t castable to this LogFactory type.</span></span><br><span class="line">        <span class="keyword">if</span> (isDiagnosticsEnabled()) &#123;</span><br><span class="line">            logDiagnostic(<span class="string">&quot;[LOOKUP] An exception occurred while trying to create an&quot;</span> +</span><br><span class="line">                    <span class="string">&quot; instance of the custom factory class&quot;</span> + <span class="string">&quot;: [&quot;</span> +</span><br><span class="line">                    trim(e.getMessage()) +</span><br><span class="line">                    <span class="string">&quot;] as specified by a system property.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二，尝试使用java spi服务发现机制，载META-INF/services下寻找org.apache.commons.logging.LogFactory实现</span></span><br><span class="line">    <span class="comment">// Second, try to find a service by using the JDK1.3 class</span></span><br><span class="line">    <span class="comment">// discovery mechanism, which involves putting a file with the name</span></span><br><span class="line">    <span class="comment">// of an interface class in the META-INF/services directory, where the</span></span><br><span class="line">    <span class="comment">// contents of the file is a single line specifying a concrete class</span></span><br><span class="line">    <span class="comment">// that implements the desired interface.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (factory == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isDiagnosticsEnabled()) &#123;</span><br><span class="line">            logDiagnostic(<span class="string">&quot;[LOOKUP] Looking for a resource file of name [&quot;</span> + SERVICE_ID +</span><br><span class="line">                    <span class="string">&quot;] to define the LogFactory subclass to use...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// META-INF/services/org.apache.commons.logging.LogFactory, SERVICE_ID</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> getResourceAsStream(contextClassLoader, SERVICE_ID);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (is != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// This code is needed by EBCDIC and other strange systems.</span></span><br><span class="line">                <span class="comment">// It&#x27;s a fix for bugs reported in xerces</span></span><br><span class="line">                BufferedReader rd;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    rd = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(is, <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (java.io.UnsupportedEncodingException e) &#123;</span><br><span class="line">                    rd = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(is));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="type">String</span> <span class="variable">factoryClassName</span> <span class="operator">=</span> rd.readLine();</span><br><span class="line">                rd.close();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (factoryClassName != <span class="literal">null</span> &amp;&amp; !<span class="string">&quot;&quot;</span>.equals(factoryClassName)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (isDiagnosticsEnabled()) &#123;</span><br><span class="line">                        logDiagnostic(<span class="string">&quot;[LOOKUP]  Creating an instance of LogFactory class &quot;</span> +</span><br><span class="line">                                factoryClassName +</span><br><span class="line">                                <span class="string">&quot; as specified by file &#x27;&quot;</span> + SERVICE_ID +</span><br><span class="line">                                <span class="string">&quot;&#x27; which was present in the path of the context classloader.&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    factory = newFactory(factoryClassName, baseClassLoader, contextClassLoader);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// is == null</span></span><br><span class="line">                <span class="keyword">if</span> (isDiagnosticsEnabled()) &#123;</span><br><span class="line">                    logDiagnostic(<span class="string">&quot;[LOOKUP] No resource file with name &#x27;&quot;</span> + SERVICE_ID + <span class="string">&quot;&#x27; found.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            <span class="comment">// note: if the specified LogFactory class wasn&#x27;t compatible with LogFactory</span></span><br><span class="line">            <span class="comment">// for some reason, a ClassCastException will be caught here, and attempts will</span></span><br><span class="line">            <span class="comment">// continue to find a compatible class.</span></span><br><span class="line">            <span class="keyword">if</span> (isDiagnosticsEnabled()) &#123;</span><br><span class="line">                logDiagnostic(</span><br><span class="line">                        <span class="string">&quot;[LOOKUP] A security exception occurred while trying to create an&quot;</span> +</span><br><span class="line">                                <span class="string">&quot; instance of the custom factory class&quot;</span> +</span><br><span class="line">                                <span class="string">&quot;: [&quot;</span> + trim(ex.getMessage()) +</span><br><span class="line">                                <span class="string">&quot;]. Trying alternative implementations...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// ignore</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第三，尝试从classpath根目录下的commons-logging.properties中查找org.apache.commons.logging.LogFactory属性指定的factory</span></span><br><span class="line">    <span class="comment">// Third try looking into the properties file read earlier (if found)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (factory == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (props != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isDiagnosticsEnabled()) &#123;</span><br><span class="line">                logDiagnostic(</span><br><span class="line">                        <span class="string">&quot;[LOOKUP] Looking in properties file for entry with key &#x27;&quot;</span> + FACTORY_PROPERTY +</span><br><span class="line">                                <span class="string">&quot;&#x27; to define the LogFactory subclass to use...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">String</span> <span class="variable">factoryClass</span> <span class="operator">=</span> props.getProperty(FACTORY_PROPERTY);</span><br><span class="line">            <span class="keyword">if</span> (factoryClass != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isDiagnosticsEnabled()) &#123;</span><br><span class="line">                    logDiagnostic(</span><br><span class="line">                            <span class="string">&quot;[LOOKUP] Properties file specifies LogFactory subclass &#x27;&quot;</span> + factoryClass + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                factory = newFactory(factoryClass, baseClassLoader, contextClassLoader);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// <span class="doctag">TODO:</span> think about whether we need to handle exceptions from newFactory</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (isDiagnosticsEnabled()) &#123;</span><br><span class="line">                    logDiagnostic(<span class="string">&quot;[LOOKUP] Properties file has no entry specifying LogFactory subclass.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (isDiagnosticsEnabled()) &#123;</span><br><span class="line">                logDiagnostic(<span class="string">&quot;[LOOKUP] No properties file available to determine&quot;</span> + <span class="string">&quot; LogFactory subclass from..&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后，使用后备factory实现，org.apache.commons.logging.impl.LogFactoryImpl</span></span><br><span class="line">    <span class="comment">// Fourth, try the fallback implementation class</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (factory == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isDiagnosticsEnabled()) &#123;</span><br><span class="line">            logDiagnostic(</span><br><span class="line">                    <span class="string">&quot;[LOOKUP] Loading the default LogFactory implementation &#x27;&quot;</span> + FACTORY_DEFAULT +</span><br><span class="line">                            <span class="string">&quot;&#x27; via the same classloader that loaded this LogFactory&quot;</span> +</span><br><span class="line">                            <span class="string">&quot; class (ie not looking in the context classloader).&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Note: unlike the above code which can try to load custom LogFactory</span></span><br><span class="line">        <span class="comment">// implementations via the TCCL, we don&#x27;t try to load the default LogFactory</span></span><br><span class="line">        <span class="comment">// implementation via the context classloader because:</span></span><br><span class="line">        <span class="comment">// * that can cause problems (see comments in newFactory method)</span></span><br><span class="line">        <span class="comment">// * no-one should be customising the code of the default class</span></span><br><span class="line">        <span class="comment">// Yes, we do give up the ability for the child to ship a newer</span></span><br><span class="line">        <span class="comment">// version of the LogFactoryImpl class and have it used dynamically</span></span><br><span class="line">        <span class="comment">// by an old LogFactory class in the parent, but that isn&#x27;t</span></span><br><span class="line">        <span class="comment">// necessarily a good idea anyway.</span></span><br><span class="line">        factory = newFactory(FACTORY_DEFAULT, thisClassLoader, contextClassLoader);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (factory != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">            * Always cache using context class loader.</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        cacheFactory(contextClassLoader, factory);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (props != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">Enumeration</span> <span class="variable">names</span> <span class="operator">=</span> props.propertyNames();</span><br><span class="line">            <span class="keyword">while</span> (names.hasMoreElements()) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> (String) names.nextElement();</span><br><span class="line">                <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> props.getProperty(name);</span><br><span class="line">                factory.setAttribute(name, value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> factory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，抽象类LogFactory加载具体实现的步骤如下：</p><ul><li>从vm系统属性org.apache.commons.logging.LogFactory</li><li>使用SPI服务发现机制，发现org.apache.commons.logging.LogFactory的实现</li><li>查找classpath根目录commons-logging.properties的org.apache.commons.logging.LogFactory属性是否指定factory实现</li><li>使用默认factory实现，org.apache.commons.logging.impl.LogFactoryImpl</li></ul><blockquote><p>LogFactory的getLog()方法返回类型是org.apache.commons.logging.Log接口，提供了从trace到fatal方法。可以确定，如果日志实现提供者只要实现该接口，并且使用继承自org.apache.commons.logging.LogFactory的子类创建Log，必然可以构建一个松耦合的日志系统。</p></blockquote><h3 id="SPI机制-插件体系"><a href="#SPI机制-插件体系" class="headerlink" title="# SPI机制 - 插件体系"></a><a href="#spi%E6%9C%BA%E5%88%B6-%E6%8F%92%E4%BB%B6%E4%BD%93%E7%B3%BB">#</a> SPI机制 - 插件体系</h3><blockquote><p>其实最具spi思想的应该属于插件开发，我们项目中也用到的这种思想，后面再说，这里具体说一下eclipse的插件思想。</p></blockquote><p>Eclipse使用OSGi作为插件系统的基础，动态添加新插件和停止现有插件，以动态的方式管理组件生命周期。</p><p>一般来说，插件的文件结构必须在指定目录下包含以下三个文件：</p><ul><li><code>META-INF/MANIFEST.MF</code>: 项目基本配置信息，版本、名称、启动器等</li><li><code>build.properties</code>: 项目的编译配置信息，包括，源代码路径、输出路径</li><li><code>plugin.xml</code>：插件的操作配置信息，包含弹出菜单及点击菜单后对应的操作执行类等</li></ul><p>当eclipse启动时，会遍历plugins文件夹中的目录，扫描每个插件的清单文件<code>MANIFEST.MF</code>，并建立一个内部模型来记录它所找到的每个插件的信息，就实现了动态添加新的插件。</p><p>这也意味着是eclipse制定了一系列的规则，像是文件结构、类型、参数等。插件开发者遵循这些规则去开发自己的插件，eclipse并不需要知道插件具体是怎样开发的，只需要在启动的时候根据配置文件解析、加载到系统里就好了，是spi思想的一种体现。</p><h3 id="SPI机制-Spring中SPI机制"><a href="#SPI机制-Spring中SPI机制" class="headerlink" title="# SPI机制 - Spring中SPI机制"></a><a href="#spi%E6%9C%BA%E5%88%B6-spring%E4%B8%ADspi%E6%9C%BA%E5%88%B6">#</a> SPI机制 - Spring中SPI机制</h3><p>在springboot的自动装配过程中，最终会加载<code>META-INF/spring.factories</code>文件，而加载的过程是由<code>SpringFactoriesLoader</code>加载的。从CLASSPATH下的每个Jar包中搜寻所有<code>META-INF/spring.factories</code>配置文件，然后将解析properties文件，找到指定名称的配置后返回。需要注意的是，其实这里不仅仅是会去ClassPath路径下查找，会扫描所有路径下的Jar包，只不过这个文件只会在Classpath下的jar包中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">FACTORIES_RESOURCE_LOCATION</span> <span class="operator">=</span> <span class="string">&quot;META-INF/spring.factories&quot;</span>;</span><br><span class="line"><span class="comment">// spring.factories文件的格式为：key=value1,value2,value3</span></span><br><span class="line"><span class="comment">// 从所有的jar包中找到META-INF/spring.factories文件</span></span><br><span class="line"><span class="comment">// 然后从文件中解析出key=factoryClass类名称的所有value值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">loadFactoryNames</span><span class="params">(Class&lt;?&gt; factoryClass, ClassLoader classLoader)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">factoryClassName</span> <span class="operator">=</span> factoryClass.getName();</span><br><span class="line">    <span class="comment">// 取得资源文件的URL</span></span><br><span class="line">    Enumeration&lt;URL&gt; urls = (classLoader != <span class="literal">null</span> ? classLoader.getResources(FACTORIES_RESOURCE_LOCATION) : ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));</span><br><span class="line">    List&lt;String&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">    <span class="comment">// 遍历所有的URL</span></span><br><span class="line">    <span class="keyword">while</span> (urls.hasMoreElements()) &#123;</span><br><span class="line">        <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> urls.nextElement();</span><br><span class="line">        <span class="comment">// 根据资源文件URL解析properties文件，得到对应的一组@Configuration类</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> PropertiesLoaderUtils.loadProperties(<span class="keyword">new</span> <span class="title class_">UrlResource</span>(url));</span><br><span class="line">        <span class="type">String</span> <span class="variable">factoryClassNames</span> <span class="operator">=</span> properties.getProperty(factoryClassName);</span><br><span class="line">        <span class="comment">// 组装数据，并返回</span></span><br><span class="line">        result.addAll(Arrays.asList(StringUtils.commaDelimitedListToStringArray(factoryClassNames)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SPI机制深入理解"><a href="#SPI机制深入理解" class="headerlink" title="# SPI机制深入理解"></a><a href="#spi%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3">#</a> SPI机制深入理解</h2><p>提示</p><p>接下来，我们深入理解下SPI相关内容</p><h3 id="SPI机制通常怎么使用"><a href="#SPI机制通常怎么使用" class="headerlink" title="# SPI机制通常怎么使用"></a><a href="#spi%E6%9C%BA%E5%88%B6%E9%80%9A%E5%B8%B8%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8">#</a> SPI机制通常怎么使用</h3><p>看完上面的几个例子解析，应该都能知道大概的流程了：</p><ul><li>有关组织或者公司定义标准。</li><li>具体厂商或者框架开发者实现。</li><li>程序猿使用。</li></ul><h4 id="定义标准"><a href="#定义标准" class="headerlink" title="# 定义标准"></a><a href="#%E5%AE%9A%E4%B9%89%E6%A0%87%E5%87%86">#</a> 定义标准</h4><p>定义标准，就是定义接口。比如接口<code>java.sql.Driver</code></p><h4 id="具体厂商或者框架开发者实现"><a href="#具体厂商或者框架开发者实现" class="headerlink" title="# 具体厂商或者框架开发者实现"></a><a href="#%E5%85%B7%E4%BD%93%E5%8E%82%E5%95%86%E6%88%96%E8%80%85%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%91%E8%80%85%E5%AE%9E%E7%8E%B0">#</a> 具体厂商或者框架开发者实现</h4><p>厂商或者框架开发者开发具体的实现：</p><p>在<code>META-INF/services</code>目录下定义一个名字为接口全限定名的文件，比如<code>java.sql.Driver</code>文件，文件内容是具体的实现名字，比如<code>me.cxis.sql.MyDriver</code>。</p><p>写具体的实现<code>me.cxis.sql.MyDriver</code>，都是对接口Driver的实现。</p><h4 id="程序猿使用"><a href="#程序猿使用" class="headerlink" title="# 程序猿使用"></a><a href="#%E7%A8%8B%E5%BA%8F%E7%8C%BF%E4%BD%BF%E7%94%A8">#</a> 程序猿使用</h4><p>我们会引用具体厂商的jar包来实现我们的功能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver.class);</span><br><span class="line"><span class="comment">//获取迭代器</span></span><br><span class="line">Iterator&lt;Driver&gt; driversIterator = loadedDrivers.iterator();</span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="keyword">while</span>(driversIterator.hasNext()) &#123;</span><br><span class="line">    driversIterator.next();</span><br><span class="line">    <span class="comment">//可以做具体的业务逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用规范"><a href="#使用规范" class="headerlink" title="# 使用规范"></a><a href="#%E4%BD%BF%E7%94%A8%E8%A7%84%E8%8C%83">#</a> 使用规范</h4><p>最后总结一下jdk spi需要遵循的规范</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230821141036973.png" alt="image-20230821141036973"></p><h3 id="SPI和API的区别是什么"><a href="#SPI和API的区别是什么" class="headerlink" title="# SPI和API的区别是什么"></a><a href="#spi%E5%92%8Capi%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88">#</a> SPI和API的区别是什么</h3><blockquote><p>这里实际包含两个问题，第一个SPI和API的区别？第二个什么时候用API，什么时候用SPI？</p></blockquote><blockquote><p>SPI - “接口”位于“调用方”所在的“包”中</p></blockquote><ul><li>概念上更依赖调用方。</li><li>组织上位于调用方所在的包中。</li><li>实现位于独立的包中。</li><li>常见的例子是：插件模式的插件。</li></ul><blockquote><p>API - “接口”位于“实现方”所在的“包”中</p></blockquote><ul><li>概念上更接近实现方。</li><li>组织上位于实现方所在的包中。</li><li>实现和接口在一个包中。</li></ul><p>参考：</p><ul><li><a href="https://stackoverflow.com/questions/2954372/difference-between-spi-and-api?answertab=votes#tab-top">difference-between-spi-and-api在新窗口打开</a></li><li><a href="https://www.cnblogs.com/happyframework/archive/2013/09/17/3325560.html">设计原则：小议 SPI 和 API在新窗口打开</a></li></ul><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230821141056131.png" alt="image-20230821141056131"></p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230821141106243.png" alt="image-20230821141106243"></p><h3 id="SPI机制实现原理"><a href="#SPI机制实现原理" class="headerlink" title="# SPI机制实现原理"></a><a href="#spi%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86">#</a> SPI机制实现原理</h3><p>不妨看下JDK中<code>ServiceLoader&lt;S&gt;</code>方法的具体实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ServiceLoader实现了Iterable接口，可以遍历所有的服务实现者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ServiceLoader</span>&lt;S&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Iterable</span>&lt;S&gt;</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找配置文件的目录</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PREFIX</span> <span class="operator">=</span> <span class="string">&quot;META-INF/services/&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//表示要被加载的服务的类或接口</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;S&gt; service;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个ClassLoader用来定位，加载，实例化服务提供者</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader loader;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问控制上下文</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AccessControlContext acc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 缓存已经被实例化的服务提供者，按照实例化的顺序存储</span></span><br><span class="line">    <span class="keyword">private</span> LinkedHashMap&lt;String,S&gt; providers = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代器</span></span><br><span class="line">    <span class="keyword">private</span> LazyIterator lookupIterator;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//重新加载，就相当于重新创建ServiceLoader了，用于新的服务提供者安装到正在运行的Java虚拟机中的情况。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reload</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//清空缓存中所有已实例化的服务提供者</span></span><br><span class="line">        providers.clear();</span><br><span class="line">        <span class="comment">//新建一个迭代器，该迭代器会从头查找和实例化服务提供者</span></span><br><span class="line">        lookupIterator = <span class="keyword">new</span> <span class="title class_">LazyIterator</span>(service, loader);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有构造器</span></span><br><span class="line">    <span class="comment">//使用指定的类加载器和服务创建服务加载器</span></span><br><span class="line">    <span class="comment">//如果没有指定类加载器，使用系统类加载器，就是应用类加载器。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">ServiceLoader</span><span class="params">(Class&lt;S&gt; svc, ClassLoader cl)</span> &#123;</span><br><span class="line">        service = Objects.requireNonNull(svc, <span class="string">&quot;Service interface cannot be null&quot;</span>);</span><br><span class="line">        loader = (cl == <span class="literal">null</span>) ? ClassLoader.getSystemClassLoader() : cl;</span><br><span class="line">        acc = (System.getSecurityManager() != <span class="literal">null</span>) ? AccessController.getContext() : <span class="literal">null</span>;</span><br><span class="line">        reload();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//解析失败处理的方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">fail</span><span class="params">(Class&lt;?&gt; service, String msg, Throwable cause)</span></span><br><span class="line">        <span class="keyword">throws</span> ServiceConfigurationError</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ServiceConfigurationError</span>(service.getName() + <span class="string">&quot;: &quot;</span> + msg,</span><br><span class="line">                                            cause);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">fail</span><span class="params">(Class&lt;?&gt; service, String msg)</span></span><br><span class="line">        <span class="keyword">throws</span> ServiceConfigurationError</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ServiceConfigurationError</span>(service.getName() + <span class="string">&quot;: &quot;</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">fail</span><span class="params">(Class&lt;?&gt; service, URL u, <span class="type">int</span> line, String msg)</span></span><br><span class="line">        <span class="keyword">throws</span> ServiceConfigurationError</span><br><span class="line">    &#123;</span><br><span class="line">        fail(service, u + <span class="string">&quot;:&quot;</span> + line + <span class="string">&quot;: &quot;</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//解析服务提供者配置文件中的一行</span></span><br><span class="line">    <span class="comment">//首先去掉注释校验，然后保存</span></span><br><span class="line">    <span class="comment">//返回下一行行号</span></span><br><span class="line">    <span class="comment">//重复的配置项和已经被实例化的配置项不会被保存</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">parseLine</span><span class="params">(Class&lt;?&gt; service, URL u, BufferedReader r, <span class="type">int</span> lc,</span></span><br><span class="line"><span class="params">                          List&lt;String&gt; names)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException, ServiceConfigurationError</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//读取一行</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">ln</span> <span class="operator">=</span> r.readLine();</span><br><span class="line">        <span class="keyword">if</span> (ln == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//#号代表注释行</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ci</span> <span class="operator">=</span> ln.indexOf(<span class="string">&#x27;#&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (ci &gt;= <span class="number">0</span>) ln = ln.substring(<span class="number">0</span>, ci);</span><br><span class="line">        ln = ln.trim();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> ln.length();</span><br><span class="line">        <span class="keyword">if</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((ln.indexOf(<span class="string">&#x27; &#x27;</span>) &gt;= <span class="number">0</span>) || (ln.indexOf(<span class="string">&#x27;\t&#x27;</span>) &gt;= <span class="number">0</span>))</span><br><span class="line">                fail(service, u, lc, <span class="string">&quot;Illegal configuration-file syntax&quot;</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">cp</span> <span class="operator">=</span> ln.codePointAt(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (!Character.isJavaIdentifierStart(cp))</span><br><span class="line">                fail(service, u, lc, <span class="string">&quot;Illegal provider-class name: &quot;</span> + ln);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> Character.charCount(cp); i &lt; n; i += Character.charCount(cp)) &#123;</span><br><span class="line">                cp = ln.codePointAt(i);</span><br><span class="line">                <span class="keyword">if</span> (!Character.isJavaIdentifierPart(cp) &amp;&amp; (cp != <span class="string">&#x27;.&#x27;</span>))</span><br><span class="line">                    fail(service, u, lc, <span class="string">&quot;Illegal provider-class name: &quot;</span> + ln);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!providers.containsKey(ln) &amp;&amp; !names.contains(ln))</span><br><span class="line">                names.add(ln);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lc + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//解析配置文件，解析指定的url配置文件</span></span><br><span class="line">    <span class="comment">//使用parseLine方法进行解析，未被实例化的服务提供者会被保存到缓存中去</span></span><br><span class="line">    <span class="keyword">private</span> Iterator&lt;String&gt; <span class="title function_">parse</span><span class="params">(Class&lt;?&gt; service, URL u)</span></span><br><span class="line">        <span class="keyword">throws</span> ServiceConfigurationError</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">r</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        ArrayList&lt;String&gt; names = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            in = u.openStream();</span><br><span class="line">            r = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(in, <span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line">            <span class="type">int</span> <span class="variable">lc</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> ((lc = parseLine(service, u, r, lc, names)) &gt;= <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> names.iterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//服务提供者查找的迭代器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">LazyIterator</span></span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;S&gt;</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        Class&lt;S&gt; service;<span class="comment">//服务提供者接口</span></span><br><span class="line">        ClassLoader loader;<span class="comment">//类加载器</span></span><br><span class="line">        Enumeration&lt;URL&gt; configs = <span class="literal">null</span>;<span class="comment">//保存实现类的url</span></span><br><span class="line">        Iterator&lt;String&gt; pending = <span class="literal">null</span>;<span class="comment">//保存实现类的全名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">nextName</span> <span class="operator">=</span> <span class="literal">null</span>;<span class="comment">//迭代器中下一个实现类的全名</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="title function_">LazyIterator</span><span class="params">(Class&lt;S&gt; service, ClassLoader loader)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.service = service;</span><br><span class="line">            <span class="built_in">this</span>.loader = loader;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">hasNextService</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (nextName != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (configs == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">fullName</span> <span class="operator">=</span> PREFIX + service.getName();</span><br><span class="line">                    <span class="keyword">if</span> (loader == <span class="literal">null</span>)</span><br><span class="line">                        configs = ClassLoader.getSystemResources(fullName);</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        configs = loader.getResources(fullName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> ((pending == <span class="literal">null</span>) || !pending.hasNext()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!configs.hasMoreElements()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                pending = parse(service, configs.nextElement());</span><br><span class="line">            &#125;</span><br><span class="line">            nextName = pending.next();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> S <span class="title function_">nextService</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!hasNextService())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">            <span class="type">String</span> <span class="variable">cn</span> <span class="operator">=</span> nextName;</span><br><span class="line">            nextName = <span class="literal">null</span>;</span><br><span class="line">            Class&lt;?&gt; c = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                c = Class.forName(cn, <span class="literal">false</span>, loader);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!service.isAssignableFrom(c)) &#123;</span><br><span class="line">                fail(service, <span class="string">&quot;Provider &quot;</span> + cn  + <span class="string">&quot; not a subtype&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">S</span> <span class="variable">p</span> <span class="operator">=</span> service.cast(c.newInstance());</span><br><span class="line">                providers.put(cn, p);</span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (acc == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> hasNextService();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                PrivilegedAction&lt;Boolean&gt; action = <span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;Boolean&gt;() &#123;</span><br><span class="line">                    <span class="keyword">public</span> Boolean <span class="title function_">run</span><span class="params">()</span> &#123; <span class="keyword">return</span> hasNextService(); &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="keyword">return</span> AccessController.doPrivileged(action, acc);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> S <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (acc == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> nextService();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                PrivilegedAction&lt;S&gt; action = <span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;S&gt;() &#123;</span><br><span class="line">                    <span class="keyword">public</span> S <span class="title function_">run</span><span class="params">()</span> &#123; <span class="keyword">return</span> nextService(); &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="keyword">return</span> AccessController.doPrivileged(action, acc);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取迭代器</span></span><br><span class="line">    <span class="comment">//返回遍历服务提供者的迭代器</span></span><br><span class="line">    <span class="comment">//以懒加载的方式加载可用的服务提供者</span></span><br><span class="line">    <span class="comment">//懒加载的实现是：解析配置文件和实例化服务提供者的工作由迭代器本身完成</span></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;S&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Iterator</span>&lt;S&gt;() &#123;</span><br><span class="line">            <span class="comment">//按照实例化顺序返回已经缓存的服务提供者实例</span></span><br><span class="line">            Iterator&lt;Map.Entry&lt;String,S&gt;&gt; knownProviders</span><br><span class="line">                = providers.entrySet().iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (knownProviders.hasNext())</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">return</span> lookupIterator.hasNext();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> S <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (knownProviders.hasNext())</span><br><span class="line">                    <span class="keyword">return</span> knownProviders.next().getValue();</span><br><span class="line">                <span class="keyword">return</span> lookupIterator.next();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为指定的服务使用指定的类加载器来创建一个ServiceLoader</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; ServiceLoader&lt;S&gt; <span class="title function_">load</span><span class="params">(Class&lt;S&gt; service,</span></span><br><span class="line"><span class="params">                                            ClassLoader loader)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ServiceLoader</span>&lt;&gt;(service, loader);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用线程上下文的类加载器来创建ServiceLoader</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; ServiceLoader&lt;S&gt; <span class="title function_">load</span><span class="params">(Class&lt;S&gt; service)</span> &#123;</span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">cl</span> <span class="operator">=</span> Thread.currentThread().getContextClassLoader();</span><br><span class="line">        <span class="keyword">return</span> ServiceLoader.load(service, cl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用扩展类加载器为指定的服务创建ServiceLoader</span></span><br><span class="line">    <span class="comment">//只能找到并加载已经安装到当前Java虚拟机中的服务提供者，应用程序类路径中的服务提供者将被忽略</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; ServiceLoader&lt;S&gt; <span class="title function_">loadInstalled</span><span class="params">(Class&lt;S&gt; service)</span> &#123;</span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">cl</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader();</span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (cl != <span class="literal">null</span>) &#123;</span><br><span class="line">            prev = cl;</span><br><span class="line">            cl = cl.getParent();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ServiceLoader.load(service, prev);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;java.util.ServiceLoader[&quot;</span> + service.getName() + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>首先</strong>，ServiceLoader实现了<code>Iterable</code>接口，所以它有迭代器的属性，这里主要都是实现了迭代器的<code>hasNext</code>和<code>next</code>方法。这里主要都是调用的<code>lookupIterator</code>的相应<code>hasNext</code>和<code>next</code>方法，<code>lookupIterator</code>是懒加载迭代器。</p><p><strong>其次</strong>，<code>LazyIterator</code>中的<code>hasNext</code>方法，静态变量PREFIX就是<code>”META-INF/services/”</code>目录，这也就是为什么需要在<code>classpath</code>下的<code>META-INF/services/</code>目录里创建一个以服务接口命名的文件。</p><p><strong>最后</strong>，通过反射方法<code>Class.forName()</code>加载类对象，并用<code>newInstance</code>方法将类实例化，并把实例化后的类缓存到<code>providers</code>对象中，(<code>LinkedHashMap&lt;String,S&gt;</code>类型）然后返回实例对象。</p><p>所以我们可以看到<code>ServiceLoader</code>不是实例化以后，就去读取配置文件中的具体实现，并进行实例化。而是等到使用迭代器去遍历的时候，才会加载对应的配置文件去解析，调用<code>hasNext</code>方法的时候会去加载配置文件进行解析，调用<code>next</code>方法的时候进行实例化并缓存。</p><p>所有的配置文件只会加载一次，服务提供者也只会被实例化一次，重新加载配置文件可使用<code>reload</code>方法。</p><h3 id="SPI机制的缺陷"><a href="#SPI机制的缺陷" class="headerlink" title="# SPI机制的缺陷"></a><a href="#spi%E6%9C%BA%E5%88%B6%E7%9A%84%E7%BC%BA%E9%99%B7">#</a> SPI机制的缺陷</h3><p>通过上面的解析，可以发现，我们使用SPI机制的缺陷：</p><ul><li>不能按需加载，需要遍历所有的实现，并实例化，然后在循环中才能找到我们需要的实现。如果不想用某些实现类，或者某些类实例化很耗时，它也被载入并实例化了，这就造成了浪费。</li><li>获取某个实现类的方式不够灵活，只能通过 Iterator 形式获取，不能根据某个参数来获取对应的实现类。</li><li>多个并发多线程使用 ServiceLoader 类的实例是不安全的。</li></ul><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="# 参考文章"></a><a href="#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0">#</a> 参考文章</h2><ul><li><a href="https://cxis.me/2017/04/17/Java%E4%B8%ADSPI%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%85%A5%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">https://cxis.me/2017/04/17/Java%E4%B8%ADSPI%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%85%A5%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</a></li><li><a href="https://stackoverflow.com/questions/2954372/difference-between-spi-and-api?answertab=votes#tab-top">https://stackoverflow.com/questions/2954372/difference-between-spi-and-api?answertab=votes#tab-top</a></li><li><a href="https://zhuanlan.zhihu.com/p/28909673">https://zhuanlan.zhihu.com/p/28909673</a></li><li><a href="http://blog.itpub.net/69912579/viewspace-2656555/">http://blog.itpub.net/69912579/viewspace-2656555/</a></li><li><a href="https://www.cnblogs.com/happyframework/archive/2013/09/17/3325560.html">https://www.cnblogs.com/happyframework/archive/2013/09/17/3325560.html</a></li><li><a href="https://blog.csdn.net/sakurainluojia/article/details/53534949">https://blog.csdn.net/sakurainluojia/article/details/53534949</a></li><li><a href="https://www.jianshu.com/p/0d196ad23915">https://www.jianshu.com/p/0d196ad23915</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 类别 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 基础 - 反射机制详解</title>
      <link href="/posts/e78c9f55.html"/>
      <url>/posts/e78c9f55.html</url>
      
        <content type="html"><![CDATA[<p>摘要</p><span id="more"></span><h2 id="反射基础"><a href="#反射基础" class="headerlink" title="反射基础"></a>反射基础</h2><p>RTTI（Run-Time Type Identification）运行时类型识别。在《Thinking in Java》一书第十四章中有提到，其作用是在运行时识别一个对象的类型和类的信息。主要有两种方式：一种是“传统的”RTTI，它假定我们在编译时已经知道了所有的类型；另一种是“反射”机制，它允许我们在运行时发现和使用类的信息。</p><p>反射就是把java类中的各种成分映射成一个个的Java对象</p><p>例如：一个类有：成员变量、方法、构造方法、包等等信息，利用反射技术可以对一个类进行解剖，把个个组成部分映射成一个个对象。</p><blockquote><p>这里我们首先需要理解 Class类，以及类的加载机制； 然后基于此我们如何通过反射获取Class类以及类中的成员变量、方法、构造方法等。</p></blockquote><h3 id="Class类"><a href="#Class类" class="headerlink" title="# Class类"></a><a href="#class%E7%B1%BB">#</a> Class类</h3><p>Class类，Class类也是一个实实在在的类，存在于JDK的java.lang包中。Class类的实例表示java应用运行时的类(class ans enum)或接口(interface and annotation)（每个java类运行时都在JVM里表现为一个class对象，可通过类名.class、类型.getClass()、Class.forName(“类名”)等方法获取class对象）。数组同样也被映射为class 对象的一个类，所有具有相同元素类型和维数的数组都共享该 Class 对象。基本类型boolean，byte，char，short，int，long，float，double和关键字void同样表现为 class 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Class</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable,</span><br><span class="line">                              GenericDeclaration,</span><br><span class="line">                              Type,</span><br><span class="line">                              AnnotatedElement &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> ANNOTATION= <span class="number">0x00002000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">ENUM</span>      <span class="operator">=</span> <span class="number">0x00004000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SYNTHETIC</span> <span class="operator">=</span> <span class="number">0x00001000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">registerNatives</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        registerNatives();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Private constructor. Only the Java Virtual Machine creates Class objects.   //私有构造器，只有JVM才能调用创建Class对象</span></span><br><span class="line"><span class="comment">     * This constructor is not used and prevents the default constructor being</span></span><br><span class="line"><span class="comment">     * generated.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Class</span><span class="params">(ClassLoader loader)</span> &#123;</span><br><span class="line">        <span class="comment">// Initialize final field for classLoader.  The initialization value of non-null</span></span><br><span class="line">        <span class="comment">// prevents future JIT optimizations from assuming this final field is null.</span></span><br><span class="line">        classLoader = loader;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>到这我们也就可以得出以下几点信息：</p><ul><li>Class类也是类的一种，与class关键字是不一样的。</li><li>手动编写的类被编译后会产生一个Class对象，其表示的是创建的类的类型信息，而且这个Class对象保存在同名.class的文件中(字节码文件)</li><li>每个通过关键字class标识的类，在内存中有且只有一个与之对应的Class对象来描述其类型信息，无论创建多少个实例对象，其依据的都是用一个Class对象。</li><li>Class类只存私有构造函数，因此对应Class对象只能有JVM创建和加载</li><li>Class类的对象作用是运行时提供或获得某个对象的类型信息，这点对于反射技术很重要(关于反射稍后分析)。</li></ul><h3 id="类加载"><a href="#类加载" class="headerlink" title="# 类加载"></a><a href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD">#</a> 类加载</h3><p>类加载机制和类字节码技术可以参考如下两篇文章：</p><ul><li>JVM基础 - 类字节码详解<ul><li>源代码通过编译器编译为字节码，再通过类加载子系统进行加载到JVM中运行</li></ul></li><li>JVM基础 - Java 类加载机制<ul><li>这篇文章将带你深入理解Java 类加载机制</li></ul></li></ul><p>其中，这里我们需要回顾的是：</p><ol><li>类加载机制流程</li></ol><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230821133303308.png" alt="image-20230821133303308"></p><ol><li>类的加载</li></ol><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230821133337728.png" alt="image-20230821133337728"></p><h2 id="反射的使用"><a href="#反射的使用" class="headerlink" title="# 反射的使用"></a><a href="#%E5%8F%8D%E5%B0%84%E7%9A%84%E4%BD%BF%E7%94%A8">#</a> 反射的使用</h2><p>提示</p><p>基于此我们如何通过反射获取Class类对象以及类中的成员变量、方法、构造方法等</p><p>在Java中，Class类与java.lang.reflect类库一起对反射技术进行了全力的支持。在反射包中，我们常用的类主要有Constructor类表示的是Class 对象所表示的类的构造方法，利用它可以在运行时动态创建对象、Field表示Class对象所表示的类的成员变量，通过它可以在运行时动态修改成员变量的属性值(包含private)、Method表示Class对象所表示的类的成员方法，通过它可以动态调用对象的方法(包含private)，下面将对这几个重要类进行分别说明。</p><h3 id="Class类对象的获取"><a href="#Class类对象的获取" class="headerlink" title="# Class类对象的获取"></a><a href="#class%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%8E%B7%E5%8F%96">#</a> Class类对象的获取</h3><p>在类加载的时候，jvm会创建一个class对象</p><p>class对象是可以说是反射中最常用的，获取class对象的方式的主要有三种</p><ul><li>根据类名：类名.class</li><li>根据对象：对象.getClass()</li><li>根据全限定类名：Class.forName(全限定类名)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">classTest</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 获取Class对象的三种方式</span></span><br><span class="line">    logger.info(<span class="string">&quot;根据类名:  \t&quot;</span> + User.class);</span><br><span class="line">    logger.info(<span class="string">&quot;根据对象:  \t&quot;</span> + <span class="keyword">new</span> <span class="title class_">User</span>().getClass());</span><br><span class="line">    logger.info(<span class="string">&quot;根据全限定类名:\t&quot;</span> + Class.forName(<span class="string">&quot;com.test.User&quot;</span>));</span><br><span class="line">    <span class="comment">// 常用的方法</span></span><br><span class="line">    logger.info(<span class="string">&quot;获取全限定类名:\t&quot;</span> + userClass.getName());</span><br><span class="line">    logger.info(<span class="string">&quot;获取类名:\t&quot;</span> + userClass.getSimpleName());</span><br><span class="line">    logger.info(<span class="string">&quot;实例化:\t&quot;</span> + userClass.newInstance());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;init&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User [name=&quot;</span> + name + <span class="string">&quot;, age=&quot;</span> + age + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">根据类名:  <span class="keyword">class</span> <span class="title class_">com</span>.test.User</span><br><span class="line">根据对象:  <span class="keyword">class</span> <span class="title class_">com</span>.test.User</span><br><span class="line">根据全限定类名:<span class="keyword">class</span> <span class="title class_">com</span>.test.User</span><br><span class="line">获取全限定类名:com.test.User</span><br><span class="line">获取类名:User</span><br><span class="line">实例化:User [name=init, age=<span class="number">0</span>]</span><br></pre></td></tr></table></figure><ul><li>再来看看 <strong>Class类的方法</strong></li></ul><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>forName()</td><td>(1)获取Class对象的一个引用，但引用的类还没有加载(该类的第一个对象没有生成)就加载了这个类。</td></tr><tr><td>(2)为了产生Class引用，forName()立即就进行了初始化。</td><td></td></tr><tr><td>Object-getClass()</td><td>获取Class对象的一个引用，返回表示该对象的实际类型的Class引用。</td></tr><tr><td>getName()</td><td>取全限定的类名(包括包名)，即类的完整名字。</td></tr><tr><td>getSimpleName()</td><td>获取类名(不包括包名)</td></tr><tr><td>getCanonicalName()</td><td>获取全限定的类名(包括包名)</td></tr><tr><td>isInterface()</td><td>判断Class对象是否是表示一个接口</td></tr><tr><td>getInterfaces()</td><td>返回Class对象数组，表示Class对象所引用的类所实现的所有接口。</td></tr><tr><td>getSupercalss()</td><td>返回Class对象，表示Class对象所引用的类所继承的直接基类。应用该方法可在运行时发现一个对象完整的继承结构。</td></tr><tr><td>newInstance()</td><td>返回一个Oject对象，是实现“虚拟构造器”的一种途径。使用该方法创建的类，必须带有无参的构造器。</td></tr><tr><td>getFields()</td><td>获得某个类的所有的公共（public）的字段，包括继承自父类的所有公共字段。 类似的还有getMethods和getConstructors。</td></tr><tr><td>getDeclaredFields</td><td>获得某个类的自己声明的字段，即包括public、private和proteced，默认但是不包括父类声明的任何字段。类似的还有getDeclaredMethods和getDeclaredConstructors。</td></tr></tbody></table><p>简单测试下（这里例子源于<a href="https://blog.csdn.net/mcryeasy/article/details/52344729%EF%BC%89">https://blog.csdn.net/mcryeasy/article/details/52344729）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cry;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">I1</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">I2</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cell</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> mCellPublic;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> <span class="keyword">extends</span>  <span class="title class_">Cell</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> mAnimalPrivate;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> mAnimalProtected;</span><br><span class="line">    <span class="type">int</span> mAnimalDefault;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> mAnimalPublic;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> sAnimalPrivate;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="type">int</span> sAnimalProtected;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> sAnimalDefault;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> sAnimalPublic;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> <span class="keyword">implements</span> <span class="title class_">I1</span>, I2 &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> mDogPrivate;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> mDogPublic;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> mDogProtected;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> mDogDefault;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> sDogPrivate;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="type">int</span> sDogProtected;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> sDogDefault;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> sDogPublic;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IllegalAccessException, InstantiationException &#123;</span><br><span class="line">        Class&lt;Dog&gt; dog = Dog.class;</span><br><span class="line">        <span class="comment">//类名打印</span></span><br><span class="line">        System.out.println(dog.getName()); <span class="comment">//com.cry.Dog</span></span><br><span class="line">        System.out.println(dog.getSimpleName()); <span class="comment">//Dog</span></span><br><span class="line">        System.out.println(dog.getCanonicalName());<span class="comment">//com.cry.Dog</span></span><br><span class="line">        <span class="comment">//接口</span></span><br><span class="line">        System.out.println(dog.isInterface()); <span class="comment">//false</span></span><br><span class="line">        <span class="keyword">for</span> (Class iI : dog.getInterfaces()) &#123;</span><br><span class="line">            System.out.println(iI);</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="comment">/*</span></span><br><span class="line"><span class="comment">          interface com.cry.I1</span></span><br><span class="line"><span class="comment">          interface com.cry.I2</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//父类</span></span><br><span class="line">        System.out.println(dog.getSuperclass());<span class="comment">//class com.cry.Animal</span></span><br><span class="line">        <span class="comment">//创建对象</span></span><br><span class="line">        <span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> dog.newInstance();</span><br><span class="line">        <span class="comment">//字段</span></span><br><span class="line">        <span class="keyword">for</span> (Field f : dog.getFields()) &#123;</span><br><span class="line">            System.out.println(f.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            mDogPublic</span></span><br><span class="line"><span class="comment">            sDogPublic</span></span><br><span class="line"><span class="comment">            mAnimalPublic</span></span><br><span class="line"><span class="comment">            sAnimalPublic</span></span><br><span class="line"><span class="comment">            mCellPublic  //父类的父类的公共字段也打印出来了</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(<span class="string">&quot;---------&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Field f : dog.getDeclaredFields()) &#123;</span><br><span class="line">            System.out.println(f.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/** 只有自己类声明的字段</span></span><br><span class="line"><span class="comment">         mDogPrivate</span></span><br><span class="line"><span class="comment">         mDogPublic</span></span><br><span class="line"><span class="comment">         mDogProtected</span></span><br><span class="line"><span class="comment">         mDogDefault</span></span><br><span class="line"><span class="comment">         sDogPrivate</span></span><br><span class="line"><span class="comment">         sDogProtected</span></span><br><span class="line"><span class="comment">         sDogDefault</span></span><br><span class="line"><span class="comment">         sDogPublic</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>getName、getCanonicalName与getSimpleName的区别</strong>：</p><ul><li>getSimpleName：只获取类名</li><li>getName：类的全限定名，jvm中Class的表示，可以用于动态加载Class对象，例如Class.forName。</li><li>getCanonicalName：返回更容易理解的表示，主要用于输出（toString）或log打印，大多数情况下和getName一样，但是在内部类、数组等类型的表示形式就不同了。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cry;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">class</span> <span class="title class_">inner</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">//普通类</span></span><br><span class="line">        System.out.println(Test.class.getSimpleName()); <span class="comment">//Test</span></span><br><span class="line">        System.out.println(Test.class.getName()); <span class="comment">//com.cry.Test</span></span><br><span class="line">        System.out.println(Test.class.getCanonicalName()); <span class="comment">//com.cry.Test</span></span><br><span class="line">        <span class="comment">//内部类</span></span><br><span class="line">        System.out.println(inner.class.getSimpleName()); <span class="comment">//inner</span></span><br><span class="line">        System.out.println(inner.class.getName()); <span class="comment">//com.cry.Test$inner</span></span><br><span class="line">        System.out.println(inner.class.getCanonicalName()); <span class="comment">//com.cry.Test.inner</span></span><br><span class="line">        <span class="comment">//数组</span></span><br><span class="line">        System.out.println(args.getClass().getSimpleName()); <span class="comment">//String[]</span></span><br><span class="line">        System.out.println(args.getClass().getName()); <span class="comment">//[Ljava.lang.String;</span></span><br><span class="line">        System.out.println(args.getClass().getCanonicalName()); <span class="comment">//java.lang.String[]</span></span><br><span class="line">        <span class="comment">//我们不能用getCanonicalName去加载类对象，必须用getName</span></span><br><span class="line">        <span class="comment">//Class.forName(inner.class.getCanonicalName()); 报错</span></span><br><span class="line">        Class.forName(inner.class.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Constructor类及其用法"><a href="#Constructor类及其用法" class="headerlink" title="# Constructor类及其用法"></a><a href="#constructor%E7%B1%BB%E5%8F%8A%E5%85%B6%E7%94%A8%E6%B3%95">#</a> Constructor类及其用法</h3><blockquote><p>Constructor类存在于反射包(java.lang.reflect)中，反映的是Class 对象所表示的类的构造方法。</p></blockquote><p>获取Constructor对象是通过Class类中的方法获取的，Class类与Constructor相关的主要方法如下：</p><table><thead><tr><th>方法返回值</th><th>方法名称</th><th>方法说明</th></tr></thead><tbody><tr><td>static Class&lt;?&gt;</td><td>forName(String className)</td><td>返回与带有给定字符串名的类或接口相关联的 Class 对象。</td></tr><tr><td>Constructor</td><td>getConstructor(Class&lt;?&gt;… parameterTypes)</td><td>返回指定参数类型、具有public访问权限的构造函数对象</td></tr><tr><td>Constructor&lt;?&gt;[]</td><td>getConstructors()</td><td>返回所有具有public访问权限的构造函数的Constructor对象数组</td></tr><tr><td>Constructor</td><td>getDeclaredConstructor(Class&lt;?&gt;… parameterTypes)</td><td>返回指定参数类型、所有声明的（包括private）构造函数对象</td></tr><tr><td>Constructor&lt;?&gt;[]</td><td>getDeclaredConstructors()</td><td>返回所有声明的（包括private）构造函数对象</td></tr><tr><td>T</td><td>newInstance()</td><td>调用无参构造器创建此 Class 对象所表示的类的一个新实例。</td></tr></tbody></table><p>下面看一个简单例子来了解Constructor对象的使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConstructionTest</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; clazz = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取Class对象的引用</span></span><br><span class="line">        clazz = Class.forName(<span class="string">&quot;com.example.javabase.User&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第一种方法，实例化默认构造方法，User必须无参构造函数,否则将抛异常</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User) clazz.newInstance();</span><br><span class="line">        user.setAge(<span class="number">20</span>);</span><br><span class="line">        user.setName(<span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">        System.out.println(user);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;--------------------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取带String参数的public构造函数</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">cs1</span> <span class="operator">=</span>clazz.getConstructor(String.class);</span><br><span class="line">        <span class="comment">//创建User</span></span><br><span class="line">        User user1= (User) cs1.newInstance(<span class="string">&quot;hiway&quot;</span>);</span><br><span class="line">        user1.setAge(<span class="number">22</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;user1:&quot;</span>+user1.toString());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;--------------------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//取得指定带int和String参数构造函数,该方法是私有构造private</span></span><br><span class="line">        Constructor cs2=clazz.getDeclaredConstructor(<span class="type">int</span>.class,String.class);</span><br><span class="line">        <span class="comment">//由于是private必须设置可访问</span></span><br><span class="line">        cs2.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//创建user对象</span></span><br><span class="line">        User user2= (User) cs2.newInstance(<span class="number">25</span>,<span class="string">&quot;hiway2&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;user2:&quot;</span>+user2.toString());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;--------------------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取所有构造包含private</span></span><br><span class="line">        Constructor&lt;?&gt; cons[] = clazz.getDeclaredConstructors();</span><br><span class="line">        <span class="comment">// 查看每个构造方法需要的参数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; cons.length; i++) &#123;</span><br><span class="line">            <span class="comment">//获取构造函数参数类型</span></span><br><span class="line">            Class&lt;?&gt; clazzs[] = cons[i].getParameterTypes();</span><br><span class="line">            System.out.println(<span class="string">&quot;构造函数[&quot;</span>+i+<span class="string">&quot;]:&quot;</span>+cons[i].toString() );</span><br><span class="line">            System.out.print(<span class="string">&quot;参数类型[&quot;</span>+i+<span class="string">&quot;]:(&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; clazzs.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j == clazzs.length - <span class="number">1</span>)</span><br><span class="line">                    System.out.print(clazzs[j].getName());</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    System.out.print(clazzs[j].getName() + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有构造</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> age</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">User</span><span class="params">(<span class="type">int</span> age, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* output </span></span><br><span class="line"><span class="comment">User&#123;age=20, name=&#x27;Jack&#x27;&#125;</span></span><br><span class="line"><span class="comment">--------------------------------------------</span></span><br><span class="line"><span class="comment">user1:User&#123;age=22, name=&#x27;hiway&#x27;&#125;</span></span><br><span class="line"><span class="comment">--------------------------------------------</span></span><br><span class="line"><span class="comment">user2:User&#123;age=25, name=&#x27;hiway2&#x27;&#125;</span></span><br><span class="line"><span class="comment">--------------------------------------------</span></span><br><span class="line"><span class="comment">构造函数[0]:private com.example.javabase.User(int,java.lang.String)</span></span><br><span class="line"><span class="comment">参数类型[0]:(int,java.lang.String)</span></span><br><span class="line"><span class="comment">构造函数[1]:public com.example.javabase.User(java.lang.String)</span></span><br><span class="line"><span class="comment">参数类型[1]:(java.lang.String)</span></span><br><span class="line"><span class="comment">构造函数[2]:public com.example.javabase.User()</span></span><br><span class="line"><span class="comment">参数类型[2]:()</span></span><br></pre></td></tr></table></figure><p>关于<strong>Constructor类本身一些常用方法</strong>如下(仅部分，其他可查API)</p><table><thead><tr><th>方法返回值</th><th>方法名称</th><th>方法说明</th></tr></thead><tbody><tr><td>Class</td><td>getDeclaringClass()</td><td>返回 Class 对象，该对象表示声明由此 Constructor 对象表示的构造方法的类,其实就是返回真实类型（不包含参数）</td></tr><tr><td>Type[]</td><td>getGenericParameterTypes()</td><td>按照声明顺序返回一组 Type 对象，返回的就是 Constructor对象构造函数的形参类型。</td></tr><tr><td>String</td><td>getName()</td><td>以字符串形式返回此构造方法的名称。</td></tr><tr><td>Class&lt;?&gt;[]</td><td>getParameterTypes()</td><td>按照声明顺序返回一组 Class 对象，即返回Constructor 对象所表示构造方法的形参类型</td></tr><tr><td>T</td><td>newInstance(Object… initargs)</td><td>使用此 Constructor对象表示的构造函数来创建新实例</td></tr><tr><td>String</td><td>toGenericString()</td><td>返回描述此 Constructor 的字符串，其中包括类型参数。</td></tr></tbody></table><p>代码演示如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Constructor</span> <span class="variable">cs3</span> <span class="operator">=</span> clazz.getDeclaredConstructor(<span class="type">int</span>.class,String.class);</span><br><span class="line">System.out.println(<span class="string">&quot;-----getDeclaringClass-----&quot;</span>);</span><br><span class="line">Class uclazz=cs3.getDeclaringClass();</span><br><span class="line"><span class="comment">//Constructor对象表示的构造方法的类</span></span><br><span class="line">System.out.println(<span class="string">&quot;构造方法的类:&quot;</span>+uclazz.getName());</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;-----getGenericParameterTypes-----&quot;</span>);</span><br><span class="line"><span class="comment">//对象表示此 Constructor 对象所表示的方法的形参类型</span></span><br><span class="line">Type[] tps=cs3.getGenericParameterTypes();</span><br><span class="line"><span class="keyword">for</span> (Type tp:tps) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;参数名称tp:&quot;</span>+tp);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;-----getParameterTypes-----&quot;</span>);</span><br><span class="line"><span class="comment">//获取构造函数参数类型</span></span><br><span class="line">Class&lt;?&gt; clazzs[] = cs3.getParameterTypes();</span><br><span class="line"><span class="keyword">for</span> (Class claz:clazzs) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;参数名称:&quot;</span>+claz.getName());</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;-----getName-----&quot;</span>);</span><br><span class="line"><span class="comment">//以字符串形式返回此构造方法的名称</span></span><br><span class="line">System.out.println(<span class="string">&quot;getName:&quot;</span>+cs3.getName());</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;-----getoGenericString-----&quot;</span>);</span><br><span class="line"><span class="comment">//返回描述此 Constructor 的字符串，其中包括类型参数。</span></span><br><span class="line">System.out.println(<span class="string">&quot;getoGenericString():&quot;</span>+cs3.toGenericString());</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-----getDeclaringClass-----</span><br><span class="line">构造方法的类:com.example.javabase.User</span><br><span class="line">-----getGenericParameterTypes-----</span><br><span class="line">参数名称tp:<span class="type">int</span></span><br><span class="line">参数名称tp:<span class="keyword">class</span> <span class="title class_">java</span>.lang.String</span><br><span class="line">-----getParameterTypes-----</span><br><span class="line">参数名称:<span class="type">int</span></span><br><span class="line">参数名称:java.lang.String</span><br><span class="line">-----getName-----</span><br><span class="line">getName:com.example.javabase.User</span><br><span class="line">-----getoGenericString-----</span><br><span class="line">getoGenericString():<span class="keyword">private</span> com.example.javabase.User(<span class="type">int</span>,java.lang.String)</span><br></pre></td></tr></table></figure><h3 id="Field类及其用法"><a href="#Field类及其用法" class="headerlink" title="# Field类及其用法"></a><a href="#field%E7%B1%BB%E5%8F%8A%E5%85%B6%E7%94%A8%E6%B3%95">#</a> Field类及其用法</h3><blockquote><p>Field 提供有关类或接口的单个字段的信息，以及对它的动态访问权限。反射的字段可能是一个类（静态）字段或实例字段。</p></blockquote><p>同样的道理，我们可以通过Class类的提供的方法来获取代表字段信息的Field对象，Class类与Field对象相关方法如下：</p><table><thead><tr><th>方法返回值</th><th>方法名称</th><th>方法说明</th></tr></thead><tbody><tr><td>Field</td><td>getDeclaredField(String name)</td><td>获取指定name名称的(包含private修饰的)字段，不包括继承的字段</td></tr><tr><td>Field[]</td><td>getDeclaredFields()</td><td>获取Class对象所表示的类或接口的所有(包含private修饰的)字段,不包括继承的字段</td></tr><tr><td>Field</td><td>getField(String name)</td><td>获取指定name名称、具有public修饰的字段，包含继承字段</td></tr><tr><td>Field[]</td><td>getFields()</td><td>获取修饰符为public的字段，包含继承字段</td></tr></tbody></table><p>下面的代码演示了上述方法的使用过程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectField</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchFieldException &#123;</span><br><span class="line">        Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;reflect.Student&quot;</span>);</span><br><span class="line">        <span class="comment">//获取指定字段名称的Field类,注意字段修饰符必须为public而且存在该字段,</span></span><br><span class="line">        <span class="comment">// 否则抛NoSuchFieldException</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> clazz.getField(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;field:&quot;</span>+field);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取所有修饰符为public的字段,包含父类字段,注意修饰符为public才会获取</span></span><br><span class="line">        Field fields[] = clazz.getFields();</span><br><span class="line">        <span class="keyword">for</span> (Field f:fields) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;f:&quot;</span>+f.getDeclaringClass());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;================getDeclaredFields====================&quot;</span>);</span><br><span class="line">        <span class="comment">//获取当前类所字段(包含private字段),注意不包含父类的字段</span></span><br><span class="line">        Field fields2[] = clazz.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (Field f:fields2) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;f2:&quot;</span>+f.getDeclaringClass());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取指定字段名称的Field类,可以是任意修饰符的自动,注意不包含父类的字段</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">field2</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;desc&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;field2:&quot;</span>+field2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      输出结果: </span></span><br><span class="line"><span class="comment">     field:public int reflect.Person.age</span></span><br><span class="line"><span class="comment">     f:public java.lang.String reflect.Student.desc</span></span><br><span class="line"><span class="comment">     f:public int reflect.Person.age</span></span><br><span class="line"><span class="comment">     f:public java.lang.String reflect.Person.name</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     ================getDeclaredFields====================</span></span><br><span class="line"><span class="comment">     f2:public java.lang.String reflect.Student.desc</span></span><br><span class="line"><span class="comment">     f2:private int reflect.Student.score</span></span><br><span class="line"><span class="comment">     field2:public java.lang.String reflect.Student.desc</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="comment">//省略set和get方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String desc;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> score;</span><br><span class="line">    <span class="comment">//省略set和get方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述方法需要注意的是，如果我们不期望获取其父类的字段，则需使用Class类的getDeclaredField/getDeclaredFields方法来获取字段即可，倘若需要连带获取到父类的字段，那么请使用Class类的getField/getFields，但是也只能获取到public修饰的的字段，无法获取父类的私有字段。下面将通过Field类本身的方法对指定类属性赋值，代码演示如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取Class对象引用</span></span><br><span class="line">Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;reflect.Student&quot;</span>);</span><br><span class="line"></span><br><span class="line">Student st= (Student) clazz.newInstance();</span><br><span class="line"><span class="comment">//获取父类public字段并赋值</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">ageField</span> <span class="operator">=</span> clazz.getField(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">ageField.set(st,<span class="number">18</span>);</span><br><span class="line"><span class="type">Field</span> <span class="variable">nameField</span> <span class="operator">=</span> clazz.getField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">nameField.set(st,<span class="string">&quot;Lily&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//只获取当前类的字段,不获取父类的字段</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">descField</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;desc&quot;</span>);</span><br><span class="line">descField.set(st,<span class="string">&quot;I am student&quot;</span>);</span><br><span class="line"><span class="type">Field</span> <span class="variable">scoreField</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;score&quot;</span>);</span><br><span class="line"><span class="comment">//设置可访问，score是private的</span></span><br><span class="line">scoreField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">scoreField.set(st,<span class="number">88</span>);</span><br><span class="line">System.out.println(st.toString());</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果：Student&#123;age=18, name=&#x27;Lily ,desc=&#x27;I am student&#x27;, score=88&#125; </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取字段值</span></span><br><span class="line">System.out.println(scoreField.get(st));</span><br><span class="line"><span class="comment">// 88</span></span><br></pre></td></tr></table></figure><p>其中的set(Object obj, Object value)方法是Field类本身的方法，用于设置字段的值，而get(Object obj)则是获取字段的值，当然关于Field类还有其他常用的方法如下：</p><table><thead><tr><th>方法返回值</th><th>方法名称</th><th>方法说明</th></tr></thead><tbody><tr><td>void</td><td>set(Object obj, Object value)</td><td>将指定对象变量上此 Field 对象表示的字段设置为指定的新值。</td></tr><tr><td>Object</td><td>get(Object obj)</td><td>返回指定对象上此 Field 表示的字段的值</td></tr><tr><td>Class&lt;?&gt;</td><td>getType()</td><td>返回一个 Class 对象，它标识了此Field 对象所表示字段的声明类型。</td></tr><tr><td>boolean</td><td>isEnumConstant()</td><td>如果此字段表示枚举类型的元素则返回 true；否则返回 false</td></tr><tr><td>String</td><td>toGenericString()</td><td>返回一个描述此 Field（包括其一般类型）的字符串</td></tr><tr><td>String</td><td>getName()</td><td>返回此 Field 对象表示的字段的名称</td></tr><tr><td>Class&lt;?&gt;</td><td>getDeclaringClass()</td><td>返回表示类或接口的 Class 对象，该类或接口声明由此 Field 对象表示的字段</td></tr><tr><td>void</td><td>setAccessible(boolean flag)</td><td>将此对象的 accessible 标志设置为指示的布尔值,即设置其可访问性</td></tr></tbody></table><p>上述方法可能是较为常用的，事实上在设置值的方法上，Field类还提供了专门针对基本数据类型的方法，如<code>setInt()/getInt()</code>、<code>setBoolean()/getBoolean</code>、<code>setChar()/getChar()</code>等等方法，这里就不全部列出了，需要时查API文档即可。需要特别注意的是被final关键字修饰的Field字段是安全的，在运行时可以接收任何修改，但最终其实际值是不会发生改变的。</p><h3 id="Method类及其用法"><a href="#Method类及其用法" class="headerlink" title="# Method类及其用法"></a><a href="#method%E7%B1%BB%E5%8F%8A%E5%85%B6%E7%94%A8%E6%B3%95">#</a> Method类及其用法</h3><blockquote><p>Method 提供关于类或接口上单独某个方法（以及如何访问该方法）的信息，所反映的方法可能是类方法或实例方法（包括抽象方法）。</p></blockquote><p>下面是Class类获取Method对象相关的方法：</p><table><thead><tr><th>方法返回值</th><th>方法名称</th><th>方法说明</th></tr></thead><tbody><tr><td>Method</td><td>getDeclaredMethod(String name, Class&lt;?&gt;… parameterTypes)</td><td>返回一个指定参数的Method对象，该对象反映此 Class 对象所表示的类或接口的指定已声明方法。</td></tr><tr><td>Method[]</td><td>getDeclaredMethods()</td><td>返回 Method 对象的一个数组，这些对象反映此 Class 对象表示的类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。</td></tr><tr><td>Method</td><td>getMethod(String name, Class&lt;?&gt;… parameterTypes)</td><td>返回一个 Method 对象，它反映此 Class 对象所表示的类或接口的指定公共成员方法。</td></tr><tr><td>Method[]</td><td>getMethods()</td><td>返回一个包含某些 Method 对象的数组，这些对象反映此 Class 对象所表示的类或接口（包括那些由该类或接口声明的以及从超类和超接口继承的那些的类或接口）的公共 member 方法。</td></tr></tbody></table><p>同样通过案例演示上述方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectMethod</span>  &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;reflect.Circle&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据参数获取public的Method,包含继承自父类的方法</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;draw&quot;</span>,<span class="type">int</span>.class,String.class);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;method:&quot;</span>+method);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取所有public的方法:</span></span><br><span class="line">        Method[] methods =clazz.getMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method m:methods)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;m::&quot;</span>+m);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;=========================================&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取当前类的方法包含private,该方法无法获取继承自父类的method</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">method1</span> <span class="operator">=</span> clazz.getDeclaredMethod(<span class="string">&quot;drawCircle&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;method1::&quot;</span>+method1);</span><br><span class="line">        <span class="comment">//获取当前类的所有方法包含private,该方法无法获取继承自父类的method</span></span><br><span class="line">        Method[] methods1=clazz.getDeclaredMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method m:methods1)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;m1::&quot;</span>+m);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;draw&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">(<span class="type">int</span> count , String name)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;draw &quot;</span>+ name +<span class="string">&quot;,count=&quot;</span>+count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">drawCircle</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;drawCircle&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAllCount</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">method:<span class="keyword">public</span> <span class="keyword">void</span> reflect.Shape.draw(<span class="type">int</span>,java.lang.String)</span><br><span class="line"></span><br><span class="line">m::<span class="keyword">public</span> <span class="type">int</span> reflect.Circle.getAllCount()</span><br><span class="line">m::<span class="keyword">public</span> <span class="keyword">void</span> reflect.Shape.draw()</span><br><span class="line">m::<span class="keyword">public</span> <span class="keyword">void</span> reflect.Shape.draw(<span class="type">int</span>,java.lang.String)</span><br><span class="line">m::<span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> java.lang.Object.wait(<span class="type">long</span>,<span class="type">int</span>) <span class="keyword">throws</span> java.lang.InterruptedException</span><br><span class="line">m::<span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> java.lang.Object.wait(<span class="type">long</span>) <span class="keyword">throws</span> java.lang.InterruptedException</span><br><span class="line">m::<span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> java.lang.Object.wait() <span class="keyword">throws</span> java.lang.InterruptedException</span><br><span class="line">m::<span class="keyword">public</span> <span class="type">boolean</span> java.lang.Object.equals(java.lang.Object)</span><br><span class="line">m::<span class="keyword">public</span> java.lang.String java.lang.Object.toString()</span><br><span class="line">m::<span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> java.lang.Object.hashCode()</span><br><span class="line">m::<span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> java.lang.Class java.lang.Object.getClass()</span><br><span class="line">m::<span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> java.lang.Object.notify()</span><br><span class="line">m::<span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> java.lang.Object.notifyAll()</span><br><span class="line"></span><br><span class="line">=========================================</span><br><span class="line">method1::<span class="keyword">private</span> <span class="keyword">void</span> reflect.Circle.drawCircle()</span><br><span class="line"></span><br><span class="line">m1::<span class="keyword">public</span> <span class="type">int</span> reflect.Circle.getAllCount()</span><br><span class="line">m1::<span class="keyword">private</span> <span class="keyword">void</span> reflect.Circle.drawCircle()</span><br></pre></td></tr></table></figure><p>在通过getMethods方法获取Method对象时，会把父类的方法也获取到，如上的输出结果，把Object类的方法都打印出来了。而<code>getDeclaredMethod/getDeclaredMethods</code>方法都只能获取当前类的方法。我们在使用时根据情况选择即可。下面将演示通过Method对象调用指定类的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;reflect.Circle&quot;</span>);</span><br><span class="line"><span class="comment">//创建对象</span></span><br><span class="line"><span class="type">Circle</span> <span class="variable">circle</span> <span class="operator">=</span> (Circle) clazz.newInstance();</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取指定参数的方法对象Method</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;draw&quot;</span>,<span class="type">int</span>.class,String.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过Method对象的invoke(Object obj,Object... args)方法调用</span></span><br><span class="line">method.invoke(circle,<span class="number">15</span>,<span class="string">&quot;圈圈&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//对私有无参方法的操作</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">method1</span> <span class="operator">=</span> clazz.getDeclaredMethod(<span class="string">&quot;drawCircle&quot;</span>);</span><br><span class="line"><span class="comment">//修改私有方法的访问标识</span></span><br><span class="line">method1.setAccessible(<span class="literal">true</span>);</span><br><span class="line">method1.invoke(circle);</span><br><span class="line"></span><br><span class="line"><span class="comment">//对有返回值得方法操作</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">method2</span> <span class="operator">=</span>clazz.getDeclaredMethod(<span class="string">&quot;getAllCount&quot;</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> (Integer) method2.invoke(circle);</span><br><span class="line">System.out.println(<span class="string">&quot;count:&quot;</span>+count);</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">draw 圈圈,count=<span class="number">15</span></span><br><span class="line">drawCircle</span><br><span class="line">count:<span class="number">100</span></span><br></pre></td></tr></table></figure><p>在上述代码中调用方法，使用了Method类的<code>invoke(Object obj,Object... args)</code>第一个参数代表调用的对象，第二个参数传递的调用方法的参数。这样就完成了类方法的动态调用。</p><table><thead><tr><th>方法返回值</th><th>方法名称</th><th>方法说明</th></tr></thead><tbody><tr><td>Object</td><td>invoke(Object obj, Object… args)</td><td>对带有指定参数的指定对象调用由此 Method 对象表示的底层方法。</td></tr><tr><td>Class&lt;?&gt;</td><td>getReturnType()</td><td>返回一个 Class 对象，该对象描述了此 Method 对象所表示的方法的正式返回类型,即方法的返回类型</td></tr><tr><td>Type</td><td>getGenericReturnType()</td><td>返回表示由此 Method 对象所表示方法的正式返回类型的 Type 对象，也是方法的返回类型。</td></tr><tr><td>Class&lt;?&gt;[]</td><td>getParameterTypes()</td><td>按照声明顺序返回 Class 对象的数组，这些对象描述了此 Method 对象所表示的方法的形参类型。即返回方法的参数类型组成的数组</td></tr><tr><td>Type[]</td><td>getGenericParameterTypes()</td><td>按照声明顺序返回 Type 对象的数组，这些对象描述了此 Method 对象所表示的方法的形参类型的，也是返回方法的参数类型</td></tr><tr><td>String</td><td>getName()</td><td>以 String 形式返回此 Method 对象表示的方法名称，即返回方法的名称</td></tr><tr><td>boolean</td><td>isVarArgs()</td><td>判断方法是否带可变参数，如果将此方法声明为带有可变数量的参数，则返回 true；否则，返回 false。</td></tr><tr><td>String</td><td>toGenericString()</td><td>返回描述此 Method 的字符串，包括类型参数。</td></tr></tbody></table><p><code>getReturnType方法/getGenericReturnType方法</code>都是获取Method对象表示的方法的返回类型，只不过前者返回的Class类型后者返回的Type(前面已分析过)，Type就是一个接口而已，在Java8中新增一个默认的方法实现，返回的就参数类型信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Type</span> &#123;</span><br><span class="line">    <span class="comment">//1.8新增</span></span><br><span class="line">    <span class="keyword">default</span> String <span class="title function_">getTypeName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而<code>getParameterTypes/getGenericParameterTypes</code>也是同样的道理，都是获取Method对象所表示的方法的参数类型，其他方法与前面的Field和Constructor是类似的。</p><h2 id="反射机制执行的流程"><a href="#反射机制执行的流程" class="headerlink" title="# 反射机制执行的流程"></a><a href="#%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E6%89%A7%E8%A1%8C%E7%9A%84%E6%B5%81%E7%A8%8B">#</a> 反射机制执行的流程</h2><blockquote><p>这部分主要参考自<a href="https://www.cnblogs.com/yougewe/p/10125073.html">https://www.cnblogs.com/yougewe/p/10125073.html</a></p></blockquote><p><strong>先看个例子</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloReflect</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1. 使用外部配置的实现，进行动态加载类</span></span><br><span class="line">            <span class="type">TempFunctionTest</span> <span class="variable">test</span> <span class="operator">=</span> (TempFunctionTest)Class.forName(<span class="string">&quot;com.tester.HelloReflect&quot;</span>).newInstance();</span><br><span class="line">            test.sayHello(<span class="string">&quot;call directly&quot;</span>);</span><br><span class="line">            <span class="comment">// 2. 根据配置的函数名，进行方法调用（不需要通用的接口抽象）</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TempFunctionTest</span>();</span><br><span class="line">            <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> t2.getClass().getDeclaredMethod(<span class="string">&quot;sayHello&quot;</span>, String.class);</span><br><span class="line">            method.invoke(test, <span class="string">&quot;method invoke&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e ) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello,&quot;</span> + word);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>来看执行流程</strong></p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230821134146895.png" alt="image-20230821134146895"></p><h3 id="反射获取类实例"><a href="#反射获取类实例" class="headerlink" title="# 反射获取类实例"></a><a href="#%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E7%B1%BB%E5%AE%9E%E4%BE%8B">#</a> 反射获取类实例</h3><p>首先调用了 java.lang.Class 的静态方法，获取类信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; forName(String className)</span><br><span class="line">            <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="comment">// 先通过反射，获取调用进来的类信息，从而获取当前的 classLoader</span></span><br><span class="line">    Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class="line">    <span class="comment">// 调用native方法进行获取class信息</span></span><br><span class="line">    <span class="keyword">return</span> forName0(className, <span class="literal">true</span>, ClassLoader.getClassLoader(caller), caller);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>forName()反射获取类信息，并没有将实现留给了java,而是交给了jvm去加载。</p><p>主要是先获取 ClassLoader, 然后调用 native 方法，获取信息，加载类则是回调 java.lang.ClassLoader.</p><p>最后，jvm又会回调 ClassLoader 进类加载。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="keyword">return</span> loadClass(name, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sun.misc.Launcher</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; loadClass(String var1, <span class="type">boolean</span> var2) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">var3</span> <span class="operator">=</span> var1.lastIndexOf(<span class="number">46</span>);</span><br><span class="line">        <span class="keyword">if</span>(var3 != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">SecurityManager</span> <span class="variable">var4</span> <span class="operator">=</span> System.getSecurityManager();</span><br><span class="line">            <span class="keyword">if</span>(var4 != <span class="literal">null</span>) &#123;</span><br><span class="line">                var4.checkPackageAccess(var1.substring(<span class="number">0</span>, var3));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.ucp.knownToNotExist(var1)) &#123;</span><br><span class="line">            <span class="type">Class</span> <span class="variable">var5</span> <span class="operator">=</span> <span class="built_in">this</span>.findLoadedClass(var1);</span><br><span class="line">            <span class="keyword">if</span>(var5 != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(var2) &#123;</span><br><span class="line">                    <span class="built_in">this</span>.resolveClass(var5);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> var5;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>(var1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>.loadClass(var1, var2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// java.lang.ClassLoader</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 先获取锁</span></span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">        <span class="comment">// 如果已经加载了的话，就不用再加载了</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">t0</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 双亲委托加载</span></span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">                    c = parent.loadClass(name, <span class="literal">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 父类没有加载到时，再自己加载</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                <span class="comment">// to find the class.</span></span><br><span class="line">                <span class="type">long</span> <span class="variable">t1</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">getClassLoadingLock</span><span class="params">(String className)</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">if</span> (parallelLockMap != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 使用 ConcurrentHashMap来保存锁</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">newLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        lock = parallelLockMap.putIfAbsent(className, newLock);</span><br><span class="line">        <span class="keyword">if</span> (lock == <span class="literal">null</span>) &#123;</span><br><span class="line">            lock = newLock;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lock;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; findLoadedClass(String name) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!checkName(name))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> findLoadedClass0(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面来看一下 newInstance() 的实现方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先肯定是 Class.newInstance</span></span><br><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">newInstance</span><span class="params">()</span></span><br><span class="line">    <span class="keyword">throws</span> InstantiationException, IllegalAccessException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (System.getSecurityManager() != <span class="literal">null</span>) &#123;</span><br><span class="line">        checkMemberAccess(Member.PUBLIC, Reflection.getCallerClass(), <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> the following code may not be strictly correct under</span></span><br><span class="line">    <span class="comment">// the current Java memory model.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Constructor lookup</span></span><br><span class="line">    <span class="comment">// newInstance() 其实相当于调用类的无参构造函数，所以，首先要找到其无参构造器</span></span><br><span class="line">    <span class="keyword">if</span> (cachedConstructor == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == Class.class) &#123;</span><br><span class="line">            <span class="comment">// 不允许调用 Class 的 newInstance() 方法</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalAccessException</span>(</span><br><span class="line">                <span class="string">&quot;Can not call newInstance() on the Class for java.lang.Class&quot;</span></span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取无参构造器</span></span><br><span class="line">            Class&lt;?&gt;[] empty = &#123;&#125;;</span><br><span class="line">            <span class="keyword">final</span> Constructor&lt;T&gt; c = getConstructor0(empty, Member.DECLARED);</span><br><span class="line">            <span class="comment">// Disable accessibility checks on the constructor</span></span><br><span class="line">            <span class="comment">// since we have to do the security check here anyway</span></span><br><span class="line">            <span class="comment">// (the stack depth is wrong for the Constructor&#x27;s</span></span><br><span class="line">            <span class="comment">// security check to work)</span></span><br><span class="line">            java.security.AccessController.doPrivileged(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">java</span>.security.PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">                    <span class="keyword">public</span> Void <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                            c.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            cachedConstructor = c;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (InstantiationException)</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InstantiationException</span>(getName()).initCause(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Constructor&lt;T&gt; tmpConstructor = cachedConstructor;</span><br><span class="line">    <span class="comment">// Security check (same as in java.lang.reflect.Constructor)</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">modifiers</span> <span class="operator">=</span> tmpConstructor.getModifiers();</span><br><span class="line">    <span class="keyword">if</span> (!Reflection.quickCheckMemberAccess(<span class="built_in">this</span>, modifiers)) &#123;</span><br><span class="line">        Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class="line">        <span class="keyword">if</span> (newInstanceCallerCache != caller) &#123;</span><br><span class="line">            Reflection.ensureMemberAccess(caller, <span class="built_in">this</span>, <span class="literal">null</span>, modifiers);</span><br><span class="line">            newInstanceCallerCache = caller;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Run constructor</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 调用无参构造器</span></span><br><span class="line">        <span class="keyword">return</span> tmpConstructor.newInstance((Object[])<span class="literal">null</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">        Unsafe.getUnsafe().throwException(e.getTargetException());</span><br><span class="line">        <span class="comment">// Not reached</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>newInstance() 主要做了三件事：</p><ul><li><ol><li>权限检测，如果不通过直接抛出异常；</li></ol></li><li><ol><li>查找无参构造器，并将其缓存起来；</li></ol></li><li><ol><li>调用具体方法的无参构造方法，生成实例并返回；</li></ol></li></ul><p>下面是获取构造器的过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Constructor&lt;T&gt; <span class="title function_">getConstructor0</span><span class="params">(Class&lt;?&gt;[] parameterTypes,</span></span><br><span class="line"><span class="params">                                    <span class="type">int</span> which)</span> <span class="keyword">throws</span> NoSuchMethodException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取所有构造器</span></span><br><span class="line">    Constructor&lt;T&gt;[] constructors = privateGetDeclaredConstructors((which == Member.PUBLIC));</span><br><span class="line">    <span class="keyword">for</span> (Constructor&lt;T&gt; constructor : constructors) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arrayContentsEq(parameterTypes,</span><br><span class="line">                            constructor.getParameterTypes())) &#123;</span><br><span class="line">            <span class="keyword">return</span> getReflectionFactory().copyConstructor(constructor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchMethodException</span>(getName() + <span class="string">&quot;.&lt;init&gt;&quot;</span> + argumentTypesToString(parameterTypes));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getConstructor0() 为获取匹配的构造方器；分三步：</p><ul><li><ol><li>先获取所有的constructors, 然后通过进行参数类型比较；</li></ol></li><li><ol><li>找到匹配后，通过 ReflectionFactory copy一份constructor返回；</li></ol></li><li><ol><li>否则抛出 NoSuchMethodException;</li></ol></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取当前类所有的构造方法，通过jvm或者缓存</span></span><br><span class="line"><span class="comment">// Returns an array of &quot;root&quot; constructors. These Constructor</span></span><br><span class="line"><span class="comment">// objects must NOT be propagated to the outside world, but must</span></span><br><span class="line"><span class="comment">// instead be copied via ReflectionFactory.copyConstructor.</span></span><br><span class="line"><span class="keyword">private</span> Constructor&lt;T&gt;[] privateGetDeclaredConstructors(<span class="type">boolean</span> publicOnly) &#123;</span><br><span class="line">    checkInitted();</span><br><span class="line">    Constructor&lt;T&gt;[] res;</span><br><span class="line">    <span class="comment">// 调用 reflectionData(), 获取保存的信息，使用软引用保存，从而使内存不够可以回收</span></span><br><span class="line">    ReflectionData&lt;T&gt; rd = reflectionData();</span><br><span class="line">    <span class="keyword">if</span> (rd != <span class="literal">null</span>) &#123;</span><br><span class="line">        res = publicOnly ? rd.publicConstructors : rd.declaredConstructors;</span><br><span class="line">        <span class="comment">// 存在缓存，则直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (res != <span class="literal">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// No cached value available; request value from VM</span></span><br><span class="line">    <span class="keyword">if</span> (isInterface()) &#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        Constructor&lt;T&gt;[] temporaryRes = (Constructor&lt;T&gt;[]) <span class="keyword">new</span> <span class="title class_">Constructor</span>&lt;?&gt;[<span class="number">0</span>];</span><br><span class="line">        res = temporaryRes;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 使用native方法从jvm获取构造器</span></span><br><span class="line">        res = getDeclaredConstructors0(publicOnly);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rd != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 最后，将从jvm中读取的内容，存入缓存</span></span><br><span class="line">        <span class="keyword">if</span> (publicOnly) &#123;</span><br><span class="line">            rd.publicConstructors = res;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            rd.declaredConstructors = res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Lazily create and cache ReflectionData</span></span><br><span class="line"><span class="keyword">private</span> ReflectionData&lt;T&gt; <span class="title function_">reflectionData</span><span class="params">()</span> &#123;</span><br><span class="line">    SoftReference&lt;ReflectionData&lt;T&gt;&gt; reflectionData = <span class="built_in">this</span>.reflectionData;</span><br><span class="line">    <span class="type">int</span> <span class="variable">classRedefinedCount</span> <span class="operator">=</span> <span class="built_in">this</span>.classRedefinedCount;</span><br><span class="line">    ReflectionData&lt;T&gt; rd;</span><br><span class="line">    <span class="keyword">if</span> (useCaches &amp;&amp;</span><br><span class="line">        reflectionData != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">        (rd = reflectionData.get()) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">        rd.redefinedCount == classRedefinedCount) &#123;</span><br><span class="line">        <span class="keyword">return</span> rd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// else no SoftReference or cleared SoftReference or stale ReflectionData</span></span><br><span class="line">    <span class="comment">// -&gt; create and replace new instance</span></span><br><span class="line">    <span class="keyword">return</span> newReflectionData(reflectionData, classRedefinedCount);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新创建缓存，保存反射信息</span></span><br><span class="line"><span class="keyword">private</span> ReflectionData&lt;T&gt; <span class="title function_">newReflectionData</span><span class="params">(SoftReference&lt;ReflectionData&lt;T&gt;&gt; oldReflectionData,</span></span><br><span class="line"><span class="params">                                            <span class="type">int</span> classRedefinedCount)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!useCaches) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用cas保证更新的线程安全性，所以反射是保证线程安全的</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        ReflectionData&lt;T&gt; rd = <span class="keyword">new</span> <span class="title class_">ReflectionData</span>&lt;&gt;(classRedefinedCount);</span><br><span class="line">        <span class="comment">// try to CAS it...</span></span><br><span class="line">        <span class="keyword">if</span> (Atomic.casReflectionData(<span class="built_in">this</span>, oldReflectionData, <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(rd))) &#123;</span><br><span class="line">            <span class="keyword">return</span> rd;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 先使用CAS更新，如果更新成功，则立即返回，否则测查当前已被其他线程更新的情况，如果和自己想要更新的状态一致，则也算是成功了</span></span><br><span class="line">        oldReflectionData = <span class="built_in">this</span>.reflectionData;</span><br><span class="line">        classRedefinedCount = <span class="built_in">this</span>.classRedefinedCount;</span><br><span class="line">        <span class="keyword">if</span> (oldReflectionData != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">            (rd = oldReflectionData.get()) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">            rd.redefinedCount == classRedefinedCount) &#123;</span><br><span class="line">            <span class="keyword">return</span> rd;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，privateGetDeclaredConstructors(), 获取所有的构造器主要步骤；</p><ul><li><ol><li>先尝试从缓存中获取；</li></ol></li><li><ol><li>如果缓存没有，则从jvm中重新获取，并存入缓存，缓存使用软引用进行保存，保证内存可用；</li></ol></li></ul><p>另外，使用 relactionData() 进行缓存保存；ReflectionData 的数据结构如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reflection data that might get invalidated when JVM TI RedefineClasses() is called</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ReflectionData</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">volatile</span> Field[] declaredFields;</span><br><span class="line">    <span class="keyword">volatile</span> Field[] publicFields;</span><br><span class="line">    <span class="keyword">volatile</span> Method[] declaredMethods;</span><br><span class="line">    <span class="keyword">volatile</span> Method[] publicMethods;</span><br><span class="line">    <span class="keyword">volatile</span> Constructor&lt;T&gt;[] declaredConstructors;</span><br><span class="line">    <span class="keyword">volatile</span> Constructor&lt;T&gt;[] publicConstructors;</span><br><span class="line">    <span class="comment">// Intermediate results for getFields and getMethods</span></span><br><span class="line">    <span class="keyword">volatile</span> Field[] declaredPublicFields;</span><br><span class="line">    <span class="keyword">volatile</span> Method[] declaredPublicMethods;</span><br><span class="line">    <span class="keyword">volatile</span> Class&lt;?&gt;[] interfaces;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Value of classRedefinedCount when we created this ReflectionData instance</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> redefinedCount;</span><br><span class="line"></span><br><span class="line">    ReflectionData(<span class="type">int</span> redefinedCount) &#123;</span><br><span class="line">        <span class="built_in">this</span>.redefinedCount = redefinedCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，还有一个点，就是如何比较构造是否是要查找构造器，其实就是比较类型完成相等就完了，有一个不相等则返回false。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">arrayContentsEq</span><span class="params">(Object[] a1, Object[] a2)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (a1 == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> a2 == <span class="literal">null</span> || a2.length == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a2 == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> a1.length == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a1.length != a2.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a1.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a1[i] != a2[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// sun.reflect.ReflectionFactory</span></span><br><span class="line"><span class="comment">/** Makes a copy of the passed constructor. The returned</span></span><br><span class="line"><span class="comment">    constructor is a &quot;child&quot; of the passed one; see the comments</span></span><br><span class="line"><span class="comment">    in Constructor.java for details. */</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; Constructor&lt;T&gt; <span class="title function_">copyConstructor</span><span class="params">(Constructor&lt;T&gt; arg)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> langReflectAccess().copyConstructor(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// java.lang.reflect.Constructor, copy 其实就是新new一个 Constructor 出来</span></span><br><span class="line">Constructor&lt;T&gt; <span class="title function_">copy</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// This routine enables sharing of ConstructorAccessor objects</span></span><br><span class="line">    <span class="comment">// among Constructor objects which refer to the same underlying</span></span><br><span class="line">    <span class="comment">// method in the VM. (All of this contortion is only necessary</span></span><br><span class="line">    <span class="comment">// because of the &quot;accessibility&quot; bit in AccessibleObject,</span></span><br><span class="line">    <span class="comment">// which implicitly requires that new java.lang.reflect</span></span><br><span class="line">    <span class="comment">// objects be fabricated for each reflective call on Class</span></span><br><span class="line">    <span class="comment">// objects.)</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.root != <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Can not copy a non-root Constructor&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Constructor&lt;T&gt; res = <span class="keyword">new</span> <span class="title class_">Constructor</span>&lt;&gt;(clazz,</span><br><span class="line">                                           parameterTypes,</span><br><span class="line">                                           exceptionTypes, modifiers, slot,</span><br><span class="line">                                           signature,</span><br><span class="line">                                           annotations,</span><br><span class="line">                                           parameterAnnotations);</span><br><span class="line">    <span class="comment">// root 指向当前 constructor</span></span><br><span class="line">    res.root = <span class="built_in">this</span>;</span><br><span class="line">    <span class="comment">// Might as well eagerly propagate this if already present</span></span><br><span class="line">    res.constructorAccessor = constructorAccessor;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面，获取到 Constructor 了。</p><p>接下来就只需调用其相应构造器的 newInstance()，即返回实例了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// return tmpConstructor.newInstance((Object[])null); </span></span><br><span class="line"><span class="comment">// java.lang.reflect.Constructor</span></span><br><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">newInstance</span><span class="params">(Object ... initargs)</span></span><br><span class="line">    <span class="keyword">throws</span> InstantiationException, IllegalAccessException,</span><br><span class="line">           IllegalArgumentException, InvocationTargetException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!override) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!Reflection.quickCheckMemberAccess(clazz, modifiers)) &#123;</span><br><span class="line">            Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class="line">            checkAccess(caller, clazz, <span class="literal">null</span>, modifiers);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((clazz.getModifiers() &amp; Modifier.ENUM) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Cannot reflectively create enum objects&quot;</span>);</span><br><span class="line">    <span class="type">ConstructorAccessor</span> <span class="variable">ca</span> <span class="operator">=</span> constructorAccessor;   <span class="comment">// read volatile</span></span><br><span class="line">    <span class="keyword">if</span> (ca == <span class="literal">null</span>) &#123;</span><br><span class="line">        ca = acquireConstructorAccessor();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="type">T</span> <span class="variable">inst</span> <span class="operator">=</span> (T) ca.newInstance(initargs);</span><br><span class="line">    <span class="keyword">return</span> inst;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// sun.reflect.DelegatingConstructorAccessorImpl</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">newInstance</span><span class="params">(Object[] args)</span></span><br><span class="line">  <span class="keyword">throws</span> InstantiationException,</span><br><span class="line">         IllegalArgumentException,</span><br><span class="line">         InvocationTargetException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> delegate.newInstance(args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// sun.reflect.NativeConstructorAccessorImpl</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">newInstance</span><span class="params">(Object[] args)</span></span><br><span class="line">    <span class="keyword">throws</span> InstantiationException,</span><br><span class="line">           IllegalArgumentException,</span><br><span class="line">           InvocationTargetException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// We can&#x27;t inflate a constructor belonging to a vm-anonymous class</span></span><br><span class="line">    <span class="comment">// because that kind of class can&#x27;t be referred to by name, hence can&#x27;t</span></span><br><span class="line">    <span class="comment">// be found from the generated bytecode.</span></span><br><span class="line">    <span class="keyword">if</span> (++numInvocations &gt; ReflectionFactory.inflationThreshold()</span><br><span class="line">            &amp;&amp; !ReflectUtil.isVMAnonymousClass(c.getDeclaringClass())) &#123;</span><br><span class="line">        <span class="type">ConstructorAccessorImpl</span> <span class="variable">acc</span> <span class="operator">=</span> (ConstructorAccessorImpl)</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">MethodAccessorGenerator</span>().</span><br><span class="line">                generateConstructor(c.getDeclaringClass(),</span><br><span class="line">                                    c.getParameterTypes(),</span><br><span class="line">                                    c.getExceptionTypes(),</span><br><span class="line">                                    c.getModifiers());</span><br><span class="line">        parent.setDelegate(acc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用native方法，进行调用 constructor</span></span><br><span class="line">    <span class="keyword">return</span> newInstance0(c, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回构造器的实例后，可以根据外部进行进行类型转换，从而使用接口或方法进行调用实例功能了。</p><h3 id="反射获取方法"><a href="#反射获取方法" class="headerlink" title="# 反射获取方法"></a><a href="#%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E6%96%B9%E6%B3%95">#</a> 反射获取方法</h3><ul><li><strong>第一步，先获取 Method</strong>;</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.lang.Class</span></span><br><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="keyword">public</span> Method <span class="title function_">getDeclaredMethod</span><span class="params">(String name, Class&lt;?&gt;... parameterTypes)</span></span><br><span class="line">    <span class="keyword">throws</span> NoSuchMethodException, SecurityException &#123;</span><br><span class="line">    checkMemberAccess(Member.DECLARED, Reflection.getCallerClass(), <span class="literal">true</span>);</span><br><span class="line">    <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> searchMethods(privateGetDeclaredMethods(<span class="literal">false</span>), name, parameterTypes);</span><br><span class="line">    <span class="keyword">if</span> (method == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchMethodException</span>(getName() + <span class="string">&quot;.&quot;</span> + name + argumentTypesToString(parameterTypes));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> method;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>忽略第一个检查权限，剩下就只有两个动作了。</p><ul><li><ol><li>获取所有方法列表；</li></ol></li><li><ol><li>根据方法名称和方法列表，选出符合要求的方法；</li></ol></li><li><ol><li>如果没有找到相应方法，抛出异常，否则返回对应方法；</li></ol></li></ul><p>所以，先看一下怎样获取类声明的所有方法？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Returns an array of &quot;root&quot; methods. These Method objects must NOT</span></span><br><span class="line"><span class="comment">// be propagated to the outside world, but must instead be copied</span></span><br><span class="line"><span class="comment">// via ReflectionFactory.copyMethod.</span></span><br><span class="line"><span class="keyword">private</span> Method[] privateGetDeclaredMethods(<span class="type">boolean</span> publicOnly) &#123;</span><br><span class="line">    checkInitted();</span><br><span class="line">    Method[] res;</span><br><span class="line">    ReflectionData&lt;T&gt; rd = reflectionData();</span><br><span class="line">    <span class="keyword">if</span> (rd != <span class="literal">null</span>) &#123;</span><br><span class="line">        res = publicOnly ? rd.declaredPublicMethods : rd.declaredMethods;</span><br><span class="line">        <span class="keyword">if</span> (res != <span class="literal">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// No cached value available; request value from VM</span></span><br><span class="line">    res = Reflection.filterMethods(<span class="built_in">this</span>, getDeclaredMethods0(publicOnly));</span><br><span class="line">    <span class="keyword">if</span> (rd != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (publicOnly) &#123;</span><br><span class="line">            rd.declaredPublicMethods = res;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            rd.declaredMethods = res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很相似，和获取所有构造器的方法很相似，都是先从缓存中获取方法，如果没有，则从jvm中获取。</p><p>不同的是，方法列表需要进行过滤 Reflection.filterMethods;当然后面看来，这个方法我们一般不会派上用场。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sun.misc.Reflection</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Method[] filterMethods(Class&lt;?&gt; containingClass, Method[] methods) &#123;</span><br><span class="line">    <span class="keyword">if</span> (methodFilterMap == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Bootstrapping</span></span><br><span class="line">        <span class="keyword">return</span> methods;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (Method[])filter(methods, methodFilterMap.get(containingClass));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可以过滤指定的方法，一般为空，如果要指定过滤，可以调用 registerMethodsToFilter(), 或者...</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Member[] filter(Member[] members, String[] filteredNames) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((filteredNames == <span class="literal">null</span>) || (members.length == <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> members;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">numNewMembers</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Member member : members) &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">shouldSkip</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (String filteredName : filteredNames) &#123;</span><br><span class="line">            <span class="keyword">if</span> (member.getName() == filteredName) &#123;</span><br><span class="line">                shouldSkip = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!shouldSkip) &#123;</span><br><span class="line">            ++numNewMembers;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Member[] newMembers =</span><br><span class="line">        (Member[])Array.newInstance(members[<span class="number">0</span>].getClass(), numNewMembers);</span><br><span class="line">    <span class="type">int</span> <span class="variable">destIdx</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Member member : members) &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">shouldSkip</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (String filteredName : filteredNames) &#123;</span><br><span class="line">            <span class="keyword">if</span> (member.getName() == filteredName) &#123;</span><br><span class="line">                shouldSkip = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!shouldSkip) &#123;</span><br><span class="line">            newMembers[destIdx++] = member;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newMembers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>第二步，根据方法名和参数类型过滤指定方法返回</strong>：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Method <span class="title function_">searchMethods</span><span class="params">(Method[] methods,</span></span><br><span class="line"><span class="params">                                    String name,</span></span><br><span class="line"><span class="params">                                    Class&lt;?&gt;[] parameterTypes)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">Method</span> <span class="variable">res</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 使用常量池，避免重复创建String</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">internedName</span> <span class="operator">=</span> name.intern();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; methods.length; i++) &#123;</span><br><span class="line">        <span class="type">Method</span> <span class="variable">m</span> <span class="operator">=</span> methods[i];</span><br><span class="line">        <span class="keyword">if</span> (m.getName() == internedName</span><br><span class="line">            &amp;&amp; arrayContentsEq(parameterTypes, m.getParameterTypes())</span><br><span class="line">            &amp;&amp; (res == <span class="literal">null</span></span><br><span class="line">                || res.getReturnType().isAssignableFrom(m.getReturnType())))</span><br><span class="line">            res = m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (res == <span class="literal">null</span> ? res : getReflectionFactory().copyMethod(res));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大概意思看得明白，就是匹配到方法名，然后参数类型匹配，才可以。</p><ul><li>但是可以看到，匹配到一个方法，并没有退出for循环，而是继续进行匹配。</li><li>这里是匹配最精确的子类进行返回（最优匹配）</li><li>最后，还是通过 ReflectionFactory, copy 方法后返回。</li></ul><h3 id="调用-method-invoke-方法"><a href="#调用-method-invoke-方法" class="headerlink" title="# 调用 method.invoke() 方法"></a><a href="#%E8%B0%83%E7%94%A8-method-invoke-%E6%96%B9%E6%B3%95">#</a> 调用 method.invoke() 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object obj, Object... args)</span></span><br><span class="line">    <span class="keyword">throws</span> IllegalAccessException, IllegalArgumentException,</span><br><span class="line">       InvocationTargetException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!override) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!Reflection.quickCheckMemberAccess(clazz, modifiers)) &#123;</span><br><span class="line">            Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class="line">            checkAccess(caller, clazz, obj, modifiers);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">MethodAccessor</span> <span class="variable">ma</span> <span class="operator">=</span> methodAccessor;             <span class="comment">// read volatile</span></span><br><span class="line">    <span class="keyword">if</span> (ma == <span class="literal">null</span>) &#123;</span><br><span class="line">        ma = acquireMethodAccessor();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ma.invoke(obj, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>invoke时，是通过 MethodAccessor 进行调用的，而 MethodAccessor 是个接口，在第一次时调用 acquireMethodAccessor() 进行新创建。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// probably make the implementation more scalable.</span></span><br><span class="line"><span class="keyword">private</span> MethodAccessor <span class="title function_">acquireMethodAccessor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// First check to see if one has been created yet, and take it</span></span><br><span class="line">    <span class="comment">// if so</span></span><br><span class="line">    <span class="type">MethodAccessor</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">null</span>) tmp = root.getMethodAccessor();</span><br><span class="line">    <span class="keyword">if</span> (tmp != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 存在缓存时，存入 methodAccessor，否则调用 ReflectionFactory 创建新的 MethodAccessor</span></span><br><span class="line">        methodAccessor = tmp;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Otherwise fabricate one and propagate it up to the root</span></span><br><span class="line">        tmp = reflectionFactory.newMethodAccessor(<span class="built_in">this</span>);</span><br><span class="line">        setMethodAccessor(tmp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// sun.reflect.ReflectionFactory</span></span><br><span class="line"><span class="keyword">public</span> MethodAccessor <span class="title function_">newMethodAccessor</span><span class="params">(Method method)</span> &#123;</span><br><span class="line">    checkInitted();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (noInflation &amp;&amp; !ReflectUtil.isVMAnonymousClass(method.getDeclaringClass())) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MethodAccessorGenerator</span>().</span><br><span class="line">            generateMethod(method.getDeclaringClass(),</span><br><span class="line">                           method.getName(),</span><br><span class="line">                           method.getParameterTypes(),</span><br><span class="line">                           method.getReturnType(),</span><br><span class="line">                           method.getExceptionTypes(),</span><br><span class="line">                           method.getModifiers());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">NativeMethodAccessorImpl</span> <span class="variable">acc</span> <span class="operator">=</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">NativeMethodAccessorImpl</span>(method);</span><br><span class="line">        <span class="type">DelegatingMethodAccessorImpl</span> <span class="variable">res</span> <span class="operator">=</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">DelegatingMethodAccessorImpl</span>(acc);</span><br><span class="line">        acc.setParent(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个Accessor详情：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//     NativeMethodAccessorImpl / DelegatingMethodAccessorImpl</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NativeMethodAccessorImpl</span> <span class="keyword">extends</span> <span class="title class_">MethodAccessorImpl</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Method method;</span><br><span class="line">    <span class="keyword">private</span> DelegatingMethodAccessorImpl parent;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> numInvocations;</span><br><span class="line"></span><br><span class="line">    NativeMethodAccessorImpl(Method method) &#123;</span><br><span class="line">        <span class="built_in">this</span>.method = method;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object obj, Object[] args)</span></span><br><span class="line">        <span class="keyword">throws</span> IllegalArgumentException, InvocationTargetException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// We can&#x27;t inflate methods belonging to vm-anonymous classes because</span></span><br><span class="line">        <span class="comment">// that kind of class can&#x27;t be referred to by name, hence can&#x27;t be</span></span><br><span class="line">        <span class="comment">// found from the generated bytecode.</span></span><br><span class="line">        <span class="keyword">if</span> (++numInvocations &gt; ReflectionFactory.inflationThreshold()</span><br><span class="line">                &amp;&amp; !ReflectUtil.isVMAnonymousClass(method.getDeclaringClass())) &#123;</span><br><span class="line">            <span class="type">MethodAccessorImpl</span> <span class="variable">acc</span> <span class="operator">=</span> (MethodAccessorImpl)</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">MethodAccessorGenerator</span>().</span><br><span class="line">                    generateMethod(method.getDeclaringClass(),</span><br><span class="line">                                   method.getName(),</span><br><span class="line">                                   method.getParameterTypes(),</span><br><span class="line">                                   method.getReturnType(),</span><br><span class="line">                                   method.getExceptionTypes(),</span><br><span class="line">                                   method.getModifiers());</span><br><span class="line">            parent.setDelegate(acc);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> invoke0(method, obj, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setParent</span><span class="params">(DelegatingMethodAccessorImpl parent)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> Object <span class="title function_">invoke0</span><span class="params">(Method m, Object obj, Object[] args)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DelegatingMethodAccessorImpl</span> <span class="keyword">extends</span> <span class="title class_">MethodAccessorImpl</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> MethodAccessorImpl delegate;</span><br><span class="line"></span><br><span class="line">    DelegatingMethodAccessorImpl(MethodAccessorImpl delegate) &#123;</span><br><span class="line">        setDelegate(delegate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object obj, Object[] args)</span></span><br><span class="line">        <span class="keyword">throws</span> IllegalArgumentException, InvocationTargetException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> delegate.invoke(obj, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setDelegate</span><span class="params">(MethodAccessorImpl delegate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.delegate = delegate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进行 ma.invoke(obj, args); 调用时，调用 DelegatingMethodAccessorImpl.invoke();</p><p>最后被委托到 NativeMethodAccessorImpl.invoke(), 即：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object obj, Object[] args)</span></span><br><span class="line">    <span class="keyword">throws</span> IllegalArgumentException, InvocationTargetException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// We can&#x27;t inflate methods belonging to vm-anonymous classes because</span></span><br><span class="line">    <span class="comment">// that kind of class can&#x27;t be referred to by name, hence can&#x27;t be</span></span><br><span class="line">    <span class="comment">// found from the generated bytecode.</span></span><br><span class="line">    <span class="keyword">if</span> (++numInvocations &gt; ReflectionFactory.inflationThreshold()</span><br><span class="line">            &amp;&amp; !ReflectUtil.isVMAnonymousClass(method.getDeclaringClass())) &#123;</span><br><span class="line">        <span class="type">MethodAccessorImpl</span> <span class="variable">acc</span> <span class="operator">=</span> (MethodAccessorImpl)</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">MethodAccessorGenerator</span>().</span><br><span class="line">                generateMethod(method.getDeclaringClass(),</span><br><span class="line">                               method.getName(),</span><br><span class="line">                               method.getParameterTypes(),</span><br><span class="line">                               method.getReturnType(),</span><br><span class="line">                               method.getExceptionTypes(),</span><br><span class="line">                               method.getModifiers());</span><br><span class="line">        parent.setDelegate(acc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// invoke0 是个 native 方法，由jvm进行调用业务方法。从而完成反射调用功能。</span></span><br><span class="line">    <span class="keyword">return</span> invoke0(method, obj, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中， generateMethod() 是生成具体类的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** This routine is not thread-safe */</span></span><br><span class="line"><span class="keyword">public</span> MethodAccessor <span class="title function_">generateMethod</span><span class="params">(Class&lt;?&gt; declaringClass,</span></span><br><span class="line"><span class="params">                                     String   name,</span></span><br><span class="line"><span class="params">                                     Class&lt;?&gt;[] parameterTypes,</span></span><br><span class="line"><span class="params">                                     Class&lt;?&gt;   returnType,</span></span><br><span class="line"><span class="params">                                     Class&lt;?&gt;[] checkedExceptions,</span></span><br><span class="line"><span class="params">                                     <span class="type">int</span> modifiers)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (MethodAccessor) generate(declaringClass,</span><br><span class="line">                                     name,</span><br><span class="line">                                     parameterTypes,</span><br><span class="line">                                     returnType,</span><br><span class="line">                                     checkedExceptions,</span><br><span class="line">                                     modifiers,</span><br><span class="line">                                     <span class="literal">false</span>,</span><br><span class="line">                                     <span class="literal">false</span>,</span><br><span class="line">                                     <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>generate() 戳详情。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** This routine is not thread-safe */</span></span><br><span class="line"><span class="keyword">private</span> MagicAccessorImpl <span class="title function_">generate</span><span class="params">(<span class="keyword">final</span> Class&lt;?&gt; declaringClass,</span></span><br><span class="line"><span class="params">                                   String name,</span></span><br><span class="line"><span class="params">                                   Class&lt;?&gt;[] parameterTypes,</span></span><br><span class="line"><span class="params">                                   Class&lt;?&gt;   returnType,</span></span><br><span class="line"><span class="params">                                   Class&lt;?&gt;[] checkedExceptions,</span></span><br><span class="line"><span class="params">                                   <span class="type">int</span> modifiers,</span></span><br><span class="line"><span class="params">                                   <span class="type">boolean</span> isConstructor,</span></span><br><span class="line"><span class="params">                                   <span class="type">boolean</span> forSerialization,</span></span><br><span class="line"><span class="params">                                   Class&lt;?&gt; serializationTargetClass)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">ByteVector</span> <span class="variable">vec</span> <span class="operator">=</span> ByteVectorFactory.create();</span><br><span class="line">    asm = <span class="keyword">new</span> <span class="title class_">ClassFileAssembler</span>(vec);</span><br><span class="line">    <span class="built_in">this</span>.declaringClass = declaringClass;</span><br><span class="line">    <span class="built_in">this</span>.parameterTypes = parameterTypes;</span><br><span class="line">    <span class="built_in">this</span>.returnType = returnType;</span><br><span class="line">    <span class="built_in">this</span>.modifiers = modifiers;</span><br><span class="line">    <span class="built_in">this</span>.isConstructor = isConstructor;</span><br><span class="line">    <span class="built_in">this</span>.forSerialization = forSerialization;</span><br><span class="line"></span><br><span class="line">    asm.emitMagicAndVersion();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Constant pool entries:</span></span><br><span class="line">    <span class="comment">// ( * = Boxing information: optional)</span></span><br><span class="line">    <span class="comment">// (+  = Shared entries provided by AccessorGenerator)</span></span><br><span class="line">    <span class="comment">// (^  = Only present if generating SerializationConstructorAccessor)</span></span><br><span class="line">    <span class="comment">//     [UTF-8] [This class&#x27;s name]</span></span><br><span class="line">    <span class="comment">//     [CONSTANT_Class_info] for above</span></span><br><span class="line">    <span class="comment">//     [UTF-8] &quot;sun/reflect/&#123;MethodAccessorImpl,ConstructorAccessorImpl,SerializationConstructorAccessorImpl&#125;&quot;</span></span><br><span class="line">    <span class="comment">//     [CONSTANT_Class_info] for above</span></span><br><span class="line">    <span class="comment">//     [UTF-8] [Target class&#x27;s name]</span></span><br><span class="line">    <span class="comment">//     [CONSTANT_Class_info] for above</span></span><br><span class="line">    <span class="comment">// ^   [UTF-8] [Serialization: Class&#x27;s name in which to invoke constructor]</span></span><br><span class="line">    <span class="comment">// ^   [CONSTANT_Class_info] for above</span></span><br><span class="line">    <span class="comment">//     [UTF-8] target method or constructor name</span></span><br><span class="line">    <span class="comment">//     [UTF-8] target method or constructor signature</span></span><br><span class="line">    <span class="comment">//     [CONSTANT_NameAndType_info] for above</span></span><br><span class="line">    <span class="comment">//     [CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info] for target method</span></span><br><span class="line">    <span class="comment">//     [UTF-8] &quot;invoke&quot; or &quot;newInstance&quot;</span></span><br><span class="line">    <span class="comment">//     [UTF-8] invoke or newInstance descriptor</span></span><br><span class="line">    <span class="comment">//     [UTF-8] descriptor for type of non-primitive parameter 1</span></span><br><span class="line">    <span class="comment">//     [CONSTANT_Class_info] for type of non-primitive parameter 1</span></span><br><span class="line">    <span class="comment">//     ...</span></span><br><span class="line">    <span class="comment">//     [UTF-8] descriptor for type of non-primitive parameter n</span></span><br><span class="line">    <span class="comment">//     [CONSTANT_Class_info] for type of non-primitive parameter n</span></span><br><span class="line">    <span class="comment">// +   [UTF-8] &quot;java/lang/Exception&quot;</span></span><br><span class="line">    <span class="comment">// +   [CONSTANT_Class_info] for above</span></span><br><span class="line">    <span class="comment">// +   [UTF-8] &quot;java/lang/ClassCastException&quot;</span></span><br><span class="line">    <span class="comment">// +   [CONSTANT_Class_info] for above</span></span><br><span class="line">    <span class="comment">// +   [UTF-8] &quot;java/lang/NullPointerException&quot;</span></span><br><span class="line">    <span class="comment">// +   [CONSTANT_Class_info] for above</span></span><br><span class="line">    <span class="comment">// +   [UTF-8] &quot;java/lang/IllegalArgumentException&quot;</span></span><br><span class="line">    <span class="comment">// +   [CONSTANT_Class_info] for above</span></span><br><span class="line">    <span class="comment">// +   [UTF-8] &quot;java/lang/InvocationTargetException&quot;</span></span><br><span class="line">    <span class="comment">// +   [CONSTANT_Class_info] for above</span></span><br><span class="line">    <span class="comment">// +   [UTF-8] &quot;&lt;init&gt;&quot;</span></span><br><span class="line">    <span class="comment">// +   [UTF-8] &quot;()V&quot;</span></span><br><span class="line">    <span class="comment">// +   [CONSTANT_NameAndType_info] for above</span></span><br><span class="line">    <span class="comment">// +   [CONSTANT_Methodref_info] for NullPointerException&#x27;s constructor</span></span><br><span class="line">    <span class="comment">// +   [CONSTANT_Methodref_info] for IllegalArgumentException&#x27;s constructor</span></span><br><span class="line">    <span class="comment">// +   [UTF-8] &quot;(Ljava/lang/String;)V&quot;</span></span><br><span class="line">    <span class="comment">// +   [CONSTANT_NameAndType_info] for &quot;&lt;init&gt;(Ljava/lang/String;)V&quot;</span></span><br><span class="line">    <span class="comment">// +   [CONSTANT_Methodref_info] for IllegalArgumentException&#x27;s constructor taking a String</span></span><br><span class="line">    <span class="comment">// +   [UTF-8] &quot;(Ljava/lang/Throwable;)V&quot;</span></span><br><span class="line">    <span class="comment">// +   [CONSTANT_NameAndType_info] for &quot;&lt;init&gt;(Ljava/lang/Throwable;)V&quot;</span></span><br><span class="line">    <span class="comment">// +   [CONSTANT_Methodref_info] for InvocationTargetException&#x27;s constructor</span></span><br><span class="line">    <span class="comment">// +   [CONSTANT_Methodref_info] for &quot;super()&quot;</span></span><br><span class="line">    <span class="comment">// +   [UTF-8] &quot;java/lang/Object&quot;</span></span><br><span class="line">    <span class="comment">// +   [CONSTANT_Class_info] for above</span></span><br><span class="line">    <span class="comment">// +   [UTF-8] &quot;toString&quot;</span></span><br><span class="line">    <span class="comment">// +   [UTF-8] &quot;()Ljava/lang/String;&quot;</span></span><br><span class="line">    <span class="comment">// +   [CONSTANT_NameAndType_info] for &quot;toString()Ljava/lang/String;&quot;</span></span><br><span class="line">    <span class="comment">// +   [CONSTANT_Methodref_info] for Object&#x27;s toString method</span></span><br><span class="line">    <span class="comment">// +   [UTF-8] &quot;Code&quot;</span></span><br><span class="line">    <span class="comment">// +   [UTF-8] &quot;Exceptions&quot;</span></span><br><span class="line">    <span class="comment">//  *  [UTF-8] &quot;java/lang/Boolean&quot;</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_Class_info] for above</span></span><br><span class="line">    <span class="comment">//  *  [UTF-8] &quot;(Z)V&quot;</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_NameAndType_info] for above</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_Methodref_info] for above</span></span><br><span class="line">    <span class="comment">//  *  [UTF-8] &quot;booleanValue&quot;</span></span><br><span class="line">    <span class="comment">//  *  [UTF-8] &quot;()Z&quot;</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_NameAndType_info] for above</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_Methodref_info] for above</span></span><br><span class="line">    <span class="comment">//  *  [UTF-8] &quot;java/lang/Byte&quot;</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_Class_info] for above</span></span><br><span class="line">    <span class="comment">//  *  [UTF-8] &quot;(B)V&quot;</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_NameAndType_info] for above</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_Methodref_info] for above</span></span><br><span class="line">    <span class="comment">//  *  [UTF-8] &quot;byteValue&quot;</span></span><br><span class="line">    <span class="comment">//  *  [UTF-8] &quot;()B&quot;</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_NameAndType_info] for above</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_Methodref_info] for above</span></span><br><span class="line">    <span class="comment">//  *  [UTF-8] &quot;java/lang/Character&quot;</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_Class_info] for above</span></span><br><span class="line">    <span class="comment">//  *  [UTF-8] &quot;(C)V&quot;</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_NameAndType_info] for above</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_Methodref_info] for above</span></span><br><span class="line">    <span class="comment">//  *  [UTF-8] &quot;charValue&quot;</span></span><br><span class="line">    <span class="comment">//  *  [UTF-8] &quot;()C&quot;</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_NameAndType_info] for above</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_Methodref_info] for above</span></span><br><span class="line">    <span class="comment">//  *  [UTF-8] &quot;java/lang/Double&quot;</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_Class_info] for above</span></span><br><span class="line">    <span class="comment">//  *  [UTF-8] &quot;(D)V&quot;</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_NameAndType_info] for above</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_Methodref_info] for above</span></span><br><span class="line">    <span class="comment">//  *  [UTF-8] &quot;doubleValue&quot;</span></span><br><span class="line">    <span class="comment">//  *  [UTF-8] &quot;()D&quot;</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_NameAndType_info] for above</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_Methodref_info] for above</span></span><br><span class="line">    <span class="comment">//  *  [UTF-8] &quot;java/lang/Float&quot;</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_Class_info] for above</span></span><br><span class="line">    <span class="comment">//  *  [UTF-8] &quot;(F)V&quot;</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_NameAndType_info] for above</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_Methodref_info] for above</span></span><br><span class="line">    <span class="comment">//  *  [UTF-8] &quot;floatValue&quot;</span></span><br><span class="line">    <span class="comment">//  *  [UTF-8] &quot;()F&quot;</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_NameAndType_info] for above</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_Methodref_info] for above</span></span><br><span class="line">    <span class="comment">//  *  [UTF-8] &quot;java/lang/Integer&quot;</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_Class_info] for above</span></span><br><span class="line">    <span class="comment">//  *  [UTF-8] &quot;(I)V&quot;</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_NameAndType_info] for above</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_Methodref_info] for above</span></span><br><span class="line">    <span class="comment">//  *  [UTF-8] &quot;intValue&quot;</span></span><br><span class="line">    <span class="comment">//  *  [UTF-8] &quot;()I&quot;</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_NameAndType_info] for above</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_Methodref_info] for above</span></span><br><span class="line">    <span class="comment">//  *  [UTF-8] &quot;java/lang/Long&quot;</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_Class_info] for above</span></span><br><span class="line">    <span class="comment">//  *  [UTF-8] &quot;(J)V&quot;</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_NameAndType_info] for above</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_Methodref_info] for above</span></span><br><span class="line">    <span class="comment">//  *  [UTF-8] &quot;longValue&quot;</span></span><br><span class="line">    <span class="comment">//  *  [UTF-8] &quot;()J&quot;</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_NameAndType_info] for above</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_Methodref_info] for above</span></span><br><span class="line">    <span class="comment">//  *  [UTF-8] &quot;java/lang/Short&quot;</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_Class_info] for above</span></span><br><span class="line">    <span class="comment">//  *  [UTF-8] &quot;(S)V&quot;</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_NameAndType_info] for above</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_Methodref_info] for above</span></span><br><span class="line">    <span class="comment">//  *  [UTF-8] &quot;shortValue&quot;</span></span><br><span class="line">    <span class="comment">//  *  [UTF-8] &quot;()S&quot;</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_NameAndType_info] for above</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_Methodref_info] for above</span></span><br><span class="line"></span><br><span class="line">    <span class="type">short</span> <span class="variable">numCPEntries</span> <span class="operator">=</span> NUM_BASE_CPOOL_ENTRIES + NUM_COMMON_CPOOL_ENTRIES;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">usesPrimitives</span> <span class="operator">=</span> usesPrimitiveTypes();</span><br><span class="line">    <span class="keyword">if</span> (usesPrimitives) &#123;</span><br><span class="line">        numCPEntries += NUM_BOXING_CPOOL_ENTRIES;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (forSerialization) &#123;</span><br><span class="line">        numCPEntries += NUM_SERIALIZATION_CPOOL_ENTRIES;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add in variable-length number of entries to be able to describe</span></span><br><span class="line">    <span class="comment">// non-primitive parameter types and checked exceptions.</span></span><br><span class="line">    numCPEntries += (<span class="type">short</span>) (<span class="number">2</span> * numNonPrimitiveParameterTypes());</span><br><span class="line"></span><br><span class="line">    asm.emitShort(add(numCPEntries, S1));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">generatedName</span> <span class="operator">=</span> generateName(isConstructor, forSerialization);</span><br><span class="line">    asm.emitConstantPoolUTF8(generatedName);</span><br><span class="line">    asm.emitConstantPoolClass(asm.cpi());</span><br><span class="line">    thisClass = asm.cpi();</span><br><span class="line">    <span class="keyword">if</span> (isConstructor) &#123;</span><br><span class="line">        <span class="keyword">if</span> (forSerialization) &#123;</span><br><span class="line">            asm.emitConstantPoolUTF8</span><br><span class="line">                (<span class="string">&quot;sun/reflect/SerializationConstructorAccessorImpl&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            asm.emitConstantPoolUTF8(<span class="string">&quot;sun/reflect/ConstructorAccessorImpl&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        asm.emitConstantPoolUTF8(<span class="string">&quot;sun/reflect/MethodAccessorImpl&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    asm.emitConstantPoolClass(asm.cpi());</span><br><span class="line">    superClass = asm.cpi();</span><br><span class="line">    asm.emitConstantPoolUTF8(getClassName(declaringClass, <span class="literal">false</span>));</span><br><span class="line">    asm.emitConstantPoolClass(asm.cpi());</span><br><span class="line">    targetClass = asm.cpi();</span><br><span class="line">    <span class="type">short</span> <span class="variable">serializationTargetClassIdx</span> <span class="operator">=</span> (<span class="type">short</span>) <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (forSerialization) &#123;</span><br><span class="line">        asm.emitConstantPoolUTF8(getClassName(serializationTargetClass, <span class="literal">false</span>));</span><br><span class="line">        asm.emitConstantPoolClass(asm.cpi());</span><br><span class="line">        serializationTargetClassIdx = asm.cpi();</span><br><span class="line">    &#125;</span><br><span class="line">    asm.emitConstantPoolUTF8(name);</span><br><span class="line">    asm.emitConstantPoolUTF8(buildInternalSignature());</span><br><span class="line">    asm.emitConstantPoolNameAndType(sub(asm.cpi(), S1), asm.cpi());</span><br><span class="line">    <span class="keyword">if</span> (isInterface()) &#123;</span><br><span class="line">        asm.emitConstantPoolInterfaceMethodref(targetClass, asm.cpi());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (forSerialization) &#123;</span><br><span class="line">            asm.emitConstantPoolMethodref(serializationTargetClassIdx, asm.cpi());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            asm.emitConstantPoolMethodref(targetClass, asm.cpi());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    targetMethodRef = asm.cpi();</span><br><span class="line">    <span class="keyword">if</span> (isConstructor) &#123;</span><br><span class="line">        asm.emitConstantPoolUTF8(<span class="string">&quot;newInstance&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        asm.emitConstantPoolUTF8(<span class="string">&quot;invoke&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    invokeIdx = asm.cpi();</span><br><span class="line">    <span class="keyword">if</span> (isConstructor) &#123;</span><br><span class="line">        asm.emitConstantPoolUTF8(<span class="string">&quot;([Ljava/lang/Object;)Ljava/lang/Object;&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        asm.emitConstantPoolUTF8</span><br><span class="line">            (<span class="string">&quot;(Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    invokeDescriptorIdx = asm.cpi();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Output class information for non-primitive parameter types</span></span><br><span class="line">    nonPrimitiveParametersBaseIdx = add(asm.cpi(), S2);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; parameterTypes.length; i++) &#123;</span><br><span class="line">        Class&lt;?&gt; c = parameterTypes[i];</span><br><span class="line">        <span class="keyword">if</span> (!isPrimitive(c)) &#123;</span><br><span class="line">            asm.emitConstantPoolUTF8(getClassName(c, <span class="literal">false</span>));</span><br><span class="line">            asm.emitConstantPoolClass(asm.cpi());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Entries common to FieldAccessor, MethodAccessor and ConstructorAccessor</span></span><br><span class="line">    emitCommonConstantPoolEntries();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Boxing entries</span></span><br><span class="line">    <span class="keyword">if</span> (usesPrimitives) &#123;</span><br><span class="line">        emitBoxingContantPoolEntries();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (asm.cpi() != numCPEntries) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalError</span>(<span class="string">&quot;Adjust this code (cpi = &quot;</span> + asm.cpi() +</span><br><span class="line">                                <span class="string">&quot;, numCPEntries = &quot;</span> + numCPEntries + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Access flags</span></span><br><span class="line">    asm.emitShort(ACC_PUBLIC);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This class</span></span><br><span class="line">    asm.emitShort(thisClass);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Superclass</span></span><br><span class="line">    asm.emitShort(superClass);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Interfaces count and interfaces</span></span><br><span class="line">    asm.emitShort(S0);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Fields count and fields</span></span><br><span class="line">    asm.emitShort(S0);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Methods count and methods</span></span><br><span class="line">    asm.emitShort(NUM_METHODS);</span><br><span class="line"></span><br><span class="line">    emitConstructor();</span><br><span class="line">    emitInvoke();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Additional attributes (none)</span></span><br><span class="line">    asm.emitShort(S0);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Load class</span></span><br><span class="line">    vec.trim();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">byte</span>[] bytes = vec.getData();</span><br><span class="line">    <span class="comment">// Note: the class loader is the only thing that really matters</span></span><br><span class="line">    <span class="comment">// here -- it&#x27;s important to get the generated code into the</span></span><br><span class="line">    <span class="comment">// same namespace as the target class. Since the generated code</span></span><br><span class="line">    <span class="comment">// is privileged anyway, the protection domain probably doesn&#x27;t</span></span><br><span class="line">    <span class="comment">// matter.</span></span><br><span class="line">    <span class="keyword">return</span> AccessController.doPrivileged(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;MagicAccessorImpl&gt;() &#123;</span><br><span class="line">            <span class="keyword">public</span> MagicAccessorImpl <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> (MagicAccessorImpl)</span><br><span class="line">                    ClassDefiner.defineClass</span><br><span class="line">                            (generatedName,</span><br><span class="line">                             bytes,</span><br><span class="line">                             <span class="number">0</span>,</span><br><span class="line">                             bytes.length,</span><br><span class="line">                             declaringClass.getClassLoader()).newInstance();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InstantiationException | IllegalAccessException e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalError</span>(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>咱们主要看这一句：<code>ClassDefiner.defineClass(xx, declaringClass.getClassLoader()).newInstance()</code>;</p><p>在<code>ClassDefiner.defineClass</code>方法实现中，每被调用一次都会生成一个DelegatingClassLoader类加载器对象 ，这里每次都生成新的类加载器，是为了性能考虑，在某些情况下可以卸载这些生成的类，因为类的卸载是只有在类加载器可以被回收的情况下才会被回收的，如果用了原来的类加载器，那可能导致这些新创建的类一直无法被卸载。</p><p>而反射生成的类，有时候可能用了就可以卸载了，所以使用其独立的类加载器，从而使得更容易控制反射类的生命周期。</p><h3 id="反射调用流程小结"><a href="#反射调用流程小结" class="headerlink" title="# 反射调用流程小结"></a><a href="#%E5%8F%8D%E5%B0%84%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B%E5%B0%8F%E7%BB%93">#</a> 反射调用流程小结</h3><p>最后，用几句话总结反射的实现原理：</p><ol><li>反射类及反射方法的获取，都是通过从列表中搜寻查找匹配的方法，所以查找性能会随类的大小方法多少而变化；</li><li>每个类都会有一个与之对应的Class实例，从而每个类都可以获取method反射方法，并作用到其他实例身上；</li><li>反射也是考虑了线程安全的，放心使用；</li><li>反射使用软引用relectionData缓存class信息，避免每次重新从jvm获取带来的开销；</li><li>反射调用多次生成新代理Accessor, 而通过字节码生存的则考虑了卸载功能，所以会使用独立的类加载器；</li><li>当找到需要的方法，都会copy一份出来，而不是使用原来的实例，从而保证数据隔离；</li><li>调度反射方法，最终是由jvm执行invoke0()执行；</li></ol><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="# 参考文章"></a><a href="#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0">#</a> 参考文章</h2><ul><li><a href="https://www.codercto.com/a/46094.html">https://www.codercto.com/a/46094.html</a></li><li><a href="https://blog.csdn.net/sinat_38259539/article/details/71799078">https://blog.csdn.net/sinat_38259539/article/details/71799078</a></li><li><a href="https://blog.csdn.net/qq_40896997/article/details/94483820">https://blog.csdn.net/qq_40896997/article/details/94483820</a></li><li><a href="https://www.cnblogs.com/zhaoguhong/p/6937364.html">https://www.cnblogs.com/zhaoguhong/p/6937364.html</a></li><li><a href="https://juejin.im/post/5c160420e51d452a60684431">https://juejin.im/post/5c160420e51d452a60684431</a></li><li><a href="https://blog.csdn.net/mcryeasy/java/article/details/52344729">https://blog.csdn.net/mcryeasy/java/article/details/52344729</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 类别 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 基础 - 异常机制详解</title>
      <link href="/posts/ad94428e.html"/>
      <url>/posts/ad94428e.html</url>
      
        <content type="html"><![CDATA[<p>Java 基础 - 异常机制详解</p><span id="more"></span><h2 id="异常的层次结构"><a href="#异常的层次结构" class="headerlink" title="异常的层次结构"></a>异常的层次结构</h2><p>异常指不期而至的各种状况，如：文件找不到、网络连接失败、非法参数等。异常是一个事件，它发生在程序运行期间，干扰了正常的指令流程。Java通 过API中Throwable类的众多子类描述各种不同的异常。因而，Java异常都是对象，是Throwable子类的实例，描述了出现在一段编码中的 错误条件。当条件生成时，错误将引发异常。</p><p>Java异常类层次结构图：</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230816163410241.png" alt="image-20230816163410241"></p><h3 id="Throwable"><a href="#Throwable" class="headerlink" title="# Throwable"></a><a href="#throwable">#</a> Throwable</h3><p>Throwable 是 Java 语言中所有错误与异常的超类。</p><p>Throwable 包含两个子类：Error（错误）和 Exception（异常），它们通常用于指示发生了异常情况。</p><p>Throwable 包含了其线程创建时线程执行堆栈的快照，它提供了 printStackTrace() 等接口用于获取堆栈跟踪数据等信息。</p><h3 id="Error（错误）"><a href="#Error（错误）" class="headerlink" title="# Error（错误）"></a><a href="#error-%E9%94%99%E8%AF%AF">#</a> Error（错误）</h3><p>Error 类及其子类：程序中无法处理的错误，表示运行应用程序中出现了严重的错误。</p><p>此类错误一般表示代码运行时 JVM 出现问题。通常有 Virtual MachineError（虚拟机运行错误）、NoClassDefFoundError（类定义错误）等。比如 OutOfMemoryError：内存不足错误；StackOverflowError：栈溢出错误。此类错误发生时，JVM 将终止线程。</p><p>这些错误是不受检异常，非代码性错误。因此，当此类错误发生时，应用程序不应该去处理此类错误。按照Java惯例，我们是不应该实现任何新的Error子类的！</p><h3 id="Exception（异常）"><a href="#Exception（异常）" class="headerlink" title="# Exception（异常）"></a><a href="#exception-%E5%BC%82%E5%B8%B8">#</a> Exception（异常）</h3><p>程序本身可以捕获并且可以处理的异常。Exception 这种异常又分为两类：运行时异常和编译时异常。</p><ul><li><strong>运行时异常</strong></li></ul><p>都是RuntimeException类及其子类异常，如NullPointerException(空指针异常)、IndexOutOfBoundsException(下标越界异常)等，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。</p><p>运行时异常的特点是Java编译器不会检查它，也就是说，当程序中可能出现这类异常，即使没有用try-catch语句捕获它，也没有用throws子句声明抛出它，也会编译通过。</p><ul><li><strong>非运行时异常</strong> （编译异常）</li></ul><p>是RuntimeException以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不自定义检查异常。</p><h3 id="可查的异常（checked-exceptions）和不可查的异常（unchecked-exceptions）"><a href="#可查的异常（checked-exceptions）和不可查的异常（unchecked-exceptions）" class="headerlink" title="# 可查的异常（checked exceptions）和不可查的异常（unchecked exceptions）"></a><a href="#%E5%8F%AF%E6%9F%A5%E7%9A%84%E5%BC%82%E5%B8%B8-checked-exceptions-%E5%92%8C%E4%B8%8D%E5%8F%AF%E6%9F%A5%E7%9A%84%E5%BC%82%E5%B8%B8-unchecked-exceptions">#</a> 可查的异常（checked exceptions）和不可查的异常（unchecked exceptions）</h3><ul><li><strong>可查异常</strong>（编译器要求必须处置的异常）：</li></ul><p>正确的程序在运行中，很容易出现的、情理可容的异常状况。可查异常虽然是异常状况，但在一定程度上它的发生是可以预计的，而且一旦发生这种异常状况，就必须采取某种方式进行处理。</p><p>除了RuntimeException及其子类以外，其他的Exception类及其子类都属于可查异常。这种异常的特点是Java编译器会检查它，也就是说，当程序中可能出现这类异常，要么用try-catch语句捕获它，要么用throws子句声明抛出它，否则编译不会通过。</p><ul><li><strong>不可查异常</strong>(编译器不要求强制处置的异常)</li></ul><p>包括运行时异常（RuntimeException与其子类）和错误（Error）。</p><h2 id="异常基础"><a href="#异常基础" class="headerlink" title="# 异常基础"></a><a href="#%E5%BC%82%E5%B8%B8%E5%9F%BA%E7%A1%80">#</a> 异常基础</h2><p>提示</p><p>接下来我们看下异常使用的基础。</p><h3 id="异常关键字"><a href="#异常关键字" class="headerlink" title="# 异常关键字"></a><a href="#%E5%BC%82%E5%B8%B8%E5%85%B3%E9%94%AE%E5%AD%97">#</a> 异常关键字</h3><ul><li><strong>try</strong> – 用于监听。将要被监听的代码(可能抛出异常的代码)放在try语句块之内，当try语句块内发生异常时，异常就被抛出。</li><li><strong>catch</strong> – 用于捕获异常。catch用来捕获try语句块中发生的异常。</li><li><strong>finally</strong> – finally语句块总是会被执行。它主要用于回收在try块里打开的物力资源(如数据库连接、网络连接和磁盘文件)。只有finally块，执行完成之后，才会回来执行try或者catch块中的return或者throw语句，如果finally中使用了return或者throw等终止方法的语句，则就不会跳回执行，直接停止。</li><li><strong>throw</strong> – 用于抛出异常。</li><li><strong>throws</strong> – 用在方法签名中，用于声明该方法可能抛出的异常。</li></ul><h3 id="异常的申明-throws"><a href="#异常的申明-throws" class="headerlink" title="# 异常的申明(throws)"></a><a href="#%E5%BC%82%E5%B8%B8%E7%9A%84%E7%94%B3%E6%98%8E-throws">#</a> 异常的申明(throws)</h3><p>在Java中，当前执行的语句必属于某个方法，Java解释器调用main方法执行开始执行程序。若方法中存在检查异常，如果不对其捕获，那必须在方法头中显式声明该异常，以便于告知方法调用者此方法有异常，需要进行处理。 在方法中声明一个异常，方法头中使用关键字throws，后面接上要声明的异常。若声明多个异常，则使用逗号分割。如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> <span class="keyword">throws</span> IOException, FileNotFoundException&#123;</span><br><span class="line">    <span class="comment">//something statements</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：若是父类的方法没有声明异常，则子类继承方法后，也不能声明异常。</p><p>通常，应该捕获那些知道如何处理的异常，将不知道如何处理的异常继续传递下去。传递异常可以在方法签名处使用 throws 关键字声明可能会抛出的异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">readFile</span><span class="params">(String filePath)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(filePath);</span><br><span class="line">    String result;</span><br><span class="line">    <span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(file));</span><br><span class="line">    <span class="keyword">while</span>((result = reader.readLine())!=<span class="literal">null</span>) &#123;</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">    reader.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Throws抛出异常的规则：</p><ul><li>如果是不可查异常（unchecked exception），即Error、RuntimeException或它们的子类，那么可以不使用throws关键字来声明要抛出的异常，编译仍能顺利通过，但在运行时会被系统抛出。</li><li>必须声明方法可抛出的任何可查异常（checked exception）。即如果一个方法可能出现受可查异常，要么用try-catch语句捕获，要么用throws子句声明将它抛出，否则会导致编译错误</li><li>仅当抛出了异常，该方法的调用者才必须处理或者重新抛出该异常。当方法的调用者无力处理该异常的时候，应该继续抛出，而不是囫囵吞枣。</li><li>调用方法必须遵循任何可查异常的处理和声明规则。若覆盖一个方法，则不能声明与覆盖方法不同的异常。声明的任何异常必须是被覆盖方法所声明异常的同类或子类。</li></ul><h3 id="异常的抛出-throw"><a href="#异常的抛出-throw" class="headerlink" title="# 异常的抛出(throw)"></a><a href="#%E5%BC%82%E5%B8%B8%E7%9A%84%E6%8A%9B%E5%87%BA-throw">#</a> 异常的抛出(throw)</h3><p>如果代码可能会引发某种错误，可以创建一个合适的异常类实例并抛出它，这就是抛出异常。如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">method</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(value == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArithmeticException</span>(<span class="string">&quot;参数不能为0&quot;</span>); <span class="comment">//抛出一个运行时异常</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">5.0</span> / value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大部分情况下都不需要手动抛出异常，因为Java的大部分方法要么已经处理异常，要么已声明异常。所以一般都是捕获异常或者再往上抛。</p><p>有时我们会从 catch 中抛出一个异常，目的是为了改变异常的类型。多用于在多系统集成时，当某个子系统故障，异常类型可能有多种，可以用统一的异常类型向外暴露，不需暴露太多内部异常细节。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">readFile</span><span class="params">(String filePath)</span> <span class="keyword">throws</span> MyException &#123;    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// code</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="type">MyException</span> <span class="variable">ex</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyException</span>(<span class="string">&quot;read file failed.&quot;</span>);</span><br><span class="line">        ex.initCause(e);</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="异常的自定义"><a href="#异常的自定义" class="headerlink" title="# 异常的自定义"></a><a href="#%E5%BC%82%E5%B8%B8%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89">#</a> 异常的自定义</h3><p>习惯上，定义一个异常类应包含两个构造函数，一个无参构造函数和一个带有详细描述信息的构造函数（Throwable 的 toString 方法会打印这些详细信息，调试时很有用）, 比如上面用到的自定义MyException：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyException</span><span class="params">()</span>&#123; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyException</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(msg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="异常的捕获"><a href="#异常的捕获" class="headerlink" title="# 异常的捕获"></a><a href="#%E5%BC%82%E5%B8%B8%E7%9A%84%E6%8D%95%E8%8E%B7">#</a> 异常的捕获</h3><p>异常捕获处理的方法通常有：</p><ul><li>try-catch</li><li>try-catch-finally</li><li>try-finally</li><li>try-with-resource</li></ul><h4 id="try-catch"><a href="#try-catch" class="headerlink" title="# try-catch"></a><a href="#try-catch">#</a> try-catch</h4><p>在一个 try-catch 语句块中可以捕获多个异常类型，并对不同类型的异常做出不同的处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">readFile</span><span class="params">(String filePath)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// code</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        <span class="comment">// handle FileNotFoundException</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">        <span class="comment">// handle IOException</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同一个 catch 也可以捕获多种类型异常，用 | 隔开</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">readFile</span><span class="params">(String filePath)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// code</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException | UnknownHostException e) &#123;</span><br><span class="line">        <span class="comment">// handle FileNotFoundException or UnknownHostException</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">        <span class="comment">// handle IOException</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="# try-catch-finally"></a><a href="#try-catch-finally">#</a> try-catch-finally</h4><ul><li>常规语法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;                        </span><br><span class="line">    <span class="comment">//执行程序代码，可能会出现异常                 </span></span><br><span class="line">&#125; <span class="keyword">catch</span>(Exception e) &#123;   </span><br><span class="line">    <span class="comment">//捕获异常并处理   </span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//必执行的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>执行的顺序 <ul><li>当try没有捕获到异常时：try语句块中的语句逐一被执行，程序将跳过catch语句块，执行finally语句块和其后的语句；</li><li>当try捕获到异常，catch语句块里没有处理此异常的情况：当try语句块里的某条语句出现异常时，而没有处理此异常的catch语句块时，此异常将会抛给JVM处理，finally语句块里的语句还是会被执行，但finally语句块后的语句不会被执行；</li><li>当try捕获到异常，catch语句块里有处理此异常的情况：在try语句块中是按照顺序来执行的，当执行到某一条语句出现异常时，程序将跳到catch语句块，并与catch语句块逐一匹配，找到与之对应的处理程序，其他的catch语句块将不会被执行，而try语句块中，出现异常之后的语句也不会被执行，catch语句块执行完后，执行finally语句块里的语句，最后执行finally语句块后的语句；</li></ul></li></ul><p><img src="images/java/java-basic-exception-2.jpg" alt="img"></p><ul><li>一个完整的例子</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">readFile</span><span class="params">(String filePath)</span> <span class="keyword">throws</span> MyException &#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(filePath);</span><br><span class="line">    String result;</span><br><span class="line">    <span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        reader = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(file));</span><br><span class="line">        <span class="keyword">while</span>((result = reader.readLine())!=<span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;readFile method catch block.&quot;</span>);</span><br><span class="line">        <span class="type">MyException</span> <span class="variable">ex</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyException</span>(<span class="string">&quot;read file failed.&quot;</span>);</span><br><span class="line">        ex.initCause(e);</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;readFile method finally block.&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != reader) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                reader.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="try-finally"><a href="#try-finally" class="headerlink" title="# try-finally"></a><a href="#try-finally">#</a> try-finally</h4><blockquote><p>可以直接用try-finally吗？ 可以。</p></blockquote><p>try块中引起异常，异常代码之后的语句不再执行，直接执行finally语句。 try块没有引发异常，则执行完try块就执行finally语句。</p><p>try-finally可用在不需要捕获异常的代码，可以保证资源在使用后被关闭。例如IO流中执行完相应操作后，关闭相应资源；使用Lock对象保证线程同步，通过finally可以保证锁会被释放；数据库连接代码时，关闭连接操作等等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以Lock加锁为例，演示try-finally</span></span><br><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//需要加锁的代码</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock(); <span class="comment">//保证锁一定被释放</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>finally遇见如下情况不会执行</p><ul><li>在前面的代码中用了System.exit()退出程序。</li><li>finally语句块中发生了异常。</li><li>程序所在的线程死亡。</li><li>关闭CPU。</li></ul><h4 id="try-with-resource"><a href="#try-with-resource" class="headerlink" title="# try-with-resource"></a><a href="#try-with-resource">#</a> try-with-resource</h4><blockquote><p>try-with-resource是Java 7中引入的，很容易被忽略。</p></blockquote><p>上面例子中，finally 中的 close 方法也可能抛出 IOException, 从而覆盖了原始异常。JAVA 7 提供了更优雅的方式来实现资源的自动释放，自动释放的资源需要是实现了 AutoCloseable 接口的类。</p><ul><li>代码实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">tryWithResourceTest</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;c:/abc&quot;</span>),<span class="string">&quot;UTF-8&quot;</span>))&#123;</span><br><span class="line">        <span class="comment">// code</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">        <span class="comment">// handle exception</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>看下Scanner</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Scanner</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;String&gt;, Closeable &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Closeable</span> <span class="keyword">extends</span> <span class="title class_">AutoCloseable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>try 代码块退出时，会自动调用 scanner.close 方法，和把 scanner.close 方法放在 finally 代码块中不同的是，若 scanner.close 抛出异常，则会被抑制，抛出的仍然为原始异常。被抑制的异常会由 addSusppressed 方法添加到原来的异常，如果想要获取被抑制的异常列表，可以调用 getSuppressed 方法来获取。</p><h3 id="异常基础总结"><a href="#异常基础总结" class="headerlink" title="# 异常基础总结"></a><a href="#%E5%BC%82%E5%B8%B8%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93">#</a> 异常基础总结</h3><ul><li>try、catch和finally都不能单独使用，只能是try-catch、try-finally或者try-catch-finally。</li><li>try语句块监控代码，出现异常就停止执行下面的代码，然后将异常移交给catch语句块来处理。</li><li>finally语句块中的代码一定会被执行，常用于回收资源 。</li><li>throws：声明一个异常，告知方法调用者。</li><li>throw ：抛出一个异常，至于该异常被捕获还是继续抛出都与它无关。</li></ul><p>Java编程思想一书中，对异常的总结。</p><ul><li>在恰当的级别处理问题。（在知道该如何处理的情况下了捕获异常。）</li><li>解决问题并且重新调用产生异常的方法。</li><li>进行少许修补，然后绕过异常发生的地方继续执行。</li><li>用别的数据进行计算，以代替方法预计会返回的值。</li><li>把当前运行环境下能做的事尽量做完，然后把相同的异常重抛到更高层。</li><li>把当前运行环境下能做的事尽量做完，然后把不同的异常抛到更高层。</li><li>终止程序。</li><li>进行简化（如果你的异常模式使问题变得太复杂，那么用起来会非常痛苦）。</li><li>让类库和程序更安全。</li></ul><h3 id="常用的异常"><a href="#常用的异常" class="headerlink" title="# 常用的异常"></a><a href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E5%BC%82%E5%B8%B8">#</a> 常用的异常</h3><p>在Java中提供了一些异常用来描述经常发生的错误，对于这些异常，有的需要程序员进行捕获处理或声明抛出，有的是由Java虚拟机自动进行捕获处理。Java中常见的异常类:</p><ul><li><strong>RuntimeException</strong><ul><li>java.lang.ArrayIndexOutOfBoundsException 数组索引越界异常。当对数组的索引值为负数或大于等于数组大小时抛出。</li><li>java.lang.ArithmeticException 算术条件异常。譬如：整数除零等。</li><li>java.lang.NullPointerException 空指针异常。当应用试图在要求使用对象的地方使用了null时，抛出该异常。譬如：调用null对象的实例方法、访问null对象的属性、计算null对象的长度、使用throw语句抛出null等等</li><li>java.lang.ClassNotFoundException 找不到类异常。当应用试图根据字符串形式的类名构造类，而在遍历CLASSPAH之后找不到对应名称的class文件时，抛出该异常。</li><li>java.lang.NegativeArraySizeException 数组长度为负异常</li><li>java.lang.ArrayStoreException 数组中包含不兼容的值抛出的异常</li><li>java.lang.SecurityException 安全性异常</li><li>java.lang.IllegalArgumentException 非法参数异常</li></ul></li><li><strong>IOException</strong><ul><li>IOException：操作输入流和输出流时可能出现的异常。</li><li>EOFException 文件已结束异常</li><li>FileNotFoundException 文件未找到异常</li></ul></li><li><strong>其他</strong><ul><li>ClassCastException 类型转换异常类</li><li>ArrayStoreException 数组中包含不兼容的值抛出的异常</li><li>SQLException 操作数据库异常类</li><li>NoSuchFieldException 字段未找到异常</li><li>NoSuchMethodException 方法未找到抛出的异常</li><li>NumberFormatException 字符串转换为数字抛出的异常</li><li>StringIndexOutOfBoundsException 字符串索引超出范围抛出的异常</li><li>IllegalAccessException 不允许访问某类异常</li><li>InstantiationException 当应用程序试图使用Class类中的newInstance()方法创建一个类的实例，而指定的类对象无法被实例化时，抛出该异常</li></ul></li></ul><h2 id="异常实践"><a href="#异常实践" class="headerlink" title="# 异常实践"></a><a href="#%E5%BC%82%E5%B8%B8%E5%AE%9E%E8%B7%B5">#</a> 异常实践</h2><p>提示</p><p>在 Java 中处理异常并不是一个简单的事情。不仅仅初学者很难理解，即使一些有经验的开发者也需要花费很多时间来思考如何处理异常，包括需要处理哪些异常，怎样处理等等。这也是绝大多数开发团队都会制定一些规则来规范进行异常处理的原因。</p><p>当你抛出或捕获异常的时候，有很多不同的情况需要考虑，而且大部分事情都是为了改善代码的可读性或者 API 的可用性。</p><p>异常不仅仅是一个错误控制机制，也是一个通信媒介。因此，为了和同事更好的合作，一个团队必须要制定出一个最佳实践和规则，只有这样，团队成员才能理解这些通用概念，同时在工作中使用它。</p><p>这里给出几个被很多团队使用的异常处理最佳实践。</p><h3 id="只针对不正常的情况才使用异常"><a href="#只针对不正常的情况才使用异常" class="headerlink" title="# 只针对不正常的情况才使用异常"></a><a href="#%E5%8F%AA%E9%92%88%E5%AF%B9%E4%B8%8D%E6%AD%A3%E5%B8%B8%E7%9A%84%E6%83%85%E5%86%B5%E6%89%8D%E4%BD%BF%E7%94%A8%E5%BC%82%E5%B8%B8">#</a> 只针对不正常的情况才使用异常</h3><blockquote><p>异常只应该被用于不正常的条件，它们永远不应该被用于正常的控制流。《阿里手册》中：【强制】Java 类库中定义的可以通过预检查方式规避的RuntimeException异常不应该通过catch 的方式来处理，比如：NullPointerException，IndexOutOfBoundsException等等。</p></blockquote><p>比如，在解析字符串形式的数字时，可能存在数字格式错误，不得通过catch Exception来实现</p><ul><li>代码1</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (obj != <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>代码2</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line">  obj.method(); </span><br><span class="line">&#125; <span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要原因有三点：</p><ul><li>异常机制的设计初衷是用于不正常的情况，所以很少会会JVM实现试图对它们的性能进行优化。所以，创建、抛出和捕获异常的开销是很昂贵的。</li><li>把代码放在try-catch中返回阻止了JVM实现本来可能要执行的某些特定的优化。</li><li>对数组进行遍历的标准模式并不会导致冗余的检查，有些现代的JVM实现会将它们优化掉。</li></ul><h3 id="在-finally-块中清理资源或者使用-try-with-resource-语句"><a href="#在-finally-块中清理资源或者使用-try-with-resource-语句" class="headerlink" title="# 在 finally 块中清理资源或者使用 try-with-resource 语句"></a><a href="#%E5%9C%A8-finally-%E5%9D%97%E4%B8%AD%E6%B8%85%E7%90%86%E8%B5%84%E6%BA%90%E6%88%96%E8%80%85%E4%BD%BF%E7%94%A8-try-with-resource-%E8%AF%AD%E5%8F%A5">#</a> 在 finally 块中清理资源或者使用 try-with-resource 语句</h3><p>当使用类似InputStream这种需要使用后关闭的资源时，一个常见的错误就是在try块的最后关闭资源。</p><ul><li>错误示例</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doNotCloseResourceInTry</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;./tmp.txt&quot;</span>);</span><br><span class="line">        inputStream = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line">        <span class="comment">// use the inputStream to read a file</span></span><br><span class="line">        <span class="comment">// do NOT do this</span></span><br><span class="line">        inputStream.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        log.error(e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        log.error(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题就是，只有没有异常抛出的时候，这段代码才可以正常工作。try 代码块内代码会正常执行，并且资源可以正常关闭。但是，使用 try 代码块是有原因的，一般调用一个或多个可能抛出异常的方法，而且，你自己也可能会抛出一个异常，这意味着代码可能不会执行到 try 代码块的最后部分。结果就是，你并没有关闭资源。</p><p>所以，你应该把清理工作的代码放到 finally 里去，或者使用 try-with-resource 特性。</p><ul><li>方法一：使用 finally 代码块</li></ul><p>与前面几行 try 代码块不同，finally 代码块总是会被执行。不管 try 代码块成功执行之后还是你在 catch 代码块中处理完异常后都会执行。因此，你可以确保你清理了所有打开的资源。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">closeResourceInFinally</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;./tmp.txt&quot;</span>);</span><br><span class="line">        inputStream = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line">        <span class="comment">// use the inputStream to read a file</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        log.error(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (inputStream != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                inputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                log.error(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>方法二：Java 7 的 try-with-resource 语法</li></ul><p>如果你的资源实现了 AutoCloseable 接口，你可以使用这个语法。大多数的 Java 标准资源都继承了这个接口。当你在 try 子句中打开资源，资源会在 try 代码块执行后或异常处理后自动关闭。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">automaticallyCloseResource</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;./tmp.txt&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">FileInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);) &#123;</span><br><span class="line">        <span class="comment">// use the inputStream to read a file</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        log.error(e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        log.error(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="尽量使用标准的异常"><a href="#尽量使用标准的异常" class="headerlink" title="# 尽量使用标准的异常"></a><a href="#%E5%B0%BD%E9%87%8F%E4%BD%BF%E7%94%A8%E6%A0%87%E5%87%86%E7%9A%84%E5%BC%82%E5%B8%B8">#</a> 尽量使用标准的异常</h3><blockquote><p>代码重用是值得提倡的，这是一条通用规则，异常也不例外。</p></blockquote><p>重用现有的异常有几个好处：</p><ul><li>它使得你的API更加易于学习和使用，因为它与程序员原来已经熟悉的习惯用法是一致的。</li><li>对于用到这些API的程序而言，它们的可读性更好，因为它们不会充斥着程序员不熟悉的异常。</li><li>异常类越少，意味着内存占用越小，并且转载这些类的时间开销也越小。</li></ul><p>Java标准异常中有几个是经常被使用的异常。如下表格：</p><table><thead><tr><th>异常</th><th>使用场合</th></tr></thead><tbody><tr><td>IllegalArgumentException</td><td>参数的值不合适</td></tr><tr><td>IllegalStateException</td><td>参数的状态不合适</td></tr><tr><td>NullPointerException</td><td>在null被禁止的情况下参数值为null</td></tr><tr><td>IndexOutOfBoundsException</td><td>下标越界</td></tr><tr><td>ConcurrentModificationException</td><td>在禁止并发修改的情况下，对象检测到并发修改</td></tr><tr><td>UnsupportedOperationException</td><td>对象不支持客户请求的方法</td></tr></tbody></table><p>虽然它们是Java平台库迄今为止最常被重用的异常，但是，在许可的条件下，其它的异常也可以被重用。例如，如果你要实现诸如复数或者矩阵之类的算术对象，那么重用ArithmeticException和NumberFormatException将是非常合适的。如果一个异常满足你的需要，则不要犹豫，使用就可以，不过你一定要确保抛出异常的条件与该异常的文档中描述的条件一致。这种重用必须建立在语义的基础上，而不是名字的基础上。</p><p>最后，一定要清楚，选择重用哪一种异常并没有必须遵循的规则。例如，考虑纸牌对象的情形，假设有一个用于发牌操作的方法，它的参数(handSize)是发一手牌的纸牌张数。假设调用者在这个参数中传递的值大于整副牌的剩余张数。那么这种情形既可以被解释为IllegalArgumentException(handSize的值太大)，也可以被解释为IllegalStateException(相对客户的请求而言，纸牌对象的纸牌太少)。</p><h3 id="对异常进行文档说明"><a href="#对异常进行文档说明" class="headerlink" title="# 对异常进行文档说明"></a><a href="#%E5%AF%B9%E5%BC%82%E5%B8%B8%E8%BF%9B%E8%A1%8C%E6%96%87%E6%A1%A3%E8%AF%B4%E6%98%8E">#</a> 对异常进行文档说明</h3><blockquote><p>当在方法上声明抛出异常时，也需要进行文档说明。目的是为了给调用者提供尽可能多的信息，从而可以更好地避免或处理异常。</p></blockquote><p>在 Javadoc 添加 @throws 声明，并且描述抛出异常的场景。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Method description</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> MyBusinessException - businuess exception description</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">(String input)</span> <span class="keyword">throws</span> MyBusinessException &#123;</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时，在抛出MyBusinessException 异常时，需要尽可能精确地描述问题和相关信息，这样无论是打印到日志中还是在监控工具中，都能够更容易被人阅读，从而可以更好地定位具体错误信息、错误的严重程度等。</p><h3 id="优先捕获最具体的异常"><a href="#优先捕获最具体的异常" class="headerlink" title="# 优先捕获最具体的异常"></a><a href="#%E4%BC%98%E5%85%88%E6%8D%95%E8%8E%B7%E6%9C%80%E5%85%B7%E4%BD%93%E7%9A%84%E5%BC%82%E5%B8%B8">#</a> 优先捕获最具体的异常</h3><blockquote><p>大多数 IDE 都可以帮助你实现这个最佳实践。当你尝试首先捕获较不具体的异常时，它们会报告无法访问的代码块。</p></blockquote><p>但问题在于，只有匹配异常的第一个 catch 块会被执行。 因此，如果首先捕获 IllegalArgumentException ，则永远不会到达应该处理更具体的 NumberFormatException 的 catch 块，因为它是 IllegalArgumentException 的子类。</p><p>总是优先捕获最具体的异常类，并将不太具体的 catch 块添加到列表的末尾。</p><p>你可以在下面的代码片断中看到这样一个 try-catch 语句的例子。 第一个 catch 块处理所有 NumberFormatException 异常，第二个处理所有非 NumberFormatException 异常的IllegalArgumentException 异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">catchMostSpecificExceptionFirst</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        doSomething(<span class="string">&quot;A message&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">        log.error(e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">        log.error(e)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="不要捕获-Throwable-类"><a href="#不要捕获-Throwable-类" class="headerlink" title="# 不要捕获 Throwable 类"></a><a href="#%E4%B8%8D%E8%A6%81%E6%8D%95%E8%8E%B7-throwable-%E7%B1%BB">#</a> 不要捕获 Throwable 类</h3><blockquote><p>Throwable 是所有异常和错误的超类。你可以在 catch 子句中使用它，但是你永远不应该这样做！</p></blockquote><p>如果在 catch 子句中使用 Throwable ，它不仅会捕获所有异常，也将捕获所有的错误。JVM 抛出错误，指出不应该由应用程序处理的严重问题。 典型的例子是 OutOfMemoryError 或者 StackOverflowError 。两者都是由应用程序控制之外的情况引起的，无法处理。</p><p>所以，最好不要捕获 Throwable ，除非你确定自己处于一种特殊的情况下能够处理错误。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doNotCatchThrowable</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="comment">// don&#x27;t do this!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="不要忽略异常"><a href="#不要忽略异常" class="headerlink" title="# 不要忽略异常"></a><a href="#%E4%B8%8D%E8%A6%81%E5%BF%BD%E7%95%A5%E5%BC%82%E5%B8%B8">#</a> 不要忽略异常</h3><blockquote><p>很多时候，开发者很有自信不会抛出异常，因此写了一个catch块，但是没有做任何处理或者记录日志。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doNotIgnoreExceptions</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">        <span class="comment">// this will never happen</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但现实是经常会出现无法预料的异常，或者无法确定这里的代码未来是不是会改动(删除了阻止异常抛出的代码)，而此时由于异常被捕获，使得无法拿到足够的错误信息来定位问题。</p><p>合理的做法是至少要记录异常的信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logAnException</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;This should never happen: &quot;</span> + e); <span class="comment">// see this line</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="不要记录并抛出异常"><a href="#不要记录并抛出异常" class="headerlink" title="# 不要记录并抛出异常"></a><a href="#%E4%B8%8D%E8%A6%81%E8%AE%B0%E5%BD%95%E5%B9%B6%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8">#</a> 不要记录并抛出异常</h3><blockquote><p>这可能是本文中最常被忽略的最佳实践。</p></blockquote><p>可以发现很多代码甚至类库中都会有捕获异常、记录日志并再次抛出的逻辑。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Long</span>(<span class="string">&quot;xyz&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">    log.error(e);</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个处理逻辑看着是合理的。但这经常会给同一个异常输出多条日志。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">17</span>:<span class="number">44</span>:<span class="number">28</span>,<span class="number">945</span> ERROR TestExceptionHandling:<span class="number">65</span> - java.lang.NumberFormatException: For input string: <span class="string">&quot;xyz&quot;</span></span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.NumberFormatException: For input string: <span class="string">&quot;xyz&quot;</span></span><br><span class="line">at java.lang.NumberFormatException.forInputString(NumberFormatException.java:<span class="number">65</span>)</span><br><span class="line">at java.lang.Long.parseLong(Long.java:<span class="number">589</span>)</span><br><span class="line">at java.lang.Long.(Long.java:<span class="number">965</span>)</span><br><span class="line">at com.stackify.example.TestExceptionHandling.logAndThrowException(TestExceptionHandling.java:<span class="number">63</span>)</span><br><span class="line">at com.stackify.example.TestExceptionHandling.main(TestExceptionHandling.java:<span class="number">58</span>)</span><br></pre></td></tr></table></figure><p>如上所示，后面的日志也没有附加更有用的信息。如果想要提供更加有用的信息，那么可以将异常包装为自定义异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">wrapException</span><span class="params">(String input)</span> <span class="keyword">throws</span> MyBusinessException &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MyBusinessException</span>(<span class="string">&quot;A message that describes the error.&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，仅仅当想要处理异常时才去捕获，否则只需要在方法签名中声明让调用者去处理。</p><h3 id="包装异常时不要抛弃原始的异常"><a href="#包装异常时不要抛弃原始的异常" class="headerlink" title="# 包装异常时不要抛弃原始的异常"></a><a href="#%E5%8C%85%E8%A3%85%E5%BC%82%E5%B8%B8%E6%97%B6%E4%B8%8D%E8%A6%81%E6%8A%9B%E5%BC%83%E5%8E%9F%E5%A7%8B%E7%9A%84%E5%BC%82%E5%B8%B8">#</a> 包装异常时不要抛弃原始的异常</h3><p>捕获标准异常并包装为自定义异常是一个很常见的做法。这样可以添加更为具体的异常信息并能够做针对的异常处理。 在你这样做时，请确保将原始异常设置为原因（注：参考下方代码 NumberFormatException e 中的原始异常 e ）。Exception 类提供了特殊的构造函数方法，它接受一个 Throwable 作为参数。否则，你将会丢失堆栈跟踪和原始异常的消息，这将会使分析导致异常的异常事件变得困难。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">wrapException</span><span class="params">(String input)</span> <span class="keyword">throws</span> MyBusinessException &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MyBusinessException</span>(<span class="string">&quot;A message that describes the error.&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="不要使用异常控制程序的流程"><a href="#不要使用异常控制程序的流程" class="headerlink" title="# 不要使用异常控制程序的流程"></a><a href="#%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%B5%81%E7%A8%8B">#</a> 不要使用异常控制程序的流程</h3><p>不应该使用异常控制应用的执行流程，例如，本应该使用if语句进行条件判断的情况下，你却使用异常处理，这是非常不好的习惯，会严重影响应用的性能。</p><h3 id="不要在finally块中使用return。"><a href="#不要在finally块中使用return。" class="headerlink" title="# 不要在finally块中使用return。"></a><a href="#%E4%B8%8D%E8%A6%81%E5%9C%A8finally%E5%9D%97%E4%B8%AD%E4%BD%BF%E7%94%A8return%E3%80%82">#</a> 不要在finally块中使用return。</h3><p>try块中的return语句执行成功后，并不马上返回，而是继续执行finally块中的语句，如果此处存在return语句，则在此直接返回，无情丢弃掉try块中的返回点。</p><p>如下是一个反例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">checkReturn</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// x等于1，此处不返回</span></span><br><span class="line">        <span class="keyword">return</span> ++x;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 返回的结果是2</span></span><br><span class="line">        <span class="keyword">return</span> ++x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="深入理解异常"><a href="#深入理解异常" class="headerlink" title="# 深入理解异常"></a><a href="#%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%BC%82%E5%B8%B8">#</a> 深入理解异常</h2><p>提示</p><p>我们再深入理解下异常，看下底层实现。</p><h3 id="JVM处理异常的机制？"><a href="#JVM处理异常的机制？" class="headerlink" title="# JVM处理异常的机制？"></a><a href="#jvm%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8%E7%9A%84%E6%9C%BA%E5%88%B6">#</a> JVM处理异常的机制？</h3><p>提到JVM处理异常的机制，就需要提及Exception Table，以下称为异常表。我们暂且不急于介绍异常表，先看一个简单的 Java 处理异常的小例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">simpleTryCatch</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       testNPE();</span><br><span class="line">   &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">       e.printStackTrace();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码是一个很简单的例子，用来捕获处理一个潜在的空指针异常。</p><p>当然如果只是看简简单单的代码，我们很难看出什么高深之处，更没有了今天文章要谈论的内容。</p><p>所以这里我们需要借助一把神兵利器，它就是javap,一个用来拆解class文件的工具，和javac一样由JDK提供。</p><p>然后我们使用javap来分析这段代码（需要先使用javac编译）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//javap -c Main</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">simpleTryCatch</span><span class="params">()</span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: invokestatic  #<span class="number">3</span>                  <span class="comment">// Method testNPE:()V</span></span><br><span class="line">       <span class="number">3</span>: goto          <span class="number">11</span></span><br><span class="line">       <span class="number">6</span>: astore_0</span><br><span class="line">       <span class="number">7</span>: aload_0</span><br><span class="line">       <span class="number">8</span>: invokevirtual #<span class="number">5</span>                  <span class="comment">// Method java/lang/Exception.printStackTrace:()V</span></span><br><span class="line">      <span class="number">11</span>: <span class="keyword">return</span></span><br><span class="line">    Exception table:</span><br><span class="line">       from    to  target type</span><br><span class="line">           <span class="number">0</span>     <span class="number">3</span>     <span class="number">6</span>   Class java/lang/Exception</span><br></pre></td></tr></table></figure><p>看到上面的代码，应该会有会心一笑，因为终于看到了Exception table，也就是我们要研究的异常表。</p><p>异常表中包含了一个或多个异常处理者(Exception Handler)的信息，这些信息包含如下</p><ul><li><strong>from</strong> 可能发生异常的起始点</li><li><strong>to</strong> 可能发生异常的结束点</li><li><strong>target</strong> 上述from和to之前发生异常后的异常处理者的位置</li><li><strong>type</strong> 异常处理者处理的异常的类信息</li></ul><p><strong>那么异常表用在什么时候呢</strong></p><p>答案是异常发生的时候，当一个异常发生时</p><ul><li>1.JVM会在当前出现异常的方法中，查找异常表，是否有合适的处理者来处理</li><li>2.如果当前方法异常表不为空，并且异常符合处理者的from和to节点，并且type也匹配，则JVM调用位于target的调用者来处理。</li><li>3.如果上一条未找到合理的处理者，则继续查找异常表中的剩余条目</li><li>4.如果当前方法的异常表无法处理，则向上查找（弹栈处理）刚刚调用该方法的调用处，并重复上面的操作。</li><li>5.如果所有的栈帧被弹出，仍然没有处理，则抛给当前的Thread，Thread则会终止。</li><li>6.如果当前Thread为最后一个非守护线程，且未处理异常，则会导致JVM终止运行。</li></ul><p>以上就是JVM处理异常的一些机制。</p><p><strong>try catch -finally</strong></p><p>除了简单的try-catch外，我们还常常和finally做结合使用。比如这样的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">simpleTryCatchFinally</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       testNPE();</span><br><span class="line">   &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">       e.printStackTrace();</span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;Finally&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样我们使用javap分析一下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">simpleTryCatchFinally</span><span class="params">()</span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: invokestatic  #<span class="number">3</span>                  <span class="comment">// Method testNPE:()V</span></span><br><span class="line">       <span class="number">3</span>: getstatic     #<span class="number">6</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">       <span class="number">6</span>: ldc           #<span class="number">7</span>                  <span class="comment">// String Finally</span></span><br><span class="line">       <span class="number">8</span>: invokevirtual #<span class="number">8</span>                  <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">      <span class="number">11</span>: goto          <span class="number">41</span></span><br><span class="line">      <span class="number">14</span>: astore_0</span><br><span class="line">      <span class="number">15</span>: aload_0</span><br><span class="line">      <span class="number">16</span>: invokevirtual #<span class="number">5</span>                  <span class="comment">// Method java/lang/Exception.printStackTrace:()V</span></span><br><span class="line">      <span class="number">19</span>: getstatic     #<span class="number">6</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">      <span class="number">22</span>: ldc           #<span class="number">7</span>                  <span class="comment">// String Finally</span></span><br><span class="line">      <span class="number">24</span>: invokevirtual #<span class="number">8</span>                  <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">      <span class="number">27</span>: goto          <span class="number">41</span></span><br><span class="line">      <span class="number">30</span>: astore_1</span><br><span class="line">      <span class="number">31</span>: getstatic     #<span class="number">6</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">      <span class="number">34</span>: ldc           #<span class="number">7</span>                  <span class="comment">// String Finally</span></span><br><span class="line">      <span class="number">36</span>: invokevirtual #<span class="number">8</span>                  <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">      <span class="number">39</span>: aload_1</span><br><span class="line">      <span class="number">40</span>: athrow</span><br><span class="line">      <span class="number">41</span>: <span class="keyword">return</span></span><br><span class="line">    Exception table:</span><br><span class="line">       from    to  target type</span><br><span class="line">           <span class="number">0</span>     <span class="number">3</span>    <span class="number">14</span>   Class java/lang/Exception</span><br><span class="line">           <span class="number">0</span>     <span class="number">3</span>    <span class="number">30</span>   any</span><br><span class="line">          <span class="number">14</span>    <span class="number">19</span>    <span class="number">30</span>   any</span><br></pre></td></tr></table></figure><p>和之前有所不同，这次异常表中，有三条数据，而我们仅仅捕获了一个Exception, 异常表的后两个item的type为any; 上面的三条异常表item的意思为:</p><ul><li>如果0到3之间，发生了Exception类型的异常，调用14位置的异常处理者。</li><li>如果0到3之间，无论发生什么异常，都调用30位置的处理者</li><li>如果14到19之间（即catch部分），不论发生什么异常，都调用30位置的处理者。</li></ul><p>再次分析上面的Java代码，finally里面的部分已经被提取到了try部分和catch部分。我们再次调一下代码来看一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">simpleTryCatchFinally</span><span class="params">()</span>;</span><br><span class="line">    Code:</span><br><span class="line">      <span class="comment">//try 部分提取finally代码，如果没有异常发生，则执行输出finally操作，直至goto到41位置，执行返回操作。  </span></span><br><span class="line"></span><br><span class="line">       <span class="number">0</span>: invokestatic  #<span class="number">3</span>                  <span class="comment">// Method testNPE:()V</span></span><br><span class="line">       <span class="number">3</span>: getstatic     #<span class="number">6</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">       <span class="number">6</span>: ldc           #<span class="number">7</span>                  <span class="comment">// String Finally</span></span><br><span class="line">       <span class="number">8</span>: invokevirtual #<span class="number">8</span>                  <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">      <span class="number">11</span>: goto          <span class="number">41</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//catch部分提取finally代码，如果没有异常发生，则执行输出finally操作，直至执行got到41位置，执行返回操作。</span></span><br><span class="line">      <span class="number">14</span>: astore_0</span><br><span class="line">      <span class="number">15</span>: aload_0</span><br><span class="line">      <span class="number">16</span>: invokevirtual #<span class="number">5</span>                  <span class="comment">// Method java/lang/Exception.printStackTrace:()V</span></span><br><span class="line">      <span class="number">19</span>: getstatic     #<span class="number">6</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">      <span class="number">22</span>: ldc           #<span class="number">7</span>                  <span class="comment">// String Finally</span></span><br><span class="line">      <span class="number">24</span>: invokevirtual #<span class="number">8</span>                  <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">      <span class="number">27</span>: goto          <span class="number">41</span></span><br><span class="line">      <span class="comment">//finally部分的代码如果被调用，有可能是try部分，也有可能是catch部分发生异常。</span></span><br><span class="line">      <span class="number">30</span>: astore_1</span><br><span class="line">      <span class="number">31</span>: getstatic     #<span class="number">6</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">      <span class="number">34</span>: ldc           #<span class="number">7</span>                  <span class="comment">// String Finally</span></span><br><span class="line">      <span class="number">36</span>: invokevirtual #<span class="number">8</span>                  <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">      <span class="number">39</span>: aload_1</span><br><span class="line">      <span class="number">40</span>: athrow     <span class="comment">//如果异常没有被catch捕获，而是到了这里，执行完finally的语句后，仍然要把这个异常抛出去，传递给调用处。</span></span><br><span class="line">      <span class="number">41</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p><strong>Catch先后顺序的问题</strong></p><p>我们在代码中的catch的顺序决定了异常处理者在异常表的位置，所以，越是具体的异常要先处理，否则就会出现下面的问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">misuseCatchException</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       testNPE();</span><br><span class="line">   &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">       t.printStackTrace();</span><br><span class="line">   &#125; <span class="keyword">catch</span> (Exception e) &#123; <span class="comment">//error occurs during compilings with tips Exception Java.lang.Exception has already benn caught.</span></span><br><span class="line">       e.printStackTrace();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码会导致编译失败，因为先捕获Throwable后捕获Exception，会导致后面的catch永远无法被执行。</p><p><strong>Return 和finally的问题</strong></p><p>这算是我们扩展的一个相对比较极端的问题，就是类似这样的代码，既有return，又有finally，那么finally导致会不会执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">tryCatchReturn</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       testNPE();</span><br><span class="line">       <span class="keyword">return</span>  <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">   &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;ERROR&quot;</span>;</span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;tryCatchReturn&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案是finally会执行，那么还是使用上面的方法，我们来看一下为什么finally会执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> java.lang.String <span class="title function_">tryCatchReturn</span><span class="params">()</span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: invokestatic  #<span class="number">3</span>                  <span class="comment">// Method testNPE:()V</span></span><br><span class="line">       <span class="number">3</span>: ldc           #<span class="number">6</span>                  <span class="comment">// String OK</span></span><br><span class="line">       <span class="number">5</span>: astore_0</span><br><span class="line">       <span class="number">6</span>: getstatic     #<span class="number">7</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">       <span class="number">9</span>: ldc           #<span class="number">8</span>                  <span class="comment">// String tryCatchReturn</span></span><br><span class="line">      <span class="number">11</span>: invokevirtual #<span class="number">9</span>                  <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">      <span class="number">14</span>: aload_0</span><br><span class="line">      <span class="number">15</span>: areturn       返回OK字符串，areturn意思为<span class="keyword">return</span> a reference from a method</span><br><span class="line">      <span class="number">16</span>: astore_0</span><br><span class="line">      <span class="number">17</span>: ldc           #<span class="number">10</span>                 <span class="comment">// String ERROR</span></span><br><span class="line">      <span class="number">19</span>: astore_1</span><br><span class="line">      <span class="number">20</span>: getstatic     #<span class="number">7</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">      <span class="number">23</span>: ldc           #<span class="number">8</span>                  <span class="comment">// String tryCatchReturn</span></span><br><span class="line">      <span class="number">25</span>: invokevirtual #<span class="number">9</span>                  <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">      <span class="number">28</span>: aload_1</span><br><span class="line">      <span class="number">29</span>: areturn  <span class="comment">//返回ERROR字符串</span></span><br><span class="line">      <span class="number">30</span>: astore_2</span><br><span class="line">      <span class="number">31</span>: getstatic     #<span class="number">7</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">      <span class="number">34</span>: ldc           #<span class="number">8</span>                  <span class="comment">// String tryCatchReturn</span></span><br><span class="line">      <span class="number">36</span>: invokevirtual #<span class="number">9</span>                  <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">      <span class="number">39</span>: aload_2</span><br><span class="line">      <span class="number">40</span>: athrow  如果<span class="keyword">catch</span>有未处理的异常，抛出去。</span><br></pre></td></tr></table></figure><h3 id="异常是否耗时？为什么会耗时？"><a href="#异常是否耗时？为什么会耗时？" class="headerlink" title="# 异常是否耗时？为什么会耗时？"></a><a href="#%E5%BC%82%E5%B8%B8%E6%98%AF%E5%90%A6%E8%80%97%E6%97%B6-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%80%97%E6%97%B6">#</a> 异常是否耗时？为什么会耗时？</h3><p>说用异常慢，首先来看看异常慢在哪里？有多慢？下面的测试用例简单的测试了建立对象、建立异常对象、抛出并接住异常对象三者的耗时对比：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionTest</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> testTimes;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ExceptionTest</span><span class="params">(<span class="type">int</span> testTimes)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.testTimes = testTimes;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">newObject</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="type">long</span> <span class="variable">l</span> <span class="operator">=</span> System.nanoTime();  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; testTimes; i++) &#123;  </span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Object</span>();  </span><br><span class="line">        &#125;  </span><br><span class="line">        System.out.println(<span class="string">&quot;建立对象：&quot;</span> + (System.nanoTime() - l));  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">newException</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="type">long</span> <span class="variable">l</span> <span class="operator">=</span> System.nanoTime();  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; testTimes; i++) &#123;  </span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Exception</span>();  </span><br><span class="line">        &#125;  </span><br><span class="line">        System.out.println(<span class="string">&quot;建立异常对象：&quot;</span> + (System.nanoTime() - l));  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">catchException</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="type">long</span> <span class="variable">l</span> <span class="operator">=</span> System.nanoTime();  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; testTimes; i++) &#123;  </span><br><span class="line">            <span class="keyword">try</span> &#123;  </span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>();  </span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        System.out.println(<span class="string">&quot;建立、抛出并接住异常对象：&quot;</span> + (System.nanoTime() - l));  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="type">ExceptionTest</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExceptionTest</span>(<span class="number">10000</span>);  </span><br><span class="line">        test.newObject();  </span><br><span class="line">        test.newException();  </span><br><span class="line">        test.catchException();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">建立对象：<span class="number">575817</span>  </span><br><span class="line">建立异常对象：<span class="number">9589080</span>  </span><br><span class="line">建立、抛出并接住异常对象：<span class="number">47394475</span>  </span><br></pre></td></tr></table></figure><p>建立一个异常对象，是建立一个普通Object耗时的约20倍（实际上差距会比这个数字更大一些，因为循环也占用了时间，追求精确的读者可以再测一下空循环的耗时然后在对比前减掉这部分），而抛出、接住一个异常对象，所花费时间大约是建立异常对象的4倍。</p><p>那占用时间的“大头”：抛出、接住异常，系统到底做了什么事情？请参考这篇文章：</p><ul><li><a href="https://www.iteye.com/blog/icyfenix-857722">https://www.iteye.com/blog/icyfenix-857722</a></li></ul><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="# 参考文章"></a><a href="#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0">#</a> 参考文章</h2><ul><li><a href="https://blog.csdn.net/MacWx/article/details/90204111">https://blog.csdn.net/MacWx/article/details/90204111</a></li><li><a href="https://blog.csdn.net/hguisu/article/details/6155636">https://blog.csdn.net/hguisu/article/details/6155636</a></li><li><a href="https://blog.csdn.net/ThinkWon/article/details/101681073">https://blog.csdn.net/ThinkWon/article/details/101681073</a></li><li><a href="https://www.cnblogs.com/skywang12345/p/3544287.html">https://www.cnblogs.com/skywang12345/p/3544287.html</a></li><li><a href="https://www.codercto.com/a/33350.html">https://www.codercto.com/a/33350.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 基础 - 注解机制详解</title>
      <link href="/posts/fdfa8e87.html"/>
      <url>/posts/fdfa8e87.html</url>
      
        <content type="html"><![CDATA[<p>Java 基础 - 注解机制详解</p><span id="more"></span><h2 id="注解基础"><a href="#注解基础" class="headerlink" title="注解基础"></a>注解基础</h2><p>注解是 JDK1.5 版本开始引入的一个特性，用于对代码进行说明，可以对包、类、接口、字段、方法参数、局部变量等进行注解。它主要的作用有以下四方面：</p><ul><li>生成文档，通过代码里标识的元数据生成 javadoc 文档。</li><li>编译检查，通过代码里标识的元数据让编译器在编译期间进行检查验证。</li><li>编译时动态处理，编译时通过代码里标识的元数据动态处理，例如动态生成代码。</li><li>运行时动态处理，运行时通过代码里标识的元数据动态处理，例如使用反射注入实例。</li></ul><p>这么来说是比较抽象的，我们具体看下注解的常见分类：</p><ul><li><strong>Java 自带的标准注解</strong>，包括<code>@Override</code>、<code>@Deprecated</code>和<code>@SuppressWarnings</code>，分别用于标明重写某个方法、标明某个类或方法过时、标明要忽略的警告，用这些注解标明后编译器就会进行检查。</li><li><strong>元注解</strong>，元注解是用于定义注解的注解，包括<code>@Retention</code>、<code>@Target</code>、<code>@Inherited</code>、<code>@Documented</code>，<code>@Retention</code>用于标明注解被保留的阶段，<code>@Target</code>用于标明注解使用的范围，<code>@Inherited</code>用于标明注解可继承，<code>@Documented</code>用于标明是否生成 javadoc 文档。</li><li><strong>自定义注解</strong>，可以根据自己的需求定义注解，并可用元注解对自定义注解进行注解。</li></ul><p>接下来我们通过这个分类角度来理解注解。</p><h3 id="Java-内置注解"><a href="#Java-内置注解" class="headerlink" title="# Java 内置注解"></a><a href="#java%E5%86%85%E7%BD%AE%E6%B3%A8%E8%A7%A3">#</a> Java 内置注解</h3><p>我们从最为常见的 Java 内置的注解开始说起，先看下下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 重载父类的test方法</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 被弃用的方法</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">oldMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 忽略告警</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;rawtypes&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List <span class="title function_">processList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java 1.5 开始自带的标准注解，包括<code>@Override</code>、<code>@Deprecated</code>和<code>@SuppressWarnings</code>：</p><ul><li><code>@Override</code>：表示当前的方法定义将覆盖父类中的方法</li><li><code>@Deprecated</code>：表示代码被弃用，如果使用了被@Deprecated 注解的代码则编译器将发出警告</li><li><code>@SuppressWarnings</code>：表示关闭编译器警告信息</li></ul><p>我们再具体看下这几个内置注解，同时通过这几个内置注解中的元注解的定义来引出元注解。</p><h4 id="内置注解-Override"><a href="#内置注解-Override" class="headerlink" title="# 内置注解 - @Override"></a><a href="#%E5%86%85%E7%BD%AE%E6%B3%A8%E8%A7%A3-override">#</a> 内置注解 - @Override</h4><p>我们先来看一下这个注解类型的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Override &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从它的定义我们可以看到，这个注解可以被用来修饰方法，并且它只在编译时有效，在编译后的 class 文件中便不再存在。这个注解的作用我们大家都不陌生，那就是告诉编译器被修饰的方法是重写的父类的中的相同签名的方法，编译器会对此做出检查，若发现父类中不存在这个方法或是存在的方法签名不同，则会报错。</p><h4 id="内置注解-Deprecated"><a href="#内置注解-Deprecated" class="headerlink" title="# 内置注解 - @Deprecated"></a><a href="#%E5%86%85%E7%BD%AE%E6%B3%A8%E8%A7%A3-deprecated">#</a> 内置注解 - @Deprecated</h4><p>这个注解的定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(value=&#123;CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Deprecated &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从它的定义我们可以知道，它会被文档化，能够保留到运行时，能够修饰构造方法、属性、局部变量、方法、包、参数、类型。这个注解的作用是告诉编译器被修饰的程序元素已被“废弃”，不再建议用户使用。</p><h4 id="内置注解-SuppressWarnings"><a href="#内置注解-SuppressWarnings" class="headerlink" title="# 内置注解 - @SuppressWarnings"></a><a href="#%E5%86%85%E7%BD%AE%E6%B3%A8%E8%A7%A3-suppresswarnings">#</a> 内置注解 - @SuppressWarnings</h4><p>这个注解我们也比较常用到，先来看下它的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SuppressWarnings &#123;</span><br><span class="line">    String[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它能够修饰的程序元素包括类型、属性、方法、参数、构造器、局部变量，只能存活在源码时，取值为 String[]。它的作用是告诉编译器忽略指定的警告信息，它可以取的值如下所示：</p><table><thead><tr><th>参数</th><th>作用</th><th>原描述</th></tr></thead><tbody><tr><td>all</td><td>抑制所有警告</td><td>to suppress all warnings</td></tr><tr><td>boxing</td><td>抑制装箱、拆箱操作时候的警告</td><td>to suppress warnings relative to boxing/unboxing operations</td></tr><tr><td>cast</td><td>抑制映射相关的警告</td><td>to suppress warnings relative to cast operations</td></tr><tr><td>dep-ann</td><td>抑制启用注释的警告</td><td>to suppress warnings relative to deprecated annotation</td></tr><tr><td>deprecation</td><td>抑制过期方法警告</td><td>to suppress warnings relative to deprecation</td></tr><tr><td>fallthrough</td><td>抑制确在 switch 中缺失 breaks 的警告</td><td>to suppress warnings relative to missing breaks in switch statements</td></tr><tr><td>finally</td><td>抑制 finally 模块没有返回的警告</td><td>to suppress warnings relative to finally block that don’t return</td></tr><tr><td>hiding</td><td>抑制与隐藏变数的区域变数相关的警告</td><td>to suppress warnings relative to locals that hide variable（）</td></tr><tr><td>incomplete-switch</td><td>忽略没有完整的 switch 语句</td><td>to suppress warnings relative to missing entries in a switch statement (enum case)</td></tr><tr><td>nls</td><td>忽略非 nls 格式的字符</td><td>to suppress warnings relative to non-nls string literals</td></tr><tr><td>null</td><td>忽略对 null 的操作</td><td>to suppress warnings relative to null analysis</td></tr><tr><td>rawtype</td><td>使用 generics 时忽略没有指定相应的类型</td><td>to suppress warnings relative to un-specific types when using</td></tr><tr><td>restriction</td><td>抑制与使用不建议或禁止参照相关的警告</td><td>to suppress warnings relative to usage of discouraged or</td></tr><tr><td>serial</td><td>忽略在 serializable 类中没有声明 serialVersionUID 变量</td><td>to suppress warnings relative to missing serialVersionUID field for a serializable class</td></tr><tr><td>static-access</td><td>抑制不正确的静态访问方式警告</td><td>to suppress warnings relative to incorrect static access</td></tr><tr><td>synthetic-access</td><td>抑制子类没有按最优方法访问内部类的警告</td><td>to suppress warnings relative to unoptimized access from inner classes</td></tr><tr><td>unchecked</td><td>抑制没有进行类型检查操作的警告</td><td>to suppress warnings relative to unchecked operations</td></tr><tr><td>unqualified-field-access</td><td>抑制没有权限访问的域的警告</td><td>to suppress warnings relative to field access unqualified</td></tr><tr><td>unused</td><td>抑制没被使用过的代码的警告</td><td>to suppress warnings relative to unused code</td></tr></tbody></table><h3 id="元注解"><a href="#元注解" class="headerlink" title="# 元注解"></a><a href="#%E5%85%83%E6%B3%A8%E8%A7%A3">#</a> 元注解</h3><p>上述内置注解的定义中使用了一些元注解（注解类型进行注解的注解类），在 JDK 1.5 中提供了 4 个标准的元注解：<code>@Target</code>，<code>@Retention</code>，<code>@Documented</code>，<code>@Inherited</code>, 在 JDK 1.8 中提供了两个元注解 <code>@Repeatable</code>和<code>@Native</code>。</p><h4 id="元注解-Target"><a href="#元注解-Target" class="headerlink" title="# 元注解 - @Target"></a><a href="#%E5%85%83%E6%B3%A8%E8%A7%A3-target">#</a> 元注解 - @Target</h4><blockquote><p>Target 注解的作用是：描述注解的使用范围（即：被修饰的注解可以用在什么地方） 。</p></blockquote><p>Target 注解用来说明那些被它所注解的注解类可修饰的对象范围：注解可以用于修饰 packages、types（类、接口、枚举、注解类）、类成员（方法、构造方法、成员变量、枚举值）、方法参数和本地变量（如循环变量、catch 参数），在定义注解类时使用了@Target 能够更加清晰的知道它能够被用来修饰哪些对象，它的取值范围定义在 ElementType 枚举中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">ElementType</span> &#123;</span><br><span class="line"></span><br><span class="line">    TYPE, <span class="comment">// 类、接口、枚举类</span></span><br><span class="line"></span><br><span class="line">    FIELD, <span class="comment">// 成员变量（包括：枚举常量）</span></span><br><span class="line"></span><br><span class="line">    METHOD, <span class="comment">// 成员方法</span></span><br><span class="line"></span><br><span class="line">    PARAMETER, <span class="comment">// 方法参数</span></span><br><span class="line"></span><br><span class="line">    CONSTRUCTOR, <span class="comment">// 构造方法</span></span><br><span class="line"></span><br><span class="line">    LOCAL_VARIABLE, <span class="comment">// 局部变量</span></span><br><span class="line"></span><br><span class="line">    ANNOTATION_TYPE, <span class="comment">// 注解类</span></span><br><span class="line"></span><br><span class="line">    PACKAGE, <span class="comment">// 可用于修饰：包</span></span><br><span class="line"></span><br><span class="line">    TYPE_PARAMETER, <span class="comment">// 类型参数，JDK 1.8 新增</span></span><br><span class="line"></span><br><span class="line">    TYPE_USE <span class="comment">// 使用类型的任何地方，JDK 1.8 新增</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="元注解-Retention-amp-RetentionTarget"><a href="#元注解-Retention-amp-RetentionTarget" class="headerlink" title="# 元注解 - @Retention &amp; @RetentionTarget"></a><a href="#%E5%85%83%E6%B3%A8%E8%A7%A3-retention-retentiontarget">#</a> 元注解 - @Retention &amp; @RetentionTarget</h4><blockquote><p>Reteniton 注解的作用是：描述注解保留的时间范围（即：被描述的注解在它所修饰的类中可以被保留到何时） 。</p></blockquote><p>Reteniton 注解用来限定那些被它所注解的注解类在注解到其他类上以后，可被保留到何时，一共有三种策略，定义在 RetentionPolicy 枚举中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">RetentionPolicy</span> &#123;</span><br><span class="line"></span><br><span class="line">    SOURCE,    <span class="comment">// 源文件保留</span></span><br><span class="line">    CLASS,       <span class="comment">// 编译期保留，默认值</span></span><br><span class="line">    RUNTIME   <span class="comment">// 运行期保留，可通过反射去获取注解信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了验证应用了这三种策略的注解类有何区别，分别使用三种策略各定义一个注解类做测试。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SourcePolicy &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.CLASS)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ClassPolicy &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RuntimePolicy &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用定义好的三个注解类分别去注解一个方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RetentionTest</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SourcePolicy</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sourcePolicy</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ClassPolicy</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">classPolicy</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RuntimePolicy</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">runtimePolicy</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过执行 <code>javap -verbose RetentionTest</code>命令获取到的 RetentionTest 的 class 字节码内容如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> retention.RetentionTest();</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">3</span>: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sourcePolicy</span><span class="params">()</span>;</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">0</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">7</span>: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">classPolicy</span><span class="params">()</span>;</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">0</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">11</span>: <span class="number">0</span></span><br><span class="line">    RuntimeInvisibleAnnotations:</span><br><span class="line">      <span class="number">0</span>: #<span class="number">11</span>()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">runtimePolicy</span><span class="params">()</span>;</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">0</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">15</span>: <span class="number">0</span></span><br><span class="line">    RuntimeVisibleAnnotations:</span><br><span class="line">      <span class="number">0</span>: #<span class="number">14</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从 RetentionTest 的字节码内容我们可以得出以下两点结论：</p><ul><li>编译器并没有记录下 sourcePolicy() 方法的注解信息；</li><li>编译器分别使用了 <code>RuntimeInvisibleAnnotations</code> 和 <code>RuntimeVisibleAnnotations</code> 属性去记录了<code>classPolicy()</code>方法 和 <code>runtimePolicy()</code>方法 的注解信息；</li></ul><h4 id="元注解-Documented"><a href="#元注解-Documented" class="headerlink" title="# 元注解 - @Documented"></a><a href="#%E5%85%83%E6%B3%A8%E8%A7%A3-documented">#</a> 元注解 - @Documented</h4><blockquote><p>Documented 注解的作用是：描述在使用 javadoc 工具为类生成帮助文档时是否要保留其注解信息。</p></blockquote><p>以下代码在使用 Javadoc 工具可以生成<code>@TestDocAnnotation</code>注解信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.Documented;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TestDocAnnotation &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;default&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@TestDocAnnotation(&quot;myMethodDoc&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDoc</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="元注解-Inherited"><a href="#元注解-Inherited" class="headerlink" title="# 元注解 - @Inherited"></a><a href="#%E5%85%83%E6%B3%A8%E8%A7%A3-inherited">#</a> 元注解 - @Inherited</h4><blockquote><p>Inherited 注解的作用：被它修饰的 Annotation 将具有继承性。如果某个类使用了被@Inherited 修饰的 Annotation，则其子类将自动具有该注解。</p></blockquote><p>我们来测试下这个注解：</p><ul><li>定义<code>@Inherited</code>注解：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TestInheritedAnnotation &#123;</span><br><span class="line">    String [] values();</span><br><span class="line">    <span class="type">int</span> <span class="title function_">number</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用这个注解</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TestInheritedAnnotation(values = &#123;&quot;value&quot;&#125;, number = 10)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Student.class;</span><br><span class="line">        Annotation[] annotations = clazz.getAnnotations();</span><br><span class="line">        <span class="keyword">for</span> (Annotation annotation : annotations) &#123;</span><br><span class="line">            System.out.println(annotation.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>输出</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xxxxxxx.TestInheritedAnnotation(values=[value], number=<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>即使 Student 类没有显示地被注解<code>@TestInheritedAnnotation</code>，但是它的父类 Person 被注解，而且<code>@TestInheritedAnnotation</code>被<code>@Inherited</code>注解，因此 Student 类自动有了该注解。</p><h4 id="元注解-Repeatable-Java8"><a href="#元注解-Repeatable-Java8" class="headerlink" title="# 元注解 - @Repeatable (Java8)"></a><a href="#%E5%85%83%E6%B3%A8%E8%A7%A3-repeatable-java8">#</a> 元注解 - @Repeatable (Java8)</h4><p><code>@Repeatable</code>请参考<a href="">Java 8 - 重复注解</a></p><h4 id="元注解-Native-Java8"><a href="#元注解-Native-Java8" class="headerlink" title="# 元注解 - @Native (Java8)"></a><a href="#%E5%85%83%E6%B3%A8%E8%A7%A3-native-java8">#</a> 元注解 - @Native (Java8)</h4><p>使用 @Native 注解修饰成员变量，则表示这个变量可以被本地代码引用，常常被代码生成工具使用。对于 @Native 注解不常使用，了解即可</p><h3 id="注解与反射接口"><a href="#注解与反射接口" class="headerlink" title="# 注解与反射接口"></a><a href="#%E6%B3%A8%E8%A7%A3%E4%B8%8E%E5%8F%8D%E5%B0%84%E6%8E%A5%E5%8F%A3">#</a> 注解与反射接口</h3><blockquote><p>定义注解后，如何获取注解中的内容呢？反射包 java.lang.reflect 下的 AnnotatedElement 接口提供这些方法。这里注意：只有注解被定义为 RUNTIME 后，该注解才能是运行时可见，当 class 文件被装载时被保存在 class 文件中的 Annotation 才会被虚拟机读取。</p></blockquote><p>AnnotatedElement 接口是所有程序元素（Class、Method 和 Constructor）的父接口，所以程序通过反射获取了某个类的 AnnotatedElement 对象之后，程序就可以调用该对象的方法来访问 Annotation 信息。我们看下具体的先关接口</p><ul><li><code>boolean isAnnotationPresent(Class&lt;?extends Annotation&gt; annotationClass)</code></li></ul><p>判断该程序元素上是否包含指定类型的注解，存在则返回 true，否则返回 false。注意：此方法会忽略注解对应的注解容器。</p><ul><li><code>&lt;T extends Annotation&gt; T getAnnotation(Class&lt;T&gt; annotationClass)</code></li></ul><p>返回该程序元素上存在的、指定类型的注解，如果该类型注解不存在，则返回 null。</p><ul><li><code>Annotation[] getAnnotations()</code></li></ul><p>返回该程序元素上存在的所有注解，若没有注解，返回长度为 0 的数组。</p><ul><li><code>&lt;T extends Annotation&gt; T[] getAnnotationsByType(Class&lt;T&gt; annotationClass)</code></li></ul><p>返回该程序元素上存在的、指定类型的注解数组。没有注解对应类型的注解时，返回长度为 0 的数组。该方法的调用者可以随意修改返回的数组，而不会对其他调用者返回的数组产生任何影响。<code>getAnnotationsByType</code>方法与 <code>getAnnotation</code>的区别在于，<code>getAnnotationsByType</code>会检测注解对应的重复注解容器。若程序元素为类，当前类上找不到注解，且该注解为可继承的，则会去父类上检测对应的注解。</p><ul><li><code>&lt;T extends Annotation&gt; T getDeclaredAnnotation(Class&lt;T&gt; annotationClass)</code></li></ul><p>返回直接存在于此元素上的所有注解。与此接口中的其他方法不同，该方法将忽略继承的注释。如果没有注释直接存在于此元素上，则返回 null</p><ul><li><code>&lt;T extends Annotation&gt; T[] getDeclaredAnnotationsByType(Class&lt;T&gt; annotationClass)</code></li></ul><p>返回直接存在于此元素上的所有注解。与此接口中的其他方法不同，该方法将忽略继承的注释</p><ul><li><code>Annotation[] getDeclaredAnnotations()</code></li></ul><p>返回直接存在于此元素上的所有注解及注解对应的重复注解容器。与此接口中的其他方法不同，该方法将忽略继承的注解。如果没有注释直接存在于此元素上，则返回长度为零的一个数组。该方法的调用者可以随意修改返回的数组，而不会对其他调用者返回的数组产生任何影响。</p><h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="# 自定义注解"></a><a href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3">#</a> 自定义注解</h3><blockquote><p>当我们理解了内置注解, 元注解和获取注解的反射接口后，我们便可以开始自定义注解了。这个例子我把上述的知识点全部融入进来, 代码很简单：</p></blockquote><ul><li>定义自己的注解</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.pdai.java.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyMethodAnnotation &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">title</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">description</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用注解</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.pdai.java.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Annotation;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestMethodAnnotation</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@MyMethodAnnotation(title = &quot;toStringMethod&quot;, description = &quot;override toString method&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Override toString method&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="meta">@MyMethodAnnotation(title = &quot;old static method&quot;, description = &quot;deprecated old static method&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">oldMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;old method, don&#x27;t use it.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;deprecation&quot;&#125;)</span></span><br><span class="line">    <span class="meta">@MyMethodAnnotation(title = &quot;test method&quot;, description = &quot;suppress warning static method&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">genericsTest</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        <span class="type">List</span> <span class="variable">l</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        l.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        oldMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>用反射接口获取注解信息</li></ul><p>在 TestMethodAnnotation 中添加 Main 方法进行测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取所有methods</span></span><br><span class="line">        Method[] methods = TestMethodAnnotation.class.getClassLoader()</span><br><span class="line">                .loadClass((<span class="string">&quot;com.pdai.java.annotation.TestMethodAnnotation&quot;</span>))</span><br><span class="line">                .getMethods();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">            <span class="comment">// 方法上是否有MyMethodAnnotation注解</span></span><br><span class="line">            <span class="keyword">if</span> (method.isAnnotationPresent(MyMethodAnnotation.class)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 获取并遍历方法上的所有注解</span></span><br><span class="line">                    <span class="keyword">for</span> (Annotation anno : method.getDeclaredAnnotations()) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;Annotation in Method &#x27;&quot;</span></span><br><span class="line">                                + method + <span class="string">&quot;&#x27; : &quot;</span> + anno);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 获取MyMethodAnnotation对象信息</span></span><br><span class="line">                    <span class="type">MyMethodAnnotation</span> <span class="variable">methodAnno</span> <span class="operator">=</span> method</span><br><span class="line">                            .getAnnotation(MyMethodAnnotation.class);</span><br><span class="line"></span><br><span class="line">                    System.out.println(methodAnno.title());</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                    ex.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SecurityException | ClassNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试的输出</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Annotation in Method <span class="string">&#x27;public static void com.pdai.java.annotation.TestMethodAnnotation.oldMethod()&#x27;</span> : <span class="meta">@java</span>.lang.Deprecated()</span><br><span class="line">Annotation in Method <span class="string">&#x27;public static void com.pdai.java.annotation.TestMethodAnnotation.oldMethod()&#x27;</span> : <span class="meta">@com</span>.pdai.java.annotation.MyMethodAnnotation(title=old <span class="keyword">static</span> method, description=deprecated old <span class="keyword">static</span> method)</span><br><span class="line">old <span class="keyword">static</span> method</span><br><span class="line">Annotation in Method <span class="string">&#x27;public static void com.pdai.java.annotation.TestMethodAnnotation.genericsTest() throws java.io.FileNotFoundException&#x27;</span> : <span class="meta">@com</span>.pdai.java.annotation.MyMethodAnnotation(title=test method, description=suppress warning <span class="keyword">static</span> method)</span><br><span class="line">test method</span><br><span class="line">Annotation in Method <span class="string">&#x27;public java.lang.String com.pdai.java.annotation.TestMethodAnnotation.toString()&#x27;</span> : <span class="meta">@com</span>.pdai.java.annotation.MyMethodAnnotation(title=toStringMethod, description=override toString method)</span><br><span class="line">toStringMethod</span><br></pre></td></tr></table></figure><h2 id="深入理解注解"><a href="#深入理解注解" class="headerlink" title="# 深入理解注解"></a><a href="#%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E6%B3%A8%E8%A7%A3">#</a> 深入理解注解</h2><p>提示</p><p>接下来，我们从其它角度深入理解注解</p><h3 id="Java8-提供了哪些新的注解？"><a href="#Java8-提供了哪些新的注解？" class="headerlink" title="# Java8 提供了哪些新的注解？"></a><a href="#java8%E6%8F%90%E4%BE%9B%E4%BA%86%E5%93%AA%E4%BA%9B%E6%96%B0%E7%9A%84%E6%B3%A8%E8%A7%A3">#</a> Java8 提供了哪些新的注解？</h3><ul><li><code>@Repeatable</code></li></ul><p>请参考<a href="">Java 8 - 重复注解</a></p><ul><li><code>ElementType.TYPE_USE</code></li></ul><p>请参考<a href="">Java 8 - 类型注解</a></p><ul><li><code>ElementType.TYPE_PARAMETER</code></li></ul><p><code>ElementType.TYPE_USE</code>(此类型包括类型声明和类型参数声明，是为了方便设计者进行类型检查)包含了<code>ElementType.TYPE</code>(类、接口（包括注解类型）和枚举的声明)和<code>ElementType.TYPE_PARAMETER</code>(类型参数声明), 不妨再看个例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义ElementType.TYPE_PARAMETER注解</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE_PARAMETER)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyNotEmpty &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义ElementType.TYPE_USE注解</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE_USE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyNotNull &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TypeParameterAndTypeUseAnnotation</span>&lt;<span class="meta">@MyNotEmpty</span> T&gt;&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//使用TYPE_PARAMETER类型，会编译不通过</span></span><br><span class="line"><span class="comment">//public @MyNotEmpty T test(@MyNotEmpty T a)&#123;</span></span><br><span class="line"><span class="comment">//new ArrayList&lt;@MyNotEmpty String&gt;();</span></span><br><span class="line"><span class="comment">//return a;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//使用TYPE_USE类型，编译通过</span></span><br><span class="line">  <span class="keyword">public</span> <span class="meta">@MyNotNull</span> T <span class="title function_">test2</span><span class="params">(<span class="meta">@MyNotNull</span> T a)</span>&#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;<span class="meta">@MyNotNull</span> String&gt;();</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注解支持继承吗？"><a href="#注解支持继承吗？" class="headerlink" title="# 注解支持继承吗？"></a><a href="#%E6%B3%A8%E8%A7%A3%E6%94%AF%E6%8C%81%E7%BB%A7%E6%89%BF%E5%90%97">#</a> 注解支持继承吗？</h3><blockquote><p>注解是不支持继承的</p></blockquote><p>不能使用关键字 extends 来继承某个@interface，但注解在编译后，编译器会自动继承 java.lang.annotation.Annotation 接口.</p><p>虽然反编译后发现注解继承了 Annotation 接口，请记住，即使 Java 的接口可以实现多继承，但定义注解时依然无法使用 extends 关键字继承@interface。</p><p>区别于注解的继承，被注解的子类继承父类注解可以用@Inherited： 如果某个类使用了被@Inherited 修饰的 Annotation，则其子类将自动具有该注解。</p><h3 id="注解实现的原理？"><a href="#注解实现的原理？" class="headerlink" title="# 注解实现的原理？"></a><a href="#%E6%B3%A8%E8%A7%A3%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8E%9F%E7%90%86">#</a> 注解实现的原理？</h3><blockquote><p>网上很多标注解的原理文章根本没有说到点子上。</p></blockquote><p>这里推荐你两篇文章：</p><ul><li><a href="https://blog.csdn.net/qq_20009015/article/details/106038023">https://blog.csdn.net/qq_20009015/article/details/106038023</a></li><li><a href="https://www.race604.com/annotation-processing/">https://www.race604.com/annotation-processing/</a></li></ul><h2 id="注解的应用场景"><a href="#注解的应用场景" class="headerlink" title="# 注解的应用场景"></a><a href="#%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">#</a> 注解的应用场景</h2><p>提示</p><p>最后我们再看看实际开发中注解的一些应用场景。@pdai</p><h3 id="配置化到注解化-框架的演进"><a href="#配置化到注解化-框架的演进" class="headerlink" title="# 配置化到注解化 - 框架的演进"></a><a href="#%E9%85%8D%E7%BD%AE%E5%8C%96%E5%88%B0%E6%B3%A8%E8%A7%A3%E5%8C%96-%E6%A1%86%E6%9E%B6%E7%9A%84%E6%BC%94%E8%BF%9B">#</a> 配置化到注解化 - 框架的演进</h3><p>Spring 框架 配置化到注解化的转变。</p><h3 id="继承实现到注解实现-Junit3-到-Junit4"><a href="#继承实现到注解实现-Junit3-到-Junit4" class="headerlink" title="# 继承实现到注解实现 - Junit3 到 Junit4"></a><a href="#%E7%BB%A7%E6%89%BF%E5%AE%9E%E7%8E%B0%E5%88%B0%E6%B3%A8%E8%A7%A3%E5%AE%9E%E7%8E%B0-junit3%E5%88%B0junit4">#</a> 继承实现到注解实现 - Junit3 到 Junit4</h3><blockquote><p>一个模块的封装大多数人都是通过继承和组合等模式来实现的，但是如果结合注解将可以极大程度提高实现的优雅度（降低耦合度）。而 Junit3 到 Junit4 的演化就是最好的一个例子。</p></blockquote><ul><li>被测试类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span>&#123;</span><br><span class="line"> System.out.println(<span class="string">&quot;hello....&quot;</span>);</span><br><span class="line"> <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NumberFormatException</span>();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayWorld</span><span class="params">()</span>&#123;</span><br><span class="line"> System.out.println(<span class="string">&quot;world....&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> String <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="string">&quot;hello world!&quot;</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Junit 3 实现 UT</li></ul><p>通过继承 TestCase 来实现，初始化是通过 Override 父类方法来进行，测试方式通过 test 的前缀方法获取。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorldTest</span> <span class="keyword">extends</span> <span class="title class_">TestCase</span>&#123;</span><br><span class="line"> <span class="keyword">private</span> HelloWorld hw;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"> <span class="built_in">super</span>.setUp();</span><br><span class="line"> hw=<span class="keyword">new</span> <span class="title class_">HelloWorld</span>();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//1.测试没有返回值</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testHello</span><span class="params">()</span>&#123;</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line"> hw.sayHello();</span><br><span class="line"> &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"> System.out.println(<span class="string">&quot;发生异常.....&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testWorld</span><span class="params">()</span>&#123;</span><br><span class="line"> hw.sayWorld();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//2.测试有返回值的方法</span></span><br><span class="line"> <span class="comment">// 返回字符串</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSay</span><span class="params">()</span>&#123;</span><br><span class="line"> assertEquals(<span class="string">&quot;测试失败&quot;</span>, hw.say(), <span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//返回对象</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testObj</span><span class="params">()</span>&#123;</span><br><span class="line"> assertNull(<span class="string">&quot;测试对象不为空&quot;</span>, <span class="literal">null</span>);</span><br><span class="line"> assertNotNull(<span class="string">&quot;测试对象为空&quot;</span>,<span class="keyword">new</span> <span class="title class_">String</span>());</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">tearDown</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"> <span class="built_in">super</span>.tearDown();</span><br><span class="line"> hw=<span class="literal">null</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Junit 4 实现 UT</li></ul><p>通过定义@Before，@Test，@After 等等注解来实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorldTest</span> &#123;</span><br><span class="line"> <span class="keyword">private</span> HelloWorld hw;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Before</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span> &#123;</span><br><span class="line"> hw = <span class="keyword">new</span> <span class="title class_">HelloWorld</span>();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Test(expected=NumberFormatException.class)</span></span><br><span class="line"> <span class="comment">// 1.测试没有返回值,有别于junit3的使用，更加方便</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testHello</span><span class="params">()</span> &#123;</span><br><span class="line"> hw.sayHello();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="meta">@Test</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testWorld</span><span class="params">()</span> &#123;</span><br><span class="line"> hw.sayWorld();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Test</span></span><br><span class="line"> <span class="comment">// 2.测试有返回值的方法</span></span><br><span class="line"> <span class="comment">// 返回字符串</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSay</span><span class="params">()</span> &#123;</span><br><span class="line"> assertEquals(<span class="string">&quot;测试失败&quot;</span>, hw.say(), <span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Test</span></span><br><span class="line"> <span class="comment">// 返回对象</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testObj</span><span class="params">()</span> &#123;</span><br><span class="line"> assertNull(<span class="string">&quot;测试对象不为空&quot;</span>, <span class="literal">null</span>);</span><br><span class="line"> assertNotNull(<span class="string">&quot;测试对象为空&quot;</span>, <span class="keyword">new</span> <span class="title class_">String</span>());</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@After</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tearDown</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"> hw = <span class="literal">null</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们发现通过注解的方式，我们实现单元测试时将更为优雅。如果你还期望了解 Junit4 是如何实现运行的呢？可以看这篇文章：<a href="https://blog.csdn.net/weixin_34043301/article/details/91799261">JUnit4 源码分析运行原理在新窗口打开</a>。</p><h3 id="自定义注解和-AOP-通过切面实现解耦"><a href="#自定义注解和-AOP-通过切面实现解耦" class="headerlink" title="# 自定义注解和 AOP - 通过切面实现解耦"></a><a href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%E5%92%8Caop-%E9%80%9A%E8%BF%87%E5%88%87%E9%9D%A2%E5%AE%9E%E7%8E%B0%E8%A7%A3%E8%80%A6">#</a> 自定义注解和 AOP - 通过切面实现解耦</h3><blockquote><p>最为常见的就是使用 Spring AOP 切面实现<strong>统一的操作日志管理</strong>，我这里找了一个开源项目中的例子（只展示主要代码），给你展示下如何通过注解实现解耦的。</p></blockquote><ul><li>自定义 Log 注解</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123; ElementType.PARAMETER, ElementType.METHOD &#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Log &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模块</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">title</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> BusinessType <span class="title function_">businessType</span><span class="params">()</span> <span class="keyword">default</span> BusinessType.OTHER;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 操作人类别</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> OperatorType <span class="title function_">operatorType</span><span class="params">()</span> <span class="keyword">default</span> OperatorType.MANAGE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否保存请求的参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSaveRequestData</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>实现日志的切面, 对自定义注解 Log 作切点进行拦截</li></ul><p>即对注解了@Log 的方法进行切点拦截，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogAspect</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(LogAspect.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置织入点 - 自定义注解的包路径</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;@annotation(com.xxx.aspectj.lang.annotation.Log)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logPointCut</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理完请求后执行</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> joinPoint 切点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@AfterReturning(pointcut = &quot;logPointCut()&quot;, returning = &quot;jsonResult&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doAfterReturning</span><span class="params">(JoinPoint joinPoint, Object jsonResult)</span> &#123;</span><br><span class="line">        handleLog(joinPoint, <span class="literal">null</span>, jsonResult);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 拦截异常操作</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> joinPoint 切点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e 异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@AfterThrowing(value = &quot;logPointCut()&quot;, throwing = &quot;e&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doAfterThrowing</span><span class="params">(JoinPoint joinPoint, Exception e)</span> &#123;</span><br><span class="line">        handleLog(joinPoint, e, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">handleLog</span><span class="params">(<span class="keyword">final</span> JoinPoint joinPoint, <span class="keyword">final</span> Exception e, Object jsonResult)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获得注解</span></span><br><span class="line">            <span class="type">Log</span> <span class="variable">controllerLog</span> <span class="operator">=</span> getAnnotationLog(joinPoint);</span><br><span class="line">            <span class="keyword">if</span> (controllerLog == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取当前的用户</span></span><br><span class="line">            <span class="type">User</span> <span class="variable">currentUser</span> <span class="operator">=</span> ShiroUtils.getSysUser();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// *========数据库日志=========*//</span></span><br><span class="line">            <span class="type">OperLog</span> <span class="variable">operLog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OperLog</span>();</span><br><span class="line">            operLog.setStatus(BusinessStatus.SUCCESS.ordinal());</span><br><span class="line">            <span class="comment">// 请求的地址</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">ip</span> <span class="operator">=</span> ShiroUtils.getIp();</span><br><span class="line">            operLog.setOperIp(ip);</span><br><span class="line">            <span class="comment">// 返回参数</span></span><br><span class="line">            operLog.setJsonResult(JSONObject.toJSONString(jsonResult));</span><br><span class="line"></span><br><span class="line">            operLog.setOperUrl(ServletUtils.getRequest().getRequestURI());</span><br><span class="line">            <span class="keyword">if</span> (currentUser != <span class="literal">null</span>) &#123;</span><br><span class="line">                operLog.setOperName(currentUser.getLoginName());</span><br><span class="line">                <span class="keyword">if</span> (StringUtils.isNotNull(currentUser.getDept())</span><br><span class="line">                        &amp;&amp; StringUtils.isNotEmpty(currentUser.getDept().getDeptName())) &#123;</span><br><span class="line">                    operLog.setDeptName(currentUser.getDept().getDeptName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">                operLog.setStatus(BusinessStatus.FAIL.ordinal());</span><br><span class="line">                operLog.setErrorMsg(StringUtils.substring(e.getMessage(), <span class="number">0</span>, <span class="number">2000</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 设置方法名称</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> joinPoint.getTarget().getClass().getName();</span><br><span class="line">            <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> joinPoint.getSignature().getName();</span><br><span class="line">            operLog.setMethod(className + <span class="string">&quot;.&quot;</span> + methodName + <span class="string">&quot;()&quot;</span>);</span><br><span class="line">            <span class="comment">// 设置请求方式</span></span><br><span class="line">            operLog.setRequestMethod(ServletUtils.getRequest().getMethod());</span><br><span class="line">            <span class="comment">// 处理设置注解上的参数</span></span><br><span class="line">            getControllerMethodDescription(controllerLog, operLog);</span><br><span class="line">            <span class="comment">// 保存数据库</span></span><br><span class="line">            AsyncManager.me().execute(AsyncFactory.recordOper(operLog));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception exp) &#123;</span><br><span class="line">            <span class="comment">// 记录本地异常日志</span></span><br><span class="line">            log.error(<span class="string">&quot;==前置通知异常==&quot;</span>);</span><br><span class="line">            log.error(<span class="string">&quot;异常信息:&#123;&#125;&quot;</span>, exp.getMessage());</span><br><span class="line">            exp.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取注解中对方法的描述信息 用于Controller层注解</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> log 日志</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> operLog 操作日志</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getControllerMethodDescription</span><span class="params">(Log log, OperLog operLog)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 设置action动作</span></span><br><span class="line">        operLog.setBusinessType(log.businessType().ordinal());</span><br><span class="line">        <span class="comment">// 设置标题</span></span><br><span class="line">        operLog.setTitle(log.title());</span><br><span class="line">        <span class="comment">// 设置操作人类别</span></span><br><span class="line">        operLog.setOperatorType(log.operatorType().ordinal());</span><br><span class="line">        <span class="comment">// 是否需要保存request，参数和值</span></span><br><span class="line">        <span class="keyword">if</span> (log.isSaveRequestData()) &#123;</span><br><span class="line">            <span class="comment">// 获取参数的信息，传入到数据库中。</span></span><br><span class="line">            setRequestValue(operLog);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取请求的参数，放到log中</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> operLog</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setRequestValue</span><span class="params">(OperLog operLog)</span> &#123;</span><br><span class="line">        Map&lt;String, String[]&gt; map = ServletUtils.getRequest().getParameterMap();</span><br><span class="line">        <span class="type">String</span> <span class="variable">params</span> <span class="operator">=</span> JSONObject.toJSONString(map);</span><br><span class="line">        operLog.setOperParam(StringUtils.substring(params, <span class="number">0</span>, <span class="number">2000</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否存在注解，如果存在就获取</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Log <span class="title function_">getAnnotationLog</span><span class="params">(JoinPoint joinPoint)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Signature</span> <span class="variable">signature</span> <span class="operator">=</span> joinPoint.getSignature();</span><br><span class="line">        <span class="type">MethodSignature</span> <span class="variable">methodSignature</span> <span class="operator">=</span> (MethodSignature) signature;</span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> methodSignature.getMethod();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (method != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> method.getAnnotation(Log.class);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用@Log 注解</li></ul><p>以一个简单的 CRUD 操作为例, 这里展示部分代码：每对“部门”进行操作就会产生一条操作日志存入数据库。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/system/dept&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeptController</span> <span class="keyword">extends</span> <span class="title class_">BaseController</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">prefix</span> <span class="operator">=</span> <span class="string">&quot;system/dept&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IDeptService deptService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 新增保存部门</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Log(title = &quot;部门管理&quot;, businessType = BusinessType.INSERT)</span></span><br><span class="line">    <span class="meta">@RequiresPermissions(&quot;system:dept:add&quot;)</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/add&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> AjaxResult <span class="title function_">addSave</span><span class="params">(<span class="meta">@Validated</span> Dept dept)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (UserConstants.DEPT_NAME_NOT_UNIQUE.equals(deptService.checkDeptNameUnique(dept))) &#123;</span><br><span class="line">            <span class="keyword">return</span> error(<span class="string">&quot;新增部门&#x27;&quot;</span> + dept.getDeptName() + <span class="string">&quot;&#x27;失败，部门名称已存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> toAjax(deptService.insertDept(dept));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保存</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Log(title = &quot;部门管理&quot;, businessType = BusinessType.UPDATE)</span></span><br><span class="line">    <span class="meta">@RequiresPermissions(&quot;system:dept:edit&quot;)</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/edit&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> AjaxResult <span class="title function_">editSave</span><span class="params">(<span class="meta">@Validated</span> Dept dept)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (UserConstants.DEPT_NAME_NOT_UNIQUE.equals(deptService.checkDeptNameUnique(dept))) &#123;</span><br><span class="line">            <span class="keyword">return</span> error(<span class="string">&quot;修改部门&#x27;&quot;</span> + dept.getDeptName() + <span class="string">&quot;&#x27;失败，部门名称已存在&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(dept.getParentId().equals(dept.getDeptId())) &#123;</span><br><span class="line">            <span class="keyword">return</span> error(<span class="string">&quot;修改部门&#x27;&quot;</span> + dept.getDeptName() + <span class="string">&quot;&#x27;失败，上级部门不能是自己&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> toAjax(deptService.updateDept(dept));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Log(title = &quot;部门管理&quot;, businessType = BusinessType.DELETE)</span></span><br><span class="line">    <span class="meta">@RequiresPermissions(&quot;system:dept:remove&quot;)</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/remove/&#123;deptId&#125;&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> AjaxResult <span class="title function_">remove</span><span class="params">(<span class="meta">@PathVariable(&quot;deptId&quot;)</span> Long deptId)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (deptService.selectDeptCount(deptId) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> AjaxResult.warn(<span class="string">&quot;存在下级部门,不允许删除&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (deptService.checkDeptExistUser(deptId)) &#123;</span><br><span class="line">            <span class="keyword">return</span> AjaxResult.warn(<span class="string">&quot;部门存在用户,不允许删除&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> toAjax(deptService.deleteDeptById(deptId));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>同样的，你也可以看到权限管理也是通过类似的注解（<code>@RequiresPermissions</code>）机制来实现的。所以我们可以看到，通过注解+AOP 最终的目标是为了实现模块的解耦。</p></blockquote><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="# 参考文章"></a><a href="#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0">#</a> 参考文章</h2><ul><li><a href="https://blog.csdn.net/javazejian/article/details/71860633">https://blog.csdn.net/javazejian/article/details/71860633</a></li><li><a href="https://blog.csdn.net/qq_20009015/article/details/106038023">https://blog.csdn.net/qq_20009015/article/details/106038023</a></li><li><a href="https://www.zhihu.com/question/47449512">https://www.zhihu.com/question/47449512</a></li><li><a href="https://www.race604.com/annotation-processing/">https://www.race604.com/annotation-processing/</a></li><li><a href="https://www.runoob.com/w3cnote/java-annotation.html">https://www.runoob.com/w3cnote/java-annotation.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 基础 - 泛型机制详解</title>
      <link href="/posts/35d92ef6.html"/>
      <url>/posts/35d92ef6.html</url>
      
        <content type="html"><![CDATA[<p>Java 基础 - 泛型机制详解</p><span id="more"></span><h2 id="为什么会引入泛型"><a href="#为什么会引入泛型" class="headerlink" title="为什么会引入泛型"></a>为什么会引入泛型</h2><blockquote><p>泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）。也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。</p></blockquote><p>引入泛型的意义在于：</p><ul><li><strong>适用于多种数据类型执行相同的代码</strong>（代码复用）</li></ul><p>我们通过一个例子来阐述，先看下下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    System.out.println(a + <span class="string">&quot;+&quot;</span> + b + <span class="string">&quot;=&quot;</span> + (a + b));</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">float</span> <span class="title function_">add</span><span class="params">(<span class="type">float</span> a, <span class="type">float</span> b)</span> &#123;</span><br><span class="line">    System.out.println(a + <span class="string">&quot;+&quot;</span> + b + <span class="string">&quot;=&quot;</span> + (a + b));</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">add</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span> &#123;</span><br><span class="line">    System.out.println(a + <span class="string">&quot;+&quot;</span> + b + <span class="string">&quot;=&quot;</span> + (a + b));</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果没有泛型，要实现不同类型的加法，每种类型都需要重载一个add方法；通过泛型，我们可以复用为一个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Number</span>&gt; <span class="type">double</span> <span class="title function_">add</span><span class="params">(T a, T b)</span> &#123;</span><br><span class="line">    System.out.println(a + <span class="string">&quot;+&quot;</span> + b + <span class="string">&quot;=&quot;</span> + (a.doubleValue() + b.doubleValue()));</span><br><span class="line">    <span class="keyword">return</span> a.doubleValue() + b.doubleValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>泛型中的类型在使用时指定，不需要强制类型转换（<strong>类型安全</strong>，编译器会<strong>检查类型</strong>）</li></ul><p>看下这个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">list.add(<span class="string">&quot;xxString&quot;</span>);</span><br><span class="line">list.add(<span class="number">100d</span>);</span><br><span class="line">list.add(<span class="keyword">new</span> <span class="title class_">Person</span>());</span><br></pre></td></tr></table></figure><p>我们在使用上述list中，list中的元素都是Object类型（无法约束其中的类型），所以在取出集合元素时需要人为的强制类型转化到具体的目标类型，且很容易出现<code>java.lang.ClassCastException</code>异常。</p><p>引入泛型，它将提供类型的约束，提供编译前的检查：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// list中只能放String, 不能放其它类型的元素</span></span><br></pre></td></tr></table></figure><h2 id="泛型的基本使用"><a href="#泛型的基本使用" class="headerlink" title="# 泛型的基本使用"></a><a href="#%E6%B3%9B%E5%9E%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8">#</a> 泛型的基本使用</h2><p>提示</p><p>我们通过一些例子来学习泛型的使用；泛型有三种使用方式，分别为：泛型类、泛型接口、泛型方法。一些例子可以参考《李兴华 - Java实战经典》。@pdai</p><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="# 泛型类"></a><a href="#%E6%B3%9B%E5%9E%8B%E7%B1%BB">#</a> 泛型类</h3><ul><li>从一个简单的泛型类看起：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span>&lt;T&gt;&#123;         <span class="comment">// 此处可以随便写标识符号，T是type的简称  </span></span><br><span class="line">    <span class="keyword">private</span> T <span class="keyword">var</span> ;     <span class="comment">// var的类型由T指定，即：由外部指定  </span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getVar</span><span class="params">()</span>&#123;  <span class="comment">// 返回值的类型由外部决定  </span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">var</span> ;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setVar</span><span class="params">(T <span class="keyword">var</span>)</span>&#123;  <span class="comment">// 设置的类型也由外部决定  </span></span><br><span class="line">        <span class="built_in">this</span>.<span class="keyword">var</span> = <span class="keyword">var</span> ;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericsDemo06</span>&#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;  </span><br><span class="line">        Point&lt;String&gt; p = <span class="keyword">new</span> <span class="title class_">Point</span>&lt;String&gt;() ;     <span class="comment">// 里面的var类型为String类型  </span></span><br><span class="line">        p.setVar(<span class="string">&quot;it&quot;</span>) ;                            <span class="comment">// 设置字符串  </span></span><br><span class="line">        System.out.println(p.getVar().length()) ;   <span class="comment">// 取得字符串的长度  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>多元泛型</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Notepad</span>&lt;K,V&gt;&#123;       <span class="comment">// 此处指定了两个泛型类型  </span></span><br><span class="line">    <span class="keyword">private</span> K key ;     <span class="comment">// 此变量的类型由外部决定  </span></span><br><span class="line">    <span class="keyword">private</span> V value ;   <span class="comment">// 此变量的类型由外部决定  </span></span><br><span class="line">    <span class="keyword">public</span> K <span class="title function_">getKey</span><span class="params">()</span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.key ;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">getValue</span><span class="params">()</span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.value ;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setKey</span><span class="params">(K key)</span>&#123;  </span><br><span class="line">        <span class="built_in">this</span>.key = key ;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(V value)</span>&#123;  </span><br><span class="line">        <span class="built_in">this</span>.value = value ;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericsDemo09</span>&#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;  </span><br><span class="line">        Notepad&lt;String,Integer&gt; t = <span class="literal">null</span> ;        <span class="comment">// 定义两个泛型类型的对象  </span></span><br><span class="line">        t = <span class="keyword">new</span> <span class="title class_">Notepad</span>&lt;String,Integer&gt;() ;       <span class="comment">// 里面的key为String，value为Integer  </span></span><br><span class="line">        t.setKey(<span class="string">&quot;汤姆&quot;</span>) ;        <span class="comment">// 设置第一个内容  </span></span><br><span class="line">        t.setValue(<span class="number">20</span>) ;            <span class="comment">// 设置第二个内容  </span></span><br><span class="line">        System.out.print(<span class="string">&quot;姓名；&quot;</span> + t.getKey()) ;      <span class="comment">// 取得信息  </span></span><br><span class="line">        System.out.print(<span class="string">&quot;，年龄；&quot;</span> + t.getValue()) ;       <span class="comment">// 取得信息  </span></span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="# 泛型接口"></a><a href="#%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3">#</a> 泛型接口</h3><ul><li>简单的泛型接口</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Info</span>&lt;T&gt;&#123;        <span class="comment">// 在接口上定义泛型  </span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getVar</span><span class="params">()</span> ; <span class="comment">// 定义抽象方法，抽象方法的返回值就是泛型类型  </span></span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InfoImpl</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Info</span>&lt;T&gt;&#123;   <span class="comment">// 定义泛型接口的子类  </span></span><br><span class="line">    <span class="keyword">private</span> T <span class="keyword">var</span> ;             <span class="comment">// 定义属性  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">InfoImpl</span><span class="params">(T <span class="keyword">var</span>)</span>&#123;     <span class="comment">// 通过构造方法设置属性内容  </span></span><br><span class="line">        <span class="built_in">this</span>.setVar(<span class="keyword">var</span>) ;    </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setVar</span><span class="params">(T <span class="keyword">var</span>)</span>&#123;  </span><br><span class="line">        <span class="built_in">this</span>.<span class="keyword">var</span> = <span class="keyword">var</span> ;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getVar</span><span class="params">()</span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.<span class="keyword">var</span> ;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericsDemo24</span>&#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String arsg[])</span>&#123;  </span><br><span class="line">        Info&lt;String&gt; i = <span class="literal">null</span>;        <span class="comment">// 声明接口对象  </span></span><br><span class="line">        i = <span class="keyword">new</span> <span class="title class_">InfoImpl</span>&lt;String&gt;(<span class="string">&quot;汤姆&quot;</span>) ;  <span class="comment">// 通过子类实例化对象  </span></span><br><span class="line">        System.out.println(<span class="string">&quot;内容：&quot;</span> + i.getVar()) ;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="# 泛型方法"></a><a href="#%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95">#</a> 泛型方法</h3><p>泛型方法，是在调用方法的时候指明泛型的具体类型。重点看下泛型的方法（图参考自：<a href="https://www.cnblogs.com/iyangyuan/archive/2013/04/09/3011274.html%EF%BC%89">https://www.cnblogs.com/iyangyuan/archive/2013/04/09/3011274.html）</a></p><ul><li>定义泛型方法语法格式</li></ul><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230816144046682.png" alt="image-20230816144046682"></p><ul><li>调用泛型方法语法格式</li></ul><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230816144057673.png" alt="image-20230816144057673"></p><p>说明一下，定义泛型方法时，必须在返回值前边加一个<code>&lt;T&gt;</code>，来声明这是一个泛型方法，持有一个泛型<code>T</code>，然后才可以用泛型T作为方法的返回值。</p><p><code>Class&lt;T&gt;</code>的作用就是指明泛型的具体类型，而<code>Class&lt;T&gt;</code>类型的变量c，可以用来创建泛型类的对象。</p><p>为什么要用变量c来创建对象呢？既然是泛型方法，就代表着我们不知道具体的类型是什么，也不知道构造方法如何，因此没有办法去new一个对象，但可以利用变量c的newInstance方法去创建对象，也就是利用反射创建对象。</p><p>泛型方法要求的参数是<code>Class&lt;T&gt;</code>类型，而<code>Class.forName()</code>方法的返回值也是<code>Class&lt;T&gt;</code>，因此可以用<code>Class.forName()</code>作为参数。其中，<code>forName()</code>方法中的参数是何种类型，返回的<code>Class&lt;T&gt;</code>就是何种类型。在本例中，<code>forName()</code>方法中传入的是User类的完整路径，因此返回的是<code>Class&lt;User&gt;</code>类型的对象，因此调用泛型方法时，变量c的类型就是<code>Class&lt;User&gt;</code>，因此泛型方法中的泛型T就被指明为User，因此变量obj的类型为User。</p><p>当然，泛型方法不是仅仅可以有一个参数<code>Class&lt;T&gt;</code>，可以根据需要添加其他参数。</p><p><strong>为什么要使用泛型方法呢</strong>？因为泛型类要在实例化的时候就指明类型，如果想换一种类型，不得不重新new一次，可能不够灵活；而泛型方法可以在调用的时候指明类型，更加灵活。</p><h3 id="泛型的上下限"><a href="#泛型的上下限" class="headerlink" title="# 泛型的上下限"></a><a href="#%E6%B3%9B%E5%9E%8B%E7%9A%84%E4%B8%8A%E4%B8%8B%E9%99%90">#</a> 泛型的上下限</h3><ul><li><strong>先看下如下的代码，很明显是会报错的</strong> （具体错误原因请参考后文）。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如下两个方法不会报错</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">funA</span><span class="params">(A a)</span> &#123;</span><br><span class="line">    <span class="comment">// ...          </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">funB</span><span class="params">(B b)</span> &#123;</span><br><span class="line">    funA(b);</span><br><span class="line">    <span class="comment">// ...             </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如下funD方法会报错</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">funC</span><span class="params">(List&lt;A&gt; listA)</span> &#123;</span><br><span class="line">    <span class="comment">// ...          </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">funD</span><span class="params">(List&lt;B&gt; listB)</span> &#123;</span><br><span class="line">    funC(listB); <span class="comment">// Unresolved compilation problem: The method doPrint(List&lt;A&gt;) in the type test is not applicable for the arguments (List&lt;B&gt;)</span></span><br><span class="line">    <span class="comment">// ...             </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么如何解决呢？</p><p>为了解决泛型中隐含的转换问题，Java泛型加入了类型参数的上下边界机制。<code>&lt;? extends A&gt;</code>表示该类型参数可以是A(上边界)或者A的子类类型。编译时擦除到类型A，即用A类型代替类型参数。这种方法可以解决开始遇到的问题，编译器知道类型参数的范围，如果传入的实例类型B是在这个范围内的话允许转换，这时只要一次类型转换就可以了，运行时会把对象当做A的实例看待。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">funC</span><span class="params">(List&lt;? extends A&gt; listA)</span> &#123;</span><br><span class="line">    <span class="comment">// ...          </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">funD</span><span class="params">(List&lt;B&gt; listB)</span> &#123;</span><br><span class="line">    funC(listB); <span class="comment">// OK</span></span><br><span class="line">    <span class="comment">// ...             </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>泛型上下限的引入</strong></li></ul><p>在使用泛型的时候，我们可以为传入的泛型类型实参进行上下边界的限制，如：类型实参只准传入某种类型的父类或某种类型的子类。</p><p>上限</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Info</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Number</span>&gt;&#123;    <span class="comment">// 此处泛型只能是数字类型</span></span><br><span class="line">    <span class="keyword">private</span> T <span class="keyword">var</span> ;        <span class="comment">// 定义泛型变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setVar</span><span class="params">(T <span class="keyword">var</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.<span class="keyword">var</span> = <span class="keyword">var</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getVar</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.<span class="keyword">var</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>&#123;    <span class="comment">// 直接打印</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.<span class="keyword">var</span>.toString() ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">demo1</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        Info&lt;Integer&gt; i1 = <span class="keyword">new</span> <span class="title class_">Info</span>&lt;Integer&gt;() ;        <span class="comment">// 声明Integer的泛型对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下限</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Info</span>&lt;T&gt;&#123;</span><br><span class="line">    <span class="keyword">private</span> T <span class="keyword">var</span> ;        <span class="comment">// 定义泛型变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setVar</span><span class="params">(T <span class="keyword">var</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.<span class="keyword">var</span> = <span class="keyword">var</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getVar</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.<span class="keyword">var</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>&#123;    <span class="comment">// 直接打印</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.<span class="keyword">var</span>.toString() ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericsDemo21</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        Info&lt;String&gt; i1 = <span class="keyword">new</span> <span class="title class_">Info</span>&lt;String&gt;() ;        <span class="comment">// 声明String的泛型对象</span></span><br><span class="line">        Info&lt;Object&gt; i2 = <span class="keyword">new</span> <span class="title class_">Info</span>&lt;Object&gt;() ;        <span class="comment">// 声明Object的泛型对象</span></span><br><span class="line">        i1.setVar(<span class="string">&quot;hello&quot;</span>) ;</span><br><span class="line">        i2.setVar(<span class="keyword">new</span> <span class="title class_">Object</span>()) ;</span><br><span class="line">        fun(i1) ;</span><br><span class="line">        fun(i2) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">(Info&lt;? <span class="built_in">super</span> String&gt; temp)</span>&#123;    <span class="comment">// 只能接收String或Object类型的泛型，String类的父类只有Object类</span></span><br><span class="line">        System.out.print(temp + <span class="string">&quot;, &quot;</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>小结</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?&gt; 无限制通配符</span><br><span class="line">&lt;? <span class="keyword">extends</span> <span class="title class_">E</span>&gt; extends 关键字声明了类型的上界，表示参数化的类型可能是所指定的类型，或者是此类型的子类</span><br><span class="line">&lt;? <span class="built_in">super</span> E&gt; <span class="built_in">super</span> 关键字声明了类型的下界，表示参数化的类型可能是指定的类型，或者是此类型的父类</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用原则《Effictive Java》</span></span><br><span class="line"><span class="comment">// 为了获得最大限度的灵活性，要在表示 生产者或者消费者 的输入参数上使用通配符，使用的规则就是：生产者有上限、消费者有下限</span></span><br><span class="line"><span class="number">1.</span> 如果参数化类型表示一个 T 的生产者，使用 &lt; ? <span class="keyword">extends</span> <span class="title class_">T</span>&gt;;</span><br><span class="line"><span class="number">2.</span> 如果它表示一个 T 的消费者，就使用 &lt; ? <span class="built_in">super</span> T&gt;；</span><br><span class="line"><span class="number">3.</span> 如果既是生产又是消费，那使用通配符就没什么意义了，因为你需要的是精确的参数类型。</span><br></pre></td></tr></table></figure><ul><li>再看一个实际例子，<strong>加深印象</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>  &lt;E <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;? <span class="built_in">super</span> E&gt;&gt; E <span class="title function_">max</span><span class="params">(List&lt;? extends E&gt; e1)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (e1 == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//迭代器返回的元素属于 E 的某个子类型</span></span><br><span class="line">    Iterator&lt;? <span class="keyword">extends</span> <span class="title class_">E</span>&gt; iterator = e1.iterator();</span><br><span class="line">    <span class="type">E</span> <span class="variable">result</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">        <span class="type">E</span> <span class="variable">next</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">        <span class="keyword">if</span> (next.compareTo(result) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            result = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中的类型参数 E 的范围是<code>&lt;E extends Comparable&lt;? super E&gt;&gt;</code>，我们可以分步查看：</p><ul><li>要进行比较，所以 E 需要是可比较的类，因此需要 <code>extends Comparable&lt;…&gt;</code>（注意这里不要和继承的 <code>extends</code> 搞混了，不一样）</li><li><code>Comparable&lt; ? super E&gt;</code> 要对 E 进行比较，即 E 的消费者，所以需要用 super</li><li>而参数 <code>List&lt; ? extends E&gt;</code> 表示要操作的数据是 E 的子类的列表，指定上限，这样容器才够大</li><li><strong>多个限制</strong></li></ul><p>使用&amp;符号</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="comment">//工资低于2500元的上斑族并且站立的乘客车票打8折</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Staff</span> &amp; Passenger&gt; <span class="keyword">void</span> <span class="title function_">discount</span><span class="params">(T t)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t.getSalary()&lt;<span class="number">2500</span> &amp;&amp; t.isStanding())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;恭喜你！您的车票打八折！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        discount(<span class="keyword">new</span> <span class="title class_">Me</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="泛型数组"><a href="#泛型数组" class="headerlink" title="# 泛型数组"></a><a href="#%E6%B3%9B%E5%9E%8B%E6%95%B0%E7%BB%84">#</a> 泛型数组</h3><blockquote><p>具体可以参考下文中关于泛型数组的理解。</p></blockquote><p>首先，我们泛型数组相关的申明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt;[] list11 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;[<span class="number">10</span>]; <span class="comment">//编译错误，非法创建 </span></span><br><span class="line">List&lt;String&gt;[] list12 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;?&gt;[<span class="number">10</span>]; <span class="comment">//编译错误，需要强转类型 </span></span><br><span class="line">List&lt;String&gt;[] list13 = (List&lt;String&gt;[]) <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;?&gt;[<span class="number">10</span>]; <span class="comment">//OK，但是会有警告 </span></span><br><span class="line">List&lt;?&gt;[] list14 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;[<span class="number">10</span>]; <span class="comment">//编译错误，非法创建 </span></span><br><span class="line">List&lt;?&gt;[] list15 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;?&gt;[<span class="number">10</span>]; <span class="comment">//OK </span></span><br><span class="line">List&lt;String&gt;[] list6 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>[<span class="number">10</span>]; <span class="comment">//OK，但是会有警告</span></span><br></pre></td></tr></table></figure><p>那么通常我们如何用呢？</p><ul><li>讨巧的使用场景</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericsDemo30</span>&#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;  </span><br><span class="line">        Integer i[] = fun1(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>) ;   <span class="comment">// 返回泛型数组  </span></span><br><span class="line">        fun2(i) ;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T[] fun1(T...arg)&#123;  <span class="comment">// 接收可变参数  </span></span><br><span class="line">        <span class="keyword">return</span> arg ;            <span class="comment">// 返回泛型数组  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">fun2</span><span class="params">(T param[])</span>&#123;   <span class="comment">// 输出  </span></span><br><span class="line">        System.out.print(<span class="string">&quot;接收泛型数组：&quot;</span>) ;  </span><br><span class="line">        <span class="keyword">for</span>(T t:param)&#123;  </span><br><span class="line">            System.out.print(t + <span class="string">&quot;、&quot;</span>) ;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>合理使用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayWithTypeToken</span><span class="params">(Class&lt;T&gt; type, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">    array = (T[]) Array.newInstance(type, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体可以查看后文解释。</p><h2 id="深入理解泛型"><a href="#深入理解泛型" class="headerlink" title="# 深入理解泛型"></a><a href="#%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E6%B3%9B%E5%9E%8B">#</a> 深入理解泛型</h2><p>提示</p><p>我们通过泛型背后的类型擦除以及相关的问题来进一步理解泛型。@pdai</p><h3 id="如何理解Java中的泛型是伪泛型？泛型中类型擦除"><a href="#如何理解Java中的泛型是伪泛型？泛型中类型擦除" class="headerlink" title="# 如何理解Java中的泛型是伪泛型？泛型中类型擦除"></a><a href="#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3java%E4%B8%AD%E7%9A%84%E6%B3%9B%E5%9E%8B%E6%98%AF%E4%BC%AA%E6%B3%9B%E5%9E%8B-%E6%B3%9B%E5%9E%8B%E4%B8%AD%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4">#</a> 如何理解Java中的泛型是伪泛型？泛型中类型擦除</h3><blockquote><p>Java泛型这个特性是从JDK 1.5才开始加入的，因此为了兼容之前的版本，Java泛型的实现采取了“<strong>伪泛型</strong>”的策略，即Java在语法上支持泛型，但是在编译阶段会进行所谓的“<strong>类型擦除</strong>”（Type Erasure），将所有的泛型表示（尖括号中的内容）都替换为具体的类型（其对应的原生态类型），就像完全没有泛型一样。理解类型擦除对于用好泛型是很有帮助的，尤其是一些看起来“疑难杂症”的问题，弄明白了类型擦除也就迎刃而解了。</p></blockquote><p><strong>泛型的类型擦除原则</strong>是：</p><ul><li>消除类型参数声明，即删除<code>&lt;&gt;</code>及其包围的部分。</li><li>根据类型参数的上下界推断并替换所有的类型参数为原生态类型：如果类型参数是无限制通配符或没有上下界限定则替换为Object，如果存在上下界限定则根据子类替换原则取类型参数的最左边限定类型（即父类）。</li><li>为了保证类型安全，必要时插入强制类型转换代码。</li><li>自动产生“桥接方法”以保证擦除类型后的代码仍然具有泛型的“多态性”。</li></ul><p><strong>那么如何进行擦除的呢</strong>？</p><p>参考自：<a href="http://softlab.sdut.edu.cn/blog/subaochen/2017/01/generics-type-erasure/">http://softlab.sdut.edu.cn/blog/subaochen/2017/01/generics-type-erasure/</a></p><ul><li>擦除类定义中的类型参数 - 无限制类型擦除</li></ul><p>当类定义中的类型参数没有任何限制时，在类型擦除中直接被替换为Object，即形如<code>&lt;T&gt;</code>和<code>&lt;?&gt;</code>的类型参数都被替换为Object。</p><p><img src="images/java/java-basic-generic-1.png" alt="img"></p><ul><li>擦除类定义中的类型参数 - 有限制类型擦除</li></ul><p>当类定义中的类型参数存在限制（上下界）时，在类型擦除中替换为类型参数的上界或者下界，比如形如<code>&lt;T extends Number&gt;</code>和<code>&lt;? extends Number&gt;</code>的类型参数被替换为<code>Number</code>，<code>&lt;? super Number&gt;</code>被替换为Object。</p><p><img src="images/java/java-basic-generic-2.png" alt="img"></p><ul><li>擦除方法定义中的类型参数</li></ul><p>擦除方法定义中的类型参数原则和擦除类定义中的类型参数是一样的，这里仅以擦除方法定义中的有限制类型参数为例。</p><p><img src="images/java/java-basic-generic-3.png" alt="img"></p><h3 id="如何证明类型的擦除呢？"><a href="#如何证明类型的擦除呢？" class="headerlink" title="# 如何证明类型的擦除呢？"></a><a href="#%E5%A6%82%E4%BD%95%E8%AF%81%E6%98%8E%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%93%A6%E9%99%A4%E5%91%A2">#</a> 如何证明类型的擦除呢？</h3><blockquote><p>我们通过两个例子证明Java类型的类型擦除</p></blockquote><ul><li>原始类型相等</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;String&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        list1.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;Integer&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        list2.add(<span class="number">123</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(list1.getClass() == list2.getClass()); <span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们定义了两个ArrayList数组，不过一个是<code>ArrayList&lt;String&gt;</code>泛型类型的，只能存储字符串；一个是<code>ArrayList&lt;Integer&gt;</code>泛型类型的，只能存储整数，最后，我们通过list1对象和list2对象的<code>getClass()</code>方法获取他们的类的信息，最后发现结果为true。说明泛型类型String和Integer都被擦除掉了，只剩下原始类型。</p><ul><li>通过反射添加其它类型元素</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">        list.add(<span class="number">1</span>);  <span class="comment">//这样调用 add 方法只能存储整形，因为泛型类型的实例为 Integer</span></span><br><span class="line"></span><br><span class="line">        list.getClass().getMethod(<span class="string">&quot;add&quot;</span>, Object.class).invoke(list, <span class="string">&quot;asd&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            System.out.println(list.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在程序中定义了一个<code>ArrayList</code>泛型类型实例化为<code>Integer</code>对象，如果直接调用<code>add()</code>方法，那么只能存储整数数据，不过当我们利用反射调用<code>add()</code>方法的时候，却可以存储字符串，这说明了<code>Integer</code>泛型实例在编译之后被擦除掉了，只保留了原始类型。</p><h3 id="如何理解类型擦除后保留的原始类型"><a href="#如何理解类型擦除后保留的原始类型" class="headerlink" title="# 如何理解类型擦除后保留的原始类型?"></a><a href="#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4%E5%90%8E%E4%BF%9D%E7%95%99%E7%9A%84%E5%8E%9F%E5%A7%8B%E7%B1%BB%E5%9E%8B">#</a> 如何理解类型擦除后保留的原始类型?</h3><blockquote><p>在上面，两次提到了原始类型，什么是原始类型？</p></blockquote><p><strong>原始类型</strong> 就是擦除去了泛型信息，最后在字节码中的类型变量的真正类型，无论何时定义一个泛型，相应的原始类型都会被自动提供，类型变量擦除，并使用其限定类型（无限定的变量用Object）替换。</p><ul><li>原始类型Object</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T&gt; &#123;  </span><br><span class="line">    <span class="keyword">private</span> T value;  </span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getValue</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> value;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(T  value)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.value = value;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>Pair的原始类型为:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> Object value;  </span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getValue</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> value;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(Object  value)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.value = value;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为在<code>Pair&lt;T&gt;</code>中，<code>T</code> 是一个无限定的类型变量，所以用Object替换，其结果就是一个普通的类，如同泛型加入Java语言之前的已经实现的样子。在程序中可以包含不同类型的Pair，如<code>Pair&lt;String&gt;</code>或<code>Pair&lt;Integer&gt;</code>，但是擦除类型后他们的就成为原始的Pair类型了，原始类型都是Object。</p><p>从上面章节，我们也可以明白ArrayList被擦除类型后，原始类型也变为Object，所以通过反射我们就可以存储字符串了。</p><p>如果类型变量有限定，那么原始类型就用第一个边界的类型变量类替换。</p><p>比如: Pair这样声明的话</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&gt; &#123;&#125;</span><br></pre></td></tr></table></figure><p>那么原始类型就是Comparable。</p><p>要区分原始类型和泛型变量的类型。</p><p>在调用泛型方法时，可以指定泛型，也可以不指定泛型:</p><ul><li>在不指定泛型的情况下，泛型变量的类型为该方法中的几种类型的同一父类的最小级，直到Object</li><li>在指定泛型的情况下，该方法的几种类型必须是该泛型的实例的类型或者其子类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line"></span><br><span class="line">        <span class="comment">/**不指定泛型的时候*/</span>  </span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> Test.add(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">//这两个参数都是Integer，所以T为Integer类型  </span></span><br><span class="line">        <span class="type">Number</span> <span class="variable">f</span> <span class="operator">=</span> Test.add(<span class="number">1</span>, <span class="number">1.2</span>); <span class="comment">//这两个参数一个是Integer，一个是Float，所以取同一父类的最小级，为Number  </span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> Test.add(<span class="number">1</span>, <span class="string">&quot;asd&quot;</span>); <span class="comment">//这两个参数一个是Integer，一个是String，所以取同一父类的最小级，为Object  </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**指定泛型的时候*/</span>  </span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> Test.&lt;Integer&gt;add(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">//指定了Integer，所以只能为Integer类型或者其子类  </span></span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> Test.&lt;Integer&gt;add(<span class="number">1</span>, <span class="number">2.2</span>); <span class="comment">//编译错误，指定了Integer，不能为Float  </span></span><br><span class="line">        <span class="type">Number</span> <span class="variable">c</span> <span class="operator">=</span> Test.&lt;Number&gt;add(<span class="number">1</span>, <span class="number">2.2</span>); <span class="comment">//指定为Number，所以可以为Integer和Float  </span></span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">//这是一个简单的泛型方法  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">add</span><span class="params">(T x,T y)</span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> y;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实在泛型类中，不指定泛型的时候，也差不多，只不过这个时候的泛型为Object，就比如ArrayList中，如果不指定泛型，那么这个ArrayList可以存储任意的对象。</p><ul><li>Object泛型</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">    <span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();  </span><br><span class="line">    list.add(<span class="number">1</span>);  </span><br><span class="line">    list.add(<span class="string">&quot;121&quot;</span>);  </span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">Date</span>());  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><h3 id="如何理解泛型的编译期检查？"><a href="#如何理解泛型的编译期检查？" class="headerlink" title="# 如何理解泛型的编译期检查？"></a><a href="#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E6%B3%9B%E5%9E%8B%E7%9A%84%E7%BC%96%E8%AF%91%E6%9C%9F%E6%A3%80%E6%9F%A5">#</a> 如何理解泛型的编译期检查？</h3><blockquote><p>既然说类型变量会在编译的时候擦除掉，那为什么我们往 ArrayList 创建的对象中添加整数会报错呢？不是说泛型变量String会在编译的时候变为Object类型吗？为什么不能存别的类型呢？既然类型擦除了，如何保证我们只能使用泛型变量限定的类型呢？</p></blockquote><p>Java编译器是通过先检查代码中泛型的类型，然后在进行类型擦除，再进行编译。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line"></span><br><span class="line">    ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();  </span><br><span class="line">    list.add(<span class="string">&quot;123&quot;</span>);  </span><br><span class="line">    list.add(<span class="number">123</span>);<span class="comment">//编译错误  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的程序中，使用add方法添加一个整型，在IDE中，直接会报错，说明这就是在编译之前的检查，因为如果是在编译之后检查，类型擦除后，原始类型为Object，是应该允许任意引用类型添加的。可实际上却不是这样的，这恰恰说明了关于泛型变量的使用，是会在编译之前检查的。</p><p>那么，<strong>这个类型检查是针对谁的呢</strong>？我们先看看参数化类型和原始类型的兼容。</p><p>以 ArrayList举例子，以前的写法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();  </span><br></pre></td></tr></table></figure><p>现在的写法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br></pre></td></tr></table></figure><p>如果是与以前的代码兼容，各种引用传值之间，必然会出现如下的情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>(); <span class="comment">//第一种 情况</span></span><br><span class="line"><span class="type">ArrayList</span> <span class="variable">list2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;(); <span class="comment">//第二种 情况</span></span><br></pre></td></tr></table></figure><p>这样是没有错误的，不过会有个编译时警告。</p><p>不过在第一种情况，可以实现与完全使用泛型参数一样的效果，第二种则没有效果。</p><p>因为类型检查就是编译时完成的，new ArrayList()只是在内存中开辟了一个存储空间，可以存储任何类型对象，而真正涉及类型检查的是它的引用，因为我们是使用它引用list1来调用它的方法，比如说调用add方法，所以list1引用能完成泛型类型的检查。而引用list2没有使用泛型，所以不行。</p><p>举例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line"></span><br><span class="line">        ArrayList&lt;String&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();  </span><br><span class="line">        list1.add(<span class="string">&quot;1&quot;</span>); <span class="comment">//编译通过  </span></span><br><span class="line">        list1.add(<span class="number">1</span>); <span class="comment">//编译错误  </span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> list1.get(<span class="number">0</span>); <span class="comment">//返回类型就是String  </span></span><br><span class="line"></span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">list2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();  </span><br><span class="line">        list2.add(<span class="string">&quot;1&quot;</span>); <span class="comment">//编译通过  </span></span><br><span class="line">        list2.add(<span class="number">1</span>); <span class="comment">//编译通过  </span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> list2.get(<span class="number">0</span>); <span class="comment">//返回类型就是Object  </span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;().add(<span class="string">&quot;11&quot;</span>); <span class="comment">//编译通过  </span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;().add(<span class="number">22</span>); <span class="comment">//编译错误  </span></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;().get(<span class="number">0</span>); <span class="comment">//返回类型就是String  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>通过上面的例子，我们可以明白，<strong>类型检查就是针对引用的，谁是一个引用，用这个引用调用泛型方法，就会对这个引用调用的方法进行类型检测，而无关它真正引用的对象</strong>。</p><p><strong>泛型中参数话类型为什么不考虑继承关系</strong>？</p><p>在Java中，像下面形式的引用传递是不允许的:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Object&gt;(); <span class="comment">//编译错误  </span></span><br><span class="line">ArrayList&lt;Object&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;(); <span class="comment">//编译错误</span></span><br></pre></td></tr></table></figure><ul><li>我们先看第一种情况，将第一种情况拓展成下面的形式：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Object&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Object&gt;();  </span><br><span class="line">list1.add(<span class="keyword">new</span> <span class="title class_">Object</span>());  </span><br><span class="line">list1.add(<span class="keyword">new</span> <span class="title class_">Object</span>());  </span><br><span class="line">ArrayList&lt;String&gt; list2 = list1; <span class="comment">//编译错误</span></span><br></pre></td></tr></table></figure><p>实际上，在第4行代码的时候，就会有编译错误。那么，我们先假设它编译没错。那么当我们使用list2引用用get()方法取值的时候，返回的都是String类型的对象（上面提到了，类型检测是根据引用来决定的），可是它里面实际上已经被我们存放了Object类型的对象，这样就会有<code>ClassCastException</code>了。所以为了避免这种极易出现的错误，Java不允许进行这样的引用传递。（这也是泛型出现的原因，就是为了解决类型转换的问题，我们不能违背它的初衷）。</p><ul><li>再看第二种情况，将第二种情况拓展成下面的形式：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();  </span><br><span class="line">list1.add(<span class="keyword">new</span> <span class="title class_">String</span>());  </span><br><span class="line">list1.add(<span class="keyword">new</span> <span class="title class_">String</span>());</span><br><span class="line"></span><br><span class="line">ArrayList&lt;Object&gt; list2 = list1; <span class="comment">//编译错误</span></span><br></pre></td></tr></table></figure><p>没错，这样的情况比第一种情况好的多，最起码，在我们用list2取值的时候不会出现ClassCastException，因为是从String转换为Object。可是，这样做有什么意义呢，泛型出现的原因，就是为了解决类型转换的问题。</p><p>我们使用了泛型，到头来，还是要自己强转，违背了泛型设计的初衷。所以java不允许这么干。再说，你如果又用list2往里面add()新的对象，那么到时候取得时候，我怎么知道我取出来的到底是String类型的，还是Object类型的呢？</p><p>所以，要格外注意，泛型中的引用传递的问题。</p><h3 id="如何理解泛型的多态？泛型的桥接方法"><a href="#如何理解泛型的多态？泛型的桥接方法" class="headerlink" title="# 如何理解泛型的多态？泛型的桥接方法"></a><a href="#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E6%B3%9B%E5%9E%8B%E7%9A%84%E5%A4%9A%E6%80%81-%E6%B3%9B%E5%9E%8B%E7%9A%84%E6%A1%A5%E6%8E%A5%E6%96%B9%E6%B3%95">#</a> 如何理解泛型的多态？泛型的桥接方法</h3><blockquote><p>类型擦除会造成多态的冲突，而JVM解决方法就是桥接方法。</p></blockquote><p>现在有这样一个泛型类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T&gt; &#123;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T value;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getValue</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> value;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(T value)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.value = value;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们想要一个子类继承它。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DateInter</span> <span class="keyword">extends</span> <span class="title class_">Pair</span>&lt;Date&gt; &#123;  </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(Date value)</span> &#123;  </span><br><span class="line">        <span class="built_in">super</span>.setValue(value);  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> Date <span class="title function_">getValue</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.getValue();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个子类中，我们设定父类的泛型类型为<code>Pair&lt;Date&gt;</code>，在子类中，我们覆盖了父类的两个方法，我们的原意是这样的：将父类的泛型类型限定为Date，那么父类里面的两个方法的参数都为Date类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Date <span class="title function_">getValue</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> value;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(Date value)</span> &#123;  </span><br><span class="line">    <span class="built_in">this</span>.value = value;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，我们在子类中重写这两个方法一点问题也没有，实际上，从他们的<code>@Override</code>标签中也可以看到，一点问题也没有，实际上是这样的吗？</p><p>分析：实际上，类型擦除后，父类的的泛型类型全部变为了原始类型Object，所以父类编译之后会变成下面的样子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> Object value;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getValue</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> value;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(Object  value)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.value = value;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>再看子类的两个重写的方法的类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(Date value)</span> &#123;  </span><br><span class="line">    <span class="built_in">super</span>.setValue(value);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="keyword">public</span> Date <span class="title function_">getValue</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.getValue();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先来分析setValue方法，父类的类型是Object，而子类的类型是Date，参数类型不一样，这如果实在普通的继承关系中，根本就不会是重写，而是重载。 我们在一个main方法测试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;  </span><br><span class="line">        <span class="type">DateInter</span> <span class="variable">dateInter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DateInter</span>();  </span><br><span class="line">        dateInter.setValue(<span class="keyword">new</span> <span class="title class_">Date</span>());                  </span><br><span class="line">        dateInter.setValue(<span class="keyword">new</span> <span class="title class_">Object</span>()); <span class="comment">//编译错误  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是重载，那么子类中两个setValue方法，一个是参数Object类型，一个是Date类型，可是我们发现，根本就没有这样的一个子类继承自父类的Object类型参数的方法。所以说，却是是重写了，而不是重载了。</p><p><strong>为什么会这样呢</strong>？</p><p>原因是这样的，我们传入父类的泛型类型是Date，<code>Pair&lt;Date&gt;</code>，我们的本意是将泛型类变为如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> Date value;  </span><br><span class="line">    <span class="keyword">public</span> Date <span class="title function_">getValue</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> value;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(Date value)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.value = value;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后再子类中重写参数类型为Date的那两个方法，实现继承中的多态。</p><p>可是由于种种原因，虚拟机并不能将泛型类型变为Date，只能将类型擦除掉，变为原始类型Object。这样，我们的本意是进行重写，实现多态。可是类型擦除后，只能变为了重载。这样，类型擦除就和多态有了冲突。JVM知道你的本意吗？知道！！！可是它能直接实现吗，不能！！！如果真的不能的话，那我们怎么去重写我们想要的Date类型参数的方法啊。</p><blockquote><p>于是JVM采用了一个特殊的方法，来完成这项功能，那就是桥方法。</p></blockquote><p>首先，我们用javap -c className的方式反编译下DateInter子类的字节码，结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">com</span>.tao.test.DateInter <span class="keyword">extends</span> <span class="title class_">com</span>.tao.test.Pair&lt;java.util.Date&gt; &#123;  </span><br><span class="line">  com.tao.test.DateInter();  </span><br><span class="line">    Code:  </span><br><span class="line">       <span class="number">0</span>: aload_0  </span><br><span class="line">       <span class="number">1</span>: invokespecial #<span class="number">8</span>                  <span class="comment">// Method com/tao/test/Pair.&quot;&lt;init&gt;&quot;:()V  </span></span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span>  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(java.util.Date)</span>;  <span class="comment">//我们重写的setValue方法  </span></span><br><span class="line">    Code:  </span><br><span class="line">       <span class="number">0</span>: aload_0  </span><br><span class="line">       <span class="number">1</span>: aload_1  </span><br><span class="line">       <span class="number">2</span>: invokespecial #<span class="number">16</span>                 <span class="comment">// Method com/tao/test/Pair.setValue:(Ljava/lang/Object;)V  </span></span><br><span class="line">       <span class="number">5</span>: <span class="keyword">return</span>  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> java.util.Date <span class="title function_">getValue</span><span class="params">()</span>;    <span class="comment">//我们重写的getValue方法  </span></span><br><span class="line">    Code:  </span><br><span class="line">       <span class="number">0</span>: aload_0  </span><br><span class="line">       <span class="number">1</span>: invokespecial #<span class="number">23</span>                 <span class="comment">// Method com/tao/test/Pair.getValue:()Ljava/lang/Object;  </span></span><br><span class="line">       <span class="number">4</span>: checkcast     #<span class="number">26</span>                 <span class="comment">// class java/util/Date  </span></span><br><span class="line">       <span class="number">7</span>: areturn  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> java.lang.Object <span class="title function_">getValue</span><span class="params">()</span>;     <span class="comment">//编译时由编译器生成的桥方法  </span></span><br><span class="line">    Code:  </span><br><span class="line">       <span class="number">0</span>: aload_0  </span><br><span class="line">       <span class="number">1</span>: invokevirtual #<span class="number">28</span>                 <span class="comment">// Method getValue:()Ljava/util/Date 去调用我们重写的getValue方法;  </span></span><br><span class="line">       <span class="number">4</span>: areturn  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(java.lang.Object)</span>;   <span class="comment">//编译时由编译器生成的桥方法  </span></span><br><span class="line">    Code:  </span><br><span class="line">       <span class="number">0</span>: aload_0  </span><br><span class="line">       <span class="number">1</span>: aload_1  </span><br><span class="line">       <span class="number">2</span>: checkcast     #<span class="number">26</span>                 <span class="comment">// class java/util/Date  </span></span><br><span class="line">       <span class="number">5</span>: invokevirtual #<span class="number">30</span>                 <span class="comment">// Method setValue:(Ljava/util/Date; 去调用我们重写的setValue方法)V  </span></span><br><span class="line">       <span class="number">8</span>: <span class="keyword">return</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从编译的结果来看，我们本意重写setValue和getValue方法的子类，竟然有4个方法，其实不用惊奇，最后的两个方法，就是编译器自己生成的桥方法。可以看到桥方法的参数类型都是Object，也就是说，子类中真正覆盖父类两个方法的就是这两个我们看不到的桥方法。而打在我们自己定义的setvalue和getValue方法上面的@Oveerride只不过是假象。而桥方法的内部实现，就只是去调用我们自己重写的那两个方法。</p><p>所以，虚拟机巧妙的使用了桥方法，来解决了类型擦除和多态的冲突。</p><p>不过，要提到一点，这里面的setValue和getValue这两个桥方法的意义又有不同。</p><p>setValue方法是为了解决类型擦除与多态之间的冲突。</p><p>而getValue却有普遍的意义，怎么说呢，如果这是一个普通的继承关系：</p><p>那么父类的getValue方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getValue</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.getValue();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而子类重写的方法是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Date <span class="title function_">getValue</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.getValue();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实这在普通的类继承中也是普遍存在的重写，这就是协变。</p><p>并且，还有一点也许会有疑问，子类中的桥方法<code>Object getValue()</code>和<code>Date getValue()</code>是同时存在的，可是如果是常规的两个方法，他们的方法签名是一样的，也就是说虚拟机根本不能分别这两个方法。如果是我们自己编写Java代码，这样的代码是无法通过编译器的检查的，但是虚拟机却是允许这样做的，因为虚拟机通过参数类型和返回类型来确定一个方法，所以编译器为了实现泛型的多态允许自己做这个看起来“不合法”的事情，然后交给虚拟器去区别。</p><h3 id="如何理解基本类型不能作为泛型类型？"><a href="#如何理解基本类型不能作为泛型类型？" class="headerlink" title="# 如何理解基本类型不能作为泛型类型？"></a><a href="#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8D%E8%83%BD%E4%BD%9C%E4%B8%BA%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%9E%8B">#</a> 如何理解基本类型不能作为泛型类型？</h3><blockquote><p>比如，我们没有<code>ArrayList&lt;int&gt;</code>，只有<code>ArrayList&lt;Integer&gt;</code>, 为何？</p></blockquote><p>因为当类型擦除后，ArrayList的原始类型变为Object，但是Object类型不能存储int值，只能引用Integer的值。</p><p>另外需要注意，我们能够使用<code>list.add(1)</code>是因为Java基础类型的自动装箱拆箱操作。</p><h3 id="如何理解泛型类型不能实例化？"><a href="#如何理解泛型类型不能实例化？" class="headerlink" title="# 如何理解泛型类型不能实例化？"></a><a href="#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%9E%8B%E4%B8%8D%E8%83%BD%E5%AE%9E%E4%BE%8B%E5%8C%96">#</a> 如何理解泛型类型不能实例化？</h3><blockquote><p>不能实例化泛型类型, 这本质上是由于类型擦除决定的：</p></blockquote><p>我们可以看到如下代码会在编译器中报错：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">T</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T</span>(); <span class="comment">// ERROR</span></span><br></pre></td></tr></table></figure><p>因为在 Java 编译期没法确定泛型参数化类型，也就找不到对应的类字节码文件，所以自然就不行了，此外由于<code>T</code> 被擦除为 <code>Object</code>，如果可以 <code>new T()</code> 则就变成了 <code>new Object()</code>，失去了本意。   如果我们确实需要实例化一个泛型，应该如何做呢？可以通过反射实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T&gt; T <span class="title function_">newTclass</span> <span class="params">(Class &lt; T &gt; clazz)</span> <span class="keyword">throws</span> InstantiationException, IllegalAccessException &#123;</span><br><span class="line">    <span class="type">T</span> <span class="variable">obj</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="泛型数组：能不能采用具体的泛型类型进行初始化？"><a href="#泛型数组：能不能采用具体的泛型类型进行初始化？" class="headerlink" title="# 泛型数组：能不能采用具体的泛型类型进行初始化？"></a><a href="#%E6%B3%9B%E5%9E%8B%E6%95%B0%E7%BB%84-%E8%83%BD%E4%B8%8D%E8%83%BD%E9%87%87%E7%94%A8%E5%85%B7%E4%BD%93%E7%9A%84%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%9E%8B%E8%BF%9B%E8%A1%8C%E5%88%9D%E5%A7%8B%E5%8C%96">#</a> 泛型数组：能不能采用具体的泛型类型进行初始化？</h3><p>我们先来看下Oracle官网提供的一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt;[] lsa = <span class="keyword">new</span> <span class="title class_">List</span>&lt;String&gt;[<span class="number">10</span>]; <span class="comment">// Not really allowed.</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> lsa;</span><br><span class="line">Object[] oa = (Object[]) o;</span><br><span class="line">List&lt;Integer&gt; li = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">li.add(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">3</span>));</span><br><span class="line">oa[<span class="number">1</span>] = li; <span class="comment">// Unsound, but passes run time store check</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> lsa[<span class="number">1</span>].get(<span class="number">0</span>); <span class="comment">// Run-time error ClassCastException.</span></span><br></pre></td></tr></table></figure><p>由于 JVM 泛型的擦除机制，所以上面代码可以给 <code>oa[1]</code> 赋值为 ArrayList 也不会出现异常，但是在取出数据的时候却要做一次类型转换，所以就会出现 <code>ClassCastException</code>，如果可以进行泛型数组的声明则上面说的这种情况在编译期不会出现任何警告和错误，只有在运行时才会出错，但是泛型的出现就是为了消灭 <code>ClassCastException</code>，所以如果 Java 支持泛型数组初始化操作就是搬起石头砸自己的脚。</p><p>而对于下面的代码来说是成立的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;?&gt;[] lsa = <span class="keyword">new</span> <span class="title class_">List</span>&lt;?&gt;[<span class="number">10</span>]; <span class="comment">// OK, array of unbounded wildcard type.</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> lsa;</span><br><span class="line">Object[] oa = (Object[]) o;</span><br><span class="line">List&lt;Integer&gt; li = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">li.add(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">3</span>));</span><br><span class="line">oa[<span class="number">1</span>] = li; <span class="comment">// Correct.</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> (Integer) lsa[<span class="number">1</span>].get(<span class="number">0</span>); <span class="comment">// OK</span></span><br></pre></td></tr></table></figure><p>所以说采用通配符的方式初始化泛型数组是允许的，因为对于通配符的方式最后取出数据是要做显式类型转换的，符合预期逻辑。综述就是说Java 的泛型数组初始化时数组类型不能是具体的泛型类型，只能是通配符的形式，因为具体类型会导致可存入任意类型对象，在取出时会发生类型转换异常，会与泛型的设计思想冲突，而通配符形式本来就需要自己强转，符合预期。</p><p>Oracle 官方文档：<a href="https://docs.oracle.com/javase/tutorial/extra/generics/fineprint.html">https://docs.oracle.com/javase/tutorial/extra/generics/fineprint.html在新窗口打开</a></p><p>更进一步的，我们看看如下的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt;[] list11 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;[<span class="number">10</span>]; <span class="comment">//编译错误，非法创建 </span></span><br><span class="line">List&lt;String&gt;[] list12 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;?&gt;[<span class="number">10</span>]; <span class="comment">//编译错误，需要强转类型 </span></span><br><span class="line">List&lt;String&gt;[] list13 = (List&lt;String&gt;[]) <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;?&gt;[<span class="number">10</span>]; <span class="comment">//OK，但是会有警告 </span></span><br><span class="line">List&lt;?&gt;[] list14 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;[<span class="number">10</span>]; <span class="comment">//编译错误，非法创建 </span></span><br><span class="line">List&lt;?&gt;[] list15 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;?&gt;[<span class="number">10</span>]; <span class="comment">//OK </span></span><br><span class="line">List&lt;String&gt;[] list6 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>[<span class="number">10</span>]; <span class="comment">//OK，但是会有警告</span></span><br></pre></td></tr></table></figure><p>因为在 Java 中是不能创建一个确切的泛型类型的数组的，除非是采用通配符的方式且要做显式类型转换才可以。</p><h3 id="泛型数组：如何正确的初始化泛型数组实例？"><a href="#泛型数组：如何正确的初始化泛型数组实例？" class="headerlink" title="# 泛型数组：如何正确的初始化泛型数组实例？"></a><a href="#%E6%B3%9B%E5%9E%8B%E6%95%B0%E7%BB%84-%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B3%9B%E5%9E%8B%E6%95%B0%E7%BB%84%E5%AE%9E%E4%BE%8B">#</a> 泛型数组：如何正确的初始化泛型数组实例？</h3><blockquote><p>这个无论我们通过<code>new ArrayList[10]</code> 的形式还是通过泛型通配符的形式初始化泛型数组实例都是存在警告的，也就是说仅仅语法合格，运行时潜在的风险需要我们自己来承担，因此那些方式初始化泛型数组都不是最优雅的方式。</p></blockquote><p>我们在使用到泛型数组的场景下应该尽量使用列表集合替换，此外也可以通过使用 <code>java.lang.reflect.Array.newInstance(Class&lt;T&gt; componentType, int length)</code> 方法来创建一个具有指定类型和维度的数组，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayWithTypeToken</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T[] array;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayWithTypeToken</span><span class="params">(Class&lt;T&gt; type, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">        array = (T[]) Array.newInstance(type, size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> index, T item)</span> &#123;</span><br><span class="line">        array[index] = item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> array[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T[] create() &#123;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">ArrayWithTypeToken&lt;Integer&gt; arrayToken = <span class="keyword">new</span> <span class="title class_">ArrayWithTypeToken</span>&lt;Integer&gt;(Integer.class, <span class="number">100</span>);</span><br><span class="line">Integer[] array = arrayToken.create();</span><br></pre></td></tr></table></figure><p>所以使用反射来初始化泛型数组算是优雅实现，因为泛型类型 <code>T</code>在运行时才能被确定下来，我们能创建泛型数组也必然是在 Java 运行时想办法，而运行时能起作用的技术最好的就是反射了。</p><h3 id="如何理解泛型类中的静态方法和静态变量？"><a href="#如何理解泛型类中的静态方法和静态变量？" class="headerlink" title="# 如何理解泛型类中的静态方法和静态变量？"></a><a href="#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E6%B3%9B%E5%9E%8B%E7%B1%BB%E4%B8%AD%E7%9A%84%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E5%92%8C%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F">#</a> 如何理解泛型类中的静态方法和静态变量？</h3><blockquote><p>泛型类中的静态方法和静态变量不可以使用泛型类所声明的泛型类型参数</p></blockquote><p>举例说明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span>&lt;T&gt; &#123;    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> T one;   <span class="comment">//编译错误    </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  T <span class="title function_">show</span><span class="params">(T one)</span>&#123; <span class="comment">//编译错误    </span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为泛型类中的泛型参数的实例化是在定义对象的时候指定的，而静态变量和静态方法不需要使用对象来调用。对象都没有创建，如何确定这个泛型参数是何种类型，所以当然是错误的。</p><p>但是要注意区分下面的一种情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span>&lt;T&gt; &#123;    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T &gt;T <span class="title function_">show</span><span class="params">(T one)</span>&#123; <span class="comment">//这是正确的    </span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为这是一个泛型方法，在泛型方法中使用的T是自己在方法中定义的 T，而不是泛型类中的T。</p><h3 id="如何理解异常中使用泛型？"><a href="#如何理解异常中使用泛型？" class="headerlink" title="# 如何理解异常中使用泛型？"></a><a href="#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%BC%82%E5%B8%B8%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%B3%9B%E5%9E%8B">#</a> 如何理解异常中使用泛型？</h3><ul><li><strong>不能抛出也不能捕获泛型类的对象</strong>。事实上，泛型类扩展Throwable都不合法。例如：下面的定义将不会通过编译：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Problem</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">Exception</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么不能扩展Throwable，因为异常都是在运行时捕获和抛出的，而在编译的时候，泛型信息全都会被擦除掉，那么，假设上面的编译可行，那么，在看下面的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span>(Problem&lt;Integer&gt; e1) &#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span>(Problem&lt;Number&gt; e2) &#123;</span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>类型信息被擦除后，那么两个地方的catch都变为原始类型Object，那么也就是说，这两个地方的catch变的一模一样,就相当于下面的这样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span>(Problem&lt;Object&gt; e1) &#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span>(Problem&lt;Object&gt; e2) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个当然就是不行的。</p><ul><li><strong>不能再catch子句中使用泛型变量</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Throwable</span>&gt; <span class="keyword">void</span> <span class="title function_">doWork</span><span class="params">(Class&lt;T&gt; t)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">catch</span>(T e) &#123; <span class="comment">//编译错误</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为泛型信息在编译的时候已经变为原始类型，也就是说上面的T会变为原始类型Throwable，那么如果可以再catch子句中使用泛型变量，那么，下面的定义呢：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Throwable</span>&gt; <span class="keyword">void</span> <span class="title function_">doWork</span><span class="params">(Class&lt;T&gt; t)</span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span>(T e) &#123; <span class="comment">//编译错误</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span>(IndexOutOfBounds e) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;                         </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据异常捕获的原则，一定是子类在前面，父类在后面，那么上面就违背了这个原则。即使你在使用该静态方法的使用T是<code>ArrayIndexOutofBounds</code>，在编译之后还是会变成Throwable，<code>ArrayIndexOutofBounds</code>是IndexOutofBounds的子类，违背了异常捕获的原则。所以java为了避免这样的情况，禁止在catch子句中使用泛型变量。</p><ul><li>但是在异常声明中可以使用类型变量。下面方法是合法的。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Throwable</span>&gt; <span class="keyword">void</span> <span class="title function_">doWork</span><span class="params">(T t)</span> <span class="keyword">throws</span> T &#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">catch</span>(Throwable realCause) &#123;</span><br><span class="line">        t.initCause(realCause);</span><br><span class="line">        <span class="keyword">throw</span> t; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的这样使用是没问题的。</p><h3 id="如何获取泛型的参数类型？"><a href="#如何获取泛型的参数类型？" class="headerlink" title="# 如何获取泛型的参数类型？"></a><a href="#%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E6%B3%9B%E5%9E%8B%E7%9A%84%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B">#</a> 如何获取泛型的参数类型？</h3><blockquote><p>既然类型被擦除了，那么如何获取泛型的参数类型呢？可以通过反射（<code>java.lang.reflect.Type</code>）获取泛型</p></blockquote><p><code>java.lang.reflect.Type</code>是Java中所有类型的公共高级接口, 代表了Java中的所有类型. Type体系中类型的包括：数组类型(GenericArrayType)、参数化类型(ParameterizedType)、类型变量(TypeVariable)、通配符类型(WildcardType)、原始类型(Class)、基本类型(Class), 以上这些类型都实现Type接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericType</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getData</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setData</span><span class="params">(T data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        GenericType&lt;String&gt; genericType = <span class="keyword">new</span> <span class="title class_">GenericType</span>&lt;String&gt;() &#123;&#125;;</span><br><span class="line">        <span class="type">Type</span> <span class="variable">superclass</span> <span class="operator">=</span> genericType.getClass().getGenericSuperclass();</span><br><span class="line">        <span class="comment">//getActualTypeArguments 返回确切的泛型参数, 如Map&lt;String, Integer&gt;返回[String, Integer]</span></span><br><span class="line">        <span class="type">Type</span> <span class="variable">type</span> <span class="operator">=</span> ((ParameterizedType) superclass).getActualTypeArguments()[<span class="number">0</span>]; </span><br><span class="line">        System.out.println(type);<span class="comment">//class java.lang.String</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>ParameterizedType</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ParameterizedType</span> <span class="keyword">extends</span> <span class="title class_">Type</span> &#123;</span><br><span class="line">    <span class="comment">// 返回确切的泛型参数, 如Map&lt;String, Integer&gt;返回[String, Integer]</span></span><br><span class="line">    Type[] getActualTypeArguments();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//返回当前class或interface声明的类型, 如List&lt;?&gt;返回List</span></span><br><span class="line">    Type <span class="title function_">getRawType</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//返回所属类型. 如,当前类型为O&lt;T&gt;.I&lt;S&gt;, 则返回O&lt;T&gt;. 顶级类型将返回null </span></span><br><span class="line">    Type <span class="title function_">getOwnerType</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="# 参考文章"></a><a href="#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0">#</a> 参考文章</h2><blockquote><p>泛型作为Java基础知识点之一，网上知识点比较多也比较散，本文主要综合了网络上比较好的文章，方便你快速学习。（以下是一部分我参考的链接）</p></blockquote><ul><li><a href="https://blog.csdn.net/sunxianghuang/article/details/51982979">https://blog.csdn.net/sunxianghuang/article/details/51982979</a></li><li><a href="https://blog.csdn.net/LonelyRoamer/article/details/7868820">https://blog.csdn.net/LonelyRoamer/article/details/7868820</a></li><li><a href="https://docs.oracle.com/javase/tutorial/extra/generics/index.html">https://docs.oracle.com/javase/tutorial/extra/generics/index.html</a></li><li><a href="https://blog.csdn.net/s10461/article/details/53941091">https://blog.csdn.net/s10461/article/details/53941091</a></li><li><a href="https://www.cnblogs.com/iyangyuan/archive/2013/04/09/3011274.html">https://www.cnblogs.com/iyangyuan/archive/2013/04/09/3011274.html</a></li><li><a href="https://www.cnblogs.com/rudy-laura/articles/3391013.html">https://www.cnblogs.com/rudy-laura/articles/3391013.html</a></li><li><a href="https://www.jianshu.com/p/986f732ed2f1">https://www.jianshu.com/p/986f732ed2f1</a></li><li><a href="https://blog.csdn.net/u011240877/article/details/53545041">https://blog.csdn.net/u011240877/article/details/53545041</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 基础 - 知识点</title>
      <link href="/posts/d9795d88.html"/>
      <url>/posts/d9795d88.html</url>
      
        <content type="html"><![CDATA[<p>摘要</p><span id="more"></span><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="包装类型"><a href="#包装类型" class="headerlink" title="# 包装类型"></a><a href="#%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B">#</a> 包装类型</h3><p>八个基本类型:</p><ul><li>boolean/1</li><li>byte/8</li><li>char/16</li><li>short/16</li><li>int/32</li><li>float/32</li><li>long/64</li><li>double/64</li></ul><p>基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">2</span>;     <span class="comment">// 装箱</span></span><br><span class="line"><span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> x;         <span class="comment">// 拆箱</span></span><br></pre></td></tr></table></figure><h3 id="缓存池"><a href="#缓存池" class="headerlink" title="# 缓存池"></a><a href="#%E7%BC%93%E5%AD%98%E6%B1%A0">#</a> 缓存池</h3><p>new Integer(123) 与 Integer.valueOf(123) 的区别在于:</p><ul><li>new Integer(123) 每次都会新建一个对象</li><li>Integer.valueOf(123) 会使用缓存池中的对象，多次调用会取得同一个对象的引用。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">123</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">y</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">123</span>);</span><br><span class="line">System.out.println(x == y);    <span class="comment">// false</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">z</span> <span class="operator">=</span> Integer.valueOf(<span class="number">123</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">k</span> <span class="operator">=</span> Integer.valueOf(<span class="number">123</span>);</span><br><span class="line">System.out.println(z == k);   <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>valueOf() 方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Java 8 中，Integer 缓存池的大小默认为 -128~127。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> -<span class="number">128</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> high;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="comment">// high value may be configured by property</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">integerCacheHighPropValue</span> <span class="operator">=</span></span><br><span class="line">        sun.misc.VM.getSavedProperty(<span class="string">&quot;java.lang.Integer.IntegerCache.high&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (integerCacheHighPropValue != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> parseInt(integerCacheHighPropValue);</span><br><span class="line">            i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">            <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">            h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">            <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    high = h;</span><br><span class="line"></span><br><span class="line">    cache = <span class="keyword">new</span> <span class="title class_">Integer</span>[(high - low) + <span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> low;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">        cache[k] = <span class="keyword">new</span> <span class="title class_">Integer</span>(j++);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">    <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器会<strong>在缓冲池范围内的基本类型</strong>自动装箱过程调用 valueOf() 方法，因此多个 Integer 实例使用自动装箱来创建并且值相同，那么就会引用相同的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">123</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">123</span>;</span><br><span class="line">System.out.println(m == n); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>基本类型对应的缓冲池如下:</p><ul><li>boolean values true and false</li><li>all byte values</li><li>short values between -128 and 127</li><li>int values between -128 and 127</li><li>char in the range \u0000 to \u007F</li></ul><p>在使用这些基本类型对应的包装类型时，就可以直接使用缓冲池中的对象。</p><p>如果在缓冲池之外：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">323</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">323</span>;</span><br><span class="line">System.out.println(m == n); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h2 id="String"><a href="#String" class="headerlink" title="# String"></a><a href="#string">#</a> String</h2><h3 id="概览"><a href="#概览" class="headerlink" title="# 概览"></a><a href="#%E6%A6%82%E8%A7%88">#</a> 概览</h3><p>String 被声明为 final，因此它不可被继承。</p><p>内部使用 char 数组存储数据，该数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];</span><br></pre></td></tr></table></figure><h3 id="不可变的好处"><a href="#不可变的好处" class="headerlink" title="# 不可变的好处"></a><a href="#%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84%E5%A5%BD%E5%A4%84">#</a> 不可变的好处</h3><p><strong>1. 可以缓存 hash 值</strong></p><p>因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。</p><p><strong>2. String Pool 的需要</strong></p><p>如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230814195714630.png" alt="image-20230814195714630"></p><p><strong>3. 安全性</strong></p><p>String 经常作为参数，String 不可变性可以保证参数不可变。例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，改变 String 对象的那一方以为现在连接的是其它主机，而实际情况却不一定是。</p><p><strong>4. 线程安全</strong></p><p>String 不可变性天生具备线程安全，可以在多个线程中安全地使用。</p><p><a href="https://www.programcreek.com/2013/04/why-string-is-immutable-in-java/">Program Creek : Why String is immutable in Java?在新窗口打开</a></p><h3 id="String-StringBuffer-and-StringBuilder"><a href="#String-StringBuffer-and-StringBuilder" class="headerlink" title="# String, StringBuffer and StringBuilder"></a><a href="#string-stringbuffer-and-stringbuilder">#</a> String, StringBuffer and StringBuilder</h3><p><strong>1. 可变性</strong></p><ul><li>String 不可变</li><li>StringBuffer 和 StringBuilder 可变</li></ul><p><strong>2. 线程安全</strong></p><ul><li>String 不可变，因此是线程安全的</li><li>StringBuilder 不是线程安全的</li><li>StringBuffer 是线程安全的，内部使用 synchronized 进行同步</li></ul><p><a href="https://stackoverflow.com/questions/2971315/string-stringbuffer-and-stringbuilder">StackOverflow : String, StringBuffer, and StringBuilder在新窗口打开</a></p><h3 id="String-intern"><a href="#String-intern" class="headerlink" title="# String.intern()"></a><a href="#string-intern">#</a> String.intern()</h3><p>使用 String.intern() 可以保证相同内容的字符串变量引用同一的内存对象。</p><p>下面示例中，s1 和 s2 采用 new String() 的方式新建了两个不同对象，而 s3 是通过 s1.intern() 方法取得一个对象引用。intern() 首先把 s1 引用的对象放到 String Pool(字符串常量池)中，然后返回这个对象引用。因此 s3 和 s1 引用的是同一个字符串常量池的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">System.out.println(s1 == s2);           <span class="comment">// false</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> s1.intern();</span><br><span class="line">System.out.println(s1.intern() == s3);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>如果是采用 “bbb” 这种使用双引号的形式创建字符串实例，会自动地将新建的对象放入 String Pool 中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;bbb&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> <span class="string">&quot;bbb&quot;</span>;</span><br><span class="line">System.out.println(s4 == s5);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><ul><li><strong>HotSpot中字符串常量池保存哪里？永久代？方法区还是堆区</strong>？</li></ul><ol><li>运行时常量池（Runtime Constant Pool）是虚拟机规范中是方法区的一部分，在加载类和结构到虚拟机后，就会创建对应的运行时常量池；而字符串常量池是这个过程中常量字符串的存放位置。所以从这个角度，字符串常量池属于虚拟机规范中的方法区，它是一个<strong>逻辑上的概念</strong>；而堆区，永久代以及元空间是实际的存放位置。</li><li>不同的虚拟机对虚拟机的规范（比如方法区）是不一样的，只有 HotSpot 才有永久代的概念。</li><li>HotSpot也是发展的，由于<a href="http://openjdk.java.net/jeps/122">一些问题在新窗口打开</a>的存在，HotSpot考虑逐渐去永久代，对于不同版本的JDK，<strong>实际的存储位置</strong>是有差异的，具体看如下表格：</li></ol><table><thead><tr><th>JDK版本</th><th>是否有永久代，字符串常量池放在哪里？</th><th>方法区逻辑上规范，由哪些实际的部分实现的？</th></tr></thead><tbody><tr><td>jdk1.6及之前</td><td>有永久代，运行时常量池（包括字符串常量池），静态变量存放在永久代上</td><td>这个时期方法区在HotSpot中是由永久代来实现的，以至于<strong>这个时期说方法区就是指永久代</strong></td></tr><tr><td>jdk1.7</td><td>有永久代，但已经逐步“去永久代”，字符串常量池、静态变量移除，保存在堆中；</td><td>这个时期方法区在HotSpot中由<strong>永久代</strong>（类型信息、字段、方法、常量）和<strong>堆</strong>（字符串常量池、静态变量）共同实现</td></tr><tr><td>jdk1.8及之后</td><td>取消永久代，类型信息、字段、方法、常量保存在本地内存的元空间，但字符串常量池、静态变量仍在堆中</td><td>这个时期方法区在HotSpot中由本地内存的<strong>元空间</strong>（类型信息、字段、方法、常量）和<strong>堆</strong>（字符串常量池、静态变量）共同实现</td></tr></tbody></table><h2 id="运算"><a href="#运算" class="headerlink" title="# 运算"></a><a href="#%E8%BF%90%E7%AE%97">#</a> 运算</h2><h3 id="参数传递"><a href="#参数传递" class="headerlink" title="# 参数传递"></a><a href="#%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92">#</a> 参数传递</h3><p>Java 的参数是以值传递的形式传入方法中，而不是引用传递。</p><p>以下代码中 Dog dog 的 dog 是一个指针，存储的是对象的地址。在将一个参数传入一个方法时，本质上是将对象的地址以值的方式传递到形参中。因此在方法中改变指针引用的对象，那么这两个指针此时指向的是完全不同的对象，一方改变其所指向对象的内容对另一方没有影响。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    Dog(String name) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">getObjectAddress</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PassByValueExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        System.out.println(dog.getObjectAddress()); <span class="comment">// Dog@4554617c</span></span><br><span class="line">        func(dog);</span><br><span class="line">        System.out.println(dog.getObjectAddress()); <span class="comment">// Dog@4554617c</span></span><br><span class="line">        System.out.println(dog.getName());          <span class="comment">// A</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">func</span><span class="params">(Dog dog)</span> &#123;</span><br><span class="line">        System.out.println(dog.getObjectAddress()); <span class="comment">// Dog@4554617c</span></span><br><span class="line">        dog = <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        System.out.println(dog.getObjectAddress()); <span class="comment">// Dog@74a14482</span></span><br><span class="line">        System.out.println(dog.getName());          <span class="comment">// B</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是如果在方法中改变对象的字段值会改变原对象该字段值，因为改变的是同一个地址指向的内容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PassByValueExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        func(dog);</span><br><span class="line">        System.out.println(dog.getName());          <span class="comment">// B</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">func</span><span class="params">(Dog dog)</span> &#123;</span><br><span class="line">        dog.setName(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://stackoverflow.com/questions/40480/is-java-pass-by-reference-or-pass-by-value">StackOverflow: Is Java “pass-by-reference” or “pass-by-value”?在新窗口打开</a></p><h3 id="float-与-double"><a href="#float-与-double" class="headerlink" title="# float 与 double"></a><a href="#float-%E4%B8%8E-double">#</a> float 与 double</h3><p>1.1 字面量属于 double 类型，不能直接将 1.1 直接赋值给 float 变量，因为这是向下转型。Java 不能隐式执行向下转型，因为这会使得精度降低。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// float f = 1.1;</span></span><br></pre></td></tr></table></figure><p>1.1f 字面量才是 float 类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">1.1f</span>;</span><br></pre></td></tr></table></figure><h3 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="# 隐式类型转换"></a><a href="#%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">#</a> 隐式类型转换</h3><p>因为字面量 1 是 int 类型，它比 short 类型精度要高，因此不能隐式地将 int 类型下转型为 short 类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">short</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="comment">// s1 = s1 + 1;</span></span><br></pre></td></tr></table></figure><p>但是使用 += 运算符可以执行隐式类型转换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s1 += <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>上面的语句相当于将 s1 + 1 的计算结果进行了向下转型:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s1 = (<span class="type">short</span>) (s1 + <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p><a href="https://stackoverflow.com/questions/8710619/why-dont-javas-compound-assignment-operators-require-casting">StackOverflow : Why don’t Java’s +=, -=, *=, /= compound assignment operators require casting?在新窗口打开</a></p><h3 id="switch"><a href="#switch" class="headerlink" title="# switch"></a><a href="#switch">#</a> switch</h3><p>从 Java 7 开始，可以在 switch 条件判断语句中使用 String 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line"><span class="keyword">switch</span> (s) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;a&quot;</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;b&quot;</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>switch 不支持 long，是因为 switch 的设计初衷是对那些只有少数的几个值进行等值判断，如果值过于复杂，那么还是用 if 比较合适。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// long x = 111;</span></span><br><span class="line"><span class="comment">// switch (x) &#123; // Incompatible types. Found: &#x27;long&#x27;, required: &#x27;char, byte, short, int, Character, Byte, Short, Integer, String, or an enum&#x27;</span></span><br><span class="line"><span class="comment">//     case 111:</span></span><br><span class="line"><span class="comment">//         System.out.println(111);</span></span><br><span class="line"><span class="comment">//         break;</span></span><br><span class="line"><span class="comment">//     case 222:</span></span><br><span class="line"><span class="comment">//         System.out.println(222);</span></span><br><span class="line"><span class="comment">//         break;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><p><a href="https://stackoverflow.com/questions/2676210/why-cant-your-switch-statement-data-type-be-long-java">StackOverflow : Why can’t your switch statement data type be long, Java?在新窗口打开</a></p><h2 id="继承"><a href="#继承" class="headerlink" title="# 继承"></a><a href="#%E7%BB%A7%E6%89%BF">#</a> 继承</h2><h3 id="访问权限"><a href="#访问权限" class="headerlink" title="# 访问权限"></a><a href="#%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90">#</a> 访问权限</h3><p>Java 中有三个访问权限修饰符: private、protected 以及 public，如果不加访问修饰符，表示包级可见。</p><p>可以对类或类中的成员(字段以及方法)加上访问修饰符。</p><ul><li>类可见表示其它类可以用这个类创建实例对象。</li><li>成员可见表示其它类可以用这个类的实例对象访问到该成员；</li></ul><p>protected 用于修饰成员，表示在继承体系中成员对于子类可见，但是这个访问修饰符对于类没有意义。</p><p>设计良好的模块会隐藏所有的实现细节，把它的 API 与它的实现清晰地隔离开来。模块之间只通过它们的 API 进行通信，一个模块不需要知道其他模块的内部工作情况，这个概念被称为信息隐藏或封装。因此访问权限应当尽可能地使每个类或者成员不被外界访问。</p><p>如果子类的方法重写了父类的方法，那么子类中该方法的访问级别不允许低于父类的访问级别。这是为了确保可以使用父类实例的地方都可以使用子类实例，也就是确保满足里氏替换原则。</p><p>字段决不能是公有的，因为这么做的话就失去了对这个字段修改行为的控制，客户端可以对其随意修改。例如下面的例子中，AccessExample 拥有 id 共有字段，如果在某个时刻，我们想要使用 int 去存储 id 字段，那么就需要去修改所有的客户端代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccessExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以使用公有的 getter 和 setter 方法来替换公有字段，这样的话就可以控制对字段的修改行为。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccessExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id + <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(String id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = Integer.valueOf(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是也有例外，如果是包级私有的类或者私有的嵌套类，那么直接暴露成员不会有特别大的影响。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccessWithInnerClassExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">InnerClass</span> &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> InnerClass innerClass;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AccessWithInnerClassExample</span><span class="params">()</span> &#123;</span><br><span class="line">        innerClass = <span class="keyword">new</span> <span class="title class_">InnerClass</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> innerClass.x;  <span class="comment">// 直接访问</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="抽象类与接口"><a href="#抽象类与接口" class="headerlink" title="# 抽象类与接口"></a><a href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3">#</a> 抽象类与接口</h3><p><strong>1. 抽象类</strong></p><p>抽象类和抽象方法都使用 abstract 关键字进行声明。抽象类一般会包含抽象方法，抽象方法一定位于抽象类中。</p><p>抽象类和普通类最大的区别是，抽象类不能被实例化，需要继承抽象类才能实例化其子类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractClassExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">func1</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">func2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;func2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AbstractExtendClassExample</span> <span class="keyword">extends</span> <span class="title class_">AbstractClassExample</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">func1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;func1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// AbstractClassExample ac1 = new AbstractClassExample(); // &#x27;AbstractClassExample&#x27; is abstract; cannot be instantiated</span></span><br><span class="line"><span class="type">AbstractClassExample</span> <span class="variable">ac2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AbstractExtendClassExample</span>();</span><br><span class="line">ac2.func1();</span><br></pre></td></tr></table></figure><p><strong>2. 接口</strong></p><p>接口是抽象类的延伸，在 Java 8 之前，它可以看成是一个完全抽象的类，也就是说它不能有任何的方法实现。</p><p>从 Java 8 开始，接口也可以拥有默认的方法实现，这是因为不支持默认方法的接口的维护成本太高了。在 Java 8 之前，如果一个接口想要添加新的方法，那么要修改所有实现了该接口的类。</p><p>接口的成员(字段 + 方法)默认都是 public 的，并且不允许定义为 private 或者 protected。</p><p>接口的字段默认都是 static 和 final 的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">InterfaceExample</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">func1</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">func2</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;func2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">123</span>;</span><br><span class="line">    <span class="comment">// int y;               // Variable &#x27;y&#x27; might not have been initialized</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">z</span> <span class="operator">=</span> <span class="number">0</span>;       <span class="comment">// Modifier &#x27;public&#x27; is redundant for interface fields</span></span><br><span class="line">    <span class="comment">// private int k = 0;   // Modifier &#x27;private&#x27; not allowed here</span></span><br><span class="line">    <span class="comment">// protected int l = 0; // Modifier &#x27;protected&#x27; not allowed here</span></span><br><span class="line">    <span class="comment">// private void fun3(); // Modifier &#x27;private&#x27; not allowed here</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterfaceImplementExample</span> <span class="keyword">implements</span> <span class="title class_">InterfaceExample</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">func1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;func1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// InterfaceExample ie1 = new InterfaceExample(); // &#x27;InterfaceExample&#x27; is abstract; cannot be instantiated</span></span><br><span class="line"><span class="type">InterfaceExample</span> <span class="variable">ie2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InterfaceImplementExample</span>();</span><br><span class="line">ie2.func1();</span><br><span class="line">System.out.println(InterfaceExample.x);</span><br></pre></td></tr></table></figure><p><strong>3. 比较</strong></p><ul><li>从设计层面上看，抽象类提供了一种 IS-A 关系，那么就必须满足里式替换原则，即子类对象必须能够替换掉所有父类对象。而接口更像是一种 LIKE-A 关系，它只是提供一种方法实现契约，并不要求接口和实现接口的类具有 IS-A 关系。</li><li>从使用上来看，一个类可以实现多个接口，但是不能继承多个抽象类。</li><li>接口的字段只能是 static 和 final 类型的，而抽象类的字段没有这种限制。</li><li>接口的成员只能是 public 的，而抽象类的成员可以有多种访问权限。</li></ul><p><strong>4. 使用选择</strong></p><p>使用接口:</p><ul><li>需要让不相关的类都实现一个方法，例如不相关的类都可以实现 Compareable 接口中的 compareTo() 方法；</li><li>需要使用多重继承。</li></ul><p>使用抽象类:</p><ul><li>需要在几个相关的类中共享代码。</li><li>需要能控制继承来的成员的访问权限，而不是都为 public。</li><li>需要继承非静态和非常量字段。</li></ul><p>在很多情况下，接口优先于抽象类，因为接口没有抽象类严格的类层次结构要求，可以灵活地为一个类添加行为。并且从 Java 8 开始，接口也可以有默认的方法实现，使得修改接口的成本也变的很低。</p><ul><li><a href="https://www.ibm.com/developerworks/cn/java/l-javainterface-abstract/">深入理解 abstract class 和 interface在新窗口打开</a></li><li><a href="https://dzone.com/articles/when-to-use-abstract-class-and-intreface">When to Use Abstract Class and Interface在新窗口打开</a></li></ul><h3 id="super"><a href="#super" class="headerlink" title="# super"></a><a href="#super">#</a> super</h3><ul><li>访问父类的构造函数: 可以使用 super() 函数访问父类的构造函数，从而委托父类完成一些初始化的工作。</li><li>访问父类的成员: 如果子类重写了父类的中某个方法的实现，可以通过使用 super 关键字来引用父类的方法实现。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SuperExample</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SuperExample</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;SuperExample.func()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SuperExtendExample</span> <span class="keyword">extends</span> <span class="title class_">SuperExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> z;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SuperExtendExample</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(x, y);</span><br><span class="line">        <span class="built_in">this</span>.z = z;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.func();</span><br><span class="line">        System.out.println(<span class="string">&quot;SuperExtendExample.func()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">SuperExample</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SuperExtendExample</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">e.func();</span><br><span class="line">SuperExample.func()</span><br><span class="line">SuperExtendExample.func()</span><br></pre></td></tr></table></figure><p><a href="https://docs.oracle.com/javase/tutorial/java/IandI/super.html">Using the Keyword super在新窗口打开</a></p><h3 id="重写与重载"><a href="#重写与重载" class="headerlink" title="# 重写与重载"></a><a href="#%E9%87%8D%E5%86%99%E4%B8%8E%E9%87%8D%E8%BD%BD">#</a> 重写与重载</h3><p><strong>1. 重写(Override)</strong></p><p>存在于继承体系中，指子类实现了一个与父类在方法声明上完全相同的一个方法。</p><p>为了满足里式替换原则，重写有以下两个限制:</p><ul><li>子类方法的访问权限必须大于等于父类方法；</li><li>子类方法的返回类型必须是父类方法返回类型或为其子类型。</li></ul><p>使用 @Override 注解，可以让编译器帮忙检查是否满足上面的两个限制条件。</p><p><strong>2. 重载(Overload)</strong></p><p>存在于同一个类中，指一个方法与已经存在的方法名称上相同，但是参数类型、个数、顺序至少有一个不同。</p><p>应该注意的是，返回值不同，其它都相同不算是重载。</p><h2 id="Object-通用方法"><a href="#Object-通用方法" class="headerlink" title="# Object 通用方法"></a><a href="#object-%E9%80%9A%E7%94%A8%E6%96%B9%E6%B3%95">#</a> Object 通用方法</h2><h3 id="概览-1"><a href="#概览-1" class="headerlink" title="# 概览"></a><a href="#%E6%A6%82%E8%A7%88-1">#</a> 概览</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notifyAll</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout, <span class="type">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="equals"><a href="#equals" class="headerlink" title="# equals()"></a><a href="#equals">#</a> equals()</h3><p><strong>1. 等价关系</strong></p><p>(一)自反性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x.equals(x); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>(二)对称性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x.equals(y) == y.equals(x); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>(三)传递性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x.equals(y) &amp;&amp; y.equals(z))</span><br><span class="line">    x.equals(z); <span class="comment">// true;</span></span><br></pre></td></tr></table></figure><p>(四)一致性</p><p>多次调用 equals() 方法结果不变</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x.equals(y) == x.equals(y); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>(五)与 null 的比较</p><p>对任何不是 null 的对象 x 调用 x.equals(null) 结果都为 false</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x.equals(<span class="literal">null</span>); <span class="comment">// false;</span></span><br></pre></td></tr></table></figure><p><strong>2. equals() 与 ==</strong></p><ul><li>对于基本类型，== 判断两个值是否相等，基本类型没有 equals() 方法。</li><li>对于引用类型，== 判断两个变量是否引用同一个对象，而 equals() 判断引用的对象是否等价。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">y</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>);</span><br><span class="line">System.out.println(x.equals(y)); <span class="comment">// true</span></span><br><span class="line">System.out.println(x == y);      <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p><strong>3. 实现</strong></p><ul><li>检查是否为同一个对象的引用，如果是直接返回 true；</li><li>检查是否是同一个类型，如果不是，直接返回 false；</li><li>将 Object 对象进行转型；</li><li>判断每个关键域是否相等。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EqualExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> y;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> z;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">EqualExample</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">        <span class="built_in">this</span>.z = z;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">EqualExample</span> <span class="variable">that</span> <span class="operator">=</span> (EqualExample) o;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (x != that.x) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (y != that.y) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> z == that.z;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="hashCode"><a href="#hashCode" class="headerlink" title="# hashCode()"></a><a href="#hashcode">#</a> hashCode()</h3><p>hashCode() 返回散列值，而 equals() 是用来判断两个对象是否等价。等价的两个对象散列值一定相同，但是散列值相同的两个对象不一定等价。</p><p>在覆盖 equals() 方法时应当总是覆盖 hashCode() 方法，保证等价的两个对象散列值也相等。</p><p>下面的代码中，新建了两个等价的对象，并将它们添加到 HashSet 中。我们希望将这两个对象当成一样的，只在集合中添加一个对象，但是因为 EqualExample 没有实现 hasCode() 方法，因此这两个对象的散列值是不同的，最终导致集合添加了两个等价的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">EqualExample</span> <span class="variable">e1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EqualExample</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="type">EqualExample</span> <span class="variable">e2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EqualExample</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">System.out.println(e1.equals(e2)); <span class="comment">// true</span></span><br><span class="line">HashSet&lt;EqualExample&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">set.add(e1);</span><br><span class="line">set.add(e2);</span><br><span class="line">System.out.println(set.size());   <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>理想的散列函数应当具有均匀性，即不相等的对象应当均匀分布到所有可能的散列值上。这就要求了散列函数要把所有域的值都考虑进来，可以将每个域都当成 R 进制的某一位，然后组成一个 R 进制的整数。R 一般取 31，因为它是一个奇素数，如果是偶数的话，当出现乘法溢出，信息就会丢失，因为与 2 相乘相当于向左移一位。</p><p>一个数与 31 相乘可以转换成移位和减法: <code>31*x == (x&lt;&lt;5)-x</code>，编译器会自动进行这个优化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">17</span>;</span><br><span class="line">    result = <span class="number">31</span> * result + x;</span><br><span class="line">    result = <span class="number">31</span> * result + y;</span><br><span class="line">    result = <span class="number">31</span> * result + z;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="# toString()"></a><a href="#tostring">#</a> toString()</h3><p>默认返回 ToStringExample@4554617c 这种形式，其中 @ 后面的数值为散列码的无符号十六进制表示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ToStringExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> number;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ToStringExample</span><span class="params">(<span class="type">int</span> number)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.number = number;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">ToStringExample</span> <span class="variable">example</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ToStringExample</span>(<span class="number">123</span>);</span><br><span class="line">System.out.println(example.toString());</span><br><span class="line">ToStringExample@4554617c</span><br></pre></td></tr></table></figure><h3 id="clone"><a href="#clone" class="headerlink" title="# clone()"></a><a href="#clone">#</a> clone()</h3><p><strong>1. cloneable</strong></p><p>clone() 是 Object 的 protected 方法，它不是 public，一个类不显式去重写 clone()，其它类就不能直接去调用该类实例的 clone() 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CloneExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> a;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">CloneExample</span> <span class="variable">e1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CloneExample</span>();</span><br><span class="line"><span class="comment">// CloneExample e2 = e1.clone(); // &#x27;clone()&#x27; has protected access in &#x27;java.lang.Object&#x27;</span></span><br></pre></td></tr></table></figure><p>重写 clone() 得到以下实现:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CloneExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> a;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> b;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> CloneExample <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> (CloneExample)<span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">CloneExample</span> <span class="variable">e1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CloneExample</span>();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">CloneExample</span> <span class="variable">e2</span> <span class="operator">=</span> e1.clone();</span><br><span class="line">&#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">java.lang.CloneNotSupportedException: CloneExample</span><br></pre></td></tr></table></figure><p>以上抛出了 CloneNotSupportedException，这是因为 CloneExample 没有实现 Cloneable 接口。</p><p>应该注意的是，clone() 方法并不是 Cloneable 接口的方法，而是 Object 的一个 protected 方法。Cloneable 接口只是规定，如果一个类没有实现 Cloneable 接口又调用了 clone() 方法，就会抛出 CloneNotSupportedException。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CloneExample</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> a;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> b;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. 浅拷贝</strong></p><p>拷贝对象和原始对象的引用类型引用同一个对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShallowCloneExample</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ShallowCloneExample</span><span class="params">()</span> &#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            arr[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        arr[index] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> arr[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> ShallowCloneExample <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> (ShallowCloneExample) <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">ShallowCloneExample</span> <span class="variable">e1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShallowCloneExample</span>();</span><br><span class="line"><span class="type">ShallowCloneExample</span> <span class="variable">e2</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    e2 = e1.clone();</span><br><span class="line">&#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">e1.set(<span class="number">2</span>, <span class="number">222</span>);</span><br><span class="line">System.out.println(e2.get(<span class="number">2</span>)); <span class="comment">// 222</span></span><br></pre></td></tr></table></figure><p><strong>3. 深拷贝</strong></p><p>拷贝对象和原始对象的引用类型引用不同对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeepCloneExample</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DeepCloneExample</span><span class="params">()</span> &#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            arr[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        arr[index] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> arr[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> DeepCloneExample <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="type">DeepCloneExample</span> <span class="variable">result</span> <span class="operator">=</span> (DeepCloneExample) <span class="built_in">super</span>.clone();</span><br><span class="line">        result.arr = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            result.arr[i] = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">DeepCloneExample</span> <span class="variable">e1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeepCloneExample</span>();</span><br><span class="line"><span class="type">DeepCloneExample</span> <span class="variable">e2</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    e2 = e1.clone();</span><br><span class="line">&#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">e1.set(<span class="number">2</span>, <span class="number">222</span>);</span><br><span class="line">System.out.println(e2.get(<span class="number">2</span>)); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p><strong>4. clone() 的替代方案</strong></p><p>使用 clone() 方法来拷贝一个对象即复杂又有风险，它会抛出异常，并且还需要类型转换。Effective Java 书上讲到，最好不要去使用 clone()，可以使用拷贝构造函数或者拷贝工厂来拷贝一个对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CloneConstructorExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CloneConstructorExample</span><span class="params">()</span> &#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            arr[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CloneConstructorExample</span><span class="params">(CloneConstructorExample original)</span> &#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="title class_">int</span>[original.arr.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; original.arr.length; i++) &#123;</span><br><span class="line">            arr[i] = original.arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        arr[index] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> arr[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">CloneConstructorExample</span> <span class="variable">e1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CloneConstructorExample</span>();</span><br><span class="line"><span class="type">CloneConstructorExample</span> <span class="variable">e2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CloneConstructorExample</span>(e1);</span><br><span class="line">e1.set(<span class="number">2</span>, <span class="number">222</span>);</span><br><span class="line">System.out.println(e2.get(<span class="number">2</span>)); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h2 id="关键字"><a href="#关键字" class="headerlink" title="# 关键字"></a><a href="#%E5%85%B3%E9%94%AE%E5%AD%97">#</a> 关键字</h2><h3 id="final"><a href="#final" class="headerlink" title="# final"></a><a href="#final">#</a> final</h3><p><strong>1. 数据</strong></p><p>声明数据为常量，可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量。</p><ul><li>对于基本类型，final 使数值不变；</li><li>对于引用类型，final 使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="comment">// x = 2;  // cannot assign value to final variable &#x27;x&#x27;</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">A</span> <span class="variable">y</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">y.a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><strong>2. 方法</strong></p><p>声明方法不能被子类重写。</p><p>private 方法隐式地被指定为 final，如果在子类中定义的方法和基类中的一个 private 方法签名相同，此时子类的方法不是重写基类方法，而是在子类中定义了一个新的方法。</p><p><strong>3. 类</strong></p><p>声明类不允许被继承。</p><h3 id="static"><a href="#static" class="headerlink" title="# static"></a><a href="#static">#</a> static</h3><p><strong>1. 静态变量</strong></p><ul><li>静态变量: 又称为类变量，也就是说这个变量属于类的，类所有的实例都共享静态变量，可以直接通过类名来访问它；静态变量在内存中只存在一份。</li><li>实例变量: 每创建一个实例就会产生一个实例变量，它与该实例同生共死。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> x;         <span class="comment">// 实例变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> y;  <span class="comment">// 静态变量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// int x = A.x;  // Non-static field &#x27;x&#x27; cannot be referenced from a static context</span></span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> a.x;</span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> A.y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. 静态方法</strong></p><p>静态方法在类加载的时候就存在了，它不依赖于任何实例。所以静态方法必须有实现，也就是说它不能是抽象方法(abstract)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">func1</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// public abstract static void func2();  // Illegal combination of modifiers: &#x27;abstract&#x27; and &#x27;static&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只能访问所属类的静态字段和静态方法，方法中不能有 this 和 super 关键字。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">func1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> x;</span><br><span class="line">        <span class="comment">// int b = y;  // Non-static field &#x27;y&#x27; cannot be referenced from a static context</span></span><br><span class="line">        <span class="comment">// int b = this.y;     // &#x27;A.this&#x27; cannot be referenced from a static context</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3. 静态语句块</strong></p><p>静态语句块在类初始化时运行一次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">A</span> <span class="variable">a1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        <span class="type">A</span> <span class="variable">a2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure><p><strong>4. 静态内部类</strong></p><p>非静态内部类依赖于外部类的实例，而静态内部类不需要。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OuterClass</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">InnerClass</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">StaticInnerClass</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// InnerClass innerClass = new InnerClass(); // &#x27;OuterClass.this&#x27; cannot be referenced from a static context</span></span><br><span class="line">        <span class="type">OuterClass</span> <span class="variable">outerClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OuterClass</span>();</span><br><span class="line">        <span class="type">InnerClass</span> <span class="variable">innerClass</span> <span class="operator">=</span> outerClass.<span class="keyword">new</span> <span class="title class_">InnerClass</span>();</span><br><span class="line">        <span class="type">StaticInnerClass</span> <span class="variable">staticInnerClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StaticInnerClass</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态内部类不能访问外部类的非静态的变量和方法。</p><p><strong>5. 静态导包</strong></p><p>在使用静态变量和方法时不用再指明 ClassName，从而简化代码，但可读性大大降低。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.xxx.ClassName.*</span><br></pre></td></tr></table></figure><p><strong>6. 初始化顺序</strong></p><p>静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">staticField</span> <span class="operator">=</span> <span class="string">&quot;静态变量&quot;</span>;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;静态语句块&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">String</span> <span class="variable">field</span> <span class="operator">=</span> <span class="string">&quot;实例变量&quot;</span>;</span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;普通语句块&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后才是构造函数的初始化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">InitialOrderTest</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;构造函数&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>存在继承的情况下，初始化顺序为:</p><ul><li>父类(静态变量、静态语句块)</li><li>子类(静态变量、静态语句块)</li><li>父类(实例变量、普通语句块)</li><li>父类(构造函数)</li><li>子类(实例变量、普通语句块)</li><li>子类(构造函数)</li></ul><h2 id="反射"><a href="#反射" class="headerlink" title="# 反射"></a><a href="#%E5%8F%8D%E5%B0%84">#</a> 反射</h2><p>每个类都有一个 <strong>Class</strong> 对象，包含了与类有关的信息。当编译一个新类时，会产生一个同名的 .class 文件，该文件内容保存着 Class 对象。</p><p>类加载相当于 Class 对象的加载。类在第一次使用时才动态加载到 JVM 中，可以使用 <code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;)</code> 这种方式来控制类的加载，该方法会返回一个 Class 对象。</p><p>反射可以提供运行时的类信息，并且这个类可以在运行时才加载进来，甚至在编译时期该类的 .class 不存在也可以加载进来。</p><p>Class 和 java.lang.reflect 一起对反射提供了支持，java.lang.reflect 类库主要包含了以下三个类:</p><ul><li><strong>Field</strong> : 可以使用 get() 和 set() 方法读取和修改 Field 对象关联的字段；</li><li><strong>Method</strong> : 可以使用 invoke() 方法调用与 Method 对象关联的方法；</li><li><strong>Constructor</strong> : 可以用 Constructor 创建新的对象。</li></ul><p><strong>Advantages of Using Reflection:</strong></p><ul><li><strong>Extensibility Features</strong> : An application may make use of external, user-defined classes by creating instances of extensibility objects using their fully-qualified names.</li><li><strong>Class Browsers and Visual Development Environments</strong> : A class browser needs to be able to enumerate the members of classes. Visual development environments can benefit from making use of type information available in reflection to aid the developer in writing correct code.</li><li><strong>Debuggers and Test Tools</strong> : Debuggers need to be able to examine private members on classes. Test harnesses can make use of reflection to systematically call a discoverable set APIs defined on a class, to insure a high level of code coverage in a test suite.</li></ul><p><strong>Drawbacks of Reflection:</strong></p><p>Reflection is powerful, but should not be used indiscriminately. If it is possible to perform an operation without using reflection, then it is preferable to avoid using it. The following concerns should be kept in mind when accessing code via reflection.</p><ul><li><strong>Performance Overhead</strong> : Because reflection involves types that are dynamically resolved, certain Java virtual machine optimizations can not be performed. Consequently, reflective operations have slower performance than their non-reflective counterparts, and should be avoided in sections of code which are called frequently in performance-sensitive applications.</li><li><strong>Security Restrictions</strong> : Reflection requires a runtime permission which may not be present when running under a security manager. This is in an important consideration for code which has to run in a restricted security context, such as in an Applet.</li><li><strong>Exposure of Internals</strong> :Since reflection allows code to perform operations that would be illegal in non-reflective code, such as accessing private fields and methods, the use of reflection can result in unexpected side-effects, which may render code dysfunctional and may destroy portability. Reflective code breaks abstractions and therefore may change behavior with upgrades of the platform.</li></ul><p>相关文章：<a href="">Java 基础 - 反射机制详解</a></p><h2 id="异常"><a href="#异常" class="headerlink" title="# 异常"></a><a href="#%E5%BC%82%E5%B8%B8">#</a> 异常</h2><p>Throwable 可以用来表示任何可以作为异常抛出的类，分为两种: <strong>Error</strong> 和 <strong>Exception</strong>。其中 Error 用来表示 JVM 无法处理的错误，Exception 分为两种:</p><ul><li><strong>受检异常</strong> : 需要用 try…catch… 语句捕获并进行处理，并且可以从异常中恢复；</li><li><strong>非受检异常</strong> : 是程序运行时错误，例如除 0 会引发 Arithmetic Exception，此时程序崩溃并且无法恢复。</li></ul><p><img src="images/pics/PPjwP.png" alt="img"></p><p>相关文章：<a href="">Java 基础 - 异常机制详解</a></p><h2 id="泛型"><a href="#泛型" class="headerlink" title="# 泛型"></a><a href="#%E6%B3%9B%E5%9E%8B">#</a> 泛型</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Box</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">// T stands for &quot;Type&quot;</span></span><br><span class="line">    <span class="keyword">private</span> T t;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T t)</span> &#123; <span class="built_in">this</span>.t = t; &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123; <span class="keyword">return</span> t; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相关文章：<a href="">Java 基础 - 泛型机制详解</a></p><h2 id="注解"><a href="#注解" class="headerlink" title="# 注解"></a><a href="#%E6%B3%A8%E8%A7%A3">#</a> 注解</h2><p>Java 注解是附加在代码中的一些元信息，用于一些工具在编译、运行时进行解析和使用，起到说明、配置的功能。注解不会也不能影响代码的实际逻辑，仅仅起到辅助性的作用。</p><p>相关文章：<a href="">Java 基础 - 注解机制详解</a></p><h2 id="特性"><a href="#特性" class="headerlink" title="# 特性"></a><a href="#%E7%89%B9%E6%80%A7">#</a> 特性</h2><h3 id="Java-各版本的新特性"><a href="#Java-各版本的新特性" class="headerlink" title="# Java 各版本的新特性"></a><a href="#java-%E5%90%84%E7%89%88%E6%9C%AC%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7">#</a> Java 各版本的新特性</h3><p><strong>New highlights in Java SE 8</strong></p><ol><li>Lambda Expressions</li><li>Pipelines and Streams</li><li>Date and Time API</li><li>Default Methods</li><li>Type Annotations</li><li>Nashhorn JavaScript Engine</li><li>Concurrent Accumulators</li><li>Parallel operations</li><li>PermGen Error Removed</li></ol><p><strong>New highlights in Java SE 7</strong></p><ol><li>Strings in Switch Statement</li><li>Type Inference for Generic Instance Creation</li><li>Multiple Exception Handling</li><li>Support for Dynamic Languages</li><li>Try with Resources</li><li>Java nio Package</li><li>Binary Literals, Underscore in literals</li><li>Diamond Syntax</li></ol><ul><li><a href="http://www.selfgrowth.com/articles/difference-between-java-18-and-java-17">Difference between Java 1.8 and Java 1.7?在新窗口打开</a></li><li><a href="http://www.importnew.com/19345.html">Java 8 特性在新窗口打开</a></li></ul><h3 id="Java-与-C-的区别"><a href="#Java-与-C-的区别" class="headerlink" title="# Java 与 C++ 的区别"></a><a href="#java-%E4%B8%8E-c-%E7%9A%84%E5%8C%BA%E5%88%AB">#</a> Java 与 C++ 的区别</h3><ul><li>Java 是纯粹的面向对象语言，所有的对象都继承自 java.lang.Object，C++ 为了兼容 C 即支持面向对象也支持面向过程。</li><li>Java 通过虚拟机从而实现跨平台特性，但是 C++ 依赖于特定的平台。</li><li>Java 没有指针，它的引用可以理解为安全指针，而 C++ 具有和 C 一样的指针。</li><li>Java 支持自动垃圾回收，而 C++ 需要手动回收。</li><li>Java 不支持多重继承，只能通过实现多个接口来达到相同目的，而 C++ 支持多重继承。</li><li>Java 不支持操作符重载，虽然可以对两个 String 对象支持加法运算，但是这是语言内置支持的操作，不属于操作符重载，而 C++ 可以。</li><li>Java 的 goto 是保留字，但是不可用，C++ 可以使用 goto。</li><li>Java 不支持条件编译，C++ 通过 #ifdef #ifndef 等预处理命令从而实现条件编译。</li></ul><p><a href="http://cs-fundamentals.com/tech-interview/java/differences-between-java-and-cpp.php">What are the main differences between Java and C++?在新窗口打开</a></p><h3 id="JRE-or-JDK"><a href="#JRE-or-JDK" class="headerlink" title="# JRE or JDK"></a><a href="#jre-or-jdk">#</a> JRE or JDK</h3><ul><li>JRE is the JVM program, Java application need to run on JRE.</li><li>JDK is a superset of JRE, JRE + tools for developing java programs. e.g, it provides the compiler “javac”</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="# 参考资料"></a><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">#</a> 参考资料</h2><ul><li>Eckel B. Java 编程思想[M]. 机械工业出版社, 2002.</li><li>Bloch J. Effective java[M]. Addison-Wesley Professional, 2017.</li></ul>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java面向对象</title>
      <link href="/posts/ef5980bd.html"/>
      <url>/posts/ef5980bd.html</url>
      
        <content type="html"><![CDATA[<p>java面向对象</p><span id="more"></span><h2 id="三大特性"><a href="#三大特性" class="headerlink" title="三大特性"></a>三大特性</h2><h3 id="封装"><a href="#封装" class="headerlink" title="# 封装"></a><a href="#%E5%B0%81%E8%A3%85">#</a> 封装</h3><p>利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体。数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外接口使之与外部发生联系。用户无需知道对象内部的细节，但可以通过对象对外提供的接口来访问该对象。</p><p>优点:</p><ul><li>减少耦合: 可以独立地开发、测试、优化、使用、理解和修改</li><li>减轻维护的负担: 可以更容易被程序员理解，并且在调试的时候可以不影响其他模块</li><li>有效地调节性能: 可以通过剖析确定哪些模块影响了系统的性能</li><li>提高软件的可重用性</li><li>降低了构建大型系统的风险: 即使整个系统不可用，但是这些独立的模块却有可能是可用的</li></ul><p>以下 Person 类封装 name、gender、age 等属性，外界只能通过 get() 方法获取一个 Person 对象的 name 属性和 gender 属性，而无法获取 age 属性，但是 age 属性可以供 work() 方法使用。</p><p>注意到 gender 属性使用 int 数据类型进行存储，封装使得用户注意不到这种实现细节。并且在需要修改 gender 属性使用的数据类型时，也可以在不影响客户端代码的情况下进行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> gender;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getGender</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> gender == <span class="number">0</span> ? <span class="string">&quot;man&quot;</span> : <span class="string">&quot;woman&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">18</span> &lt;= age &amp;&amp; age &lt;= <span class="number">50</span>) &#123;</span><br><span class="line">            System.out.println(name + <span class="string">&quot; is working very hard!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(name + <span class="string">&quot; can&#x27;t work any more!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承实现了 <strong>IS-A</strong> 关系，例如 Cat 和 Animal 就是一种 IS-A 关系，因此 Cat 可以继承自 Animal，从而获得 Animal 非 private 的属性和方法。</p><p>继承应该遵循里氏替换原则，子类对象必须能够替换掉所有父类对象。</p><p>Cat 可以当做 Animal 来使用，也就是说可以使用 Animal 引用 Cat 对象。父类引用指向子类对象称为 <strong>向上转型</strong> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br></pre></td></tr></table></figure><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态分为编译时多态和运行时多态:</p><ul><li>编译时多态主要指方法的重载</li><li>运行时多态指程序中定义的对象引用所指向的具体类型在运行期间才确定</li></ul><p>运行时多态有三个条件:</p><ul><li>继承</li><li>覆盖(重写)</li><li>向上转型</li></ul><p>下面的代码中，乐器类(Instrument)有两个子类: Wind 和 Percussion，它们都覆盖了父类的 play() 方法，并且在 main() 方法中使用父类 Instrument 来引用 Wind 和 Percussion 对象。在 Instrument 引用调用 play() 方法时，会执行实际引用对象所在类的 play() 方法，而不是 Instrument 类的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Instrument</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Instrument is playing...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Wind</span> <span class="keyword">extends</span> <span class="title class_">Instrument</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Wind is playing...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Percussion</span> <span class="keyword">extends</span> <span class="title class_">Instrument</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Percussion is playing...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Music</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Instrument&gt; instruments = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        instruments.add(<span class="keyword">new</span> <span class="title class_">Wind</span>());</span><br><span class="line">        instruments.add(<span class="keyword">new</span> <span class="title class_">Percussion</span>());</span><br><span class="line">        <span class="keyword">for</span>(Instrument instrument : instruments) &#123;</span><br><span class="line">            instrument.play();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类图"><a href="#类图" class="headerlink" title="# 类图"></a><a href="#%E7%B1%BB%E5%9B%BE">#</a> 类图</h2><p>以下类图使用 <a href="https://www.planttext.com/">PlantUML在新窗口打开</a> 绘制，更多语法及使用请参考: <a href="http://plantuml.com/">http://plantuml.com/</a> 。</p><h3 id="泛化关系-Generalization"><a href="#泛化关系-Generalization" class="headerlink" title="# 泛化关系 (Generalization)"></a><a href="#%E6%B3%9B%E5%8C%96%E5%85%B3%E7%B3%BB-generalization">#</a> 泛化关系 (Generalization)</h3><p>用来描述继承关系，在 Java 中使用 extends 关键字。</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230814191623527.png" alt="image-20230814191623527"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line"></span><br><span class="line">title Generalization</span><br><span class="line"></span><br><span class="line">class Vehical</span><br><span class="line">class Car</span><br><span class="line">class Truck</span><br><span class="line"></span><br><span class="line">Vehical &lt;|-- Car</span><br><span class="line">Vehical &lt;|-- Truck</span><br><span class="line"></span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><h3 id="实现关系-Realization"><a href="#实现关系-Realization" class="headerlink" title="# 实现关系 (Realization)"></a><a href="#%E5%AE%9E%E7%8E%B0%E5%85%B3%E7%B3%BB-realization">#</a> 实现关系 (Realization)</h3><p>用来实现一个接口，在 Java 中使用 implements 关键字。</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230814191700265.png" alt="image-20230814191700265"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line"></span><br><span class="line">title Realization</span><br><span class="line"></span><br><span class="line">interface MoveBehavior</span><br><span class="line">class Fly</span><br><span class="line">class Run</span><br><span class="line"></span><br><span class="line">MoveBehavior &lt;|.. Fly</span><br><span class="line">MoveBehavior &lt;|.. Run</span><br><span class="line"></span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><h3 id="聚合关系-Aggregation"><a href="#聚合关系-Aggregation" class="headerlink" title="# 聚合关系 (Aggregation)"></a><a href="#%E8%81%9A%E5%90%88%E5%85%B3%E7%B3%BB-aggregation">#</a> 聚合关系 (Aggregation)</h3><p>表示整体由部分组成，但是整体和部分不是强依赖的，整体不存在了部分还是会存在。</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230814194959080.png" alt="image-20230814194959080"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line"></span><br><span class="line">title Aggregation</span><br><span class="line"></span><br><span class="line">class Computer</span><br><span class="line">class Keyboard</span><br><span class="line">class Mouse</span><br><span class="line">class Screen</span><br><span class="line"></span><br><span class="line">Computer o-- Keyboard</span><br><span class="line">Computer o-- Mouse</span><br><span class="line">Computer o-- Screen</span><br><span class="line"></span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><h3 id="组合关系-Composition"><a href="#组合关系-Composition" class="headerlink" title="# 组合关系 (Composition)"></a><a href="#%E7%BB%84%E5%90%88%E5%85%B3%E7%B3%BB-composition">#</a> 组合关系 (Composition)</h3><p>和聚合不同，组合中整体和部分是强依赖的，整体不存在了部分也不存在了。比如公司和部门，公司没了部门就不存在了。但是公司和员工就属于聚合关系了，因为公司没了员工还在。</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230814195034025.png" alt="image-20230814195034025"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line"></span><br><span class="line">title Composition</span><br><span class="line"></span><br><span class="line">class Company</span><br><span class="line">class DepartmentA</span><br><span class="line">class DepartmentB</span><br><span class="line"></span><br><span class="line">Company *-- DepartmentA</span><br><span class="line">Company *-- DepartmentB</span><br><span class="line"></span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><h3 id="关联关系-Association"><a href="#关联关系-Association" class="headerlink" title="# 关联关系 (Association)"></a><a href="#%E5%85%B3%E8%81%94%E5%85%B3%E7%B3%BB-association">#</a> 关联关系 (Association)</h3><p>表示不同类对象之间有关联，这是一种静态关系，与运行过程的状态无关，在最开始就可以确定。因此也可以用 1 对 1、多对 1、多对多这种关联关系来表示。比如学生和学校就是一种关联关系，一个学校可以有很多学生，但是一个学生只属于一个学校，因此这是一种多对一的关系，在运行开始之前就可以确定。</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230814195122584.png" alt="image-20230814195122584"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line"></span><br><span class="line">title Association</span><br><span class="line"></span><br><span class="line">class School</span><br><span class="line">class Student</span><br><span class="line"></span><br><span class="line">School <span class="string">&quot;1&quot;</span> - <span class="string">&quot;n&quot;</span> Student</span><br><span class="line"></span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><h3 id="依赖关系-Dependency"><a href="#依赖关系-Dependency" class="headerlink" title="# 依赖关系 (Dependency)"></a><a href="#%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB-dependency">#</a> 依赖关系 (Dependency)</h3><p>和关联关系不同的是，依赖关系是在运行过程中起作用的。A 类和 B 类是依赖关系主要有三种形式:</p><ul><li>A 类是 B 类中的(某中方法的)局部变量；</li><li>A 类是 B 类方法当中的一个参数；</li><li>A 类向 B 类发送消息，从而影响 B 类发生变化；</li></ul><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230814195135119.png" alt="image-20230814195135119"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line"></span><br><span class="line">title Dependency</span><br><span class="line"></span><br><span class="line">class Vehicle &#123;</span><br><span class="line">    move(MoveBehavior)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface MoveBehavior &#123;</span><br><span class="line">    move()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">note <span class="string">&quot;MoveBehavior.move()&quot;</span> as N</span><br><span class="line"></span><br><span class="line">Vehicle ..&gt; MoveBehavior</span><br><span class="line"></span><br><span class="line">Vehicle .. N</span><br><span class="line"></span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="# 参考资料"></a><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">#</a> 参考资料</h2><ul><li>Java 编程思想</li><li>敏捷软件开发: 原则、模式与实践</li><li><a href="http://www.cnblogs.com/shanyou/archive/2009/09/21/1570716.html">面向对象设计的 SOLID 原则在新窗口打开</a></li><li><a href="http://design-patterns.readthedocs.io/zh_CN/latest/read_uml.html#generalization">看懂 UML 类图和时序图在新窗口打开</a></li><li><a href="http://www.cnblogs.com/wolf-sun/p/UML-Sequence-diagram.html">UML 系列——时序图(顺序图)sequence diagram在新窗口打开</a></li><li><a href="http://blog.csdn.net/jianyuerensheng/article/details/51602015">面向对象编程三大特性 —— 封装、继承、多态在新窗口打开</a></li><li>javaoop基础知识总结 <a href="https://blog.csdn.net/weixin_38173324/article/details/70037927">https://blog.csdn.net/weixin_38173324/article/details/70037927</a></li><li>Java实现OOP(面向对象编程) <a href="https://www.cnblogs.com/AlanLee/p/6475334.html">https://www.cnblogs.com/AlanLee/p/6475334.html</a></li><li>Java 抽象类与oop三大特征 <a href="http://www.cnblogs.com/wujing-hubei/p/6012105.html">http://www.cnblogs.com/wujing-hubei/p/6012105.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>form表单效验</title>
      <link href="/posts/f44a0d63.html"/>
      <url>/posts/f44a0d63.html</url>
      
        <content type="html"><![CDATA[<p>element form 表单效验和原理</p><span id="more"></span><h2 id="Element-的表单校验"><a href="#Element-的表单校验" class="headerlink" title="Element 的表单校验"></a>Element 的表单校验</h2><blockquote><p>我们尝试通过一个案例对 Element 的表单校验进行一下补充</p></blockquote><h3 id="实现表单基本结构"><a href="#实现表单基本结构" class="headerlink" title="实现表单基本结构"></a>实现表单基本结构</h3><p><strong>创建项目</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vue create login</span><br></pre></td></tr></table></figure><blockquote><p>选择 babel / eslint</p></blockquote><p><strong>安装 Element</strong></p><p>开发时依赖 ： 开发环境所需要的依赖 -&gt; devDependencies</p><p>运行时依赖: 项目上线依然需要的依赖 -&gt; dependencies</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm i element-ui</span><br></pre></td></tr></table></figure><p><strong>在 main.js 中对 ElementUI 进行注册</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">ElementUI</span> <span class="keyword">from</span> <span class="string">&quot;element-ui&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;element-ui/lib/theme-chalk/index.css&quot;</span>;</span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">ElementUI</span>);</span><br></pre></td></tr></table></figure><p>接下来,利用 Element 组件完成如图的效果</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230720083444058.png" alt="image-20230720083444058"></p><p>代码如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;!-- 卡片组件 --&gt;</span><br><span class="line">    &lt;el-card class=&quot;login-card&quot;&gt;</span><br><span class="line">      &lt;!-- 登录表单 --&gt;</span><br><span class="line">      &lt;el-form style=&quot;margin-top: 50px&quot;&gt;</span><br><span class="line">        &lt;el-form-item&gt;</span><br><span class="line">          &lt;el-input placeholder=&quot;请输入手机号&quot;&gt;&lt;/el-input&gt;</span><br><span class="line">        &lt;/el-form-item&gt;</span><br><span class="line">        &lt;el-form-item&gt;</span><br><span class="line">          &lt;el-input placeholder=&quot;请输入密码&quot;&gt;&lt;/el-input&gt;</span><br><span class="line">        &lt;/el-form-item&gt;</span><br><span class="line">        &lt;el-form-item&gt;</span><br><span class="line">          &lt;el-button type=&quot;primary&quot; style=&quot;width: 100%&quot;&gt;登录&lt;/el-button&gt;</span><br><span class="line">        &lt;/el-form-item&gt;</span><br><span class="line">      &lt;/el-form&gt;</span><br><span class="line">    &lt;/el-card&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;App&quot;,</span><br><span class="line">  components: &#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">#app &#123;</span><br><span class="line">  width: 100%;</span><br><span class="line">  height: 100vh;</span><br><span class="line">  background-color: pink;</span><br><span class="line">  display: flex;</span><br><span class="line">  justify-content: center;</span><br><span class="line">  align-items: center;</span><br><span class="line">&#125;</span><br><span class="line">.login-card &#123;</span><br><span class="line">  width: 440px;</span><br><span class="line">  height: 300px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h3 id="表单校验的先决条件"><a href="#表单校验的先决条件" class="headerlink" title="表单校验的先决条件"></a>表单校验的先决条件</h3><p>接下来，完成表单的校验规则如下几个先决条件</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230720083513340.png" alt="image-20230720083513340"></p><p><strong>model 属性</strong> (表单数据对象)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">data () &#123;</span><br><span class="line">  <span class="comment">// 定义表单数据对象</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">loginForm</span>: &#123;</span><br><span class="line">      <span class="attr">mobile</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">      <span class="attr">password</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>绑定 model</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-form style=&quot;margin-top:40px&quot; :model=&quot;loginForm&quot; &gt;</span><br></pre></td></tr></table></figure><p><strong>rules 规则</strong> 先定义空规则，后续再详解</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">loginRules</span>: &#123;&#125;</span><br><span class="line">&lt;el-form style=<span class="string">&quot;margin-top: 50px&quot;</span> :model=<span class="string">&quot;loginForm&quot;</span> :rules=<span class="string">&quot;loginRules&quot;</span>&gt;</span><br></pre></td></tr></table></figure><p><strong>设置 prop 属性</strong></p><blockquote><p>校验谁写谁的字段</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-form-item prop=&quot;mobile&quot;&gt;</span><br><span class="line">   ...</span><br><span class="line">&lt;el-form-item prop=&quot;password&quot;&gt;</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure><p><strong>给 input 绑定字段属性</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-input v-model=&quot;loginForm.mobile&quot;&gt;&lt;/el-input&gt;</span><br><span class="line">&lt;el-input v-model=&quot;loginForm.password&quot;&gt;&lt;/el-input&gt;</span><br></pre></td></tr></table></figure><h3 id="表单校验规则"><a href="#表单校验规则" class="headerlink" title="表单校验规则"></a>表单校验规则</h3><p>此时，先决条件已经完成，要完成表单的校验，需要编写规则</p><blockquote><p>ElementUI 的表单校验规则来自第三方校验规则参见 <a href="https://link.juejin.cn/?target=https://github.com/yiminghe/async-validator">async-validator</a></p></blockquote><p>我们介绍几个基本使用的规则</p><table><thead><tr><th>规则</th><th>说明</th></tr></thead><tbody><tr><td>required</td><td>如果为 true，表示该字段为必填</td></tr><tr><td>message</td><td>当不满足设置的规则时的提示信息</td></tr><tr><td>pattern</td><td>正则表达式，通过正则验证值</td></tr><tr><td>min</td><td>当值为字符串时，min 表示字符串的最小长度，当值为数字时，min 表示数字的最小值</td></tr><tr><td>max</td><td>当值为字符串时，max 表示字符串的最大长度，当值为数字时，max 表示数字的最大值</td></tr><tr><td>trigger</td><td>校验的触发方式，change（值改变） / blur （失去焦点）两种，</td></tr><tr><td>validator</td><td>如果配置型的校验规则不满足你的需求，你可以通过自定义函数来完成校验</td></tr></tbody></table><p>校验规则的格式</p><p><strong><em>{ key(字段名): value(校验规则) =&gt; [{}] }</em></strong></p><p>根据以上的规则，针对当前表单完成如下要求</p><p><strong>手机号</strong> 1.必填 2.手机号格式校验 3. 失去焦点校验</p><p><strong>密码</strong> 1.必填 2.6-16 位长度 3. 失去焦点校验</p><p><strong>规则如下</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">loginRules</span>: &#123;</span><br><span class="line">        <span class="attr">mobile</span>: [</span><br><span class="line">          &#123; <span class="attr">required</span>: <span class="literal">true</span>, <span class="attr">message</span>: <span class="string">&quot;手机号不能为空&quot;</span>, <span class="attr">trigger</span>: <span class="string">&quot;blur&quot;</span> &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">pattern</span>: <span class="regexp">/^1[3-9]\d&#123;9&#125;$/</span>,</span><br><span class="line">            <span class="attr">message</span>: <span class="string">&quot;请输入正确的手机号&quot;</span>,</span><br><span class="line">            <span class="attr">trigger</span>: <span class="string">&quot;blur&quot;</span>,</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">pattern</span>: <span class="regexp">/^1[3-9]\d&#123;9&#125;$/</span>,</span><br><span class="line">            <span class="attr">message</span>: <span class="string">&quot;请输入正确的手机号&quot;</span>,</span><br><span class="line">            <span class="attr">trigger</span>: <span class="string">&quot;blur&quot;</span>,</span><br><span class="line">          &#125;,</span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">password</span>: [</span><br><span class="line">          &#123; <span class="attr">required</span>: <span class="literal">true</span>, <span class="attr">message</span>: <span class="string">&quot;密码不能为空&quot;</span>, <span class="attr">trigger</span>: <span class="string">&quot;blur&quot;</span> &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">min</span>: <span class="number">6</span>,</span><br><span class="line">            <span class="attr">max</span>: <span class="number">16</span>,</span><br><span class="line">            <span class="attr">message</span>: <span class="string">&quot;密码应为6-16位的长度&quot;</span>,</span><br><span class="line">            <span class="attr">trigger</span>: <span class="string">&quot;blur&quot;</span>,</span><br><span class="line">          &#125;,</span><br><span class="line">        ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义校验规则"><a href="#自定义校验规则" class="headerlink" title="自定义校验规则"></a>自定义校验规则</h3><blockquote><p>自定义校验规则怎么用</p></blockquote><p><strong><code>validator</code>**是一个函数, 其中有三个参数 (**<code>rule</code></strong>(当前规则),<code>value</code>(当前值),<strong><code>callback</code></strong>(回调函数))</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> func = <span class="keyword">function</span> (<span class="params">rule, value, callback</span>) &#123;</span><br><span class="line">  <span class="comment">// 根据value进行进行校验</span></span><br><span class="line">  <span class="comment">// 如果一切ok</span></span><br><span class="line">  <span class="comment">// 直接执行callback</span></span><br><span class="line">  <span class="title function_">callback</span>(); <span class="comment">// 一切ok 请继续</span></span><br><span class="line">  <span class="comment">// 如果不ok</span></span><br><span class="line">  <span class="title function_">callback</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;错误信息&quot;</span>));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>根据以上要求，增加手机号第三位必须是 9 的校验规则</p><p>如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义校验函数</span></span><br><span class="line"><span class="keyword">const</span> checkMobile = <span class="keyword">function</span> (<span class="params">rule, value, callback</span>) &#123;</span><br><span class="line">    value.<span class="title function_">charAt</span>(<span class="number">2</span>) === <span class="string">&#x27;9&#x27;</span> ? <span class="title function_">callback</span>() : <span class="title function_">callback</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;第三位手机号必须是9&#x27;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="attr">mobile</span>: [</span><br><span class="line">          &#123; <span class="attr">required</span>: <span class="literal">true</span>, <span class="attr">message</span>: <span class="string">&#x27;手机号不能为空&#x27;</span>, <span class="attr">trigger</span>: <span class="string">&#x27;blur&#x27;</span> &#125;,</span><br><span class="line">          &#123; <span class="attr">pattern</span>: <span class="regexp">/^1[3-9]\d&#123;9&#125;$/</span>, <span class="attr">message</span>: <span class="string">&#x27;请输入正确的手机号&#x27;</span>, <span class="attr">trigger</span>: <span class="string">&#x27;blur&#x27;</span> &#125;, &#123;</span><br><span class="line">            <span class="attr">trigger</span>: <span class="string">&#x27;blur&#x27;</span>,</span><br><span class="line">            <span class="attr">validator</span>: checkMobile</span><br><span class="line">   &#125;],</span><br></pre></td></tr></table></figure><h3 id="手动校验的实现"><a href="#手动校验的实现" class="headerlink" title="手动校验的实现"></a>手动校验的实现</h3><blockquote><p>最后一个问题，如果我们直接点登陆按钮，没有离开焦点，那该怎么校验 ？</p></blockquote><p>此时我们需要用到手动完整校验 <a href="https://link.juejin.cn/?target=https://element.eleme.cn/%23/zh-CN/component/form">案例</a></p><p>form 表单提供了一份 API 方法，我们可以对表单进行完整和部分校验</p><table><thead><tr><th>方法名</th><th>说明</th><th>参数</th></tr></thead><tbody><tr><td>validate</td><td>对整个表单进行校验的方法，参数为一个回调函数。该回调函数会在校验结束后被调用，并传入两个参数：是否校验成功和未通过校验的字段。若不传入回调函数，则会返回一个 promise</td><td>Function(callback: Function(boolean, object))</td></tr><tr><td>validateField</td><td>对部分表单字段进行校验的方法</td><td>Function(props: array | string, callback: Function(errorMessage: string))</td></tr><tr><td>resetFields</td><td>对整个表单进行重置，将所有字段值重置为初始值并移除校验结果</td><td>—</td></tr><tr><td>clearValidate</td><td>移除表单项的校验结果。传入待移除的表单项的 prop 属性或者 prop 组成的数组，如不传则移除整个表单的校验结果</td><td>Function(props: array | string)</td></tr></tbody></table><p>这些方法是 el-form 的 API，需要获取 el-form 的实例，才可以调用</p><p><strong>采用 ref 进行调用</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-form ref=&quot;loginForm&quot; style=&quot;margin-top:40px&quot; :model=&quot;loginForm&quot; :rules=&quot;loginRules&quot;&gt;</span><br></pre></td></tr></table></figure><p><strong>调用校验方法</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">login () &#123;</span><br><span class="line">    <span class="comment">// 获取el-form的实例</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">loginForm</span>.<span class="title function_">validate</span>(<span class="keyword">function</span> (<span class="params">isOK</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isOK) &#123;</span><br><span class="line">            <span class="comment">// 说明校验通过</span></span><br><span class="line">            <span class="comment">// 调用登录接口</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;) <span class="comment">// 校验整个表单</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="element-原理"><a href="#element-原理" class="headerlink" title="element 原理"></a>element 原理</h1><h1 id="一、async-validator"><a href="#一、async-validator" class="headerlink" title="一、async-validator"></a>一、async-validator</h1><p>​ 在介绍表单校验之前，我们需要先了解 async-validator。</p><p>​ <a href="https://link.juejin.cn/?target=https://www.npmjs.com/package/async-validator">async-validator</a>是一个异步校验的功能库，可以根据传入的规则和数据输出校验结果。</p><p>​ 目前大多数组件库(包括 element-ui)内部都是引入 async-validator 完成数据校验的，即表单中的每一项都是用 async-validator 来进行校验的。</p><p>​ 看一下 async-validator 的基本使用方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncValidator <span class="keyword">from</span> <span class="string">&#x27;async-validator&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> descriptor = &#123;</span><br><span class="line">  <span class="attr">name</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&quot;string&quot;</span>,</span><br><span class="line">    <span class="attr">required</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">validator</span>: <span class="function">(<span class="params">rule, value, callback</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (value === <span class="string">&quot;Ezrel&quot;</span>) &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="title function_">callback</span>();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">callback</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Wrong name&quot;</span>));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> validator = <span class="keyword">new</span> <span class="title function_">asyncValidator</span>(descriptor);</span><br><span class="line"></span><br><span class="line"><span class="comment">// callback USAGE</span></span><br><span class="line">validator.<span class="title function_">validate</span>(</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&quot;Jinx&quot;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">firstFields</span>: <span class="literal">true</span> &#125;,<span class="comment">// 串行校验，遇到错误就停止校验</span></span><br><span class="line">  <span class="function">(<span class="params">errors, fields</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (errors) &#123;</span><br><span class="line">      <span class="comment">// validation failed, errors is an array of all errors</span></span><br><span class="line">      <span class="comment">// fields is an object keyed by field name with an array of</span></span><br><span class="line">      <span class="comment">// errors per field</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;validate error =&gt;&quot;</span>, errors);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// validation passed</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;validate success!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​ 这里如果不是很清楚也没关系，只需要知道 async-validator 的用处就是传入值和规则，会返回校验的结果即可，不影响后续的阅读。</p><p>（值得注意的是，async-validator 在 web 和 node 端的使用略有差异，这里我们关注的是 web 端的使用）</p><h1 id="二、表单项-Form-item"><a href="#二、表单项-Form-item" class="headerlink" title="二、表单项 Form-item"></a>二、表单项 Form-item</h1><p>​ 整个表单的校验其实是其所包含的每个表单项校验的结果集合，因此先看一下每个表单项是如何校验的。</p><h2 id="2-1-表单项校验规则"><a href="#2-1-表单项校验规则" class="headerlink" title="2.1 表单项校验规则"></a>2.1 表单项校验规则</h2><p>​ getRules 方法用于获取当前表单项的校验规则，我们看一下代码</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// element-ui\packages\form\src\form-item.vue</span></span><br><span class="line"></span><br><span class="line">getRules() &#123;</span><br><span class="line">  let formRules = <span class="keyword">this</span>.form.rules; <span class="comment">// 整个表单的rules属性</span></span><br><span class="line">  <span class="keyword">const</span> selfRules = <span class="keyword">this</span>.rules; <span class="comment">// 当前表单项的rules属性</span></span><br><span class="line">  <span class="keyword">const</span> requiredRule = <span class="keyword">this</span>.required !== undefined ? &#123; required: !!<span class="keyword">this</span>.required &#125; : []; <span class="comment">// 当前表单项的required属性</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> prop = getPropByPath(formRules, <span class="keyword">this</span>.prop || <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">  formRules = formRules ? (prop.o[<span class="keyword">this</span>.prop || <span class="string">&#x27;&#x27;</span>] || prop.v) : [];<span class="comment">// 根据当期表单项的prop属性，从整个表单的rules中获取对应的规则</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> [].concat(selfRules || formRules || []).concat(requiredRule);<span class="comment">// 校验规则组合</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>​ 从以上代码中可以分析出几点：</p><p>​ 1、表单项自身的 rules 规则优先级高于整个表单上的 rules 规则（selfRules || formRules || []）；</p><p>​ 2、如果表单项自身没有 rules 规则，则从表单的 rules 规则中取 prop 属性对应的规则（说明 prop 属性在表单校验中是非常重要，如果没有给表单项传递 prop 属性，则无法从表单的规则中拿到对应表单项的规则；实际上表单项校验时的值也是通过 prop 属性从表单的 model 属性中读取的）；</p><p>​ 3、表单项上的 required 属性与 rules 中的 required 具有同等效果。</p><h2 id="2-2-trigger-属性"><a href="#2-2-trigger-属性" class="headerlink" title="2.2 trigger 属性"></a>2.2 trigger 属性</h2><p>​ 在 rules 中我们可以设置 trigger 属性，trigger 表示校验的触发条件，可以设置的值为’change’、’blur、数组，也可以不设置 trigger 属性。</p><p>​ trigger 属性在 async-validator 中是不存在的，这个属性是 element-ui 添加的。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// element-ui\packages\form\src\form-item.vue</span></span><br><span class="line"></span><br><span class="line">addValidateEvents() &#123;</span><br><span class="line">  <span class="keyword">const</span> rules = <span class="keyword">this</span>.getRules();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (rules.length || <span class="keyword">this</span>.required !== undefined) &#123;</span><br><span class="line">    <span class="comment">// 监听blur和change事件</span></span><br><span class="line">    <span class="keyword">this</span>.$on(<span class="string">&#x27;el.form.blur&#x27;</span>, <span class="keyword">this</span>.onFieldBlur);</span><br><span class="line">    <span class="keyword">this</span>.$on(<span class="string">&#x27;el.form.change&#x27;</span>, <span class="keyword">this</span>.onFieldChange);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">onFieldBlur() &#123;</span><br><span class="line">  <span class="comment">// 触发blur校验</span></span><br><span class="line">  <span class="keyword">this</span>.validate(<span class="string">&#x27;blur&#x27;</span>);</span><br><span class="line">&#125;,</span><br><span class="line">onFieldChange() &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.validateDisabled) &#123;</span><br><span class="line">    <span class="keyword">this</span>.validateDisabled = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 触发change校验</span></span><br><span class="line">  <span class="keyword">this</span>.validate(<span class="string">&#x27;change&#x27;</span>);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>​ el.form.blur 和 el.form.change 是在 input/select 等组件中 dispatch 出来的</p><h2 id="2-3-过滤-trigger-后的规则"><a href="#2-3-过滤-trigger-后的规则" class="headerlink" title="2.3 过滤 trigger 后的规则"></a>2.3 过滤 trigger 后的规则</h2><p>​ 既然设置了 trigger 属性，那么在校验时应该要过滤对应 trigger 的规则，用过滤后的规则进行校验。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// element-ui\packages\form\src\form-item.vue</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">getFilteredRule</span>(<span class="params">trigger</span>) &#123;</span><br><span class="line">  <span class="comment">// 获取当前表单项的规则</span></span><br><span class="line">  <span class="keyword">const</span> rules = <span class="variable language_">this</span>.<span class="title function_">getRules</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> rules.<span class="title function_">filter</span>(<span class="function"><span class="params">rule</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 规则中未设置trigger或者当前的trigger为&#x27;&#x27;时，规则会被用于校验</span></span><br><span class="line">    <span class="keyword">if</span> (!rule.<span class="property">trigger</span> || trigger === <span class="string">&#x27;&#x27;</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(rule.<span class="property">trigger</span>)) &#123;</span><br><span class="line">      <span class="comment">// 规则中的trigger是数组的情况,需要包含当前的trigger</span></span><br><span class="line">      <span class="keyword">return</span> rule.<span class="property">trigger</span>.<span class="title function_">indexOf</span>(trigger) &gt; -<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 规则中的trigger与当前trigger完全匹配</span></span><br><span class="line">      <span class="keyword">return</span> rule.<span class="property">trigger</span> === trigger;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;).<span class="title function_">map</span>(<span class="function"><span class="params">rule</span> =&gt;</span> <span class="title function_">objectAssign</span>(&#123;&#125;, rule));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​ 从以上代码可以分析出：</p><ol><li>规则中没有设置 trigger，规则会被选取</li><li>当前查询的 trigger 为’’时，规则会被选取</li><li>规则中设置了 trigger，且当前查询的 trigger 不为’’时，需要规则中的 trigger 包含当前 trigger 或者与之完全一致才会被选取。</li></ol><h2 id="2-4-表单项校验的值-filedValue"><a href="#2-4-表单项校验的值-filedValue" class="headerlink" title="2.4 表单项校验的值 filedValue"></a>2.4 表单项校验的值 filedValue</h2><p>​ 上面分析了获得校验规则的代码，接下里是获取参与校验的值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// element-ui\packages\form\src\form-item.vue</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">fieldValue</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// form表单的model属性</span></span><br><span class="line">  <span class="keyword">const</span> model = <span class="variable language_">this</span>.<span class="property">form</span>.<span class="property">model</span>;</span><br><span class="line">  <span class="comment">// 如果表单没有model属性或者表单项没有prop属性，则返回undefined</span></span><br><span class="line">  <span class="keyword">if</span> (!model || !<span class="variable language_">this</span>.<span class="property">prop</span>) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> path = <span class="variable language_">this</span>.<span class="property">prop</span>;</span><br><span class="line">  <span class="keyword">if</span> (path.<span class="title function_">indexOf</span>(<span class="string">&#x27;:&#x27;</span>) !== -<span class="number">1</span>) &#123;</span><br><span class="line">    path = path.<span class="title function_">replace</span>(<span class="regexp">/:/</span>, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 根据prop从model中读取值</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">getPropByPath</span>(model, path, <span class="literal">true</span>).<span class="property">v</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​ 从代码中可以分析出：</p><ol><li>表单 form 必须有 model 属性，如果没有 model 属性，参与校验的值就会是 undefined;</li><li>表单项 form-item 必须有 prop 属性（这一点在获取校验规则时一致）,如果没有 prop 属性，参与校验的值就会是 undefined;</li><li>参与校验的值是读取表单 model 中 prop 对应的值</li></ol><h2 id="2-5-表单项校验-validate"><a href="#2-5-表单项校验-validate" class="headerlink" title="2.5 表单项校验 validate"></a>2.5 表单项校验 validate</h2><p>​ 经过以上步骤，已经获取到表单项对应的规则以及参与校验的值，接下来就是进行校验</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// element-ui\packages\form\src\form-item.vue</span></span><br><span class="line"></span><br><span class="line">validate(trigger, callback = noop) &#123;</span><br><span class="line">  <span class="keyword">this</span>.validateDisabled = <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">// 拿到表单项的校验规则(过滤trigger之后的)</span></span><br><span class="line">  <span class="keyword">const</span> rules = <span class="keyword">this</span>.getFilteredRule(trigger);</span><br><span class="line">  <span class="comment">// 如果没有匹配的校验规则，直接返回</span></span><br><span class="line">  <span class="keyword">if</span> ((!rules || rules.length === <span class="number">0</span>) &amp;&amp; <span class="keyword">this</span>.required === undefined) &#123;</span><br><span class="line">    callback();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.validateState = <span class="string">&#x27;validating&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> descriptor = &#123;&#125;;</span><br><span class="line">  <span class="comment">// 删除掉校验规则中的trigger属性，因为async-validator不需要</span></span><br><span class="line">  <span class="keyword">if</span> (rules &amp;&amp; rules.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    rules.forEach(rule =&gt; &#123;</span><br><span class="line">      delete rule.trigger;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  descriptor[<span class="keyword">this</span>.prop] = rules;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> validator = new AsyncValidator(descriptor);</span><br><span class="line">  <span class="keyword">const</span> model = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 参与校验的值</span></span><br><span class="line">  model[<span class="keyword">this</span>.prop] = <span class="keyword">this</span>.fieldValue;</span><br><span class="line"></span><br><span class="line">  validator.validate(model,</span><br><span class="line">  &#123; firstFields: <span class="literal">true</span> &#125;, <span class="comment">// 规则串行校验，遇到错误则停止</span></span><br><span class="line">  (errors, invalidFields) =&gt; &#123; <span class="comment">// 回调，校验完成后执行</span></span><br><span class="line">      <span class="keyword">this</span>.validateState = !errors ? <span class="string">&#x27;success&#x27;</span> : <span class="string">&#x27;error&#x27;</span>;</span><br><span class="line">      <span class="keyword">this</span>.validateMessage = errors ? errors[<span class="number">0</span>].message : <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">      callback(<span class="keyword">this</span>.validateMessage, invalidFields);</span><br><span class="line">    <span class="comment">// 任一表单项校验时发射validate事件</span></span><br><span class="line">      <span class="keyword">this</span>.elForm &amp;&amp; <span class="keyword">this</span>.elForm.$emit(<span class="string">&#x27;validate&#x27;</span>, <span class="keyword">this</span>.prop, !errors, <span class="keyword">this</span>.validateMessage || <span class="literal">null</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>​ 表单项的 validate 方法很清晰，就是获取表单项的规则，然后构造 async-validator 进行校验，在校验完成的回调中处理表单项的校验状态、执行传入的 callback、发射 validate 事件。</p><h1 id="三、表单-Form"><a href="#三、表单-Form" class="headerlink" title="三、表单 Form"></a>三、表单 Form</h1><p>​ 第二部分中我们弄清楚了表单项是如何进行校验的，这一部分我们分析一下 Form 是如何组织表单项进行校验的。</p><h2 id="3-1-fields-数组"><a href="#3-1-fields-数组" class="headerlink" title="3.1 fields 数组"></a>3.1 fields 数组</h2><p>​ form 作为父组件，其中可以包含任意多个 form-item 组件，因此就有必要维护一个数据结构表示其所包含的 form-item，在代码中使用的是 fileds 数组</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// element-ui\packages\form\src\form-item.vue</span></span><br><span class="line">mounted() &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.prop) &#123;</span><br><span class="line">    <span class="comment">// 向&#x27;ElForm&#x27;组件发布‘el.form.addField’消息</span></span><br><span class="line">    <span class="keyword">this</span>.dispatch(<span class="string">&#x27;ElForm&#x27;</span>, <span class="string">&#x27;el.form.addField&#x27;</span>, [<span class="keyword">this</span>]);</span><br><span class="line">    ......</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">beforeDestroy() &#123;</span><br><span class="line">  <span class="comment">// 向&#x27;ElForm&#x27;组件发布‘el.form.removeField’消息</span></span><br><span class="line">  <span class="keyword">this</span>.dispatch(<span class="string">&#x27;ElForm&#x27;</span>, <span class="string">&#x27;el.form.removeField&#x27;</span>, [<span class="keyword">this</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// element-ui\packages\form\src\form.vue</span></span><br><span class="line">created() &#123;</span><br><span class="line">  <span class="comment">// 监听el.form.addField事件，填充fields数组</span></span><br><span class="line">  <span class="keyword">this</span>.$on(<span class="string">&#x27;el.form.addField&#x27;</span>, (field) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (field) &#123;</span><br><span class="line">      <span class="keyword">this</span>.fields.push(field);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// 监听el.form.removeField事件，删除fields数组中对应的field</span></span><br><span class="line">  <span class="keyword">this</span>.$on(<span class="string">&#x27;el.form.removeField&#x27;</span>, (field) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (field.prop) &#123;</span><br><span class="line">      <span class="keyword">this</span>.fields.splice(<span class="keyword">this</span>.fields.indexOf(field), <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​ 在 form-item 挂载时向 form 父组件发布 el.form.addField 消息，form 组件接受消息后，将该 form-item 实例加入到 fileds 数组中。反之，在 form-item 销毁发送 el.form.removeFileld 消息，form 组件接受消息后在 fields 中将该 form-item 实例删除。这样就维护了一个 form-item 的实例数组。</p><h2 id="3-2-表单校验-validate"><a href="#3-2-表单校验-validate" class="headerlink" title="3.2 表单校验 validate"></a>3.2 表单校验 validate</h2><p>​ 上一步中已经维护了表单中的表单项的数组，那么对所有表单项进行校验就很简单了，我们来看代码</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">// element-ui\packages\form\src\form.vue</span><br><span class="line">validate(callback) &#123;</span><br><span class="line">  // 没有model直接返回</span><br><span class="line">  if (!this.model) &#123;</span><br><span class="line">    console.warn(&#x27;<span class="section">[Element Warn]</span><span class="section">[Form]</span>model is required for validate to work!&#x27;)<span class="comment">;</span></span><br><span class="line">    return<span class="comment">;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  let promise<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">  if (typeof callback !== &#x27;function&#x27; &amp;&amp; window.Promise) &#123;</span><br><span class="line">    <span class="attr">promise</span> = new window.Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">      <span class="attr">callback</span> = function(valid) &#123;</span><br><span class="line">        valid ? resolve(valid) : reject(valid)<span class="comment">;</span></span><br><span class="line">      &#125;<span class="comment">;</span></span><br><span class="line">    &#125;)<span class="comment">;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  let <span class="attr">valid</span> = <span class="literal">true</span><span class="comment">;</span></span><br><span class="line">  let <span class="attr">count</span> = <span class="number">0</span><span class="comment">;</span></span><br><span class="line">  // 如果没有表单项，无需校验，直接返回true</span><br><span class="line">  if (<span class="attr">this.fields.length</span> === <span class="number">0</span> &amp;&amp; callback) &#123;</span><br><span class="line">    callback(true)<span class="comment">;</span></span><br><span class="line">  &#125;</span><br><span class="line">  let <span class="attr">invalidFields</span> = &#123;&#125;<span class="comment">;</span></span><br><span class="line">  // 对每一个表单项，调用表单项自身的validate方法进行校验</span><br><span class="line">  this.fields.forEach(<span class="attr">field</span> =&gt; &#123;</span><br><span class="line">    field.validate(&#x27;&#x27;, (message, field) =&gt; &#123;</span><br><span class="line">      if (message) &#123;</span><br><span class="line">        // 有一个表单项校验失败，valid置未false</span><br><span class="line">        <span class="attr">valid</span> = <span class="literal">false</span><span class="comment">;</span></span><br><span class="line">      &#125;</span><br><span class="line">      // 记录校验失败的表单项</span><br><span class="line">      <span class="attr">invalidFields</span> = objectAssign(&#123;&#125;, invalidFields, field)<span class="comment">;</span></span><br><span class="line">      if (typeof <span class="attr">callback</span> === <span class="string">&#x27;function&#x27;</span> &amp;&amp; ++count === this.fields.length) &#123;</span><br><span class="line">        // 完成最后一个表单项的校验后，调用callback</span><br><span class="line">        callback(valid, invalidFields)<span class="comment">;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)<span class="comment">;</span></span><br><span class="line">  &#125;)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">  if (promise) &#123;</span><br><span class="line">    // 如果没有传入callback,则返回的是一个promise对象</span><br><span class="line">    return promise<span class="comment">;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​ 从代码中可以看出，表单的校验确实就是依次执行表单项的校验，最后将校验结果组合后传入 callback 中执行。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven教程</title>
      <link href="/posts/21effdcf.html"/>
      <url>/posts/21effdcf.html</url>
      
        <content type="html"><![CDATA[<p>摘要</p><span id="more"></span><h2 id="1-Maven-是什么"><a href="#1-Maven-是什么" class="headerlink" title="1. Maven 是什么"></a>1. Maven 是什么</h2><p>Maven 是 Apache 软件基金会组织维护的一款专门为 Java 项目提供<strong>构建</strong>和<strong>依赖</strong>管理支持的工具。</p><p>一个 Maven 工程有约定的目录结构，约定的目录结构对于 Maven 实现自动化构建而言是必不可少的一环，就拿自动编译来说，Maven 必须 能找到 Java 源文件，下一步才能编译，而编译之后也必须有一个准确的位置保持编译得到的字节码文件。 我们在开发中如果需要让第三方工具或框架知道我们自己创建的资源在哪，那么基本上就是两种方式：</p><ol><li>通过配置的形式明确告诉它</li><li>基于第三方工具或框架的约定 Maven 对工程目录结构的要求</li></ol><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230718162731572.png" alt="image-20230718162731572"></p><h3 id="1-1-构建"><a href="#1-1-构建" class="headerlink" title="1.1 构建"></a>1.1 构建</h3><p>Java 项目开发过程中，构建指的是使用『<strong>原材料生产产品</strong>』的过程。</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230718162753206.png" alt="image-20230718162753206"></p><p>构建过程主要包含以下环节：</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230718162817262.png" alt="image-20230718162817262"></p><h3 id="1-2-依赖"><a href="#1-2-依赖" class="headerlink" title="1.2 依赖"></a>1.2 依赖</h3><p>Maven 中最关键的部分，我们使用 Maven 最主要的就是使用它的依赖管理功能。当 A jar 包用到了 B jar 包中的某些类时，A 就对 B 产生了依赖，那么我们就可以说 A 依赖 B。</p><p>依赖管理中要解决的具体问题：</p><ul><li>jar 包的下载：使用 Maven 之后，jar 包会从规范的远程仓库下载到本地</li><li>jar 包之间的依赖：通过依赖的传递性自动完成</li><li>jar 包之间的冲突：通过对依赖的配置进行调整，让某些 jar 包不会被导入</li></ul><h2 id="2-Maven-开发环境配置"><a href="#2-Maven-开发环境配置" class="headerlink" title="2. Maven 开发环境配置"></a>2. Maven 开发环境配置</h2><h3 id="2-1-下载安装"><a href="#2-1-下载安装" class="headerlink" title="2.1 下载安装"></a>2.1 下载安装</h3><p>首页：</p><p><a href="https://xie.infoq.cn/link?target=https://maven.apache.org/">Maven – Welcome to Apache Maven</a></p><p>下载页面：</p><p><a href="https://xie.infoq.cn/link?target=https://maven.apache.org/download.cgi">Maven – Download Apache Maven</a></p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230718162850114.png" alt="image-20230718162850114"></p><p>或者你也可以选择之前的版本：</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230718162909619.png" alt="image-20230718162909619"></p><p>然后里面选择自己对应的版本下载即可：</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230718162927263.png" alt="image-20230718162927263"></p><p>下载之后解压到<strong>非中文、没有空格</strong>的目录，如下：</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230718162953121.png" alt="image-20230718162953121"></p><h3 id="2-2-指定本地仓库"><a href="#2-2-指定本地仓库" class="headerlink" title="2.2 指定本地仓库"></a>2.2 指定本地仓库</h3><p>本地仓库默认值：用户家目录/.m2/repository。由于本地仓库的默认位置是在用户的家目录下，而家目录往往是在 C 盘，也就是系统盘。将来 Maven 仓库中 jar 包越来越多，仓库体积越来越大，可能会拖慢 C 盘运行速度，影响系统性能。所以建议将 Maven 的本地仓库放在其他盘符下。配置方式如下：</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230718163226250.png" alt="image-20230718163226250"></p><p>本地仓库这个目录，我们手动创建一个空的目录即可。</p><p><strong>记住</strong>：一定要把 localRepository 标签<strong>从注释中拿出来</strong>。</p><p><strong>注意</strong>：本地仓库本身也需要使用一个<strong>非中文、没有空格</strong>的目录。</p><h3 id="2-3-配置阿里云提供的镜像仓库"><a href="#2-3-配置阿里云提供的镜像仓库" class="headerlink" title="2.3 配置阿里云提供的镜像仓库"></a>2.3 配置阿里云提供的镜像仓库</h3><p>Maven 下载 jar 包默认访问境外的中央仓库，而国外网站速度很慢。改成阿里云提供的镜像仓库，<strong>访问国内网站</strong>，可以让 Maven 下载 jar 包的时候速度更快。配置的方式是：</p><ol><li><p>将原有的例子配置注释掉</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230718163244605.png"></p></li><li><p>加入自己的配置</p></li></ol><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230718163306018.png" alt="image-20230718163306018"></p><h3 id="2-4-配置基础-JDK-版本"><a href="#2-4-配置基础-JDK-版本" class="headerlink" title="2.4 配置基础 JDK 版本"></a>2.4 配置基础 JDK 版本</h3><p>如果按照默认配置运行，Java 工程使用的默认 JDK 版本是 1.5，而我们熟悉和常用的是 JDK 1.8 版本。修改配置的方式是：将 <code>profile</code> 标签整个复制到 settings.xml 文件的 <code>profiles</code> 标签内。</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230718163336804.png" alt="image-20230718163336804"></p><h3 id="2-5-配置环境变量"><a href="#2-5-配置环境变量" class="headerlink" title="2.5 配置环境变量"></a>2.5 配置环境变量</h3><p>Maven 是一个用 Java 语言开发的程序，它必须基于 JDK 来运行，需要通过 JAVA_HOME 来找到 JDK 的安装位置。</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230718163355389.png" alt="image-20230718163355389"></p><p>可以使用下面的命令验证：</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230718163412454.png" alt="image-20230718163412454"></p><p>然后新建环境变量：</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230718163433104.png" alt="image-20230718163433104"></p><blockquote><p>配置环境变量的规律：</p><p>XXX_HOME 通常指向的是 bin 目录的上一级</p><p>PATH 指向的是 bin 目录</p></blockquote><p>在配置 PATH</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230718163510875.png" alt="image-20230718163510875"></p><p>通过 <code>mvn -v</code> 验证：</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230718163528303.png" alt="image-20230718163528303"></p><h2 id="3-Maven-的使用"><a href="#3-Maven-的使用" class="headerlink" title="3. Maven 的使用"></a>3. Maven 的使用</h2><h3 id="3-1-核心概念：坐标"><a href="#3-1-核心概念：坐标" class="headerlink" title="3.1 核心概念：坐标"></a>3.1 核心概念：坐标</h3><p><strong>数学中的坐标</strong>使用 x、y、z 三个『<strong>向量</strong>』作为空间的坐标系，可以在『<strong>空间</strong>』中唯一的定位到一个『<strong>点</strong>』。</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230718163558907.png" alt="image-20230718163558907"></p><p><strong>Maven 中的坐标</strong>使用三个『<strong>向量</strong>』在『<strong>Maven 的仓库</strong>』中<strong>唯一</strong>的定位到一个『<strong>jar</strong>』包。</p><ul><li><strong>groupId</strong>：公司或组织的 id，即公司或组织域名的倒序，通常也会加上项目名称</li><li>例如：groupId：com.javatv.maven</li><li><strong>artifactId</strong>：一个项目或者是项目中的一个模块的 id，即模块的名称，将来作为 Maven 工程的工程名</li><li>例如：artifactId：auth</li><li><strong>version</strong>：版本号</li><li>例如：version：1.0.0</li></ul><p>提示：坐标和仓库中 jar 包的存储路径之间的对应关系，如下</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230718163619119.png" alt="image-20230718163619119"></p><p>上面坐标对应的 jar 包在 Maven 本地仓库中的位置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Maven本地仓库根目录\javax\servlet\servlet-api\2.5\servlet-api-2.5.jar</span><br></pre></td></tr></table></figure><h3 id="3-2-pom-xml"><a href="#3-2-pom-xml" class="headerlink" title="3.2 pom.xml"></a>3.2 pom.xml</h3><p>POM：<strong>P</strong>roject <strong>O</strong>bject <strong>M</strong>odel，项目对象模型。和 POM 类似的是：DOM（Document Object Model），文档对象模型。它们都是模型化思想的具体体现。</p><p>POM 表示将工程抽象为一个模型，再用程序中的对象来描述这个模型。这样我们就可以用程序来管理项目了。我们在开发过程中，最基本的做法就是将现实生活中的事物抽象为模型，然后封装模型相关的数据作为一个对象，这样就可以在程序中计算与现实事物相关的数据。</p><p>POM 理念集中体现在 Maven 工程根目录下 <strong>pom.xml</strong> 这个配置文件中。所以这个 pom.xml 配置文件就是 Maven 工程的核心配置文件。其实学习 Maven 就是学这个文件怎么配置，各个配置有什么用。</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230718163722375.png" alt="image-20230718163722375"></p><h3 id="3-3-依赖"><a href="#3-3-依赖" class="headerlink" title="3.3 依赖"></a>3.3 依赖</h3><p>上面说到我们使用 Maven 最主要的就是使用它的依赖管理功能，引入依赖存在一个范围，maven 的依赖范围包括： <code>compile</code>，<code>provide</code>，<code>runtime</code>，<code>test</code>，<code>system</code>。</p><ul><li><strong>compile</strong>：表示编译范围，指 A 在编译时依赖 B，该范围为<strong>默认依赖范围</strong>。编译范围的依赖会用在编译，测试，运行，由于运行时需要，所以编译范围的依赖会被打包。</li><li><strong>provided</strong>：provied 依赖只有当 jdk 或者一个容器已提供该依赖之后才使用。provide 依赖在编译和测试时需要，在运行时不需要。例如：servlet api 被 Tomcat 容器提供了。</li><li><strong>runtime</strong>：runtime 依赖在运行和测试系统时需要，但在编译时不需要。例如：jdbc 的驱动包。由于运行时需要，所以 runtime 范围的依赖会被打包。</li><li><strong>test</strong>：test 范围依赖在编译和运行时都不需要，只在测试编译和测试运行时需要。例如：Junit。由于运行时不需要，所以 test 范围依赖不会被打包。</li><li><strong>system</strong>：system 范围依赖与 provide 类似，但是必须显示的提供一个对于本地系统中 jar 文件的路径。一般不推荐使用。</li></ul><p>而在实际开发中，我们常用的就是 <code>compile</code>、<code>test</code>、<code>provided</code> 。</p><h3 id="3-4-依赖的传递"><a href="#3-4-依赖的传递" class="headerlink" title="3.4 依赖的传递"></a>3.4 依赖的传递</h3><p>A 依赖 B，B 依赖 C，那么在 A 没有配置对 C 的依赖的情况下，A 里面能不能直接使用 C？</p><p>再以上的前提下，C 是否能够传递到 A，取决于 B 依赖 C 时使用的依赖范围。</p><ul><li>B 依赖 C 时使用 compile 范围：可以传递</li><li>B 依赖 C 时使用 test 或 provided 范围：不能传递，所以需要这样的 jar 包时，就必须在需要的地方明确配置依赖才可以。</li></ul><h3 id="3-5-依赖的排除"><a href="#3-5-依赖的排除" class="headerlink" title="3.5 依赖的排除"></a>3.5 依赖的排除</h3><p>当 A 依赖 B，B 依赖 C 而且 C 可以传递到 A 的时候，A 不想要 C，需要在 A 里面把 C 排除掉。而往往这种情况都是为了避免 jar 包之间的冲突。</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230718163823784.png" alt="image-20230718163823784"></p><p>所以配置依赖的排除其实就是阻止某些 jar 包的传递。因为这样的 jar 包传递过来会和其他 jar 包冲突。</p><p>一般通过使用<code>excludes</code>标签配置依赖的排除：</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230718163844025.png" alt="image-20230718163844025"></p><h3 id="3-6-继承"><a href="#3-6-继承" class="headerlink" title="3.6 继承"></a>3.6 继承</h3><h4 id="3-6-1-概念"><a href="#3-6-1-概念" class="headerlink" title="3.6.1 概念"></a>3.6.1 概念</h4><p>Maven 工程之间，A 工程继承 B 工程</p><ul><li>B 工程：父工程</li><li>A 工程：子工程</li></ul><p>本质上是 A 工程的 pom.xml 中的配置继承了 B 工程中 pom.xml 的配置。</p><h4 id="3-6-2-作用"><a href="#3-6-2-作用" class="headerlink" title="3.6.2 作用"></a>3.6.2 作用</h4><p>在父工程中统一管理项目中的依赖信息，具体来说是管理依赖信息的版本。</p><p>它的背景是：</p><ul><li>对一个比较大型的项目进行了模块拆分。</li><li>一个 project 下面，创建了很多个 module。</li><li>每一个 module 都需要配置自己的依赖信息。</li></ul><p>它背后的需求是：</p><ul><li>在每一个 module 中各自维护各自的依赖信息很容易发生出入，不易统一管理。</li><li>使用同一个框架内的不同 jar 包，它们应该是同一个版本，所以整个项目中使用的框架版本需要统一。</li><li>使用框架时所需要的 jar 包组合（或者说依赖信息组合）需要经过长期摸索和反复调试，最终确定一个可用组合。这个耗费很大精力总结出来的方案不应该在新的项目中重新摸索。</li></ul><p>通过在父工程中为整个项目维护依赖信息的组合既<strong>保证了整个项目使用规范、准确的 jar 包</strong>；又能够将<strong>以往的经验沉淀</strong>下来，节约时间和精力。</p><h4 id="3-6-3-一个例子"><a href="#3-6-3-一个例子" class="headerlink" title="3.6.3 一个例子"></a>3.6.3 一个例子</h4><p><strong>① 一般再模块化开发中一般都会创建一个父工程，如下</strong>：</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230718163937475.png" alt="image-20230718163937475"></p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230718163955261.png" alt="image-20230718163955261"></p><p>父工程创建好之后，要修改它的打包方式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 当前工程作为父工程，它要去管理子工程，所以打包方式必须是 pom --&gt;</span><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br></pre></td></tr></table></figure><p>只有打包方式为 pom 的 Maven 工程能够管理其他 Maven 工程。打包方式为 pom 的 Maven 工程中不写业务代码，它是专门管理其他 Maven 工程的工程，所以可以将生成的 src 目录删除。</p><p><strong>② 创建模块工程</strong></p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230718164033287.png" alt="image-20230718164033287"></p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230718164045231.png" alt="image-20230718164045231"></p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230718164056861.png" alt="image-20230718164056861"></p><p>然后可以再<strong>父工程</strong>的 pom 文件中看到：</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230718164121375.png" alt="image-20230718164121375"></p><p>而<strong>子工程</strong>的 pom 如下：</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230718164142233.png" alt="image-20230718164142233"></p><p><strong>③ 在父工程中配置依赖的统一管理</strong></p><p>使用<code>dependencyManagement</code>标签配置对依赖的管理，如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.javatv.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-demo-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>demo-module<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-beans<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.19<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.19<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.19<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.19<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>而实际上<strong>被管理的依赖并没有真正被引入到工程</strong>。</p><p><strong>④ 子工程中引用那些被父工程管理的依赖</strong></p><p>关键点：省略版本号</p><p>子工程引用父工程中的依赖信息时，可以把版本号去掉。把版本号去掉就表示子工程中这个依赖的版本由父工程决定，具体来说是由父工程的 dependencyManagement 来决定。</p><p>子工程 pom 如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用parent标签指定当前工程的父工程 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-demo-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.javatv.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 子工程的坐标 --&gt;</span>    <span class="comment">&lt;!-- 如果子工程坐标中的groupId和version与父工程一致，那么可以省略 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>demo-module<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-beans<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此时，<strong>被管理的依赖才被引入到工程</strong>。</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230718164447635.png" alt="image-20230718164447635"></p><p><strong>⑤ 修改父工程依赖信息的版本</strong></p><p>这个修改可以是降级，也可以是升级，但一般来说都是升级。</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230718164506947.png" alt="image-20230718164506947"></p><p><strong>⑥ 父工程中声明自定义属性</strong></p><p>对同一个框架的一组 jar 包最好使用相同的版本，为了方便升级框架，可以将 jar 包的版本信息统一提取出来，统一声明版本号 ：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 通过自定义属性，统一指定Spring的版本 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span>    <span class="comment">&lt;!-- 自定义标签，维护Spring版本数据 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">spring.version</span>&gt;</span>5.3.19<span class="tag">&lt;/<span class="name">spring.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在需要的地方使用<code>$&#123;&#125;</code>的形式来引用自定义的属性名，真正实现<strong>一处修改，处处生效</strong>。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.javatv.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-demo-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>demo-module<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 通过自定义属性，统一指定Spring的版本 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 自定义标签，维护Spring版本数据 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">spring.version</span>&gt;</span>5.3.19<span class="tag">&lt;/<span class="name">spring.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-beans<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>编写一套符合要求、开发各种功能都能正常工作的依赖组合并不容易。如果公司里已经有人总结了成熟的组合方案，那么再开发新项目时，如果不使用原有的积累，而是重新摸索，会浪费大量的时间。为了提高效率，我们可以使用工程继承的机制，让成熟的依赖组合方案能够保留下来。如下：</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230718164607769.png" alt="image-20230718164607769"></p><p>如上图所示，公司级的父工程中管理的就是成熟的依赖组合方案，各个新项目、子系统各取所需即可。</p><h3 id="3-7-聚合"><a href="#3-7-聚合" class="headerlink" title="3.7 聚合"></a>3.7 聚合</h3><p>聚合，指分散的聚集到一起，即部分组成整体。</p><h4 id="3-7-1-Maven-中的聚合"><a href="#3-7-1-Maven-中的聚合" class="headerlink" title="3.7.1 Maven 中的聚合"></a>3.7.1 Maven 中的聚合</h4><p>使用一个<strong>总工程</strong>将各个<strong>模块工程</strong>汇集起来，作为一个整体对应完整的项目，实际就是 <code>module</code> 标签。</p><ul><li>项目：整体</li><li>模块：部分</li></ul><h4 id="3-7-2-继承和聚合的对应关系"><a href="#3-7-2-继承和聚合的对应关系" class="headerlink" title="3.7.2 继承和聚合的对应关系"></a>3.7.2 继承和聚合的对应关系</h4><p>从继承关系角度来看：</p><ul><li>父工程</li><li>子工程</li></ul><p>从聚合关系角度来看：</p><ul><li>总工程</li><li>模块工程</li></ul><h4 id="3-7-3-聚合的配置"><a href="#3-7-3-聚合的配置" class="headerlink" title="3.7.3 聚合的配置"></a>3.7.3 聚合的配置</h4><p>在总工程中配置 modules 即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">modules</span>&gt;</span>    <span class="tag">&lt;<span class="name">module</span>&gt;</span>demo-module<span class="tag">&lt;/<span class="name">module</span>&gt;</span><span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="3-7-4-依赖循环问题"><a href="#3-7-4-依赖循环问题" class="headerlink" title="3.7.4 依赖循环问题"></a>3.7.4 依赖循环问题</h4><p>如果 A 工程依赖 B 工程，B 工程依赖 C 工程，C 工程又反过来依赖 A 工程，那么在执行构建操作时会报下面的错误：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DANGER</span><br><span class="line">[ERROR] [ERROR] The projects in the reactor contain a cyclic reference:</span><br></pre></td></tr></table></figure><p>这个错误的含义是：循环引用。</p><h2 id="4-build-标签"><a href="#4-build-标签" class="headerlink" title="4. build 标签"></a>4. build 标签</h2><p>在实际使用 Maven 的过程中，我们会发现 build 标签有时候有，有时候没，这是怎么回事呢？其实通过有效 POM 我们能够看到，build 标签的相关配置其实一直都在，只是在我们需要定制构建过程的时候才会通过配置 build 标签覆盖默认值或补充配置。这一点我们可以通过打印有效 POM 来看到。</p><blockquote><p>打印有效 pom</p><p>mvn help:effective-pom</p></blockquote><p>当默认配置无法满足需求的定制构建的时候，就需要使用 build 标签。</p><h3 id="4-1-build-标签的组成"><a href="#4-1-build-标签的组成" class="headerlink" title="4.1 build 标签的组成"></a>4.1 build 标签的组成</h3><p>build 标签的子标签大致包含三个主体部分：</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230718164646398.png" alt="image-20230718164646398"></p><h4 id="4-1-1-定义约定的目录结构"><a href="#4-1-1-定义约定的目录结构" class="headerlink" title="4.1.1 定义约定的目录结构"></a>4.1.1 定义约定的目录结构</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sourceDirectory</span>&gt;</span>D:\product\maven-demo-parent\demo-module\src\main\java<span class="tag">&lt;/<span class="name">sourceDirectory</span>&gt;</span><span class="tag">&lt;<span class="name">scriptSourceDirectory</span>&gt;</span></span><br><span class="line">D:\product\maven-demo-parent\demo-module\src\main\scripts</span><br><span class="line"><span class="tag">&lt;/<span class="name">scriptSourceDirectory</span>&gt;</span><span class="tag">&lt;<span class="name">testSourceDirectory</span>&gt;</span>D:\product\maven-demo-parent\demo-module\src\test\java</span><br><span class="line"><span class="tag">&lt;/<span class="name">testSourceDirectory</span>&gt;</span><span class="tag">&lt;<span class="name">outputDirectory</span>&gt;</span>D:\product\maven-demo-parent\demo-module\target\classes</span><br><span class="line"><span class="tag">&lt;/<span class="name">outputDirectory</span>&gt;</span><span class="tag">&lt;<span class="name">testOutputDirectory</span>&gt;</span>D:\product\maven-demo-parent\demo-module\target\test-classes</span><br><span class="line"><span class="tag">&lt;/<span class="name">testOutputDirectory</span>&gt;</span><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">directory</span>&gt;</span>D:\product\maven-demo-parent\demo-module\src\main\resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span><span class="tag">&lt;<span class="name">testResources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">testResource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">directory</span>&gt;</span>D:\product\maven-demo-parent\demo-module\src\test\resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">testResource</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">testResources</span>&gt;</span><span class="tag">&lt;<span class="name">directory</span>&gt;</span>D:\product\maven-demo-parent\demo-module\target<span class="tag">&lt;/<span class="name">directory</span>&gt;</span><span class="tag">&lt;<span class="name">finalName</span>&gt;</span></span><br><span class="line">demo-module-1.0-SNAPSHOT</span><br><span class="line"><span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br></pre></td></tr></table></figure><p>各个目录的作用如下：</p><h4 id="4-1-2-备用插件管理"><a href="#4-1-2-备用插件管理" class="headerlink" title="4.1.2 备用插件管理"></a>4.1.2 备用插件管理</h4><p>pluginManagement 标签存放着几个极少用到的插件：</p><ul><li>maven-antrun-plugin</li><li>maven-assembly-plugin</li><li>maven-dependency-plugin</li><li>maven-release-plugin</li></ul><p>通过 pluginManagement 标签管理起来的插件就像 dependencyManagement 一样，子工程使用时可以省略版本号，起到在父工程中统一管理版本的效果。</p><h4 id="4-1-3-生命周期插件"><a href="#4-1-3-生命周期插件" class="headerlink" title="4.1.3 生命周期插件"></a>4.1.3 生命周期插件</h4><p>plugins 标签存放的是默认生命周期中实际会用到的插件，这些插件想必大家都不陌生，所以抛开插件本身不谈，plugin 标签的结构如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>default-compile<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">phase</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">goal</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>default-testCompile<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">phase</span>&gt;</span>test-compile<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">goal</span>&gt;</span>testCompile<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>① 坐标部分</strong></p><p>artifactId 和 version 标签定义了插件的坐标，作为 Maven 的自带插件这里省略了 groupId。</p><p><strong>② 执行部分</strong></p><p>executions 标签内可以配置多个 execution 标签，execution 标签内：</p><ul><li>id：指定唯一标识</li><li>phase：关联的生命周期阶段</li><li>goals/goal：关联指定生命周期的目标</li><li>goals 标签中可以配置多个 goal 标签，表示一个生命周期环节可以对应当前插件的多个目标。</li></ul><h3 id="4-2-典型应用：指定-JDK-版本"><a href="#4-2-典型应用：指定-JDK-版本" class="headerlink" title="4.2 典型应用：指定 JDK 版本"></a>4.2 典型应用：指定 JDK 版本</h3><p>前面我们在 settings.xml 中配置了 JDK 版本，那么将来把 Maven 工程部署都服务器上，脱离了 settings.xml 配置，如何保证程序正常运行呢？思路就是我们直接把 JDK 版本信息告诉负责编译操作的 maven-compiler-plugin 插件，让它在构建过程中，按照我们指定的信息工作。如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- build 标签：意思是告诉 Maven，你的构建行为，我要开始定制了！ --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span>    <span class="comment">&lt;!-- plugins 标签：Maven 你给我听好了，你给我构建的时候要用到这些插件！ --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span>        <span class="comment">&lt;!-- plugin 标签：这是我要指定的一个具体的插件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span>            <span class="comment">&lt;!-- 插件的坐标。此处引用的 maven-compiler-plugin 插件不是第三方的，是一个 Maven 自带的插件。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span>                        <span class="comment">&lt;!-- configuration 标签：配置 maven-compiler-plugin 插件 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span>                <span class="comment">&lt;!-- 具体配置信息会因为插件不同、需求不同而有所差异 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>settings.xml 中配置：仅在本地生效，如果脱离当前 settings.xml 能够覆盖的范围，则无法生效。</li><li>在当前 Maven 工程 pom.xml 中配置：无论在哪个环境执行编译等构建操作都有效。</li></ul><h3 id="4-3-典型应用：SpringBoot-定制化打包"><a href="#4-3-典型应用：SpringBoot-定制化打包" class="headerlink" title="4.3 典型应用：SpringBoot 定制化打包"></a>4.3 典型应用：SpringBoot 定制化打包</h3><p>很显然 spring-boot-maven-plugin 并不是 Maven 自带的插件，而是 SpringBoot 提供的，用来改变 Maven 默认的构建行为。具体来说是改变打包的行为。默认情况下 Maven 调用 maven-jar-plugin 插件的 jar 目标，生成普通的 jar 包。</p><p>普通 jar 包没法使用 java -jar xxx.jar 这样的命令来启动、运行，但是 SpringBoot 的设计理念就是每一个『<strong>微服务</strong>』导出为一个 jar 包，这个 jar 包可以使用 java -jar xxx.jar 这样的命令直接启动运行。</p><p>这样一来，打包的方式肯定要进行调整。所以 SpringBoot 提供了 spring-boot-maven-plugin 这个插件来定制打包行为。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="5-依赖配置补充"><a href="#5-依赖配置补充" class="headerlink" title="5. 依赖配置补充"></a>5. 依赖配置补充</h2><p>管理依赖最基本的办法是继承父工程，但是和 Java 类一样，Maven 也是单继承的。如果不同体系的依赖信息封装在不同 POM 中了，没办法继承多个父工程怎么办？这时就可以使用 import 依赖范围。</p><h3 id="5-1-import"><a href="#5-1-import" class="headerlink" title="5.1 import"></a>5.1 import</h3><p>典型案例当然是在项目中引入 SpringBoot、SpringCloud 依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>        <span class="comment">&lt;!-- SpringCloud 微服务 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>                <span class="comment">&lt;!-- SpringCloud Alibaba 微服务 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-cloud-alibaba.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><p>import 依赖范围使用要求：</p><ul><li>打包类型必须是 pom</li><li>必须放在 dependencyManagement 中</li></ul><blockquote><p>官网说明如下：</p><p>This scope is only supported on a dependency of type <code>pom</code> in the <code>&lt;dependencyManagement&gt;</code> section. It indicates the dependency is to be replaced with the effective list of dependencies in the specified POM’s <code>&lt;dependencyManagement&gt;</code> section. Since they are replaced, dependencies with a scope of <code>import</code> do not actually participate in limiting the transitivity of a dependency.</p></blockquote><h3 id="5-2-system"><a href="#5-2-system" class="headerlink" title="5.2 system"></a>5.2 system</h3><p>以 Windows 系统环境下开发为例，假设现在 <code>D:\product\maven-demo-parent\demo-module\target\demo-module-1.0-SNAPSHOT.jar</code> 想要引入到我们的项目中，此时我们就可以将依赖配置为 system 范围：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.javatv.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>demo-module<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">systemPath</span>&gt;</span>D:\product\maven-demo-parent\demo-module\target\demo-module-1.0-SNAPSHOT.jar<span class="tag">&lt;/<span class="name">systemPath</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>system<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但是很明显：这样引入依赖完全不具有可移植性，所以<strong>不要使用</strong>。</p><h3 id="5-3-runtime"><a href="#5-3-runtime" class="headerlink" title="5.3 runtime"></a>5.3 runtime</h3><p>专门用于编译时不需要，但是运行时需要的 jar 包。比如：编译时我们根据接口调用方法，但是实际运行时需要的是接口的实现类。典型案例是：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--热部署 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="6-profile"><a href="#6-profile" class="headerlink" title="6. profile"></a>6. profile</h2><h3 id="6-1-profile-概述"><a href="#6-1-profile-概述" class="headerlink" title="6.1 profile 概述"></a>6.1 profile 概述</h3><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230718164920473.png" alt="image-20230718164920473"></p><p>这里我们可以对接 profile 这个单词中『<strong>侧面</strong>』这个含义：项目的每一个运行环境，相当于是项目整体的一个侧面。</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230718164953119.png" alt="image-20230718164953119"></p><p>通常情况下，我们项目至少有三种运行环境：</p><ul><li>开发环境：供不同开发工程师开发的各个模块之间互相调用、访问；内部使用</li><li>测试环境：供测试工程师对项目的各个模块进行功能测试；内部使用</li><li>生产环境：供最终用户访问——所以这是正式的运行环境，对外提供服务</li></ul><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230718165021114.png" alt="image-20230718165021114"></p><p>而我们这里的『环境』仍然只是一个笼统的说法，实际工作中一整套运行环境会包含很多种不同服务器：</p><ul><li>MySQL</li><li>Redis</li><li>ElasticSearch</li><li>RabbitMQ</li><li>FastDFS</li><li>Nginx</li><li>Tomcat</li><li>……</li></ul><p>就拿其中的 MySQL 来说，不同环境下的访问参数肯定完全不同，可是代码只有一套。如果在 jdbc.properties 里面来回改，那就太麻烦了，而且很容易遗漏或写错，增加调试的难度和工作量。所以最好的办法就是把适用于各种不同环境的配置信息分别准备好，部署哪个环境就激活哪个配置。</p><p>在 Maven 中，使用 profile 机制来管理不同环境下的配置信息。但是解决同类问题的类似机制在其他框架中也有，而且从模块划分的角度来说，持久化层的信息放在构建工具中配置也违反了『高内聚，低耦合』的原则。</p><p>实际上，即使我们在 pom.xml 中不配置 profile 标签，也已经用到 profile 了。为什么呢？因为根标签 project 下所有标签相当于都是在设定默认的 profile。这样一来我们也就很容易理解下面这句话：project 标签下除了 modelVersion 和坐标标签之外，其它标签都可以配置到 profile 中。</p><h3 id="6-2-profile-配置"><a href="#6-2-profile-配置" class="headerlink" title="6.2 profile 配置"></a>6.2 profile 配置</h3><h4 id="6-2-1-外部视角：配置文件"><a href="#6-2-1-外部视角：配置文件" class="headerlink" title="6.2.1 外部视角：配置文件"></a>6.2.1 外部视角：配置文件</h4><p>从外部视角来看，profile 可以在下面两种配置文件中配置：</p><ul><li>settings.xml：全局生效。其中我们最熟悉的就是配置 JDK 1.8。</li><li>pom.xml：当前 POM 生效</li></ul><h4 id="6-2-2-内部实现：具体标签"><a href="#6-2-2-内部实现：具体标签" class="headerlink" title="6.2.2 内部实现：具体标签"></a>6.2.2 内部实现：具体标签</h4><p>从内部视角来看，配置 profile 有如下语法要求：</p><p><strong>① profiles/profile 标签</strong></p><ul><li>由于 profile 天然代表众多可选配置中的一个所以由复数形式的 profiles 标签统一管理。</li><li>由于 profile 标签覆盖了 pom.xml 中的默认配置，所以 profiles 标签通常是 pom.xml 中的最后一个标签。</li></ul><p><strong>② id 标签</strong></p><p>每个 profile 都必须有一个 id 标签，指定该 profile 的唯一标识。这个 id 标签的值会在命令行调用 profile 时被用到。这个命令格式是：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-D&lt;profile id&gt;</span><br></pre></td></tr></table></figure><p><strong>③ 其它允许出现的标签</strong></p><p>一个 profile 可以覆盖项目的最终名称、项目依赖、插件配置等各个方面以影响构建行为。</p><ul><li>build</li><li>defaultGoal</li><li>finalName</li><li>resources</li><li>testResources</li><li>plugins</li><li>reporting</li><li>modules</li><li>dependencies</li><li>dependencyManagement</li><li>repositories</li><li>pluginRepositories</li><li>properties</li></ul><h3 id="6-3-激活-profile"><a href="#6-3-激活-profile" class="headerlink" title="6.3 激活 profile"></a>6.3 激活 profile</h3><p><strong>① 默认配置默认被激活</strong></p><p>前面提到了，POM 中没有在 profile 标签里的就是默认的 profile，当然默认被激活。</p><p><strong>② 基于环境信息激活</strong></p><p>环境信息包含：JDK 版本、操作系统参数、文件、属性等各个方面。一个 profile 一旦被激活，那么它定义的所有配置都会覆盖原来 POM 中对应层次的元素。可参考下面的标签结构：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>dev<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activation</span>&gt;</span>        <span class="comment">&lt;!-- 配置是否默认激活 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>false<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdk</span>&gt;</span>1.5<span class="tag">&lt;/<span class="name">jdk</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">os</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>Windows XP<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">family</span>&gt;</span>Windows<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">arch</span>&gt;</span>x86<span class="tag">&lt;/<span class="name">arch</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.2600<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">os</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>mavenVersion<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>2.0.5<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">file</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exists</span>&gt;</span>file2.properties<span class="tag">&lt;/<span class="name">exists</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">missing</span>&gt;</span>file1.properties<span class="tag">&lt;/<span class="name">missing</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里有个问题是：多个激活条件之间是什么关系呢？</p><ul><li>Maven <strong>3.2.2 之前</strong>：遇到第一个满足的条件即可激活——<strong>或</strong>的关系。</li><li>Maven <strong>3.2.2 开始</strong>：各条件均需满足——<strong>且</strong>的关系。</li></ul><p>下面我们来看一个具体例子。假设有如下 profile 配置，在 JDK 版本为 1.6 时被激活：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>JDK1.6<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activation</span>&gt;</span>            <span class="comment">&lt;!-- 指定激活条件为：JDK 1.6 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">jdk</span>&gt;</span>1.6<span class="tag">&lt;/<span class="name">jdk</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">        ……</span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里需要指出的是：Maven 会自动检测当前环境安装的 JDK 版本，只要 JDK 版本是以 1.6 开头都算符合条件。下面几个例子都符合：</p><ul><li>1.6.0_03</li><li>1.6.0_02</li><li>……</li></ul><h3 id="6-4-Maven-profile-多环境管理"><a href="#6-4-Maven-profile-多环境管理" class="headerlink" title="6.4 Maven profile 多环境管理"></a>6.4 Maven profile 多环境管理</h3><p>在开发过程中，我们的软件会面对不同的运行环境，比如开发环境、测试环境、生产环境，而我们的软件在不同的环境中，有的配置可能会不一样，比如数据源配置、日志文件配置、以及一些软件运行过程中的基本配置，那每次我们将软件部署到不同的环境时，都需要修改相应的配置文件，这样来回修改，很容易出错，而且浪费劳动力。</p><p>因此我们可以利用 Maven 的 profile 来进行定义多个 profile，然后每个 profile 对应不同的激活条件和配置信息，从而达到不同环境使用不同配置信息的效果。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span>    <span class="comment">&lt;!-- profile对资源的操作 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span>            <span class="comment">&lt;!-- 先排除所有环境相关的配置文件 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>application*.yml<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources</span><br><span class="line">            <span class="tag">&lt;/<span class="name">directory</span>&gt;</span>            <span class="comment">&lt;!-- 是否替换 @xx@ 表示的maven properties属性值 --&gt;</span>            <span class="comment">&lt;!--通过开启 filtering，maven 会将文件中的 @xx@ 替换 profile 中定义的 xx 变量/属性--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>application.yml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>application-$&#123;profileActive&#125;.yml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--多环境文件配置--&gt;</span><span class="tag">&lt;<span class="name">profiles</span>&gt;</span>    <span class="comment">&lt;!--开发环境--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>dev<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activation</span>&gt;</span>            <span class="comment">&lt;!--默认激活--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">profileActive</span>&gt;</span>dev<span class="tag">&lt;/<span class="name">profileActive</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profile</span>&gt;</span>    <span class="comment">&lt;!--测试环境--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>test<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">profileActive</span>&gt;</span>test<span class="tag">&lt;/<span class="name">profileActive</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profile</span>&gt;</span>    <span class="comment">&lt;!--正式环境--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>prod<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">profileActive</span>&gt;</span>prod<span class="tag">&lt;/<span class="name">profileActive</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在 idea 中可以看到，因此，当你需要打包哪一个环境的就勾选即可：</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230718165207096.png" alt="image-20230718165207096"></p><p>同时，SpringBoot 天然支持多环境配置，一般来说，<code>application.yml</code>存放公共的配置，<code>application-dev.yml</code>、<code>application-test.yml</code>、<code>application.prod.yml</code>分别存放三个环境的配置。如下：</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230718165231318.png" alt="image-20230718165231318"></p><p><code>application.yml</code> 中配置<code>spring.profiles.active=prod</code>（或者 dev、test）指定使用的配置文件，如下：</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230718165251938.png" alt="image-20230718165251938"></p><p>注：<code>profileActive</code>，就是上面我们自定义的标签。</p><p>然后当我们勾选哪一个环境，打包的配置文件就是那一个环境：</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230718165326261.png" alt="image-20230718165326261"></p><p>同时我们再在 resource 标签下看到 includes 和 excludes 标签。它们的作用是：</p><ul><li>includes：指定执行 resource 阶段时要包含到目标位置的资源</li><li>excludes：指定执行 resource 阶段时要排除的资源</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>交叉熵</title>
      <link href="/posts/ea101373.html"/>
      <url>/posts/ea101373.html</url>
      
        <content type="html"><![CDATA[<p>摘要</p><span id="more"></span>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vite</title>
      <link href="/posts/5e9df9d6.html"/>
      <url>/posts/5e9df9d6.html</url>
      
        <content type="html"><![CDATA[<p>深入理解Vite核心原理</p><span id="more"></span><h3 id="1-Vite介绍"><a href="#1-Vite介绍" class="headerlink" title="1 Vite介绍"></a>1 Vite介绍</h3><h4 id="1-1-Vite是什么？"><a href="#1-1-Vite是什么？" class="headerlink" title="1.1 Vite是什么？"></a>1.1 Vite是什么？</h4><p><code>Vite</code>是新一代的前端构建工具，在尤雨溪开发<code>Vue3.0</code>的时候诞生。类似于<code>Webpack</code>+ <code>Webpack-dev-server</code>。其主要利用浏览器<code>ESM</code>特性导入组织代码，在服务器端按需编译返回，完全跳过了打包这个概念，服务器随起随用。生产中利用<code>Rollup</code>作为打包工具，号称下一代的前端构建工具。</p><p><code>Vite</code>有如下特点：</p><ul><li><p>快速的冷启动: <code>No Bundle</code> + <code>esbuild</code> 预构建</p></li><li><p>即时的模块热更新: 基于<code>ESM</code>的<code>HMR</code>，同时利用浏览器缓存策略提升速度</p></li><li><p>真正的按需加载: 利用浏览器<code>ESM</code>支持，实现真正的按需加载</p></li></ul><h4 id="1-2-Vite和传统打包方式的对比"><a href="#1-2-Vite和传统打包方式的对比" class="headerlink" title="1.2 Vite和传统打包方式的对比"></a>1.2 Vite和传统打包方式的对比</h4><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230611214645602.png" alt="image-20230611214645602"></p><h5 id="1-2-1-VS-Webapck"><a href="#1-2-1-VS-Webapck" class="headerlink" title="1.2.1 VS Webapck"></a>1.2.1 VS Webapck</h5><p><code>Webpack</code>是近年来使用量最大，同时社区最完善的前端打包构建工具，新出的<code>5.x</code>版本对构建细节进行了优化，在部分场景下打包速度提升明显。<code>Webpack</code>在启动时，会先构建项目模块的依赖图，如果在项目中的某个地方改动了代码，<code>Webpack</code>则会对相关的依赖重新打包，随着项目的增大，其打包速度也会下降。</p><p><code>Vite</code>相比于<code>Webpack</code>而言，没有打包的过程，而是直接启动了一个开发服务器devServer。<code>Vite</code>劫持浏览器的<code>HTTP</code>请求，在后端进行相应的处理将项目中使用的文件通过简单的分解与整合，然后再返回给浏览器(整个过程没有对文件进行打包编译)。所以编译速度很快。</p><h5 id="1-2-2-VS-SnowPack"><a href="#1-2-2-VS-SnowPack" class="headerlink" title="1.2.2 VS SnowPack"></a>1.2.2 VS SnowPack</h5><p><code>Snowpack</code> 首次提出利用浏览器原生<code>ESM</code>能力的打包工具，其理念就是减少或避免整个<code>bundle</code>的打包。默认在 <code>dev</code> 和 <code>production</code> 环境都使用 <code>unbundle</code> 的方式来部署应用。但是它的构建时却是交给用户自己选择，整体的打包体验显得有点支离破碎。</p><p>而 <code>Vite</code> 直接整合了 <code>Rollup</code>，为用户提供了完善、开箱即用的解决方案，并且由于这些集成，也方便扩展更多的高级功能。</p><p>两者较大的区别是在需要<code>bundle</code>打包的时候<code>Vite</code> 使用 <code>Rollup</code> 内置配置，而 <code>Snowpack</code> 通过其他插件将其委托给 <code>Parcel/``webpack</code>。</p><h3 id="2-前置知识"><a href="#2-前置知识" class="headerlink" title="2 前置知识"></a>2 前置知识</h3><h4 id="2-1-ESM"><a href="#2-1-ESM" class="headerlink" title="2.1 ESM"></a>2.1 ESM</h4><p>在了解<code>Vite</code>之前，需要先了解下<code>ESM</code></p><p><code>ESM</code>是<code>JavaScript</code>提出的官方标准化模块系统，不同于之前的<code>CJS</code>，<code>AMD</code>，<code>CMD</code>等等，<code>ESM</code>提供了更原生以及更动态的模块加载方案，最重要的就是它是浏览器原生支持的，也就是说我们可以直接在浏览器中去执行<code>import</code>，动态引入我们需要的模块，而不是把所有模块打包在一起。</p><p>目前<code>ESM</code>模块化已经支持92%以上的浏览器，而且且作为 <code>ECMA</code> 标准，未来会有更多浏览器支持<code>ECMA</code>规范</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230611214659667.png" alt="image-20230611214659667"></p><p>当我们在使用模块开发时，其实就是在构建一张模块依赖关系图，当模块加载时，就会从入口文件开始，最终生成完整的模块实例图。</p><p><code>ESM</code>的执行可以分为三个步骤：</p><ul><li><p>构建: 确定从哪里下载该模块文件、下载并将所有的文件解析为模块记录</p></li><li><p>实例化: 将模块记录转换为一个模块实例，为所有的模块分配内存空间，依照导出、导入语句把模块指向对应的内存地址。</p></li><li><p>运行：运行代码，将内存空间填充</p></li></ul><p>从上面实例化的过程可以看出，<code>ESM</code>使用实时绑定的模式，导出和导入的模块都指向相同的内存地址，也就是值引用。而<code>CJS</code>采用的是值拷贝，即所有导出值都是拷贝值。</p><h4 id="2-2-Esbuild"><a href="#2-2-Esbuild" class="headerlink" title="2.2 Esbuild"></a>2.2 Esbuild</h4><p><code>Vite</code>底层使用<code>Esbuild</code>实现对<code>.``ts</code>、<code>jsx</code>、<code>.``js</code>代码文件的转化，所以先看下什么是<code>es-build</code>。</p><p><code>Esbuild</code>是一个<code>JavaScript``  Bundler </code>打包和压缩工具，它提供了与<code>Webpack</code>、<code>Rollup</code>等工具相似的资源打包能力。可以将<code>JavaScript</code> 和<code>TypeScript</code>代码打包分发在网页上运行。但其打包速度却是其他工具的10～100倍。</p><p>目前他支持以下的功能：</p><ul><li><p>加载器</p></li><li><p>压缩</p></li><li><p>打包</p></li><li><p><code>Tree shaking</code></p></li><li><p><code>Source map</code>生成</p></li></ul><p><code>esbuild</code>总共提供了四个函数：<code>transform</code>、<code>build</code>、<code>buildSync</code>、<code>Service</code>。有兴趣的可以移步<a href="https://link.juejin.cn/?target=https://esbuild.github.io/api/">官方文档</a>了解。</p><h4 id="2-3-Rollup"><a href="#2-3-Rollup" class="headerlink" title="2.3 Rollup"></a>2.3 Rollup</h4><p>在生产环境下，<code>Vite</code>使用<code>Rollup</code>来进行打包</p><p><code>Rollup</code>是基于<code>ESM</code>的<code>JavaScript</code>打包工具。相比于其他打包工具如<code>Webpack</code>，他总是能打出更小、更快的包。因为 <code>Rollup</code> 基于 <code>ESM</code> 模块，比 <code>Webpack</code> 和 <code>Browserify</code> 使用的 <code>CommonJS</code>模块机制更高效。<code>Rollup</code>的亮点在于同一个地方，一次性加载。能针对源码进行 <code>Tree Shaking</code>(去除那些已被定义但没被使用的代码)，以及 <code>Scope Hoisting</code> 以减小输出文件大小提升运行性能。</p><p><code>Rollup</code>分为<code>build</code>（构建）阶段和<code>output generate</code>（输出生成）阶段。主要过程如下：</p><ul><li><p>获取入口文件的内容，包装成<code>module</code>，生成抽象语法树</p></li><li><p>对入口文件抽象语法树进行依赖解析</p></li><li><p>生成最终代码</p></li><li><p>写入目标文件</p></li></ul><p>如果你的项目（特别是类库）只有<code>JavaScript</code>，而没有其他的静态资源文件，使用<code>Webpack</code>就有点大才小用了。因为<code>Webpack</code> 打包的文件的体积略大，运行略慢，可读性略低。这时候<code>Rollup</code>也不失为一个好选择。</p><p>这里想对Rollp进行更深入的学习可以看看<a href="https://link.juejin.cn/?target=https://rollupjs.org/guide/en/">官网的介绍</a>。</p><h3 id="3-核心原理"><a href="#3-核心原理" class="headerlink" title="3 核心原理"></a>3 核心原理</h3><p>详细阐述下：</p><ol><li>当声明一个 <code>script</code>标签类型为 <code>module</code> 时,如</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/src/main.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li>当浏览器解析资源时，会往当前域名发起一个<code>GET</code>请求<code>main.js</code>文件</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"><span class="title function_">createApp</span>(<span class="title class_">App</span>).<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure><ol><li>请求到了<code>main.js</code>文件，会检测到内部含有<code>import</code>引入的包，又会<code>import</code> 引用发起<code>HTTP</code>请求获取模块的内容文件，如<code>App.vue</code>、<code>vue</code>文件</li></ol><p><code>Vite</code>其核心原理是利用浏览器现在已经支持<code>ES6</code>的<code>import</code>,碰见<code>import</code>就会发送一个<code>HTTP</code>请求去加载文件，<code>Vite</code>启动一个 <code>koa</code> 服务器拦截这些请求，并在后端进行相应的处理将项目中使用的文件通过简单的分解与整合，然后再以<code>ESM</code>格式返回返回给浏览器。<code>Vite</code>整个过程中没有对文件进行打包编译，做到了真正的按需加载，所以其运行速度比原始的<code>webpack</code>开发编译速度快出许多！</p><h4 id="3-1-基于ESM的Dev-server"><a href="#3-1-基于ESM的Dev-server" class="headerlink" title="3.1 基于ESM的Dev server"></a>3.1 基于ESM的Dev server</h4><p>在<code>Vite</code>出来之前，传统的打包工具如<code>Webpack</code>是先解析依赖、打包构建再启动开发服务器，<code>Dev Server</code> 必须等待所有模块构建完成，当我们修改了 <code>bundle</code>模块中的一个子模块， 整个 <code>bundle</code> 文件都会重新打包然后输出。项目应用越大，启动时间越长。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/75cc6d8f467a40f78f0b01f10f5ae5e0~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img"></p><p>而<code>Vite</code>利用浏览器对<code>ESM</code>的支持，当 <code>import</code> 模块时，浏览器就会下载被导入的模块。先启动开发服务器，当代码执行到模块加载时再请求对应模块的文件,本质上实现了动态加载。灰色部分是暂时没有用到的路由，所有这部分不会参与构建过程。随着项目里的应用越来越多，增加<code>route</code>，也不会影响其构建速度。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c4b6fdbc052849b991dc309e0114b6d7~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img"></p><h4 id="3-2-基于ESM-的-HMR-热更新"><a href="#3-2-基于ESM-的-HMR-热更新" class="headerlink" title="3.2 基于ESM 的 HMR 热更新"></a>3.2 基于ESM 的 HMR 热更新</h4><p>目前所有的打包工具实现热更新的思路都大同小异：主要是通过<code>WebSocket</code>创建浏览器和服务器的通信监听文件的改变，当文件被修改时，服务端发送消息通知客户端修改相应的代码，客户端对应不同的文件进行不同的操作的更新。</p><h5 id="3-2-1-VS-Webpack"><a href="#3-2-1-VS-Webpack" class="headerlink" title="3.2.1 VS Webpack"></a>3.2.1 VS Webpack</h5><p><code>Webpack</code>: 重新编译，请求变更后模块的代码，客户端重新加载</p><p><code>Vite</code>: 请求变更的模块，再重新加载</p><p><code>Vite</code> 通过 <code>chokidar</code> 来监听文件系统的变更，只用对发生变更的模块重新加载， 只需要精确的使相关模块与其临近的 <code>HMR</code>边界连接失效即可，这样<code>HMR</code> 更新速度就不会因为应用体积的增加而变慢而 <code>Webpack</code> 还要经历一次打包构建。所以 <code>HMR</code> 场景下，<code>Vite</code> 表现也要好于 <code>Webpack</code>。</p><h5 id="3-2-2-核心流程"><a href="#3-2-2-核心流程" class="headerlink" title="3.2.2 核心流程"></a>3.2.2 核心流程</h5><p><code>Vite</code>整个热更新过程可以分成四步</p><ol><li><p>创建一个<code>websocket</code>服务端和<code>client</code>文件，启动服务</p></li><li><p>通过<code>chokidar</code>监听文件变更</p></li><li><p>当代码变更后，服务端进行判断并推送到客户端</p></li><li><p>客户端根据推送的信息执行不同操作的更新</p></li></ol><p>整体流程图：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aa4444159ea14eb583dc787d5f399b56~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="流程图.jpg"></p><h6 id="3-2-2-1-启动热更新：createWebSocketServer"><a href="#3-2-2-1-启动热更新：createWebSocketServer" class="headerlink" title="3.2.2.1 启动热更新：createWebSocketServer"></a>3.2.2.1 启动热更新：createWebSocketServer</h6><p>在 <code>Vite``  dev server </code> 启动之前，<code>Vite</code> 会为 <code>HMR</code> 做一些准备工作：比如创建<code>websocket</code>服务，利用<code>chokidar</code>创建一个监听对象 <code>watcher</code> 用于对文件修改进行监听等等，具体核心代码：</p><blockquote><p>源码位置：packages/vite/src/node/server/index.ts</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">createServer</span>(<span class="params"></span></span><br><span class="line"><span class="params">  inlineConfig: InlineConfig = &#123;&#125;</span></span><br><span class="line"><span class="params"></span>): <span class="title class_">Promise</span>&lt;<span class="title class_">ViteDevServer</span>&gt; &#123;</span><br><span class="line">  ....</span><br><span class="line">  <span class="keyword">const</span> ws = <span class="title function_">createWebSocketServer</span>(httpServer, config, httpsOptions)</span><br><span class="line">  <span class="keyword">const</span> &#123; ignored = [], ...watchOptions &#125; = serverConfig.<span class="property">watch</span> || &#123;&#125;</span><br><span class="line">  <span class="keyword">const</span> watcher = chokidar.<span class="title function_">watch</span>(path.<span class="title function_">resolve</span>(root), &#123;</span><br><span class="line">    <span class="attr">ignored</span>: [</span><br><span class="line">      <span class="string">&#x27;**/node_modules/**&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;**/.git/**&#x27;</span>,</span><br><span class="line">      ...(<span class="title class_">Array</span>.<span class="title function_">isArray</span>(ignored) ? ignored : [ignored])</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">ignoreInitial</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">ignorePermissionErrors</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">disableGlobbing</span>: <span class="literal">true</span>,</span><br><span class="line">    ...watchOptions</span><br><span class="line">  &#125;) <span class="keyword">as</span> <span class="title class_">FSWatcher</span></span><br><span class="line">  ....</span><br><span class="line">  watcher.<span class="title function_">on</span>(<span class="string">&#x27;change&#x27;</span>, <span class="keyword">async</span> (file) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  &#125;)</span><br><span class="line">  watcher.<span class="title function_">on</span>(<span class="string">&#x27;add&#x27;</span>, <span class="function">(<span class="params">file</span>) =&gt;</span> &#123;</span><br><span class="line">  &#125;)</span><br><span class="line">  watcher.<span class="title function_">on</span>(<span class="string">&#x27;unlink&#x27;</span>, <span class="function">(<span class="params">file</span>) =&gt;</span> &#123;</span><br><span class="line">  &#125;)</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> server</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>createWebSocketServer</code>这个方法主是创建<code>WebSocket</code>服务并对错误进行一些处理，最后返回封装好的<code>on</code>、<code>off</code>、 <code>send</code> 和 <code>close</code> 方法，用于后续服务端推送消息和关闭服务。</p><blockquote><p>源码位置：packages/vite/src/node/server/ws.ts</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">createWebSocketServer</span>(<span class="params"></span></span><br><span class="line"><span class="params">  server: Server | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">  config: ResolvedConfig,</span></span><br><span class="line"><span class="params">  httpsOptions?: HttpsServerOptions</span></span><br><span class="line"><span class="params"></span>): <span class="title class_">WebSocketServer</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="attr">wss</span>: <span class="title class_">WebSocket</span></span><br><span class="line">  <span class="keyword">let</span> <span class="attr">httpsServer</span>: <span class="title class_">Server</span> | <span class="literal">undefined</span> = <span class="literal">undefined</span></span><br><span class="line">  <span class="comment">// 热更新配置</span></span><br><span class="line">  <span class="keyword">const</span> hmr = <span class="title function_">isObject</span>(config.<span class="property">server</span>.<span class="property">hmr</span>) &amp;&amp; config.<span class="property">server</span>.<span class="property">hmr</span></span><br><span class="line">  <span class="keyword">const</span> wsServer = (hmr &amp;&amp; hmr.<span class="property">server</span>) || server</span><br><span class="line">  <span class="comment">// 普通模式</span></span><br><span class="line">  <span class="keyword">if</span> (wsServer) &#123;</span><br><span class="line">    wss = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(&#123; <span class="attr">noServer</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">    wsServer.<span class="title function_">on</span>(<span class="string">&#x27;upgrade&#x27;</span>, <span class="function">(<span class="params">req, socket, head</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 监听通过vite客户端发送的websocket消息，通过HMR_HEADER区分</span></span><br><span class="line">      <span class="keyword">if</span> (req.<span class="property">headers</span>[<span class="string">&#x27;sec-websocket-protocol&#x27;</span>] === <span class="variable constant_">HMR_HEADER</span>) &#123;</span><br><span class="line">        wss.<span class="title function_">handleUpgrade</span>(req, socket <span class="keyword">as</span> <span class="title class_">Socket</span>, head, <span class="function">(<span class="params">ws</span>) =&gt;</span> &#123;</span><br><span class="line">          wss.<span class="title function_">emit</span>(<span class="string">&#x27;connection&#x27;</span>, ws, req)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// 中间件模式</span></span><br><span class="line">    <span class="comment">// vite dev server in middleware mode</span></span><br><span class="line">    wss = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(websocketServerOptions)</span><br><span class="line">  &#125;</span><br><span class="line">  wss.<span class="title function_">on</span>(<span class="string">&#x27;connection&#x27;</span>, <span class="function">(<span class="params">socket</span>) =&gt;</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 错误处理</span></span><br><span class="line">  wss.<span class="title function_">on</span>(<span class="string">&#x27;error&#x27;</span>, <span class="function">(<span class="params">e: <span class="built_in">Error</span> &amp; &#123; code: string &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 返回</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">on</span>: wss.<span class="property">on</span>.<span class="title function_">bind</span>(wss),</span><br><span class="line">    <span class="attr">off</span>: wss.<span class="property">off</span>.<span class="title function_">bind</span>(wss),</span><br><span class="line">    <span class="title function_">send</span>(<span class="params">payload: HMRPayload</span>) &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">close</span>(<span class="params"></span>) &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="3-2-2-2-执行热更新：moduleGraph-handleHMRUpdate模块"><a href="#3-2-2-2-执行热更新：moduleGraph-handleHMRUpdate模块" class="headerlink" title="3.2.2.2 执行热更新：moduleGraph+handleHMRUpdate模块"></a>3.2.2.2 执行热更新：moduleGraph+handleHMRUpdate模块</h6><p>接收到文件改动执行的回调，这里主要两个操作：<code>moduleGraph.onFileChange</code>修改文件的缓存和<code>handleHMRUpdate</code>执行热更新</p><blockquote><p>源码位置：packages/vite/src/node/server/index.ts</p></blockquote><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">watcher<span class="selector-class">.on</span>(&#x27;change&#x27;, async (file) =&gt; &#123;</span><br><span class="line">    file = <span class="built_in">normalizePath</span>(file)</span><br><span class="line">    if (file.endsWith(&#x27;/package.json&#x27;)) &#123;</span><br><span class="line">      return <span class="built_in">invalidatePackageData</span>(packageCache, file)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// invalidate module graph cache on file change</span></span><br><span class="line">    moduleGraph<span class="selector-class">.onFileChange</span>(file)</span><br><span class="line">    if (serverConfig.hmr !== false) &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        await <span class="built_in">handleHMRUpdate</span>(file, server)</span><br><span class="line">      &#125; catch (err) &#123;</span><br><span class="line">        ws<span class="selector-class">.send</span>(&#123;</span><br><span class="line">          type: &#x27;error&#x27;,</span><br><span class="line">          err: prepareError(err)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p>3.2.2.2.1 moduleGraph</p><p><code>moduleGraph</code> 是<code>Vite</code>定义的用来记录整个应用的模块依赖图的类，除此之外还有<code>moduleNode</code>。</p><blockquote><p>源码位置：packages/vite/src/node/server/moduleGraph.ts</p></blockquote><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/255b00da11d44a5cbe1cbc077e57cc10~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a5963a5b23e542679409493f1e3022dc~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img"></p><p><code>moduleGraph</code>是由一系列 <code>map</code> 组成，而这些<code>map</code>分别是<code>url</code>、<code>id</code>、<code>file</code>等与<code>ModuleNode</code>的映射，而<code>ModuleNode</code> 是 <code>Vite</code>中定义的最小模块单位。通过这两个类可以构建下面的模块依赖图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4b3cdbaa8c164503a397fd317b3f5f3f~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img"></p><p>可以看看<code>moduleGraph.``onFileChange</code>这个函数：主要是用来清空被修改文件对应的<code>ModuleNode</code>对象的 <code>transformResult</code> 属性，使之前的模块已有的转换缓存失效。这块也就是<code>Vite</code>在热更新里的缓存机制。可以看看官网的<a href="https://link.juejin.cn/?target=https://cn.vitejs.dev/guide/dep-pre-bundling.html%23customizing-the-behavior">介绍</a>。</p><blockquote><p>源码位置：packages/vite/src/node/server/moduleGraph.ts</p></blockquote><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">onFileChange</span>(<span class="attr">file</span>: <span class="built_in">string</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> mods = <span class="variable language_">this</span>.<span class="title function_">getModulesByFile</span>(file)</span><br><span class="line">    <span class="keyword">if</span> (mods) &#123;</span><br><span class="line">      <span class="keyword">const</span> seen = <span class="keyword">new</span> <span class="title class_">Set</span>&lt;<span class="title class_">ModuleNode</span>&gt;()</span><br><span class="line">      mods.<span class="title function_">forEach</span>(<span class="function">(<span class="params">mod</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">invalidateModule</span>(mod, seen)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">invalidateModule</span>(<span class="attr">mod</span>: <span class="title class_">ModuleNode</span>, <span class="attr">seen</span>: <span class="title class_">Set</span>&lt;<span class="title class_">ModuleNode</span>&gt; = <span class="keyword">new</span> <span class="title class_">Set</span>()): <span class="built_in">void</span> &#123;</span><br><span class="line">    mod.<span class="property">info</span> = <span class="literal">undefined</span></span><br><span class="line">    mod.<span class="property">transformResult</span> = <span class="literal">null</span></span><br><span class="line">    mod.<span class="property">ssrTransformResult</span> = <span class="literal">null</span></span><br><span class="line">    <span class="title function_">invalidateSSRModule</span>(mod, seen)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>3.2.2.2.2 handleHMRUpdate</p><p><code>handleHMRUpdate</code> 模块主要是监听文件的更改，进行处理和判断通过<code>WebSocket</code>给客户端发送消息通知客户端去请求新的模块代码。</p><blockquote><p>源码位置：packages/vite/packages/vite/src/node/server/hmr.ts</p></blockquote><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d193a0ce12fd4dcc9ff61f59a7391877~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="流程图2.jpg"></p><h6 id="3-2-2-3-客户端：websocket通信和更新处理"><a href="#3-2-2-3-客户端：websocket通信和更新处理" class="headerlink" title="3.2.2.3 客户端：websocket通信和更新处理"></a>3.2.2.3 客户端：websocket通信和更新处理</h6><p>客户端：当我们配置了热更新且不是<code>ssr</code>的时候，<code>Vite</code>底层在处理html的时候会把<code>HMR</code>相关的客户端代码写入在我们的代码中，如下：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7fc364f458444311bb7f0982d762b77a~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img"></p><p>当接收到服务端推送的消息，通过不同的消息类型做相应的处理，如(<code>connected</code>、<code>update</code>、<code>custom</code>…)，在实际开发热更新中使用最频繁的是<code>update</code>(动态加载热更新模块)和<code>full-reload</code>(刷新整个页面)事件。</p><blockquote><p>源码位置：packages/vite/packages/vite/src/client/client.ts</p></blockquote><p>核心代码实现</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2288c655ae0d48119992c036cb7882d3~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="流程图 3.jpg"></p><h6 id="3-2-2-4-优化：浏览器的缓存策略提高响应速度"><a href="#3-2-2-4-优化：浏览器的缓存策略提高响应速度" class="headerlink" title="3.2.2.4 优化：浏览器的缓存策略提高响应速度"></a>3.2.2.4 优化：浏览器的缓存策略提高响应速度</h6><p>同时，<code>Vite</code> 还利用<code>HTTP</code>加速整个页面的重新加载。设置响应头使得依赖模块(<code>dependency module</code>)进行强缓存，而源码文件通过设置 <code>304 Not Modified</code> 而变成可依据条件而进行更新。</p><p>若需要对依赖代码模块做改动可手动操作使缓存失效:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vite <span class="attr">--force</span></span><br></pre></td></tr></table></figure><p>或者手动删除 <code>node_modules/.``vite</code> 中的缓存文件。</p><h4 id="3-3-基于esbuild的依赖预编译优化"><a href="#3-3-基于esbuild的依赖预编译优化" class="headerlink" title="3.3 基于esbuild的依赖预编译优化"></a>3.3 基于esbuild的依赖预编译优化</h4><h5 id="3-3-1-为什么需要预构建？"><a href="#3-3-1-为什么需要预构建？" class="headerlink" title="3.3.1 为什么需要预构建？"></a>3.3.1 为什么需要预构建？</h5><ol><li><p>支持<code>commonJS</code>依赖</p></li><li><p>上面提到<code>Vite</code>是基于浏览器原生支持<code>ESM</code>的能力实现的，但要求用户的代码模块必须是<code>ESM</code>模块，因此必须将<code>commonJs</code>的文件提前处理，转化成 <code>ESM</code> 模块并缓存入 <code>node_modules/.vite</code></p></li><li><p>减少模块和请求数量</p></li></ol><p>除此之外，我们常用的<code>lodash</code>工具库，里面有很多包通过单独的文件相互导入，而 <code>lodash-es</code>这种包会有几百个子模块，当代码中出现 <code>import &#123; debounce &#125; from &#39;lodash-es&#39;</code> 会发出几百个 <code>HTTP</code> 请求，这些请求会造成网络堵塞，影响页面的加载。</p><p> <code>Vite</code> 将有许多内部模块的 <code>ESM</code> 依赖关系转换为单个模块，以提高后续页面加载性能。</p><p>通过预构建 <code>lodash-es</code> 成为一个模块，也就只需要一个 <code>HTTP</code> 请求了！</p><h5 id="3-3-2-为什么使用Esbuild"><a href="#3-3-2-为什么使用Esbuild" class="headerlink" title="3.3.2 为什么使用Esbuild?"></a>3.3.2 为什么使用<code>Esbuild</code>?</h5><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a6306c038f7343f69a505ffc15b4d274~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img"></p><p>引用尤大的一句话：“快”就一个字</p><p>这是<code>Esbuild</code>首页的图。新一代的打包工具，提供了与<code>Webpack</code>、<code>Rollup</code>、<code>Parcel</code> 等工具相似的资源打包能力，但在时速上达到10～100倍的差距，耗时是<code>Webpack</code>2%~3%</p><ol><li>编译运行 VS 解释运行</li></ol><ul><li>大多数前端打包工具都是基于 <code>JavaScript</code> 实现的，大家都知道<code>JavaScript</code>是解释型语言，边运行边解释。而 <code>Esbuild</code> 则选择使用 <code>Go</code> 语言编写，该语言可以编译为原生代码,在编译的时候都将语言转为机器语言，在启动的时候直接执行即可，在 <code>CPU</code> 密集场景下，<code>Go</code> 更具性能优势。</li></ul><ol><li><p>多线程 VS 单线程</p></li><li><p><code>JavaScript</code> 本质上是一门单线程语言，直到引入 <code>WebWorker</code> 之后才有可能在浏览器、<code>Node</code> 中实现多线程操作。就我对<code>Webpack</code>的源码理解，其源码也并未使用 <code>WebWorker</code> 提供的多线程能力。而<code>GO</code>天生的多线程优势。</p></li><li><p>对构建流程进行了优化，充分利用 <code>CPU</code> 资源</p></li></ol><h5 id="3-3-3-实现原理？"><a href="#3-3-3-实现原理？" class="headerlink" title="3.3.3 实现原理？"></a>3.3.3 实现原理？</h5><p><code>Vite</code>预编译之后，将文件缓存在<code>node_modules/.vite/</code>文件夹下。根据以下地方来决定是否需要重新执行预构建。</p><ul><li><p><code>package.json</code>中：<code>dependencies</code>发生变化</p></li><li><p>包管理器的<code>lockfile</code></p></li></ul><p>如果想强制让<code>Vite</code>重新预构建依赖，可以使用<code>--force</code>启动开发服务器，或者直接删掉<code>node_modules/.vite/</code>文件夹。</p><h6 id="3-3-3-1-核心代码实现"><a href="#3-3-3-1-核心代码实现" class="headerlink" title="3.3.3.1 核心代码实现"></a>3.3.3.1 核心代码实现</h6><ol><li><p>通过<code>createServer</code>创建<code>server</code>对象后，当服务器启动会执行<code>httpServer.listen</code>方法</p></li><li><p>在执行<code>createServer</code>时，<code>Vite</code>底层会重写<code>server.listen</code>方法:首先调用插件的<code>buildStart</code>再执行<code>runOptimize()</code>方法</p></li><li><p><code>runOptimize()</code>调用<code>optimizeDeps()</code>和<code>createMissingImporterRegisterFn()</code>方法</p></li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">runOptimize</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (config.<span class="property">cacheDir</span>) &#123;</span><br><span class="line">      server.<span class="property">_isRunningOptimizer</span> = <span class="literal">true</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        server.<span class="property">_optimizeDepsMetadata</span> = <span class="keyword">await</span> <span class="title function_">optimizeDeps</span>(</span><br><span class="line">          config,</span><br><span class="line">          config.<span class="property">server</span>.<span class="property">force</span> || server.<span class="property">_forceOptimizeOnRestart</span></span><br><span class="line">        )</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        server.<span class="property">_isRunningOptimizer</span> = <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">      server.<span class="property">_registerMissingImport</span> = <span class="title function_">createMissingImporterRegisterFn</span>(server)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">if</span> (!middlewareMode &amp;&amp; httpServer) &#123;</span><br><span class="line">  <span class="keyword">let</span> isOptimized = <span class="literal">false</span></span><br><span class="line">  <span class="comment">// overwrite listen to run optimizer before server start</span></span><br><span class="line">  <span class="keyword">const</span> listen = httpServer.<span class="property">listen</span>.<span class="title function_">bind</span>(httpServer)</span><br><span class="line">  httpServer.<span class="property">listen</span> = (<span class="keyword">async</span> (<span class="attr">port</span>: <span class="built_in">number</span>, ...<span class="attr">args</span>: <span class="built_in">any</span>[]) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isOptimized) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">await</span> container.<span class="title function_">buildStart</span>(&#123;&#125;)</span><br><span class="line">        <span class="keyword">await</span> <span class="title function_">runOptimize</span>()</span><br><span class="line">        isOptimized = <span class="literal">true</span></span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        httpServer.<span class="title function_">emit</span>(<span class="string">&#x27;error&#x27;</span>, e)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">listen</span>(port, ...args)</span><br><span class="line">  &#125;) <span class="keyword">as</span> <span class="built_in">any</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">await</span> container.<span class="title function_">buildStart</span>(&#123;&#125;)</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">runOptimize</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>optimizeDeps()</code>主要是根据配置文件生成<code>hash</code>，获取上次预购建的内容(存放在<code>_metadata.json</code>文件)。如果不是强预构建就对比<code>_metadata.json</code>文件的<code>hash</code>和新生成的<code>hash</code>：一致就返回<code>_metadata.json</code>文件的内容，否则清空缓存文件调用<code>Esbuild</code>构建模块再次存入<code>_metadata.json</code>文件</li></ol><h6 id="3-3-3-2-整体的流程图"><a href="#3-3-3-2-整体的流程图" class="headerlink" title="3.3.3.2 整体的流程图"></a>3.3.3.2 整体的流程图</h6><p>核心代码都在<code>packages/``vite``/``src``/``node``/optimizer/index.ts</code>里面</p><ul><li><p>自动搜寻依赖主要模块：<code>esbuildScanPlugin</code></p></li><li><p>预构建编译主要模块：<code>esbuildDepPlugin</code></p></li></ul><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/65b8b81442b14ed8a0a1738fba03cfe9~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="流程图 4.jpg"></p><h4 id="3-4-基于Rollup的-Plugins"><a href="#3-4-基于Rollup的-Plugins" class="headerlink" title="3.4 基于Rollup的 Plugins"></a>3.4 基于Rollup的 Plugins</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vite` 从 `preact` 的 `WMR` 中得到了启发，将`Vite Plugins`继承`Rollup``  Plugins `` ``API`，在其基础上进行了一些扩展(如`Vite`特有的钩子等)，同时`Vite`也基于`Rollup plugins`机制提供了强大的插件`API`。目前和 `Vite` 兼容或者内置的插件，可以查看`vite-rollup-plugins</span><br></pre></td></tr></table></figure><h5 id="3-4-1-Vite插件是什么"><a href="#3-4-1-Vite插件是什么" class="headerlink" title="3.4.1 Vite插件是什么"></a>3.4.1 Vite插件是什么</h5><p>使用<code>Vite</code>插件可以扩展<code>Vite</code>能力，通过暴露一些构建打包过程的一些时机配合工具函数，让用户可以自定义地写一些配置代码，执行在打包过程中。比如解析用户自定义的文件输入，在打包代码前转译代码，或者查找。</p><p>在实际的实现中，<code>Vite</code> 仅仅需要基于<code>Rollup</code>设计的接口进行扩展，在保证兼容 <code>Rollup</code>插件的同时再加入一些<code>Vite</code>特有的钩子和属性来进行扩展。</p><h5 id="3-4-2-Vite独有钩子"><a href="#3-4-2-Vite独有钩子" class="headerlink" title="3.4.2 Vite独有钩子"></a>3.4.2 Vite独有钩子</h5><p>对于各个钩子的具体使用可以<a href="https://link.juejin.cn/?target=https://cn.vitejs.dev/guide/api-plugin.html%23vite-specific-hooks">移步这里</a></p><ul><li><p><code>config</code>：可以在<code>Vite</code>被解析之前修改<code>Vite</code>的相关配置。钩子接收原始用户配置<code>config</code>和一个描述配置环境的变量<code>env</code></p></li><li><p><code>configResolved</code>：解析<code>Vite</code>配置后调用，配置确认</p></li><li><p><code>configureserver</code>：主要用来配置开发服务器，为<code>dev-server</code>添加自定义的中间件</p></li><li><p><code>transformindexhtml</code>：主要用来转换<code>index.html</code>，钩子接收当前的 <code>HTML</code> 字符串和转换上下文</p></li><li><p><code>handlehotupdate</code>：执行自定义<code>HMR</code>更新，可以通过<code>ws</code>往客户端发送自定义的事件</p></li></ul><h5 id="3-4-3-通用钩子"><a href="#3-4-3-通用钩子" class="headerlink" title="3.4.3 通用钩子"></a>3.4.3 通用钩子</h5><p>这里举一些常用的通用钩子，其余的通用钩子可以<a href="https://link.juejin.cn/?target=https://cn.vitejs.dev/guide/api-plugin.html%23universal-hooks">移步这里</a></p><ul><li><p>服务启动时调用一次</p><ul><li><code>options</code>: 获取、操纵<code>Rollup</code>选项</li><li><code>buildstart</code>：开始创建</li></ul></li><li><p>在每个传入模块请求时被调用</p><ul><li><code>resolveId</code>: 创建自定义确认函数，可以用来定位第三方依赖</li><li><code>load</code>：可以自定义加载器，可用来返回自定义的内容</li><li><code>transform</code>：在每个传入模块请求时被调用，主要是用来转换单个模块</li></ul></li><li><p>服务关闭时调用一次</p><ul><li><code>buildend</code>：在服务器关闭时被调用</li><li><code>closeBundle</code></li></ul></li></ul><h5 id="3-4-4-钩子的调用顺序"><a href="#3-4-4-钩子的调用顺序" class="headerlink" title="3.4.4 钩子的调用顺序"></a>3.4.4 钩子的调用顺序</h5><p>引用@young村长的一个图:</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/564ebefb5e304704b2dba4b132129d94~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img"></p><p><code>Vite</code><a href="https://link.juejin.cn/?target=https://cn.vitejs.dev/guide/api-plugin.html%23plugin-ordering">的官网</a>可以看出：<code>Vite</code>插件可以用一个 <code>enforce</code> 属性（类似于 <code>Webpack</code>加载器）来调整它的应用顺序。<code>enforce</code> 的值可以是<code>pre</code> 或 <code>post</code>。解析后的插件将按照以下顺序排列：</p><ul><li><p><code>Alias</code></p></li><li><p><code>enforce:&#39;pre&#39;</code>的自定义插件</p></li><li><p><code>Vite</code>核心插件</p></li><li><p>没有<code>enforce</code>的自定义插件</p></li><li><p><code>Vite</code>构建用的插件</p></li><li><p><code>enforce:&#39;post&#39;</code>的自定义插件</p></li><li><p><code>Vite</code>后置构建插件</p></li></ul><h5 id="3-4-5-自定义插件"><a href="#3-4-5-自定义插件" class="headerlink" title="3.4.5 自定义插件"></a>3.4.5 自定义插件</h5><ul><li>编写插件代码</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">myVitePlugin</span> () &#123;</span><br><span class="line">  <span class="comment">// 定义vite插件唯一id</span></span><br><span class="line">  <span class="keyword">const</span> virtualFileId = <span class="string">&#x27;@my-vite-plugin&#x27;</span></span><br><span class="line">  <span class="comment">// 返回的整个插件对象</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="comment">// 必须的，将会显示在 warning 和 error 中</span></span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;vite-plugin&#x27;</span>,</span><br><span class="line">    <span class="comment">// 钩子</span></span><br><span class="line">    <span class="comment">// config</span></span><br><span class="line">    <span class="attr">config</span>: <span class="function">(<span class="params">config, env</span>) =&gt;</span> (&#123;</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;config&#x27;</span>,config)</span><br><span class="line">       <span class="keyword">return</span> &#123;&#125;</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="comment">// 确认config</span></span><br><span class="line">    <span class="attr">configResolved</span>: <span class="function"><span class="params">config</span> =&gt;</span> (&#123;&#125;),</span><br><span class="line">    <span class="attr">options</span>: <span class="function"><span class="params">options</span> =&gt;</span> (&#123;&#125;),</span><br><span class="line">    <span class="attr">buildStart</span>: <span class="function"><span class="params">options</span> =&gt;</span> (&#123;&#125;),</span><br><span class="line">    <span class="attr">transformIndexHtml</span>: <span class="function">(<span class="params">html, ctx</span>) =&gt;</span> (&#123;</span><br><span class="line">        <span class="keyword">return</span> html</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="comment">//确认</span></span><br><span class="line">    <span class="attr">resolveId</span>: <span class="function">(<span class="params">source, importer</span>) =&gt;</span> (&#123;&#125;),</span><br><span class="line">    <span class="comment">// 转换</span></span><br><span class="line">    <span class="attr">transform</span>: <span class="function">(<span class="params">code, id</span>) =&gt;</span> (&#123;&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>引入插件：<code>vite.config.js/ts</code> 中引用</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vite.config.js/ts</span></span><br><span class="line"><span class="keyword">import</span> myVitePlugin <span class="keyword">from</span> <span class="string">&#x27;...&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> defineConfig&#123;</span><br><span class="line">    <span class="attr">plugins</span>:[<span class="title function_">vue</span>(),<span class="title function_">myVitePlugin</span>()]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h3><p>最后总结下<code>Vite</code>相关的优缺点：</p><ul><li><p>优点：</p><ul><li>快速的冷启动: 采用<code>No Bundle</code>和<code>esbuild</code>预构建，速度远快于<code>Webpack</code></li><li>高效的热更新：基于<code>ESM</code>实现，同时利用<code>HTTP</code>头来加速整个页面的重新加载，增加缓存策略</li><li>真正的按需加载: 基于浏览器<code>ESM</code>的支持，实现真正的按需加载</li></ul></li><li><p>缺点</p><ul><li>生态：目前<code>Vite</code>的生态不如<code>Webapck</code>，不过我觉得生态也只是时间上的问题。</li><li>生产环境由于<code>esbuild</code>对<code>css</code>和代码分割不友好使用<code>Rollup</code>进行打包</li></ul></li></ul><p><code>Vite.js</code>虽然才在构建打包场景兴起，但在很多场景下基本都会优于现有的解决方案。如果有生态、想要丰富的<code>loader</code>、<code>plugins</code>的要求可以考虑成熟的<code>Webpack</code>。在其余情况下，<code>Vite.js</code>不失为一个打包构建工具的好选择。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微前端</title>
      <link href="/posts/3b97e6.html"/>
      <url>/posts/3b97e6.html</url>
      
        <content type="html"><![CDATA[<p>摘要</p><span id="more"></span><h1 id="对微前端的理解"><a href="#对微前端的理解" class="headerlink" title="对微前端的理解"></a>对微前端的理解</h1><p>微前端的核心理念是将前端应用程序看作是一个整体，由多个独立的部分组成。每个部分被视为一个微前端应用，它们可以具有自己的技术栈、开发流程和团队组织。这种方式使得团队可以独立开发和部署各个子应用，减少了协调和合并的复杂性。</p><h1 id="为什么-Iframe-无法胜任微前端的工作？"><a href="#为什么-Iframe-无法胜任微前端的工作？" class="headerlink" title="为什么 Iframe 无法胜任微前端的工作？"></a>为什么 Iframe 无法胜任微前端的工作？</h1><p>IFrame 在传统的前端开发中是一种常见的技术，用于在页面中嵌入其他网页或应用程序。然而，在微前端架构中，IFrame 并不是一个理想的选择，主要是因为以下几个方面的限制：</p><ol><li>隔离性和通信复杂性：IFrame 本身提供了一种隔离的环境，但这也带来了通信和数据交互的复杂性。由于每个子应用都在独立的 IFrames 中运行，它们之间的通信需要通过特定的机制，如消息传递，而这增加了开发和维护的复杂性。</li><li>性能和加载时间：每个 IFrames 都需要加载和渲染独立的 HTML、CSS 和 JavaScript。这意味着在加载微前端应用时，需要同时加载多个 IFrames，导致额外的网络请求和页面资源占用，可能会影响性能和加载时间。</li><li>样式和布局限制：IFrame 的内容在页面中是独立的，它们具有自己的 CSS 样式和布局上下文。这导致在微前端架构中难以实现全局样式的一致性，以及子应用之间的布局和交互的协调问题。</li><li>浏览器安全性限制：由于安全策略的限制，IFrame 之间的跨域通信可能受到限制，特别是在涉及跨域资源访问和共享数据时。这可能导致在微前端架构中需要处理复杂的安全性问题。</li></ol><p>鉴于以上限制，微前端架构通常采用其他技术手段来实现子应用的拆分和集成，例如使用 Web Components、JavaScript 模块加载器等。这些技术能够提供更好的隔离性、通信机制和性能优化，使得微前端架构更具可行性和灵活性。</p><h1 id="微前端运行原理"><a href="#微前端运行原理" class="headerlink" title="微前端运行原理"></a>微前端运行原理</h1><ul><li>监听路由变化</li><li>匹配子应用</li><li>加载子应用</li><li>渲染子应用</li></ul><h2 id="监听路由变化"><a href="#监听路由变化" class="headerlink" title="监听路由变化"></a>监听路由变化</h2><ol><li>监听 hash 路由: <code>window.onhashchange</code></li><li>监听 history 路由</li></ol><p>history.go、history.back、history.forward 使用 popstate 事件 <code>window.onpopstate</code></p><p>监听的方式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;popstate&#x27;</span>, <span class="function">() =&gt;</span> &#123;&#125;)</span><br></pre></td></tr></table></figure><p><strong>重写</strong>: pushState、replaceState 需要通过函数重写的方式进行 <code>劫持</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> rawPushState = <span class="variable language_">window</span>.<span class="property">history</span>.<span class="property">pushState</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">history</span>.<span class="property">pushState</span> = <span class="keyword">function</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">  rawPushState.<span class="title function_">apply</span>(<span class="variable language_">window</span>.<span class="property">history</span>, args)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 其他逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rawReplaceState = <span class="variable language_">window</span>.<span class="property">history</span>.<span class="property">replaceState</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">history</span>.<span class="property">replaceState</span> = <span class="keyword">function</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">  rawReplaceState.<span class="title function_">apply</span>(<span class="variable language_">window</span>.<span class="property">history</span>, args)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 其他逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Vue 项目中，我们通过 this.router.push会触发‘history.pushState‘事件，this.router.push 会触发 <code>history.pushState</code> 事件，this.router.push会触发‘history.pushState‘事件，this.router.replace 会触发 <code>history.replaceState</code> 事件。</p><h2 id="匹配子应用"><a href="#匹配子应用" class="headerlink" title="匹配子应用"></a>匹配子应用</h2><p>监听路由的变化后，拿到当前路由的路径 <code>window.location.pathname</code>，然后根据 registerMicroApps 的参数 <code>apps</code> 查找子应用。因为子应用都配置了 <code>activeRule</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果当前的 pathname 以 activeRule 开头，表明匹配到了子应用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> currentApp = apps.<span class="title function_">find</span>(<span class="function"><span class="params">app</span> =&gt;</span> <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">pathname</span>.<span class="title function_">startWith</span>(app.<span class="property">activeRule</span>))</span><br></pre></td></tr></table></figure><h2 id="加载子应用"><a href="#加载子应用" class="headerlink" title="加载子应用"></a>加载子应用</h2><p>当我们找到了与当前路由匹配的子应用，接着就去加载这个子应用的资源。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> handleRouter = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="comment">// 匹配子应用</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 加载资源</span></span><br><span class="line">  <span class="keyword">const</span> html = <span class="keyword">await</span> <span class="title function_">fetch</span>(currentApp.<span class="property">entry</span>.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> res.<span class="title function_">text</span>())</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将 html 渲染到指定的容器内</span></span><br><span class="line">  <span class="keyword">const</span> container = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(currentApp.<span class="property">container</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候，我们就拿到了子应用的 <code>html</code> 文本。</p><p>但是我们不能给直接通过 <code>container.innerHTML = html</code> 将文本放到容器内，这样是无法显示的。</p><p><strong>注意</strong> 浏览器处于安全考虑，放到页面上的 html 如果包含了 js 脚本，它是不会去执行 js 的。我们需要手动处理 <code>script</code> 脚本。</p><h2 id="importHTML-加载资源-处理脚本"><a href="#importHTML-加载资源-处理脚本" class="headerlink" title="importHTML 加载资源/处理脚本"></a>importHTML 加载资源/处理脚本</h2><p>我们来封装一个函数 <code>importHTML</code>，专门来处理 <code>html</code> 文本。(<code>qiankun内部引用的 import-html-entry 就是做这个事的。</code>)</p><p>我们可以把加载子应用资源的 fetch 请求放到 importHTML 函数中，它还有如下几个功能：</p><ul><li>将获取到的 html 文本，放到 template DOM节点中</li><li>获取所有的 Script 脚本</li><li>执行所有的 Script 脚本</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">importHTML</span> = url =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> html = <span class="keyword">await</span> <span class="title function_">fetch</span>(currentApp.<span class="property">entry</span>).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> res.<span class="title function_">text</span>()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> template = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  template.<span class="property">innerHTML</span> = html</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> scripts = template.<span class="title function_">querySelectAll</span>(<span class="string">&#x27;script&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">getExternalScripts</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;解析所有脚本: &#x27;</span>, scripts)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">execScripts</span> = (<span class="params"></span>) =&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    template, <span class="comment">// html 文本</span></span><br><span class="line">    getExternalScripts, <span class="comment">// 获取 Script 脚本</span></span><br><span class="line">    execScripts, <span class="comment">// 执行 Sript 脚本</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>script 脚本分为 <code>内联</code> 脚本和外链脚本，这里需要分开处理，拿到内联脚本后，获取内容可以通过 <code>eval</code> 直接处理。如果是含有 <code>scr</code> 的 script 脚本，还需要拿到 src 的值，通过 <code>fetch</code> 去加载脚本。</p><p>我们在 <code>getExternalScripts</code> 方法中来处理</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">getExternalScripts</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>(<span class="title class_">Array</span>.<span class="title function_">from</span>(scripts).<span class="title function_">map</span>(<span class="function"><span class="params">script</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 获取 scr 属性</span></span><br><span class="line">    <span class="keyword">const</span> src = script.<span class="title function_">getAttribute</span>(<span class="string">&#x27;src&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!src) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(script.<span class="property">innerHTML</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">fetch</span>(src.<span class="title function_">startWith</span>(<span class="string">&#x27;http&#x27;</span>) ? src : <span class="string">`<span class="subst">$&#123;url&#125;</span><span class="subst">$&#123;src&#125;</span>`</span>).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> res.<span class="title function_">text</span>())</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们就可以通过 <code>execScripts</code> 方法去调用 getExternalScripts，拿到所有的脚本内容后，执行！</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">execScripts</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> scripts = <span class="keyword">await</span> <span class="title function_">getExternalScripts</span>() </span><br><span class="line"></span><br><span class="line">  scripts.<span class="title function_">forEach</span>(<span class="function"><span class="params">code</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">eval</span>(code)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="qiankun"><a href="#qiankun" class="headerlink" title="qiankun"></a>qiankun</h1><blockquote><p><a href="https://link.juejin.cn/?target=https://qiankun.umijs.org/zh">qiankun.umijs.org/zh</a></p></blockquote><p>我们看 qiankun 的依赖，可以发现 qiankun 是基于 single-spa 实现的，通过 import-html-entry 包处理 html / css</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;dependencies&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;import-html-entry&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^1.14.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;single-spa&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^5.9.2&quot;</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><h1 id="微前端的子项目是怎么引入到主项目里的"><a href="#微前端的子项目是怎么引入到主项目里的" class="headerlink" title="微前端的子项目是怎么引入到主项目里的"></a>微前端的子项目是怎么引入到主项目里的</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">registerMicroApps</span>(</span><br><span class="line">  [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;react16&#x27;</span>,</span><br><span class="line">      <span class="attr">entry</span>: <span class="string">&#x27;//localhost:7100&#x27;</span>,</span><br><span class="line">      <span class="attr">container</span>: <span class="string">&#x27;#subapp-viewport&#x27;</span>,</span><br><span class="line">      loader,</span><br><span class="line">      <span class="attr">activeRule</span>: <span class="string">&#x27;/react16&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;react15&#x27;</span>,</span><br><span class="line">      <span class="attr">entry</span>: <span class="string">&#x27;//localhost:7102&#x27;</span>,</span><br><span class="line">      <span class="attr">container</span>: <span class="string">&#x27;#subapp-viewport&#x27;</span>,</span><br><span class="line">      loader,</span><br><span class="line">      <span class="attr">activeRule</span>: <span class="string">&#x27;/react15&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  ]</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ol><li>容器指定路由匹配规则加载子应用，一旦路径匹配就会加载子应用资源</li><li>子应用打包输出格式为 umd，并且要允许跨域</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vue.config.js</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">devServer</span>: &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="attr">headers</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>: <span class="string">&#x27;*&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 自定义webpack配置</span></span><br><span class="line">  <span class="attr">configureWebpack</span>: &#123;</span><br><span class="line">    <span class="attr">output</span>: &#123;</span><br><span class="line">      <span class="comment">// 把子应用打包成库文件、格式是 umd</span></span><br><span class="line">      <span class="attr">library</span>: <span class="string">`<span class="subst">$&#123;name&#125;</span>-[name]`</span>,</span><br><span class="line">      <span class="attr">libraryTarget</span>: <span class="string">&#x27;umd&#x27;</span>,</span><br><span class="line">      <span class="attr">jsonpFunction</span>: <span class="string">`webpackJsonp_<span class="subst">$&#123;name&#125;</span>`</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="umd"><a href="#umd" class="headerlink" title="umd"></a>umd</h1><p>umd全称是UniversalModuleDefinition，是一种通用模块定义格式，通常用于前端模块化开发中。</p><p>由于不同的模块化规范定义不同，为了让各种规范的模块可以通用，在不同的环境下都可以正常运行，就出现了umd这个通用格式。</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>umd 格式是一种既可以在浏览器环境下使用，也可以在 node 环境下使用的格式。它将 CommonJS、AMD以及普通的全局定义模块三种模块模式进行了整合。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span> (<span class="params"><span class="variable language_">global</span>, factory</span>) &#123;</span><br><span class="line">  <span class="comment">// CommonJS</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">exports</span> === <span class="string">&#x27;object&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> <span class="variable language_">module</span> !== <span class="string">&#x27;undefined&#x27;</span> ? <span class="title function_">factory</span>(<span class="built_in">exports</span>) :</span><br><span class="line">  <span class="comment">// AMD</span></span><br><span class="line"><span class="keyword">typeof</span> define === <span class="string">&#x27;function&#x27;</span> &amp;&amp; define.<span class="property">amd</span> ? <span class="title function_">define</span>([<span class="string">&#x27;exports&#x27;</span>], factory) :</span><br><span class="line">  <span class="comment">// Window</span></span><br><span class="line">(<span class="variable language_">global</span> = <span class="keyword">typeof</span> globalThis !== <span class="string">&#x27;undefined&#x27;</span> ? globalThis : <span class="variable language_">global</span> || self, <span class="title function_">factory</span>(<span class="variable language_">global</span>.<span class="property">qiankun</span> = &#123;&#125;));</span><br><span class="line">&#125;(<span class="variable language_">this</span>, (<span class="keyword">function</span> (<span class="params"><span class="built_in">exports</span></span>) &#123;</span><br><span class="line">  <span class="comment">// 应用代码</span></span><br><span class="line">&#125;)));</span><br></pre></td></tr></table></figure><h2 id="为什么-qiankun-要求子应用打包为-umd-库格式呢？"><a href="#为什么-qiankun-要求子应用打包为-umd-库格式呢？" class="headerlink" title="为什么 qiankun 要求子应用打包为 umd 库格式呢？"></a>为什么 qiankun 要求子应用打包为 umd 库格式呢？</h2><p>主要是为了主应用能够拿到子应用在 <code>入口文件</code> 导出的 <code>生命钩子函数</code>，这也是主应用和子应用之间通信的关键。</p><ul><li>bootstrap</li><li>mount</li><li>unmount</li></ul><h1 id="获取子应用资源-import-html-entry"><a href="#获取子应用资源-import-html-entry" class="headerlink" title="获取子应用资源 - import-html-entry"></a>获取子应用资源 - import-html-entry</h1><p>HTML Entry + Sandbox 是 qiankun 区别于 single-spa 的主要两个特性。</p><p>single-spa和qiankun最大的不同，大概就是qiankun实现了html entry，而single-spa只能是js entry</p><p>通过 import-html-entry，我就能像 iframe 一样加载一个子应用，只需要知道其 html 的 url 就能加载到主应用中。</p><p>importHTML 几个核心方法:</p><p>首先importHTML的参数为需要加载的页面url，拿到后会先通过 <code>fetch方法</code> 读取页面内容。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> importHTML <span class="keyword">from</span> <span class="string">&#x27;import-html-entry&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">importHTML</span>(<span class="string">&#x27;./subApp/index.html&#x27;</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res.<span class="property">template</span>);</span><br><span class="line"></span><br><span class="line">    res.<span class="title function_">execScripts</span>().<span class="title function_">then</span>(<span class="function"><span class="params">exports</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> mobx = <span class="built_in">exports</span>;</span><br><span class="line">      <span class="keyword">const</span> &#123; observable &#125; = mobx;</span><br><span class="line">      <span class="title function_">observable</span>(&#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;kuitos&#x27;</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><ul><li>template - string - 处理过的 HTML 模板。</li><li>assetPublicPath - string - 资源的公共途径。</li><li>getExternalScripts - Promise&lt;string[]&gt; - 来自模板的脚本 URL。</li><li>getExternalStyleSheets - Promise&lt;string[]&gt; - 来自模板的 StyleSheets URL。</li><li>execScripts - (sandbox?: object, strictGlobal?: boolean, execScriptsHooks?: ExecScriptsHooks): - Promise - the return value is the last property on window or proxy window which set by the entry - script.<ul><li>sandbox - optional, Window or proxy window.</li><li>strictGlobal - optional, Strictly enforce the sandbox.</li></ul></li></ul><h2 id="processTpl"><a href="#processTpl" class="headerlink" title="processTpl"></a>processTpl</h2><p>它会解析html的内容并且删除注释，获取style样式及script代码。通过<code>大量的正则</code> + replace，每一个步骤都做了很多适配，比如获取script脚本，需要区分该script是不是entry script，type是JavaScript还是module，是行内script还是外链script，是相对路径还是绝对路径，是否需要处理协议等等。</p><p>processTpl的返回值有 template，script，style，entry。</p><h1 id="JS-沙箱"><a href="#JS-沙箱" class="headerlink" title="JS 沙箱"></a>JS 沙箱</h1><p>JavaScript 沙箱是一种安全机制，用于隔离和限制 JavaScript 代码的执行环境，以防止恶意代码或意外行为对系统造成损害。沙箱提供了一种受控的环境，限制了代码的访问权限和执行能力，确保代码只能在受限制的范围内操作。</p><p>JavaScript 沙箱通常用于以下情况：</p><ol><li>在多租户环境中，确保不同用户或组织的代码相互隔离，防止相互干扰或访问敏感信息。</li><li>在第三方代码或插件中使用，以确保其代码不会对宿主环境造成潜在的安全漏洞或冲突。</li><li>在应用程序中执行用户提供的代码，例如在线代码编辑器或脚本执行环境，以防止恶意代码对用户数据或系统进行攻击。</li><li>在浏览器中执行不受信任的代码，例如浏览器插件或扩展，以保护用户的隐私和安全。</li></ol><p>JavaScript 沙箱通过限制代码的访问权限、提供隔离的执行环境、使用安全策略和沙箱沙盒技术等手段来实现。常见的 JavaScript 沙箱技术包括沙盒环境、Web Worker、iframe、JavaScript 虚拟机等。这些技术通过限制代码的执行权限、提供独立的运行环境、隔离全局上下文等方式来确保代码的安全执行。</p><h2 id="快照沙箱-SnapshotSandbox"><a href="#快照沙箱-SnapshotSandbox" class="headerlink" title="快照沙箱-SnapshotSandbox"></a>快照沙箱-SnapshotSandbox</h2><p>缺点：</p><ul><li>遍历 window 上所有属性，性能差</li><li>同一时间只能激活一个微应用</li><li>污染全局 window</li></ul><p>优点：</p><p>可以支持不兼容Proxy的浏览器。</p><p>先了解 SnapshotSandbox 的功能</p><ol><li>我们激活沙箱后，在 window 上修改的所有属性，都应该存起来，在下一次激活时，需要还原上次在 window 上修改的属性</li><li>失活后，应该将 window 还原成激活前的状态</li></ol><p>我们来举个例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 激活前</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">city</span> = <span class="string">&#x27;Beijing&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 激活</span></span><br><span class="line">sanbox.<span class="title function_">active</span>()</span><br><span class="line"></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">city</span> = <span class="string">&#x27;上海&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 失活</span></span><br><span class="line">sanbox.<span class="title function_">inactive</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">city</span>) <span class="comment">// 打印 &#x27;Beijing&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 再激活</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">city</span>) <span class="comment">// 打印 &#x27;上海&#x27;</span></span><br></pre></td></tr></table></figure><p>接下来，实现一个简易版的 SnapshotSandbox</p><ol><li>SnapshotSandbox 能够还原 window 和记录自己以前的状态，那么就需要两个对象来存储这些信息</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> windowSnapshot 用来存储沙箱激活前的 <span class="variable language_">window</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> modifyPropsMap 用来存储沙箱激活期间，在 <span class="variable language_">window</span> 上修改过的属性</span><br></pre></td></tr></table></figure><ol><li>沙箱需要两个方法及作用</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> sanbox.<span class="title function_">active</span>() <span class="comment">// 激活沙箱</span></span><br><span class="line"></span><br><span class="line">  - 保存 <span class="variable language_">window</span> 的快照</span><br><span class="line"></span><br><span class="line">  - 再次激活时，将 <span class="variable language_">window</span> 还原到上次 active 的状态</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> sanbox.<span class="title function_">inactive</span>() <span class="comment">// 失活沙箱</span></span><br><span class="line"></span><br><span class="line">  - 记录当前在 <span class="variable language_">window</span> 上修改了的 prop</span><br><span class="line"></span><br><span class="line">  - 还原 <span class="variable language_">window</span> 到 active 之前的状态</span><br></pre></td></tr></table></figure><p>我们先来实现沙箱内部细节：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SnapshotSandbox</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">windowSnapshot</span> = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">modifyPropsMap</span> = &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">active</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 1. 保存 window 的快照</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> prop <span class="keyword">in</span> <span class="variable language_">window</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="title function_">hasOwnProperty</span>(prop)) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">windowSnapshot</span>[prop] = <span class="variable language_">window</span>[prop]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 再次激活时，将 window 还原到上次 active 的状态，modifyPropsMap 存储了上次 active 时在 widow 上修改了哪些属性</span></span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">keys</span>(modifyPropsMap).<span class="title function_">forEach</span>(<span class="function"><span class="params">prop</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">window</span>[prop] = <span class="variable language_">this</span>.<span class="property">modifyPropsMap</span>[prop]</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">inactive</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> prop <span class="keyword">in</span> <span class="variable language_">window</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="title function_">hasOwnProperty</span>(prop)) &#123;</span><br><span class="line">        <span class="comment">// 两者不相同，表示修改了某个 prop 记录当前在 window 上修改了的 prop</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">window</span>[prop] !== <span class="variable language_">this</span>.<span class="property">windowSnapshot</span>[prop]) &#123;</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">modifyPropsMap</span>[prop] = <span class="variable language_">window</span>[prop]</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 还原 window</span></span><br><span class="line">        <span class="variable language_">window</span>[prop] = <span class="variable language_">this</span>.<span class="property">windowSnapshot</span>[prop]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来验证一下，首先设置 <code>window.city</code> 一个初始值 <code>beijing</code>，然后初始化 沙箱，在第一次激活后，修改了 <code>window.city</code> 为 <code>上海</code>，那么应该在失活后，打印 <code>beijing</code>，再次激活时，<code>window.city</code> 是 <code>上海</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">city</span> = <span class="string">&#x27;beijing&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ss = <span class="keyword">new</span> <span class="title class_">SnapshotSandbox</span>()</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;window.city0 &#x27;</span>, <span class="variable language_">window</span>.<span class="property">city</span>)</span><br><span class="line"></span><br><span class="line">ss.<span class="title function_">active</span>() <span class="comment">// 激活</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">city</span> = <span class="string">&#x27;上海&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;window.city1 &#x27;</span>, <span class="variable language_">window</span>.<span class="property">city</span>) <span class="comment">// 上海</span></span><br><span class="line"></span><br><span class="line">ss.<span class="title function_">inactive</span>()</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;window.city2 &#x27;</span>, <span class="variable language_">window</span>.<span class="property">city</span>) <span class="comment">// beijing</span></span><br><span class="line"></span><br><span class="line">ss.<span class="title function_">active</span>()</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;window.city3 &#x27;</span>, <span class="variable language_">window</span>.<span class="property">city</span>) <span class="comment">// 上海</span></span><br><span class="line"></span><br><span class="line">ss.<span class="title function_">inactive</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;window.city4 &#x27;</span>, <span class="variable language_">window</span>.<span class="property">city</span>) <span class="comment">// beijing</span></span><br><span class="line"></span><br><span class="line">ss.<span class="title function_">active</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;window.city5 &#x27;</span>, <span class="variable language_">window</span>.<span class="property">city</span>) <span class="comment">// 上海</span></span><br></pre></td></tr></table></figure><p>不支持多个应用同时运行，因为污染了全局 window</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">city</span> = <span class="string">&#x27;beijing&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ss = <span class="keyword">new</span> <span class="title class_">SnapshotSandbox</span>()</span><br><span class="line">ss.<span class="title function_">active</span>() <span class="comment">// 激活</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">city</span> = <span class="string">&#x27;上海&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ss1 = <span class="keyword">new</span> <span class="title class_">SnapshotSandbox</span>()</span><br><span class="line">ss1.<span class="title function_">active</span>() <span class="comment">// 激活</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">city</span> = <span class="string">&#x27;广州&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">city</span>) <span class="comment">// 广州</span></span><br></pre></td></tr></table></figure><h2 id="Legacy沙箱-LegacySandbox（单例）"><a href="#Legacy沙箱-LegacySandbox（单例）" class="headerlink" title="Legacy沙箱-LegacySandbox（单例）"></a>Legacy沙箱-LegacySandbox（单例）</h2><ul><li>不需要遍历 window 上的所有属性，性能比快照沙箱要好</li><li>基于 proxy 实现，依然操作了 window，污染了全局，同一时间只能运行一个应用</li><li>兼容性没有快照沙箱好</li></ul><p>功能和 <code>快照沙箱</code> 一样，但内部实现是通过 proxy 实现的。</p><h2 id="ProxySandbox-沙箱（多例）"><a href="#ProxySandbox-沙箱（多例）" class="headerlink" title="ProxySandbox 沙箱（多例）"></a>ProxySandbox 沙箱（多例）</h2><ul><li>基于 proxy 代理对象，不需要遍历 window，性能要比快照沙箱好</li><li>支持多个应用</li><li>没有污染全局 window</li><li>应用失活后，依然可以获取到激活时定义的属性。</li></ul><p>主要实现在 <code>constructor</code> 中，创建一个 <code>fakeWindow</code> 对象，通过 Proxy 代理这个对象，全程没有改变 window</p><p>只是在获取属性值的时候，如果在代理对象上没有找到想要的属性，才回去 window 中查找。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ProxySandbox</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 沙箱是否是激活状态</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">isRunning</span> = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> fakeWindow = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _this = <span class="variable language_">this</span></span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">proxyWindow</span> = <span class="keyword">new</span> <span class="title class_">Proxy</span>(fakeWindow, &#123;</span><br><span class="line">      <span class="title function_">set</span>(<span class="params">target, prop, value</span>) &#123;</span><br><span class="line">        <span class="comment">// 只有激活状态下，才做处理</span></span><br><span class="line">        <span class="keyword">if</span> (_this.<span class="property">isRunning</span>) &#123;</span><br><span class="line">          target[prop] = value</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="title function_">get</span>(<span class="params">target, prop, reciver</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果fakeWindow里面有，就从fakeWindow里面取，否则，就从外部的window里面取</span></span><br><span class="line">        <span class="keyword">return</span> prop <span class="keyword">in</span> target ? target[prop] : <span class="variable language_">window</span>[prop]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">active</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">isRunning</span> = <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">inactive</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">isRunning</span> = <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">city</span> = <span class="string">&#x27;北京&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">ProxySandbox</span>()</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">ProxySandbox</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 激活</span></span><br><span class="line">p1.<span class="title function_">active</span>()</span><br><span class="line">p2.<span class="title function_">active</span>()</span><br><span class="line"></span><br><span class="line">p1.<span class="property">proxyWindow</span>.<span class="property">city</span> = <span class="string">&#x27;上海&#x27;</span></span><br><span class="line">p2.<span class="property">proxyWindow</span>.<span class="property">city</span> = <span class="string">&#x27;杭州&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1.<span class="property">proxyWindow</span>.<span class="property">city</span>) <span class="comment">// &#x27;上海&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p2.<span class="property">proxyWindow</span>.<span class="property">city</span>) <span class="comment">// &#x27;杭州&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">city</span>) <span class="comment">// 北京</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 失活</span></span><br><span class="line">p1.<span class="title function_">inactive</span>()</span><br><span class="line">p2.<span class="title function_">inactive</span>()</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1.<span class="property">proxyWindow</span>.<span class="property">city</span>) <span class="comment">// &#x27;上海&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p2.<span class="property">proxyWindow</span>.<span class="property">city</span>) <span class="comment">// &#x27;杭州&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">city</span>) <span class="comment">// &#x27;北京&#x27;</span></span><br></pre></td></tr></table></figure><h1 id="qiankun-的样式问题"><a href="#qiankun-的样式问题" class="headerlink" title="qiankun 的样式问题"></a>qiankun 的样式问题</h1><p>如果不启动样式隔离，主应用、子应用所有的样式都是全局环境下，意味着，如果我在主应用里面设置了高权重的 css 样式，是会直接影响到子应用的。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 主应用 <span class="selector-tag">main</span><span class="selector-class">.css</span></span><br><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">button</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: red <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主应用、子应用所有的 h1 和 button 都会应用以上颜色。</p><p>当然我们不能这样做，我们的应用间样式应该独立，不能互相影响。可以通过 BEM 解决，不过在大型项目下，约定是一件很不靠谱的事情，最好是在框架中解决此问题，一劳永逸。</p><h2 id="qiankun-样式隔离方案"><a href="#qiankun-样式隔离方案" class="headerlink" title="qiankun 样式隔离方案"></a>qiankun 样式隔离方案</h2><ul><li>shadow dom（sanbox: strictStyleIsolation）</li><li>scoped css（sanbox: experimentalStyleIsolation）</li></ul><p>在 start 方法中，配置 sanbox 属性，即可开启 css 隔离。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sanbox: boolean | &#123; strictStyleIsolation?: boolean, experimentalStyleIsolation?: boolean &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">start</span>(&#123;</span><br><span class="line">  <span class="attr">sanbox</span>: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>strictStyleIsolation</li></ul><p><code>strictStyleIsolation</code> 模式下 qiankun 会为每个微应用的容器包裹上一个 <code>shadow dom</code> 节点，**<code>所有的子应用都被 #shadow-root 所包裹</code>**，从而确保微应用的样式不会对全局造成影响。</p><p>当我们开启了 <code>strictStyleIsolation</code> 模式后，主应用设置的高权重 css 确实没有影响子应用了。但是，但是，咱们去看看 Vue <code>dialog</code> 的样式（别看 React 的，因为React事件在 Shadow DOM 中根本不起作用 😂😂😂）</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意：</span><br></pre></td></tr></table></figure><p><code>shadow dom</code> 并不是一个无脑的解决方案，特别是在 React 中，事件的处理可能不那么奏效了😄！</p><p><a href="https://link.juejin.cn/?target=https://legacy.reactjs.org/docs/web-components.html">React 官方关于 web component 的解释</a></p></blockquote><p>乍一看是不是没问题？</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0bd7e2786efb4a0a8ad42a23be04b675~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image.png"></p><p>我们摁下电脑的 <code>ESC</code> 键，会触发 <code>是否取消弹窗</code> 的二次确认，你再看看有没有问题？</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/80b4925533f440e28534bfb5dc78de85~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image.png"> 样式完全丢失了，这是为什么呢？<code>因为二次确认的 Dialog 是挂在 body 下，而我们整个子应用都被 shadow dom 所包裹，内部的样式对外部的样式起不到任何作用，所以这个弹窗失去了漂亮的外衣了😭😭😭</code>！</p><p>不过，为啥弹窗要挂在 body 下？</p><p>这个是为了避免被父元素的样式影响，比如父元素设置了 display:none，那么这个弹窗也是无法展示的。</p><ul><li>experimentalStyleIsolation</li></ul><p><code>experimentalStyleIsolation</code> 被设置为 true 时，qiankun 会改写子应用所添加的样式为所有样式规则增加一个特殊的选择器规则来限定其影响范围，因此改写后的代码会表达类似为如下结构：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 假设应用名是 react16 中的样式是这样</span><br><span class="line"><span class="selector-class">.app-main</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ===== 处理后 ======&gt;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-attr">[data-qiankun-react16]</span> <span class="selector-class">.app-main</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有点类似 Vue 中的 css scoped 作用，给每个子应用加了一个 ”唯一“ 的属性选择器。</p><p>这个时候，React 的事件处理没问题了（真好啊😁），我们来到页面上看看效果：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/df4d3ba0019f4f09a71e6f6dd915aa44~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image.png"> 事件是生效了，但是弹窗样式丢失了😭😭😭</p><p>这个弹窗是挂在 body 下，而加了 <code>experimentalStyleIsolation</code> 之后，所有的样式都加了 <code>div[data-qiankun=&quot;react16&quot;]</code> 前缀，唯独 body 下的 dialog 没有加前缀，导致无法应用到正确的样式了。(Vue子应用 也有这样的问题!!)</p><p>还有就是，在主应用设置的<code>高权重样式</code>依然影响到了子应用。</p><h2 id="Vue-Scoped"><a href="#Vue-Scoped" class="headerlink" title="Vue Scoped"></a>Vue Scoped</h2><p>在 Vue 的单文件组件中使用 <code>&lt;style scoped&gt;</code> 标签时，Vue 会自动将该样式应用于当前组件的元素，并在编译过程中为每个 CSS 规则添加一个<code>唯一的属性选择器</code>，以确保样式仅对当前组件有效。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h3</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: pink;</span><br><span class="line">  <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ======= 使用 style scoped 后 ====&gt;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">h3</span><span class="selector-attr">[data-v-469af010]</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: pink;</span><br><span class="line">  <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CSS-Modules"><a href="#CSS-Modules" class="headerlink" title="CSS Modules"></a>CSS Modules</h2><p>要使用 CSS Modules，首先要改造 webpack.config.js，修改 css-loader 部分</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">test</span>: <span class="regexp">/\.(le|c)ss$/</span>,</span><br><span class="line">  <span class="attr">use</span>: [<span class="string">&#x27;style-loader&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">loader</span>: <span class="string">&#x27;css-loader&#x27;</span>,</span><br><span class="line">    <span class="attr">options</span>: &#123;</span><br><span class="line">      <span class="attr">modules</span>: <span class="literal">true</span> <span class="comment">// 开启 css modules</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="string">&#x27;less-loader&#x27;</span>],</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>然后定义 模块 css <code>index.module.css</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.text-color</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.text-gb</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: pink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用的时候，导入 <code>index.module.css</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> styles <span class="keyword">from</span> <span class="string">&#x27;./index.module.css&#x27;</span></span><br><span class="line"></span><br><span class="line">&lt;div className=&#123;styles[<span class="string">&#x27;text-bg&#x27;</span>]&#125;&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">className</span>=<span class="string">&#123;styles[</span>&#x27;<span class="attr">text-color</span>&#x27;]&#125;&gt;</span>CSS Modules<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>我们再查看页面上的元素，看看样式长什么样:</p><p>![转存失败，建议直接上传图片文件](C:\Users\Administrator\Desktop\code\why862555625.github.io\source_posts\js\转存失败，建议直接上传图片文件 ..\img\css-modules.png)</p><p>使用 CSS Modules 之后，选择器名字上加了 hash。</p><p>既然 父元素 class name 用 css modules 加上了 hash，那么内部元素的 class name 该怎么用怎么用，不使用 <code>模块CSS</code> 中的样式也是 OK 的。</p><p>css modules 和 scoped css 差不多，都能实现组件级别样式隔离，能设置子组件和全局样式，只是实现方式不同，导致了使用起来也有差异。</p><h2 id="那么-qiankun-的样式隔离还有必要做吗"><a href="#那么-qiankun-的样式隔离还有必要做吗" class="headerlink" title="那么 qiankun 的样式隔离还有必要做吗"></a>那么 qiankun 的样式隔离还有必要做吗</h2><p>老项目还是可以用的，比如 JQuery 这种，qiankun 的样式隔离能用。</p><p>如果要在 JQuery 这种项目中使用 CSS Module、CSS in JS，可能改造成本有点大了。</p><p>只是现在的应用，不管是 vue 还是 react 基本都开启了组件级别样式隔离，qiankun 自带的样式隔离问题太多了，不能用了。</p><h1 id="CSS-沙箱解决方案"><a href="#CSS-沙箱解决方案" class="headerlink" title="CSS 沙箱解决方案"></a>CSS 沙箱解决方案</h1><p>在前端开发中，为了实现 CSS 的沙箱化，即将某个 CSS 样式应用于特定的范围而不影响其他元素，可以采用以下几种实现方案：</p><ol><li><strong>命名约定（BEM）</strong>：通过给特定范围内的元素添加特定的类名或命名前缀，然后在 CSS 中通过类选择器或属性选择器来应用相应的样式。这种方式需要在开发过程中遵循命名约定，确保样式只作用于指定的元素，避免与其他元素产生冲突。</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">div</span> class=&quot;block&quot;&gt;</span><br><span class="line">  &lt;<span class="selector-tag">div</span> class=&quot;block__element&quot;&gt;&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">  &lt;<span class="selector-tag">div</span> class=&quot;block__element<span class="attr">--modifier</span>&quot;&gt;&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;<span class="selector-tag">div</span> class=&quot;<span class="selector-tag">header</span>-<span class="selector-tag">section</span>&quot;&gt;</span><br><span class="line">  &lt;<span class="selector-tag">div</span> class=&quot;<span class="selector-tag">header</span>-section__logo&quot;&gt;&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">  &lt;<span class="selector-tag">div</span> class=&quot;<span class="selector-tag">header</span>-section__menu&quot;&gt;&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">&lt;/<span class="selector-tag">div</span>&gt;</span><br></pre></td></tr></table></figure><ol><li><strong>CSS Modules</strong>：CSS Modules 是一种在构建过程中将 CSS 样式模块化的解决方案。它通过为每个模块生成唯一的类名，将样式限定在模块的范围内。在使用 CSS Modules 时，可以在 JavaScript 代码中导入样式文件，并通过类名来引用特定的样式，从而实现样式的沙箱化。</li></ol><p>要使用 CSS Modules，需要在 css-loader 中开启 module：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">test</span>: <span class="regexp">/\.(le|c)ss$/</span>,</span><br><span class="line">  <span class="attr">use</span>: [<span class="string">&#x27;style-loader&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">loader</span>: <span class="string">&#x27;css-loader&#x27;</span>,</span><br><span class="line">    <span class="attr">options</span>: &#123;</span><br><span class="line">      <span class="attr">modules</span>: <span class="literal">true</span> <span class="comment">// 开启 css modules</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="string">&#x27;less-loader&#x27;</span>],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Button.module.css</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.button</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: blue;</span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.button--disabled</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0.5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>App.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> styles <span class="keyword">from</span> <span class="string">&#x27;./Button.module.css&#x27;</span>;</span><br><span class="line"></span><br><span class="line">interface <span class="title class_">ButtonProps</span> &#123;</span><br><span class="line">  disabled?: boolean;</span><br><span class="line">  <span class="attr">onClick</span>: <span class="function">() =&gt;</span> <span class="keyword">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Button</span>: <span class="title class_">React</span>.<span class="property">FC</span>&lt;<span class="title class_">ButtonProps</span>&gt; = <span class="function">(<span class="params">&#123; disabled, onClick, children &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> buttonClasses = <span class="string">`<span class="subst">$&#123;styles.button&#125;</span> <span class="subst">$&#123;disabled ? styles[<span class="string">&#x27;button--disabled&#x27;</span>] : <span class="string">&#x27;&#x27;</span>&#125;</span>`</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">className</span>=<span class="string">&#123;buttonClasses&#125;</span> <span class="attr">onClick</span>=<span class="string">&#123;onClick&#125;</span> <span class="attr">disabled</span>=<span class="string">&#123;disabled&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;children&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Button</span>;</span><br></pre></td></tr></table></figure><ol><li><strong>CSS-in-JS</strong>：CSS-in-JS 是一种将 CSS 样式写在 JavaScript 代码中的方式，通过将样式与组件绑定在一起，实现了样式的局部化和沙箱化。常见的 CSS-in-JS 解决方案包括 styled-components、Emotion、CSS Modules with React 等。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> styled <span class="keyword">from</span> <span class="string">&#x27;styled-components&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Button</span> = styled.<span class="property">button</span><span class="string">`</span></span><br><span class="line"><span class="string">  background-color: blue;</span></span><br><span class="line"><span class="string">  color: white;</span></span><br><span class="line"><span class="string">  padding: 10px 20px;</span></span><br><span class="line"><span class="string">  border: none;</span></span><br><span class="line"><span class="string">  border-radius: 4px;</span></span><br><span class="line"><span class="string">  cursor: pointer;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  &amp;:hover &#123;</span></span><br><span class="line"><span class="string">    background-color: darkblue;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  &amp;:disabled &#123;</span></span><br><span class="line"><span class="string">    opacity: 0.5;</span></span><br><span class="line"><span class="string">    cursor: not-allowed;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">ExampleComponent</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> console.log(&#x27;Button clicked&#x27;)&#125;&gt;Click me<span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Button</span> <span class="attr">disabled</span>&gt;</span>Disabled Button<span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">ExampleComponent</span>;</span><br></pre></td></tr></table></figure><p>在使用 CSS-in-JS 的方案中，样式是通过 JavaScript 运行时动态生成的，每个组件都具有自己独特的样式，并且不会与其他组件的样式发生冲突。这种方式提供了更好的样式隔离和组件化能力，并且使得样式与组件的代码更紧密集成在一起，提高了可维护性和可读性。</p><ol><li><strong>Shadow DOM</strong>：Shadow DOM 是 Web 标准中的一个技术，可以创建一个隔离的 DOM 子树，其中的样式和脚本不会影响到外部的 DOM。通过在元素上应用 Shadow DOM，可以将样式限定在 Shadow DOM 内部，实现样式的沙箱化。Shadow DOM 主要用于 Web 组件开发，可以实现组件样式的封装和隔离。</li></ol><p>这些方案各有特点，选择合适的方案取决于具体的需求和项目情况。命名约定是最简单的方式，适用于小型项目和简单的样式隔离。CSS Modules 和 CSS-in-JS 提供了更丰富的功能和工具支持，适用于中大型项目和复杂的样式需求。Shadow DOM 则主要应用于 Web 组件开发，提供了更强大的封装和隔离能力。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.outer</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">background-color</span>: pink;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">padding</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;outer&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Outer Component<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;inner-root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> outerElement = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.outer&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> innerRoot = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;inner-root&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 创建 Shadow DOM，open 表示可以通过页面内的 JavaScript 方法来获取 Shadow DOM</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> shadowRoot = innerRoot.<span class="title function_">attachShadow</span>(&#123; <span class="attr">mode</span>: <span class="string">&#x27;open&#x27;</span> &#125;);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 在 Shadow DOM 中创建样式</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> style = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;style&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    style.<span class="property">textContent</span> = <span class="string">`</span></span></span><br><span class="line"><span class="string"><span class="language-javascript">      .inner &#123;</span></span></span><br><span class="line"><span class="string"><span class="language-javascript">        background-color: aqua;</span></span></span><br><span class="line"><span class="string"><span class="language-javascript">        padding: 10px;</span></span></span><br><span class="line"><span class="string"><span class="language-javascript">      &#125;</span></span></span><br><span class="line"><span class="string"><span class="language-javascript">    `</span>;</span></span><br><span class="line"><span class="language-javascript">    shadowRoot.<span class="title function_">appendChild</span>(style);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 在 Shadow DOM 中创建内容</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> innerDiv = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    innerDiv.<span class="property">className</span> = <span class="string">&#x27;inner&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">    innerDiv.<span class="property">textContent</span> = <span class="string">&#x27;Inner Component&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">    shadowRoot.<span class="title function_">appendChild</span>(innerDiv);</span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="微前端框架"><a href="#微前端框架" class="headerlink" title="微前端框架"></a>微前端框架</h1><p>qiankun、wujie、micro-app 的区别主要还是实现容器（或者叫沙箱）上有区别</p><ul><li>qiankun: function + proxy + with</li><li>micro-app: web components</li><li>wujie: web components 和 iframe。</li></ul><h1 id="微前端（qiankun）架构中，主应用和子应用有共同的组件，如何封装呢？"><a href="#微前端（qiankun）架构中，主应用和子应用有共同的组件，如何封装呢？" class="headerlink" title="微前端（qiankun）架构中，主应用和子应用有共同的组件，如何封装呢？"></a>微前端（qiankun）架构中，主应用和子应用有共同的组件，如何封装呢？</h1><p>在微前端架构中，主应用和子应用可能会共享一些组件，为了实现组件的共享和封装，可以采用以下方法：</p><ol><li>封装为独立的 npm 包：将共享的组件封装为独立的 npm 包，并发布到私有或公共的 npm 仓库中。主应用和子应用都可以通过 npm 安装该组件，并在需要的地方引入和使用。</li><li>Git 仓库依赖：将共享组件放置在一个独立的 Git 仓库中，并通过 Git 仓库的依赖关系来引入组件。主应用和子应用可以通过 Git 仓库的 URL 或路径来引入共享组件。</li><li>Git Submodule：如果主应用和子应用都在同一个 Git 仓库下，可以使用 Git Submodule 的方式来引入共享组件。将共享组件作为子模块添加到主应用和子应用的仓库中。</li><li>本地引用：如果主应用和子应用处于同一个代码仓库中，可以直接通过相对路径引入共享组件。将共享组件放置在一个独立的目录下，并通过相对路径引用。</li></ol><p>无论选择哪种方式，关键是要保持共享组件的独立性和可维护性。确保共享组件的代码和样式与具体的主应用和子应用解耦，避免出现冲突和依赖混乱的情况。同时，建议对共享组件进行版本管理，以便在更新和维护时能够更好地控制和追踪变更。</p><p>在微前端架构中，可以通过合适的方式引入共享组件，使主应用和子应用可以共享和复用组件，提高开发效率和代码质量。</p><h2 id="monorepo架构"><a href="#monorepo架构" class="headerlink" title="monorepo架构"></a>monorepo架构</h2><p>Monorepo 模式也可以解决微前端中的公共依赖包和公共组件的问题。</p><p>Monorepo 模式是指将多个项目或应用放置在同一个代码仓库中管理的开发模式。</p><p>在 Monorepo 中，可以将公共依赖包和公共组件作为共享资源，放置在代码仓库的合适位置，供不同的项目或应用使用。这样可以避免不同项目之间重复安装和维护相同的依赖包，也能够统一管理和更新公共组件。</p><p>以下是 Monorepo 模式下解决微前端中公共依赖包和公共组件的方式：</p><ol><li>公共依赖包管理：将公共的依赖包放置在代码仓库的根目录或指定目录下，通过工具如 Yarn 或 Lerna 管理依赖包的安装、更新和版本控制。不同的项目或应用可以通过引用共享的依赖包来解决依赖关系，避免重复安装和冲突。</li><li>公共组件封装：将公共的组件封装为独立的包或模块，放置在代码仓库的特定目录中，并通过工具如 NPM 发布和安装。不同的项目或应用可以通过引用共享的组件来实现组件的复用和共享，提高开发效率和代码一致性。</li></ol><p>通过 Monorepo 模式，可以集中管理和维护公共依赖包和公共组件，减少重复工作和资源浪费。同时，还能够促进团队协作和代码共享，统一规范和风格，提高整体项目的质量和可维护性。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ts复习</title>
      <link href="/posts/19f9951.html"/>
      <url>/posts/19f9951.html</url>
      
        <content type="html"><![CDATA[<p>摘要</p><span id="more"></span><p><strong>1. 什么是TypeScript？</strong></p><blockquote><p>Typescript 是一个强类型的 JavaScript 超集，支持ES6语法，支持面向对象编程的概念，如类、接口、继承、泛型等。Typescript并不直接在浏览器上运行，需要编译器编译成纯Javascript来运行。</p></blockquote><p><strong>2. 为什么要使用 TypeScript ? TypeScript 相对于 JavaScript 的优势是什么？</strong></p><blockquote><p>增加了静态类型，可以在开发人员编写脚本时检测错误，使得代码质量更好，更健壮。<br> 优势: </p><ol><li>杜绝手误导致的变量名写错; </li><li>类型可以一定程度上充当文档; </li><li>IDE自动填充，自动联想;</li></ol></blockquote><p><strong>3. TypeScript 中 const 和 readonly 的区别？枚举和常量枚举的区别？接口和类型别名的区别？</strong></p><blockquote><p><code>const 和 readonly</code>: const可以防止变量的值被修改，readonly可以防止变量的属性被修改。<br> <code>枚举和常量枚举</code>: 常量枚举只能使用常量枚举表达式，并且不同于常规的枚举，它们在编译阶段会被删除。 常量枚举成员在使用的地方会被内联进来。 之所以可以这么做是因为，常量枚举不允许包含计算成员。<br> <code>接口和类型别名</code>: 两者都可以用来描述对象或函数的类型。与接口不同，类型别名还可以用于其他类型，如基本类型（原始值）、联合类型、元组。</p></blockquote><p><strong>4. TypeScript 中 any 类型的作用是什么？</strong></p><blockquote><p>为编程阶段还不清楚类型的变量指定一个类型。 这些值可能来自于动态的内容，比如来自用户输入或第三方代码库。 这种情况下，我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查。</p></blockquote><p><strong>5. TypeScript 中 any、never、unknown、null &amp; undefined 和 void 有什么区别？</strong></p><blockquote><p><code>any</code>: 动态的变量类型（失去了类型检查的作用）。<br> <code>never</code>: 永不存在的值的类型。例如：never 类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型。<br> <code>unknown</code>: 任何类型的值都可以赋给 unknown 类型，但是 unknown 类型的值只能赋给 unknown 本身和 any 类型。<br> <code>null &amp; undefined</code>: 默认情况下 null 和 undefined 是所有类型的子类型。 就是说你可以把 null 和  undefined 赋值给 number 类型的变量。当你指定了 –strictNullChecks 标记，null 和 undefined 只能赋值给 void 和它们各自。<br> <code>void</code>: 没有任何类型。例如：一个函数如果没有返回值，那么返回值可以定义为void。</p></blockquote><p><strong>6. TypeScript 中 interface 可以给 Function / Array / Class（Indexable）做声明吗？</strong></p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 可以 */</span></span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line">interface <span class="title class_">Say</span> &#123;</span><br><span class="line"> (<span class="attr">name</span>: string): viod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">say</span>: <span class="title class_">Say</span> = (<span class="attr">name</span>: string):<span class="function"><span class="params">viod</span> =&gt;</span> &#123;&#125;</span><br><span class="line"><span class="comment">// Array 声明</span></span><br><span class="line">interface <span class="title class_">NumberArray</span> &#123; </span><br><span class="line"> [<span class="attr">index</span>: number]: number; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> <span class="attr">fibonacci</span>: <span class="title class_">NumberArray</span> = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>];</span><br><span class="line"><span class="comment">// Class 声明</span></span><br><span class="line">interface <span class="title class_">PersonalIntl</span> &#123;</span><br><span class="line"> <span class="attr">name</span>: string</span><br><span class="line"> sayHi (<span class="attr">name</span>: string): string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p><strong>7. TypeScript 中可以使用 String、Number、Boolean、Symbol、Object 等给类型做声明吗？</strong></p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 可以 */</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">name</span>: string = <span class="string">&quot;bob&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">decLiteral</span>: number = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">isDone</span>: boolean = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">sym</span>: symbol = <span class="title class_">Symbol</span>();</span><br><span class="line">interface <span class="title class_">Person</span> &#123;</span><br><span class="line"> <span class="attr">name</span>: string;</span><br><span class="line"> <span class="attr">age</span>: number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p><strong>8. TypeScript 中的 this 和 JavaScript 中的 this 有什么差异？</strong></p><blockquote><ol><li>TypeScript：noImplicitThis: true 的情况下，必须去声明 this 的类型，才能在函数或者对象中使用this。</li><li>Typescript 中箭头函数的 this 和 ES6 中箭头函数中的 this 是一致的。</li></ol></blockquote><p><strong>9. TypeScript 中使用 Union Types 时有哪些注意事项？</strong></p><blockquote><p><strong>属性或方法访问</strong>: 当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们只能访问此联合类型的所有类型里共有的属性或方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getLength</span>(<span class="params">something: string | number</span>): number &#123;</span><br><span class="line">   <span class="keyword">return</span> something.<span class="property">length</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// index.ts(2,22): error TS2339: Property &#x27;length&#x27; does not exist on type &gt;&#x27;string | number&#x27;.</span></span><br><span class="line"><span class="comment">//   Property &#x27;length&#x27; does not exist on type &#x27;number&#x27;.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getString</span>(<span class="params">something: string | number</span>): string &#123;</span><br><span class="line">   <span class="keyword">return</span> something.<span class="title function_">toString</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 公共方法和属性可以访问</span></span><br></pre></td></tr></table></figure></blockquote><p><strong>10. TypeScript 如何设计 Class 的声明？</strong></p><blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Greeter</span> &#123;</span><br><span class="line">   <span class="attr">greeting</span>: <span class="built_in">string</span>;</span><br><span class="line">   <span class="title function_">constructor</span>(<span class="params">message: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">       <span class="variable language_">this</span>.<span class="property">greeting</span> = message;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="title function_">greet</span>(): <span class="built_in">string</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;Hello, &quot;</span> + <span class="variable language_">this</span>.<span class="property">greeting</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> greeter = <span class="keyword">new</span> <span class="title class_">Greeter</span>(<span class="string">&quot;world&quot;</span>);</span><br><span class="line"><span class="comment">// 在声明类的时候，一般类中都会包含，构造函数、对构造函数中的属性进行类型声明、类中的方法。</span></span><br></pre></td></tr></table></figure></blockquote><p><strong>11. TypeScript 中如何联合枚举类型的 Key?</strong></p><blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> str &#123;</span><br><span class="line">   A,</span><br><span class="line">   B,</span><br><span class="line">   C</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> strUnion =  keyof <span class="keyword">typeof</span> str; <span class="comment">// &#x27;A&#x27; | &#x27;B&#x27; | &#x27;C&#x27;</span></span><br></pre></td></tr></table></figure></blockquote><p><strong>12. TypeScript 中 type 和 interface 的区别?</strong></p><blockquote><p>相同点： </p><ol><li>都可以描述 ‘对象’ 或者 ‘函数’ </li><li>都允许拓展(extends)</li></ol><p>不同点： </p><ol><li>type 可以声明基本类型，联合类型，元组</li><li>type 可以使用 typeof 获取实例的类型进行赋值</li><li>多个相同的 interface 声明可以自动合并</li></ol><p>使用 interface 描述‘数据结构’，使用 type 描述‘类型关系’</p></blockquote><p><em><em>13. TypeScript 中 ?.、??、!、!.、_、*</em> 等符号的含义？</em>*</p><blockquote><p><code>?. 可选链</code> 遇到 null 和 undefined 可以立即停止表达式的运行。<br> <code>?? 空值合并运算符</code> 当左侧操作数为 null 或 undefined 时，其返回右侧的操作数，否则返回左侧的操作数。<br> <code>! 非空断言运算符</code> x! 将从 x 值域中排除 null 和 undefined<br> <code>!. </code> 在变量名后添加，可以断言排除undefined和null类型<br> <code>_ 数字分割符</code> 分隔符不会改变数值字面量的值，使人更容易读懂数字 .e.g 1_101_324。<br> <code>** </code>求幂</p></blockquote><p><strong>15. 简单介绍一下 TypeScript 模块的加载机制？</strong></p><blockquote><p>假设有一个导入语句 <code>import &#123; a &#125; from &quot;moduleA&quot;</code>; </p><ol><li>首先，编译器会尝试定位需要导入的模块文件，通过绝对或者相对的路径查找方式； </li><li>如果上面的解析失败了，没有查找到对应的模块，编译器会尝试定位一个<code>外部模块声明</code>（.d.ts）； </li><li>最后，如果编译器还是不能解析这个模块，则会抛出一个错误 <code>error TS2307: Cannot find module &#39;moduleA&#39;.</code></li></ol></blockquote><p><strong>16. 简单聊聊你对 TypeScript 类型兼容性的理解？</strong></p><blockquote><p><code>ts 类型兼容：</code> 当一个类型 Y 可以赋值给另一个类型 X 时， 我们就可以说类型 X 兼容类型 Y。也就是说两者在结构上是一致的，而不一定非得通过 extends 的方式继承而来<br> <code>接口的兼容性：X = Y </code>只要目标类型 X 中声明的属性变量在源类型 Y 中都存在就是兼容的（ Y 中的类型可以比 X 中的多，但是不能少）<br> <code>函数的兼容性：X = Y </code> Y 的每个参数必须能在 X 里找到对应类型的参数，参数的名字相同与否无所谓，只看它们的类型（参数可以少但是不能多。与接口的兼容性有区别，原因参考第 17 问）</p></blockquote><p><strong>17. 协变、逆变、双变和抗变的理解？</strong></p><blockquote><p><code>协变：X = Y </code>Y 类型可以赋值给 X 类型的情况就叫做协变，也可以说是 X 类型兼容 Y 类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> X &#123; <span class="attr">name</span>: <span class="built_in">string</span>; <span class="attr">age</span>: <span class="built_in">number</span>; &#125; </span><br><span class="line"><span class="keyword">interface</span> Y &#123; <span class="attr">name</span>: <span class="built_in">string</span>; <span class="attr">age</span>: <span class="built_in">number</span>; <span class="attr">hobbies</span>: <span class="built_in">string</span>[] &#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">x</span>: X = &#123; <span class="attr">name</span>: <span class="string">&#x27;xiaoming&#x27;</span>, <span class="attr">age</span>: <span class="number">16</span> &#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">y</span>: Y = &#123; <span class="attr">name</span>: <span class="string">&#x27;xiaohong&#x27;</span>, <span class="attr">age</span>: <span class="number">18</span>, <span class="attr">hobbies</span>: [<span class="string">&#x27;eat&#x27;</span>] &#125;</span><br><span class="line">x = y</span><br></pre></td></tr></table></figure><p><code>逆变：printY = printX</code> 函数X 类型可以赋值给函数Y 类型，因为函数Y 在调用的时候参数是按照Y类型进行约束的，但是用到的是函数X的X的属性和方法，ts检查结果是类型安全的。这种特性就叫做逆变，函数的参数有逆变的性质。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">printY</span>: <span class="function">(<span class="params">y: Y</span>) =&gt;</span> <span class="built_in">void</span></span><br><span class="line">printY = <span class="function">(<span class="params">y</span>) =&gt;</span> &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(y.<span class="property">hobbies</span>) &#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">printX</span>: <span class="function">(<span class="params">x: X</span>) =&gt;</span> <span class="built_in">void</span></span><br><span class="line">printX = <span class="function">(<span class="params">x</span>) =&gt;</span> &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(x.<span class="property">name</span>) &#125;</span><br><span class="line">printY = printX</span><br></pre></td></tr></table></figure><p><code>双变（双向协变）：X = Y；Y = X</code>父类型可以赋值给子类型，子类型可以赋值给父类型，既逆变又协变，叫做“双向协变”（ts2.x 之前支持这种赋值，之后 ts 加了一个编译选项 strictFunctionTypes，设置为 true 就只支持函数参数的逆变，设置为 false 则支持双向协变）<br> <code>抗变（不变）：</code>非父子类型之间不会发生型变，只要类型不一样就会报错</p></blockquote><p><strong>18. TypeScript 中对象展开会有什么副作用吗？</strong></p><blockquote><ol><li>展开对象后面的属性会覆盖前面的属性；</li><li>仅包含对象自身的可枚举属性，不可枚举的属性将会丢失。</li></ol></blockquote><p><strong>19. 类型的全局声明和局部声明</strong></p><blockquote><p>如果声明文件内不包含<code>import、export</code>，那么这个文件声明的类型就会变成全局声明。反之，若是这个文件包含了<code>import、export</code>，那么这个文件包含的类型声明则会是局部声明，不会影响到全局声明。</p></blockquote><p><strong>20. TypeScript 中同名的 interface 或者同名的 interface 和 class 可以合并吗？</strong></p><blockquote><p>同名的interface会自动合并，同名的interface和class会自动聚合。</p></blockquote><p><strong>21. 如何使 TypeScript 项目引入并识别编译为 JavaScript 的 npm 库包？</strong></p><blockquote><ol><li>选择安装 ts 版本，<code>npm install @types/包名 --save</code>；</li><li>对于没有类型的 js 库，需要编写同名的.d.ts文件</li></ol></blockquote><p><strong>22. TypeScript 的 tsconfig.json 中有哪些配置项信息？</strong></p><blockquote><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;files&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;include&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;exclude&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;compileOnSave&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;extends&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;compilerOptions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> ... <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><code>files</code> 是一个数组列表，里面包含指定文件的相对或绝对路径，用来指定待编译文件，编译器在编译的时候只会编译包含在files中列出的文件。<br> <code>include &amp; exclude</code> 指定编译某些文件，或者指定排除某些文件。<br> <code>compileOnSave：true</code> 让IDE在保存文件的时候根据tsconfig.json重新生成文件。<br> <code>extends</code> 可以通过指定一个其他的tsconfig.json文件路径，来继承这个配置文件里的配置。<br> <code>compilerOptions</code> 编译配置项，如何对具体的ts文件进行编译</p></blockquote><p><strong>23. TypeScript 中如何设置模块导入的路径别名？</strong></p><blockquote><p>通过 tsconfig.json 中的 paths 项来配置:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span> </span><br><span class="line">  <span class="attr">&quot;compilerOptions&quot;</span><span class="punctuation">:</span> </span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;baseUrl&quot;</span><span class="punctuation">:</span> <span class="string">&quot;.&quot;</span><span class="punctuation">,</span> </span><br><span class="line">      <span class="attr">&quot;paths&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> </span><br><span class="line">         <span class="attr">&quot;@helper/*&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;src/helper/*&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span> </span><br><span class="line">         <span class="attr">&quot;@utils/*&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;src/utils/*&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span> </span><br><span class="line">         ... </span><br><span class="line">      <span class="punctuation">&#125;</span> </span><br><span class="line">   <span class="punctuation">&#125;</span> </span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></blockquote><p><strong>24. declare，declare global是什么？</strong></p><blockquote><p><code>declare</code> 是用来定义全局变量、全局函数、全局命名空间、js modules、class等<br> <code>declare global</code> 为全局对象 <code>window</code> 增加新的属性</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="variable language_">global</span> &#123; </span><br><span class="line">   <span class="keyword">interface</span> <span class="title class_">Window</span> &#123; </span><br><span class="line">        <span class="attr">csrf</span>: <span class="built_in">string</span>; </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p><strong>25. 对 TypeScript 类中成员的 public、private、protected、readonly 修饰符的理解？</strong></p><blockquote><p><code>public</code>: 成员都默认为<code>public</code>，被此限定符修饰的成员是可以被外部访问；<br> <code>private</code>: 被此限定符修饰的成员是只可以被类的内部访问；<br> <code>protected</code>: 被此限定符修饰的成员是只可以被类的内部以及类的子类访问;<br> <code>readonly</code>: 关键字将属性设置为只读的。 只读属性必须在声明时或构造函数里被初始化。</p></blockquote><p><strong>26. keyof 和 typeof 关键字的作用？</strong></p><blockquote><p><code>keyof 索引类型查询操作符</code> 获取索引类型的属性名，构成联合类型。<br> <code>typeof</code> 获取一个变量或对象的类型。</p></blockquote><p><strong>27. 简述工具类型 <code>Exclude</code>、<code>Omit</code>、<code>Merge</code>、<code>Intersection</code>、<code>Overwrite</code>的作用。</strong></p><blockquote><p><code>Exclude&lt;T, U&gt;</code> 从 <code>T</code> 中排除出可分配给 <code>U</code>的元素。<br> <code>Omit&lt;T, K&gt;</code> 的作用是忽略<code>T</code>中的某些属性。<br> <code>Merge&lt;O1, O2&gt;</code> 是将两个对象的属性合并。<br> <code>Compute&lt;A &amp; B&gt;</code> 是将交叉类型合并<br> <code>Intersection&lt;T, U&gt;</code>的作用是取<code>T</code>的属性,此属性同样也存在与<code>U</code>。<br> <code>Overwrite&lt;T, U&gt;</code> 是用<code>U</code>的属性覆盖<code>T</code>的相同属性。</p></blockquote><p><strong>28. 数组定义的两种方式</strong></p><blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Foo</span>= <span class="title class_">Array</span>&lt;<span class="built_in">string</span>&gt;;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Bar</span> &#123; </span><br><span class="line">     <span class="attr">baz</span>: <span class="title class_">Array</span>&lt;&#123; <span class="attr">name</span>: <span class="built_in">string</span>, <span class="attr">age</span>: <span class="built_in">number</span>&#125;&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Foo</span> = <span class="built_in">string</span>[];</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Bar</span> &#123; </span><br><span class="line">     baz : &#123; <span class="attr">name</span>: <span class="built_in">string</span>, <span class="attr">age</span>: <span class="built_in">number</span> &#125;[] </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器原理</title>
      <link href="/posts/f1e02d11.html"/>
      <url>/posts/f1e02d11.html</url>
      
        <content type="html"><![CDATA[<p>摘要</p><span id="more"></span><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230611135321995.png" alt="image-20230611135321995"></p><h2 id="一、浏览器安全"><a href="#一、浏览器安全" class="headerlink" title="一、浏览器安全"></a>一、浏览器安全</h2><h3 id="1-什么是-XSS-攻击？"><a href="#1-什么是-XSS-攻击？" class="headerlink" title="1.  什么是 XSS 攻击？"></a>1.  什么是 XSS 攻击？</h3><h4 id="（1）概念"><a href="#（1）概念" class="headerlink" title="（1）概念"></a>（1）概念</h4><p>XSS 攻击指的是跨站脚本攻击，是一种代码注入攻击。攻击者通过在网站注入恶意脚本，使之在用户的浏览器上运行，从而盗取用户的信息如 cookie 等。</p><p>XSS 的本质是因为网站没有对恶意代码进行过滤，与正常的代码混合在一起了，浏览器没有办法分辨哪些脚本是可信的，从而导致了恶意代码的执行。</p><p>攻击者可以通过这种攻击方式可以进行以下操作：</p><ul><li>获取页面的数据，如DOM、cookie、localStorage；</li><li>DOS攻击，发送合理请求，占用服务器资源，从而使用户无法访问服务器；</li><li>破坏页面结构；</li><li>流量劫持（将链接指向某网站）；</li></ul><h4 id="（2）攻击类型"><a href="#（2）攻击类型" class="headerlink" title="（2）攻击类型"></a>（2）攻击类型</h4><p>XSS 可以分为存储型、反射型和 DOM 型：</p><ul><li>存储型指的是恶意脚本会存储在目标服务器上，当浏览器请求数据时，脚本从服务器传回并执行。</li><li>反射型指的是攻击者诱导用户访问一个带有恶意代码的 URL 后，服务器端接收数据后处理，然后把带有恶意代码的数据发送到浏览器端，浏览器端解析这段带有 XSS 代码的数据后当做脚本执行，最终完成 XSS 攻击。 </li><li>DOM 型指的通过修改页面的 DOM 节点形成的 XSS。</li></ul><p><strong>1）存储型 XSS 的攻击步骤：</strong></p><ol><li>攻击者将恶意代码提交到⽬标⽹站的数据库中。</li><li>⽤户打开⽬标⽹站时，⽹站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。</li><li>⽤户浏览器接收到响应后解析执⾏，混在其中的恶意代码也被执⾏。</li><li>恶意代码窃取⽤户数据并发送到攻击者的⽹站，或者冒充⽤户的⾏为，调⽤⽬标⽹站接⼝执⾏攻击者指定的操作。</li></ol><p>这种攻击常⻅于带有⽤户保存数据的⽹站功能，如论坛发帖、商品评论、⽤户私信等。</p><p><strong>2）反射型 XSS 的攻击步骤：</strong></p><ol><li>攻击者构造出特殊的 URL，其中包含恶意代码。</li><li>⽤户打开带有恶意代码的 URL 时，⽹站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。</li><li>⽤户浏览器接收到响应后解析执⾏，混在其中的恶意代码也被执⾏。</li><li>恶意代码窃取⽤户数据并发送到攻击者的⽹站，或者冒充⽤户的⾏为，调⽤⽬标⽹站接⼝执⾏攻击者指定的操作。</li></ol><p>反射型 XSS 跟存储型 XSS 的区别是：存储型 XSS 的恶意代码存在数据库⾥，反射型 XSS 的恶意代码存在 URL ⾥。</p><p>反射型 XSS 漏洞常⻅于通过 URL 传递参数的功能，如⽹站搜索、跳转等。 由于需要⽤户主动打开恶意的 URL 才能⽣效，攻击者往往会结合多种⼿段诱导⽤户点击。</p><p><strong>3）DOM 型 XSS 的攻击步骤：</strong></p><ol><li>攻击者构造出特殊的 URL，其中包含恶意代码。</li><li>⽤户打开带有恶意代码的 URL。</li><li>⽤户浏览器接收到响应后解析执⾏，前端 JavaScript 取出 URL 中的恶意代码并执⾏。</li><li>恶意代码窃取⽤户数据并发送到攻击者的⽹站，或者冒充⽤户的⾏为，调⽤⽬标⽹站接⼝执⾏攻击者指定的操作。</li></ol><p>DOM 型 XSS 跟前两种 XSS 的区别：DOM 型 XSS 攻击中，取出和执⾏恶意代码由浏览器端完成，属于前端JavaScript ⾃身的安全漏洞，⽽其他两种 XSS 都属于服务端的安全漏洞。</p><h3 id="2-如何防御-XSS-攻击？"><a href="#2-如何防御-XSS-攻击？" class="headerlink" title="2. 如何防御 XSS 攻击？"></a>2. 如何防御 XSS 攻击？</h3><p>可以看到XSS危害如此之大， 那么在开发网站时就要做好防御措施，具体措施如下：</p><ul><li>可以从浏览器的执行来进行预防，一种是使用纯前端的方式，不用服务器端拼接后返回（不使用服务端渲染）。另一种是对需要插入到 HTML 中的代码做好充分的转义。对于 DOM 型的攻击，主要是前端脚本的不可靠而造成的，对于数据获取渲染和字符串拼接的时候应该对可能出现的恶意代码情况进行判断。</li><li>使用 CSP ，CSP 的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行，从而防止恶意代码的注入攻击。</li></ul><blockquote><ol><li>CSP 指的是内容安全策略，它的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行。我们只需要配置规则，如何拦截由浏览器自己来实现。</li><li>通常有两种方式来开启 CSP，一种是设置 HTTP 首部中的 Content-Security-Policy，一种是设置 meta 标签的方式 </li></ol></blockquote><ul><li>对一些敏感信息进行保护，比如 cookie 使用 http-only，使得脚本无法获取。也可以使用验证码，避免脚本伪装成用户执行一些操作。</li></ul><h3 id="3-什么是-CSRF-攻击？"><a href="#3-什么是-CSRF-攻击？" class="headerlink" title="3. 什么是 CSRF 攻击？"></a>3. 什么是 CSRF 攻击？</h3><h4 id="（1）概念-1"><a href="#（1）概念-1" class="headerlink" title="（1）概念"></a>（1）概念</h4><p>CSRF 攻击指的是<strong>跨站请求伪造攻击</strong>，攻击者诱导用户进入一个第三方网站，然后该网站向被攻击网站发送跨站请求。如果用户在被攻击网站中保存了登录状态，那么攻击者就可以利用这个登录状态，绕过后台的用户验证，冒充用户向服务器执行一些操作。</p><p>CSRF 攻击的<strong>本质是利用 cookie 会在同源请求中携带发送给服务器的特点，以此来实现用户的冒充。</strong></p><h4 id="（2）攻击类型-1"><a href="#（2）攻击类型-1" class="headerlink" title="（2）攻击类型"></a>（2）攻击类型</h4><p>常见的 CSRF 攻击有三种：</p><ul><li>GET 类型的 CSRF 攻击，比如在网站中的一个 img 标签里构建一个请求，当用户打开这个网站的时候就会自动发起提交。</li><li>POST 类型的 CSRF 攻击，比如构建一个表单，然后隐藏它，当用户进入页面时，自动提交这个表单。</li><li>链接类型的 CSRF 攻击，比如在 a 标签的 href 属性里构建一个请求，然后诱导用户去点击。</li></ul><h3 id="4-如何防御-CSRF-攻击？"><a href="#4-如何防御-CSRF-攻击？" class="headerlink" title="4. 如何防御 CSRF 攻击？"></a>4. 如何防御 CSRF 攻击？</h3><p><strong>CSRF 攻击可以使用以下方法来防护：</strong></p><ul><li><strong>进行同源检测</strong>，服务器根据 http 请求头中 origin 或者 referer 信息来判断请求是否为允许访问的站点，从而对请求进行过滤。当 origin 或者 referer 信息都不存在的时候，直接阻止请求。这种方式的缺点是有些情况下 referer 可以被伪造，同时还会把搜索引擎的链接也给屏蔽了。所以一般网站会允许搜索引擎的页面请求，但是相应的页面请求这种请求方式也可能被攻击者给利用。（Referer 字段会告诉服务器该网页是从哪个页面链接过来的）</li><li><strong>使用 CSRF Token 进行验证</strong>，服务器向用户返回一个随机数 Token ，当网站再次发起请求时，在请求参数中加入服务器端返回的 token ，然后服务器对这个 token 进行验证。这种方法解决了使用 cookie 单一验证方式时，可能会被冒用的问题，但是这种方法存在一个缺点就是，我们需要给网站中的所有请求都添加上这个 token，操作比较繁琐。还有一个问题是一般不会只有一台网站服务器，如果请求经过负载平衡转移到了其他的服务器，但是这个服务器的 session 中没有保留这个 token 的话，就没有办法验证了。这种情况可以通过改变 token 的构建方式来解决。</li><li><strong>对 Cookie 进行双重验证</strong>，服务器在用户访问网站页面时，向请求域名注入一个Cookie，内容为随机字符串，然后当用户再次向服务器发送请求的时候，从 cookie 中取出这个字符串，添加到 URL 参数中，然后服务器通过对 cookie 中的数据和参数中的数据进行比较，来进行验证。使用这种方式是利用了攻击者只能利用 cookie，但是不能访问获取 cookie 的特点。并且这种方法比 CSRF Token 的方法更加方便，并且不涉及到分布式访问的问题。这种方法的缺点是如果网站存在 XSS 漏洞的，那么这种方式会失效。同时这种方式不能做到子域名的隔离。</li><li><strong>在设置 cookie 属性的时候设置 Samesite ，限制 cookie 不能作为被第三方使用</strong>，从而可以避免被攻击者利用。Samesite 一共有两种模式，一种是严格模式，在严格模式下 cookie 在任何情况下都不可能作为第三方 Cookie 使用，在宽松模式下，cookie 可以被请求是 GET 请求，且会发生页面跳转的请求所使用。</li></ul><h3 id="5-什么是中间人攻击？如何防范中间人攻击？"><a href="#5-什么是中间人攻击？如何防范中间人攻击？" class="headerlink" title="5. 什么是中间人攻击？如何防范中间人攻击？"></a>5. 什么是中间人攻击？如何防范中间人攻击？</h3><p>中间⼈ (Man-in-the-middle attack, MITM) 是指攻击者与通讯的两端分别创建独⽴的联系, 并交换其所收到的数据, 使通讯的两端认为他们正在通过⼀个私密的连接与对⽅直接对话, 但事实上整个会话都被攻击者完全控制。在中间⼈攻击中，攻击者可以拦截通讯双⽅的通话并插⼊新的内容。</p><p>攻击过程如下:</p><ul><li>客户端发送请求到服务端，请求被中间⼈截获</li><li>服务器向客户端发送公钥</li><li>中间⼈截获公钥，保留在⾃⼰⼿上。然后⾃⼰⽣成⼀个<strong>伪造的</strong>公钥，发给客户端</li><li>客户端收到伪造的公钥后，⽣成加密hash值发给服务器</li><li>中间⼈获得加密hash值，⽤⾃⼰的私钥解密获得真秘钥,同时⽣成假的加密hash值，发给服务器</li><li>服务器⽤私钥解密获得假密钥,然后加密数据传输给客户端</li></ul><h3 id="6-有哪些可能引起前端安全的问题"><a href="#6-有哪些可能引起前端安全的问题" class="headerlink" title="6. 有哪些可能引起前端安全的问题?"></a>6. 有哪些可能引起前端安全的问题?</h3><ul><li>跨站脚本 (Cross-Site Scripting, XSS): ⼀种代码注⼊⽅式, 为了与 CSS 区分所以被称作 XSS。早期常⻅于⽹络论坛, 起因是⽹站没有对⽤户的输⼊进⾏严格的限制, 使得攻击者可以将脚本上传到帖⼦让其他⼈浏览到有恶意脚本的⻚⾯, 其注⼊⽅式很简单包括但不限于 JavaScript / CSS / Flash 等；</li><li>iframe的滥⽤: iframe中的内容是由第三⽅来提供的，默认情况下他们不受控制，他们可以在iframe中运⾏JavaScirpt脚本、Flash插件、弹出对话框等等，这可能会破坏前端⽤户体验；</li><li>跨站点请求伪造（Cross-Site Request Forgeries，CSRF）: 指攻击者通过设置好的陷阱，强制对已完成认证的⽤户进⾏⾮预期的个⼈信息或设定信息等某些状态更新，属于被动攻击</li><li>恶意第三⽅库: ⽆论是后端服务器应⽤还是前端应⽤开发，绝⼤多数时候都是在借助开发框架和各种类库进⾏快速开发，⼀旦第三⽅库被植⼊恶意代码很容易引起安全问题。</li></ul><h3 id="7-网络劫持有哪几种，如何防范？"><a href="#7-网络劫持有哪几种，如何防范？" class="headerlink" title="7. 网络劫持有哪几种，如何防范？"></a>7. 网络劫持有哪几种，如何防范？</h3><p>⽹络劫持分为两种:</p><p>（1）<strong>DNS劫持</strong>: (输⼊京东被强制跳转到淘宝这就属于dns劫持)</p><ul><li>DNS强制解析: 通过修改运营商的本地DNS记录，来引导⽤户流量到缓存服务器</li><li>302跳转的⽅式: 通过监控⽹络出⼝的流量，分析判断哪些内容是可以进⾏劫持处理的,再对劫持的内存发起302跳转的回复，引导⽤户获取内容</li></ul><p>（2）<strong>HTTP劫持</strong>: (访问⾕歌但是⼀直有贪玩蓝⽉的⼴告),由于http明⽂传输,运营商会修改你的http响应内容(即加⼴告)</p><p>DNS劫持由于涉嫌违法，已经被监管起来，现在很少会有DNS劫持，⽽http劫持依然⾮常盛⾏，最有效的办法就是全站HTTPS，将HTTP加密，这使得运营商⽆法获取明⽂，就⽆法劫持你的响应内容。</p><h2 id="二、进程与线程"><a href="#二、进程与线程" class="headerlink" title="二、进程与线程"></a>二、进程与线程</h2><h3 id="1-进程与线程的概念"><a href="#1-进程与线程的概念" class="headerlink" title="1. 进程与线程的概念"></a>1. 进程与线程的概念</h3><p>从本质上说，进程和线程都是 CPU 工作时间片的一个描述：</p><ul><li>进程描述了 CPU 在运行指令及加载和保存上下文所需的时间，放在应用上来说就代表了一个程序。</li><li>线程是进程中的更小单位，描述了执行一段指令所需的时间。</li></ul><p><strong>进程是资源分配的最小单位，线程是CPU调度的最小单位。</strong></p><p>一个进程就是一个程序的运行实例。详细解释就是，启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的一个运行环境叫<strong>进程</strong>。<strong>进程是运行在虚拟内存上的，虚拟内存是用来解决用户对硬件资源的无限需求和有限的硬件资源之间的矛盾的。从操作系统角度来看，虚拟内存即交换文件；从处理器角度看，虚拟内存即虚拟地址空间。</strong></p><p>如果程序很多时，内存可能会不够，操作系统为每个进程提供一套独立的虚拟地址空间，从而使得同一块物理内存在不同的进程中可以对应到不同或相同的虚拟地址，变相的增加了程序可以使用的内存。</p><p>进程和线程之间的关系有以下四个特点：</p><p><strong>（1）进程中的任意一线程执行出错，都会导致整个进程的崩溃。</strong></p><p><strong>（2）线程之间共享进程中的数据。</strong></p><p><strong>（3）当一个进程关闭之后，操作系统会回收进程所占用的内存，</strong> 当一个进程退出时，操作系统会回收该进程所申请的所有资源；即使其中任意线程因为操作不当导致内存泄漏，当进程退出时，这些内存也会被正确回收。</p><p><strong>（4）进程之间的内容相互隔离。</strong> 进程隔离就是为了使操作系统中的进程互不干扰，每一个进程只能访问自己占有的数据，也就避免出现进程 A 写入数据到进程 B 的情况。正是因为进程之间的数据是严格隔离的，所以一个进程如果崩溃了，或者挂起了，是不会影响到其他进程的。如果进程之间需要进行数据的通信，这时候，就需要使用用于进程间通信的机制了。</p><p><strong>Chrome浏览器的架构图</strong>：<img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230611140737544.png" alt="image-20230611140737544"> 从图中可以看出，最新的 Chrome 浏览器包括：</p><ul><li>1 个浏览器主进程</li><li>1 个 GPU 进程</li><li>1 个网络进程</li><li>多个渲染进程</li><li>多个插件进程</li></ul><p>这些进程的功能：</p><ul><li><strong>浏览器进程</strong>：主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。</li><li><strong>渲染进程</strong>：核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。</li><li><strong>GPU 进程</strong>：其实， GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。</li><li><strong>网络进程</strong>：主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。</li><li><strong>插件进程</strong>：主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。</li></ul><p>所以，<strong>打开一个网页，最少需要四个进程</strong>：1 个网络进程、1 个浏览器进程、1 个 GPU 进程以及 1 个渲染进程。如果打开的页面有运行插件的话，还需要再加上 1 个插件进程。</p><p>虽然多进程模型提升了浏览器的稳定性、流畅性和安全性，但同样不可避免地带来了一些问题：</p><ul><li><strong>更高的资源占用</strong>：因为每个进程都会包含公共基础结构的副本（如 JavaScript 运行环境），这就意味着浏览器会消耗更多的内存资源。</li><li><strong>更复杂的体系架构</strong>：浏览器各模块之间耦合性高、扩展性差等问题，会导致现在的架构已经很难适应新的需求了。</li></ul><h3 id="2-进程和线程的区别"><a href="#2-进程和线程的区别" class="headerlink" title="2. 进程和线程的区别"></a>2. 进程和线程的区别</h3><ul><li>进程可以看做独立应用，线程不能</li><li>资源：进程是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位）；线程是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）。</li><li>通信方面：线程间可以通过直接共享同一进程中的资源，而进程通信需要借助 进程间通信。</li><li>调度：进程切换比线程切换的开销要大。线程是CPU调度的基本单位，线程的切换不会引起进程切换，但某个进程中的线程切换到另一个进程中的线程时，会引起进程切换。</li><li>系统开销：由于创建或撤销进程时，系统都要为之分配或回收资源，如内存、I/O 等，其开销远大于创建或撤销线程时的开销。同理，在进行进程切换时，涉及当前执行进程 CPU 环境还有各种各样状态的保存及新调度进程状态的设置，而线程切换时只需保存和设置少量寄存器内容，开销较小。</li></ul><h3 id="3-浏览器渲染进程的线程有哪些"><a href="#3-浏览器渲染进程的线程有哪些" class="headerlink" title="3. 浏览器渲染进程的线程有哪些"></a>3. 浏览器渲染进程的线程有哪些</h3><p>浏览器的渲染进程的线程总共有五种： <img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230611141053247.png" alt="image-20230611141053247"> <strong>（1)GUI渲染线程</strong> 负责渲染浏览器页面，解析HTML、CSS，构建DOM树、构建CSSOM树、构建渲染树和绘制页面；当界面需要<strong>重绘</strong>或由于某种操作引发<strong>回流</strong>时，该线程就会执行。</p><p>注意：GUI渲染线程和JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起，GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。</p><p><strong>（2）JS引擎线程</strong> JS引擎线程也称为JS内核，负责处理Javascript脚本程序，解析Javascript脚本，运行代码；JS引擎线程一直等待着任务队列中任务的到来，然后加以处理，一个Tab页中无论什么时候都只有一个JS引擎线程在运行JS程序；</p><p>注意：GUI渲染线程与JS引擎线程的互斥关系，所以如果JS执行的时间过长，会造成页面的渲染不连贯，导致页面渲染加载阻塞。</p><p><strong>（3）时间触发线程</strong> <strong>时间触发线程</strong>属于浏览器而不是JS引擎，用来控制事件循环；当JS引擎执行代码块如setTimeOut时（也可是来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件触发线程中；当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理；</p><p>注意：由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）；</p><p><strong>（4）定时器触发进程</strong> <strong>定时器触发进程</strong>即setInterval与setTimeout所在线程；浏览器定时计数器并不是由JS引擎计数的，因为JS引擎是单线程的，如果处于阻塞线程状态就会影响记计时的准确性；因此使用单独线程来计时并触发定时器，计时完毕后，添加到事件队列中，等待JS引擎空闲后执行，所以定时器中的任务在设定的时间点不一定能够准时执行，定时器只是在指定时间点将任务添加到事件队列中；</p><p>注意：W3C在HTML标准中规定，定时器的定时时间不能小于4ms，如果是小于4ms，则默认为4ms。</p><p><strong>（5）异步http请求线程</strong></p><ul><li>XMLHttpRequest连接后通过浏览器新开一个线程请求；</li><li>检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将回调函数放入事件队列中，等待JS引擎空闲后执行；</li></ul><h3 id="4-进程之前的通信方式"><a href="#4-进程之前的通信方式" class="headerlink" title="4. 进程之前的通信方式"></a>4. 进程之前的通信方式</h3><p><strong>（1）管道通信</strong></p><p>管道是一种最基本的进程间通信机制。<strong>管道就是操作系统在内核中开辟的一段缓冲区，进程1可以将需要交互的数据拷贝到这段缓冲区，进程2就可以读取了。</strong></p><p>管道的特点：</p><ul><li>只能单向通信</li><li>只能血缘关系的进程进行通信</li><li>依赖于文件系统</li><li>生命周期随进程</li><li>面向字节流的服务</li><li>管道内部提供了同步机制</li></ul><p><strong>（2）消息队列通信</strong></p><p>消息队列就是一个消息的列表。用户可以在消息队列中添加消息、读取消息等。消息队列提供了一种从一个进程向另一个进程发送一个数据块的方法。 每个数据块都被认为含有一个类型，接收进程可以独立地接收含有不同类型的数据结构。可以通过发送消息来避免命名管道的同步和阻塞问题。但是消息队列与命名管道一样，每个数据块都有一个最大长度的限制。</p><p>使用消息队列进行进程间通信，可能会收到数据块最大长度的限制约束等，这也是这种通信方式的缺点。如果频繁的发生进程间的通信行为，那么进程需要频繁地读取队列中的数据到内存，相当于间接地从一个进程拷贝到另一个进程，这需要花费时间。</p><p><strong>（3）信号量通信</strong></p><p>共享内存最大的问题就是多进程竞争内存的问题，就像类似于线程安全问题。我们可以使用信号量来解决这个问题。信号量的本质就是一个计数器，用来实现进程之间的互斥与同步。例如信号量的初始值是 1，然后 a 进程来访问内存1的时候，我们就把信号量的值设为 0，然后进程b 也要来访问内存1的时候，看到信号量的值为 0 就知道已经有进程在访问内存1了，这个时候进程 b 就会访问不了内存1。所以说，信号量也是进程之间的一种通信方式。</p><p><strong>（4）信号通信</strong></p><p>信号（Signals ）是Unix系统中使用的最古老的进程间通信的方法之一。操作系统通过信号来通知进程系统中发生了某种预先规定好的事件（一组事件中的一个），它也是用户进程之间通信和同步的一种原始机制。</p><p><strong>（5）共享内存通信</strong></p><p>共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问（使多个进程可以访问同一块内存空间）。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。</p><p><strong>（6）套接字通信</strong></p><p>上面说的共享内存、管道、信号量、消息队列，他们都是多个进程在一台主机之间的通信，那两个相隔几千里的进程能够进行通信吗？答是必须的，这个时候 Socket 这家伙就派上用场了，例如我们平时通过浏览器发起一个 http 请求，然后服务器给你返回对应的数据，这种就是采用 Socket 的通信方式了。</p><h3 id="5-僵尸进程和孤儿进程是什么？"><a href="#5-僵尸进程和孤儿进程是什么？" class="headerlink" title="5. 僵尸进程和孤儿进程是什么？"></a>5. 僵尸进程和孤儿进程是什么？</h3><ul><li><strong>孤儿进程</strong>：父进程退出了，而它的一个或多个进程还在运行，那这些子进程都会成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。</li><li><strong>僵尸进程</strong>：子进程比父进程先结束，而父进程又没有释放子进程占用的资源，那么子进程的进程描述符仍然保存在系统中，这种进程称之为僵死进程。</li></ul><h3 id="6-死锁产生的原因？-如果解决死锁的问题？"><a href="#6-死锁产生的原因？-如果解决死锁的问题？" class="headerlink" title="6. 死锁产生的原因？ 如果解决死锁的问题？"></a>6. 死锁产生的原因？ 如果解决死锁的问题？</h3><p>所谓死锁，是指多个进程在运行过程中因争夺资源而造成的一种僵局，当进程处于这种僵持状态时，若无外力作用，它们都将无法再向前推进。</p><p>系统中的资源可以分为两类：</p><ul><li>可剥夺资源，是指某进程在获得这类资源后，该资源可以再被其他进程或系统剥夺，CPU和主存均属于可剥夺性资源；</li><li>不可剥夺资源，当系统把这类资源分配给某进程后，再不能强行收回，只能在进程用完后自行释放，如磁带机、打印机等。</li></ul><p><strong>产生死锁的原因：</strong></p><p><strong>（1）竞争资源</strong></p><ul><li>产生死锁中的竞争资源之一指的是<strong>竞争不可剥夺资源</strong>（例如：系统中只有一台打印机，可供进程P1使用，假定P1已占用了打印机，若P2继续要求打印机打印将阻塞）</li><li>产生死锁中的竞争资源另外一种资源指的是<strong>竞争临时资源</strong>（临时资源包括硬件中断、信号、消息、缓冲区内的消息等），通常消息通信顺序进行不当，则会产生死锁</li></ul><p><strong>（2）进程间推进顺序非法</strong></p><p>若P1保持了资源R1，P2保持了资源R2，系统处于不安全状态，因为这两个进程再向前推进，便可能发生死锁。例如，当P1运行到P1：Request（R2）时，将因R2已被P2占用而阻塞；当P2运行到P2：Request（R1）时，也将因R1已被P1占用而阻塞，于是发生进程死锁</p><p><strong>产生死锁的必要条件：</strong></p><ul><li>互斥条件：进程要求对所分配的资源进行排它性控制，即在一段时间内某资源仅为一进程所占用。</li><li>请求和保持条件：当进程因请求资源而阻塞时，对已获得的资源保持不放。</li><li>不剥夺条件：进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放。</li><li>环路等待条件：在发生死锁时，必然存在一个进程——资源的环形链。</li></ul><p><strong>预防死锁的方法：</strong></p><ul><li>资源一次性分配：一次性分配所有资源，这样就不会再有请求了（破坏请求条件）</li><li>只要有一个资源得不到分配，也不给这个进程分配其他的资源（破坏请保持条件）</li><li>可剥夺资源：即当某进程获得了部分资源，但得不到其它资源，则释放已占有的资源（破坏不可剥夺条件）</li><li>资源有序分配法：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反（破坏环路等待条件）</li></ul><h3 id="7-如何实现浏览器内多个标签页之间的通信"><a href="#7-如何实现浏览器内多个标签页之间的通信" class="headerlink" title="7. 如何实现浏览器内多个标签页之间的通信?"></a>7. 如何实现浏览器内多个标签页之间的通信?</h3><p>实现多个标签页之间的通信，本质上都是通过中介者模式来实现的。因为标签页之间没有办法直接通信，因此我们可以找一个中介者，让标签页和中介者进行通信，然后让这个中介者来进行消息的转发。通信方法如下：</p><ul><li><strong>使用 websocket 协议</strong>，因为 websocket 协议可以实现服务器推送，所以服务器就可以用来当做这个中介者。标签页通过向服务器发送数据，然后由服务器向其他标签页推送转发。</li><li><strong>使用 ShareWorker 的方式</strong>，shareWorker 会在页面存在的生命周期内创建一个唯一的线程，并且开启多个页面也只会使用同一个线程。这个时候共享线程就可以充当中介者的角色。标签页间通过共享一个线程，然后通过这个共享的线程来实现数据的交换。</li><li><strong>使用 localStorage 的方式</strong>，我们可以在一个标签页对 localStorage 的变化事件进行监听，然后当另一个标签页修改数据的时候，我们就可以通过这个监听事件来获取到数据。这个时候 localStorage 对象就是充当的中介者的角色。</li><li><strong>使用 postMessage 方法</strong>，如果我们能够获得对应标签页的引用，就可以使用postMessage 方法，进行通信。</li></ul><h3 id="8-对Service-Worker的理解"><a href="#8-对Service-Worker的理解" class="headerlink" title="8. 对Service Worker的理解"></a>8. 对Service Worker的理解</h3><p>Service Worker 是运行在浏览器背后的<strong>独立线程</strong>，一般可以用来实现缓存功能。使用 Service Worker的话，传输协议必须为 <strong>HTTPS</strong>。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。</p><p>Service Worker 实现缓存功能一般分为三个步骤：首先需要先注册 Service Worker，然后监听到 <code>install</code> 事件以后就可以缓存需要的文件，那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据。以下是这个步骤的实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">if</span> (navigator.<span class="property">serviceWorker</span>) &#123;</span><br><span class="line">  navigator.<span class="property">serviceWorker</span></span><br><span class="line">    .<span class="title function_">register</span>(<span class="string">&#x27;sw.js&#x27;</span>)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">registration</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;service worker 注册成功&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">err</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;servcie worker 注册失败&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// sw.js</span></span><br><span class="line"><span class="comment">// 监听 `install` 事件，回调中缓存所需文件</span></span><br><span class="line">self.<span class="title function_">addEventListener</span>(<span class="string">&#x27;install&#x27;</span>, <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  e.<span class="title function_">waitUntil</span>(</span><br><span class="line">    caches.<span class="title function_">open</span>(<span class="string">&#x27;my-cache&#x27;</span>).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">cache</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> cache.<span class="title function_">addAll</span>([<span class="string">&#x27;./index.html&#x27;</span>, <span class="string">&#x27;./index.js&#x27;</span>])</span><br><span class="line">    &#125;)</span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 拦截所有请求事件</span></span><br><span class="line"><span class="comment">// 如果缓存中已经有请求的数据就直接用缓存，否则去请求数据</span></span><br><span class="line">self.<span class="title function_">addEventListener</span>(<span class="string">&#x27;fetch&#x27;</span>, <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  e.<span class="title function_">respondWith</span>(</span><br><span class="line">    caches.<span class="title function_">match</span>(e.<span class="property">request</span>).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">response</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (response) &#123;</span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;fetch source&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>打开页面，可以在开发者工具中的 <code>Application</code> 看到 Service Worker 已经启动了： <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0ef126ed3be8463a8e04d4156b2addd9~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img"> 在 Cache 中也可以发现所需的文件已被缓存： <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a223ee3c073d47188ecee7c410ee557c~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img"></p><h2 id="三、浏览器缓存"><a href="#三、浏览器缓存" class="headerlink" title="三、浏览器缓存"></a>三、浏览器缓存</h2><h3 id="1-对浏览器的缓存机制的理解"><a href="#1-对浏览器的缓存机制的理解" class="headerlink" title="1. 对浏览器的缓存机制的理解"></a>1. 对浏览器的缓存机制的理解</h3><p><strong>浏览器缓存的全过程：</strong></p><ul><li>浏览器第一次加载资源，服务器返回 200，浏览器从服务器下载资源文件，并缓存资源文件与 response header，以供下次加载时对比使用；</li><li>下一次加载资源时，由于强制缓存优先级较高，先比较当前时间与上一次返回 200 时的时间差，如果没有超过 cache-control 设置的 max-age，则没有过期，并命中强缓存，直接从本地读取资源。如果浏览器不支持HTTP1.1，则使用 expires 头判断是否过期；</li><li>如果资源已过期，则表明强制缓存没有被命中，则开始协商缓存，向服务器发送带有 If-None-Match 和 If-Modified-Since 的请求；</li><li>服务器收到请求后，优先根据 Etag 的值判断被请求的文件有没有做修改，Etag 值一致则没有修改，命中协商缓存，返回 304；如果不一致则有改动，直接返回新的资源文件带上新的 Etag 值并返回 200；</li><li>如果服务器收到的请求没有 Etag 值，则将 If-Modified-Since 和被请求文件的最后修改时间做比对，一致则命中协商缓存，返回 304；不一致则返回新的 last-modified 和文件并返回 200；</li></ul><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230611142319335.png" alt="image-20230611142319335"> 很多网站的资源后面都加了版本号，这样做的目的是：每次升级了 JS 或 CSS 文件后，为了防止浏览器进行缓存，强制改变版本号，客户端浏览器就会重新下载新的 JS 或 CSS 文件 ，以保证用户能够及时获得网站的最新更新。</p><h3 id="3-协商缓存和强缓存的区别"><a href="#3-协商缓存和强缓存的区别" class="headerlink" title="3. 协商缓存和强缓存的区别"></a>3. 协商缓存和强缓存的区别</h3><h4 id="（1）强缓存"><a href="#（1）强缓存" class="headerlink" title="（1）强缓存"></a>（1）强缓存</h4><p>使用强缓存策略时，如果缓存资源有效，则直接使用缓存资源，不必再向服务器发起请求。</p><p>强缓存策略可以通过两种方式来设置，分别是 http 头信息中的 Expires 属性和 Cache-Control 属性。</p><p>（1）服务器通过在响应头中添加 Expires 属性，来指定资源的过期时间。在过期时间以内，该资源可以被缓存使用，不必再向服务器发送请求。这个时间是一个绝对时间，它是服务器的时间，因此可能存在这样的问题，就是客户端的时间和服务器端的时间不一致，或者用户可以对客户端时间进行修改的情况，这样就可能会影响缓存命中的结果。</p><p>（2）Expires 是 http1.0 中的方式，因为它的一些缺点，在 HTTP 1.1 中提出了一个新的头部属性就是 Cache-Control 属性，它提供了对资源的缓存的更精确的控制。它有很多不同的值，</p><p><code>Cache-Control</code>可设置的字段：</p><ul><li><code>public</code>：设置了该字段值的资源表示可以被任何对象（包括：发送请求的客户端、代理服务器等等）缓存。这个字段值不常用，一般还是使用max-age=来精确控制；</li><li><code>private</code>：设置了该字段值的资源只能被用户浏览器缓存，不允许任何代理服务器缓存。在实际开发当中，对于一些含有用户信息的HTML，通常都要设置这个字段值，避免代理服务器(CDN)缓存；</li><li><code>no-cache</code>：设置了该字段需要先和服务端确认返回的资源是否发生了变化，如果资源未发生变化，则直接使用缓存好的资源；</li><li><code>no-store</code>：设置了该字段表示禁止任何缓存，每次都会向服务端发起新的请求，拉取最新的资源；</li><li><code>max-age=</code>：设置缓存的最大有效期，单位为秒；</li><li><code>s-maxage=</code>：优先级高于max-age=，仅适用于共享缓存(CDN)，优先级高于max-age或者Expires头；</li><li><code>max-stale[=]</code>：设置了该字段表明客户端愿意接收已经过期的资源，但是不能超过给定的时间限制。</li></ul><p>一般来说只需要设置其中一种方式就可以实现强缓存策略，当两种方式一起使用时，Cache-Control 的优先级要高于 Expires。</p><p><strong>no-cache和no-store很容易混淆：</strong></p><ul><li>no-cache 是指先要和服务器确认是否有资源更新，在进行判断。也就是说没有强缓存，但是会有协商缓存；</li><li>no-store 是指不使用任何缓存，每次请求都直接从服务器获取资源。</li></ul><h4 id="（2）协商缓存"><a href="#（2）协商缓存" class="headerlink" title="（2）协商缓存"></a>（2）协商缓存</h4><p>如果命中强制缓存，我们无需发起新的请求，直接使用缓存内容，如果没有命中强制缓存，如果设置了协商缓存，这个时候协商缓存就会发挥作用了。</p><p>上面已经说到了，命中协商缓存的条件有两个：</p><ul><li><code>max-age=xxx</code> 过期了</li><li>值为<code>no-store</code></li></ul><p>使用协商缓存策略时，会先向服务器发送一个请求，如果资源没有发生修改，则返回一个 304 状态，让浏览器使用本地的缓存副本。如果资源发生了修改，则返回修改后的资源。</p><p>协商缓存也可以通过两种方式来设置，分别是 http 头信息中的<strong>Etag</strong> 和<strong>Last-Modified</strong>属性。</p><p>（1）服务器通过在响应头中添加 Last-Modified 属性来指出资源最后一次修改的时间，当浏览器下一次发起请求时，会在请求头中添加一个 If-Modified-Since 的属性，属性值为上一次资源返回时的 Last-Modified 的值。当请求发送到服务器后服务器会通过这个属性来和资源的最后一次的修改时间来进行比较，以此来判断资源是否做了修改。如果资源没有修改，那么返回 304 状态，让客户端使用本地的缓存。如果资源已经被修改了，则返回修改后的资源。使用这种方法有一个缺点，就是 Last-Modified 标注的最后修改时间只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，那么文件已将改变了但是 Last-Modified 却没有改变，这样会造成缓存命中的不准确。</p><p>（2）因为 Last-Modified 的这种可能发生的不准确性，http 中提供了另外一种方式，那就是 Etag 属性。服务器在返回资源的时候，在头信息中添加了 Etag 属性，这个属性是资源生成的唯一标识符，当资源发生改变的时候，这个值也会发生改变。在下一次资源请求时，浏览器会在请求头中添加一个 If-None-Match 属性，这个属性的值就是上次返回的资源的 Etag 的值。服务接收到请求后会根据这个值来和资源当前的 Etag 的值来进行比较，以此来判断资源是否发生改变，是否需要返回资源。通过这种方式，比 Last-Modified 的方式更加精确。</p><p>当 Last-Modified 和 Etag 属性同时出现的时候，Etag 的优先级更高。使用协商缓存的时候，服务器需要考虑负载平衡的问题，因此多个服务器上资源的 Last-Modified 应该保持一致，因为每个服务器上 Etag 的值都不一样，因此在考虑负载平衡时，最好不要设置 Etag 属性。</p><p><strong>总结：</strong></p><p>强缓存策略和协商缓存策略在缓存命中时都会直接使用本地的缓存副本，区别只在于协商缓存会向服务器发送一次请求。它们缓存不命中时，都会向服务器发送请求来获取资源。在实际的缓存机制中，强缓存策略和协商缓存策略是一起合作使用的。浏览器首先会根据请求的信息判断，强缓存是否命中，如果命中则直接使用资源。如果不命中则根据头信息向服务器发起请求，使用协商缓存，如果协商缓存命中的话，则服务器不返回资源，浏览器直接使用本地资源的副本，如果协商缓存不命中，则浏览器返回最新的资源给浏览器。</p><h3 id="4-为什么需要浏览器缓存？"><a href="#4-为什么需要浏览器缓存？" class="headerlink" title="4. 为什么需要浏览器缓存？"></a>4. 为什么需要浏览器缓存？</h3><p>对于浏览器的缓存，主要针对的是前端的静态资源，最好的效果就是，在发起请求之后，拉取相应的静态资源，并保存在本地。如果服务器的静态资源没有更新，那么在下次请求的时候，就直接从本地读取即可，如果服务器的静态资源已经更新，那么我们再次请求的时候，就到服务器拉取新的资源，并保存在本地。这样就大大的减少了请求的次数，提高了网站的性能。这就要用到浏览器的缓存策略了。</p><p>所谓的<strong>浏览器缓存</strong>指的是浏览器将用户请求过的静态资源，存储到电脑本地磁盘中，当浏览器再次访问时，就可以直接从本地加载，不需要再去服务端请求了。</p><p>使用浏览器缓存，有以下优点：</p><ul><li>减少了服务器的负担，提高了网站的性能</li><li>加快了客户端网页的加载速度</li><li>减少了多余网络数据传输</li></ul><h3 id="5-点击刷新按钮或者按-F5、按-Ctrl-F5-（强制刷新）、地址栏回车有什么区别？"><a href="#5-点击刷新按钮或者按-F5、按-Ctrl-F5-（强制刷新）、地址栏回车有什么区别？" class="headerlink" title="5. 点击刷新按钮或者按 F5、按 Ctrl+F5 （强制刷新）、地址栏回车有什么区别？"></a>5. 点击刷新按钮或者按 F5、按 Ctrl+F5 （强制刷新）、地址栏回车有什么区别？</h3><ul><li><strong>点击刷新按钮或者按 F5：</strong> 浏览器直接对本地的缓存文件过期，但是会带上If-Modifed-Since，If-None-Match，这就意味着服务器会对文件检查新鲜度，返回结果可能是 304，也有可能是 200。</li><li><strong>用户按 Ctrl+F5（强制刷新）：</strong> 浏览器不仅会对本地文件过期，而且不会带上 If-Modifed-Since，If-None-Match，相当于之前从来没有请求过，返回结果是 200。</li><li>地址栏回车： 浏览器发起请求，按照正常流程，本地检查是否过期，然后服务器检查新鲜度，最后返回内容。</li></ul><h2 id="四、浏览器组成"><a href="#四、浏览器组成" class="headerlink" title="四、浏览器组成"></a>四、浏览器组成</h2><h3 id="1-对浏览器的理解"><a href="#1-对浏览器的理解" class="headerlink" title="1. 对浏览器的理解"></a>1. 对浏览器的理解</h3><p>浏览器的主要功能是将用户选择的 web 资源呈现出来，它需要从服务器请求资源，并将其显示在浏览器窗口中，资源的格式通常是 HTML，也包括 PDF、image 及其他格式。用户用 URI（Uniform Resource Identifier 统一资源标识符）来指定所请求资源的位置。</p><p>HTML 和 CSS 规范中规定了浏览器解释 html 文档的方式，由 W3C 组织对这些规范进行维护，W3C 是负责制定 web 标准的组织。但是浏览器厂商纷纷开发自己的扩展，对规范的遵循并不完善，这为 web 开发者带来了严重的兼容性问题。</p><p>浏览器可以分为两部分，shell 和 内核。其中 shell 的种类相对比较多，内核则比较少。也有一些浏览器并不区分外壳和内核。从 Mozilla 将 Gecko 独立出来后，才有了外壳和内核的明确划分。</p><ul><li>shell 是指浏览器的外壳：例如菜单，工具栏等。主要是提供给用户界面操作，参数设置等等。它是调用内核来实现各种功能的。</li><li>内核是浏览器的核心。内核是基于标记语言显示内容的程序或模块。</li></ul><h3 id="2-对浏览器内核的理解"><a href="#2-对浏览器内核的理解" class="headerlink" title="2. 对浏览器内核的理解"></a>2. 对浏览器内核的理解</h3><p>浏览器内核主要分成两部分：</p><ul><li>渲染引擎的职责就是渲染，即在浏览器窗口中显示所请求的内容。默认情况下，渲染引擎可以显示 html、xml 文档及图片，它也可以借助插件显示其他类型数据，例如使用 PDF 阅读器插件，可以显示 PDF 格式。</li><li>JS 引擎：解析和执行 javascript 来实现网页的动态效果。</li></ul><p>最开始渲染引擎和 JS 引擎并没有区分的很明确，后来 JS 引擎越来越独立，内核就倾向于只指渲染引擎。</p><h3 id="3-常见的浏览器内核比较"><a href="#3-常见的浏览器内核比较" class="headerlink" title="3. 常见的浏览器内核比较"></a>3. 常见的浏览器内核比较</h3><ul><li><strong>Trident：</strong> 这种浏览器内核是 IE 浏览器用的内核，因为在早期 IE 占有大量的市场份额，所以这种内核比较流行，以前有很多网页也是根据这个内核的标准来编写的，但是实际上这个内核对真正的网页标准支持不是很好。但是由于 IE 的高市场占有率，微软也很长时间没有更新 Trident 内核，就导致了 Trident 内核和 W3C 标准脱节。还有就是 Trident 内核的大量 Bug 等安全问题没有得到解决，加上一些专家学者公开自己认为 IE 浏览器不安全的观点，使很多用户开始转向其他浏览器。</li><li><strong>Gecko：</strong> 这是 Firefox 和 Flock 所采用的内核，这个内核的优点就是功能强大、丰富，可以支持很多复杂网页效果和浏览器扩展接口，但是代价是也显而易见就是要消耗很多的资源，比如内存。</li><li><strong>Presto：</strong> Opera 曾经采用的就是 Presto 内核，Presto 内核被称为公认的浏览网页速度最快的内核，这得益于它在开发时的天生优势，在处理 JS 脚本等脚本语言时，会比其他的内核快3倍左右，缺点就是为了达到很快的速度而丢掉了一部分网页兼容性。</li><li><strong>Webkit：</strong> Webkit 是 Safari 采用的内核，它的优点就是网页浏览速度较快，虽然不及 Presto 但是也胜于 Gecko 和 Trident，缺点是对于网页代码的容错性不高，也就是说对网页代码的兼容性较低，会使一些编写不标准的网页无法正确显示。WebKit 前身是 KDE 小组的 KHTML 引擎，可以说 WebKit 是 KHTML 的一个开源的分支。</li><li><strong>Blink：</strong> 谷歌在 Chromium Blog 上发表博客，称将与苹果的开源浏览器核心 Webkit 分道扬镳，在 Chromium 项目中研发 Blink 渲染引擎（即浏览器核心），内置于 Chrome 浏览器之中。其实 Blink 引擎就是 Webkit 的一个分支，就像 webkit 是KHTML 的分支一样。Blink 引擎现在是谷歌公司与 Opera Software 共同研发，上面提到过的，Opera 弃用了自己的 Presto 内核，加入 Google 阵营，跟随谷歌一起研发 Blink。</li></ul><h3 id="4-常见浏览器所用内核"><a href="#4-常见浏览器所用内核" class="headerlink" title="4. 常见浏览器所用内核"></a>4. 常见浏览器所用内核</h3><p>（1） IE 浏览器内核：Trident 内核，也是俗称的 IE 内核；</p><p>（2） Chrome 浏览器内核：统称为 Chromium 内核或 Chrome 内核，以前是 Webkit 内核，现在是 Blink内核；</p><p>（3） Firefox 浏览器内核：Gecko 内核，俗称 Firefox 内核；</p><p>（4） Safari 浏览器内核：Webkit 内核；</p><p>（5） Opera 浏览器内核：最初是自己的 Presto 内核，后来加入谷歌大军，从 Webkit 又到了 Blink 内核；</p><p>（6） 360浏览器、猎豹浏览器内核：IE + Chrome 双内核；</p><p>（7） 搜狗、遨游、QQ 浏览器内核：Trident（兼容模式）+ Webkit（高速模式）；</p><p>（8） 百度浏览器、世界之窗内核：IE 内核；</p><p>（9） 2345浏览器内核：好像以前是 IE 内核，现在也是 IE + Chrome 双内核了；</p><p>（10）UC 浏览器内核：这个众口不一，UC 说是他们自己研发的 U3 内核，但好像还是基于 Webkit 和 Trident ，还有说是基于火狐内核。</p><h3 id="5-浏览器的主要组成部分"><a href="#5-浏览器的主要组成部分" class="headerlink" title="5. 浏览器的主要组成部分"></a>5. 浏览器的主要组成部分</h3><ul><li><strong>⽤户界⾯</strong> 包括地址栏、前进/后退按钮、书签菜单等。除了浏览器主窗⼝显示的您请求的⻚⾯外，其他显示的各个部分都属于⽤户界⾯。</li><li><strong>浏览器引擎</strong> 在⽤户界⾯和呈现引擎之间传送指令。</li><li><strong>呈现引擎</strong> 负责显示请求的内容。如果请求的内容是 HTML，它就负责解析 HTML 和 CSS 内容，并将解析后的内容显示在屏幕上。</li><li><strong>⽹络</strong> ⽤于⽹络调⽤，⽐如 HTTP 请求。其接⼝与平台⽆关，并为所有平台提供底层实现。</li><li><strong>⽤户界⾯后端</strong> ⽤于绘制基本的窗⼝⼩部件，⽐如组合框和窗⼝。其公开了与平台⽆关的通⽤接⼝，⽽在底层使⽤操作系统的⽤户界⾯⽅法。</li><li><strong>JavaScript 解释器</strong>。⽤于解析和执⾏ JavaScript 代码。</li><li><strong>数据存储</strong> 这是持久层。浏览器需要在硬盘上保存各种数据，例如 Cookie。新的 HTML 规范 (HTML5) 定义了“⽹络数据库”，这是⼀个完整（但是轻便）的浏览器内数据库。</li></ul><p>值得注意的是，和⼤多数浏览器不同，Chrome 浏览器的每个标签⻚都分别对应⼀个呈现引擎实例。每个标签⻚都是⼀个独⽴的进程。</p><h2 id="五、浏览器渲染原理"><a href="#五、浏览器渲染原理" class="headerlink" title="五、浏览器渲染原理"></a>五、浏览器渲染原理</h2><h3 id="1-浏览器的渲染过程"><a href="#1-浏览器的渲染过程" class="headerlink" title="1. 浏览器的渲染过程"></a>1. 浏览器的渲染过程</h3><p>浏览器渲染主要有以下步骤：</p><ul><li>首先解析收到的文档，根据文档定义构建一棵 DOM 树，DOM 树是由 DOM 元素及属性节点组成的。</li><li>然后对 CSS 进行解析，生成 CSSOM 规则树。</li><li>根据 DOM 树和 CSSOM 规则树构建渲染树。渲染树的节点被称为渲染对象，渲染对象是一个包含有颜色和大小等属性的矩形，渲染对象和 DOM 元素相对应，但这种对应关系不是一对一的，不可见的 DOM 元素不会被插入渲染树。还有一些 DOM元素对应几个可见对象，它们一般是一些具有复杂结构的元素，无法用一个矩形来描述。</li><li>当渲染对象被创建并添加到树中，它们并没有位置和大小，所以当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流）。这一阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切位置和大小。通常这一行为也被称为“自动重排”。</li><li>布局阶段结束后是绘制阶段，遍历渲染树并调用渲染对象的 paint 方法将它们的内容显示在屏幕上，绘制使用 UI 基础组件。</li></ul><p>大致过程如图所示： <img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230611143245300.png" alt="image-20230611143245300"></p><p><strong>注意：</strong> 这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的html 都解析完成之后再去构建和布局 render 树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。</p><h3 id="2-浏览器渲染优化"><a href="#2-浏览器渲染优化" class="headerlink" title="2. 浏览器渲染优化"></a>2. 浏览器渲染优化</h3><p><strong>（1）针对JavaScript：</strong> JavaScript既会阻塞HTML的解析，也会阻塞CSS的解析。因此我们可以对JavaScript的加载方式进行改变，来进行优化：</p><p>（1）尽量将JavaScript文件放在body的最后</p><p>（2） body中间尽量不要写<code>&lt;script&gt;</code>标签</p><p>（3）<code>&lt;script&gt;</code>标签的引入资源方式有三种，有一种就是我们常用的直接引入，还有两种就是使用 async 属性和 defer 属性来异步引入，两者都是去异步加载外部的JS文件，不会阻塞DOM的解析（尽量使用异步加载）。三者的区别如下：</p><ul><li><strong>script</strong> 立即停止页面渲染去加载资源文件，当资源加载完毕后立即执行js代码，js代码执行完毕后继续渲染页面；</li><li><strong>async</strong> 是在下载完成之后，立即异步加载，加载好后立即执行，多个带async属性的标签，不能保证加载的顺序；</li><li><strong>defer</strong> 是在下载完成之后，立即异步加载。加载好后，如果 DOM 树还没构建好，则先等 DOM 树解析好再执行；如果DOM树已经准备好，则立即执行。多个带defer属性的标签，按照顺序执行。</li></ul><p>**（2）针对CSS：**使用CSS有三种方式：使用**link、@import、内联样式**，其中link和@import都是导入外部样式。它们之间的区别：</p><ul><li><strong>link</strong>：浏览器会派发一个新等线程(HTTP线程)去加载资源文件，与此同时GUI渲染线程会继续向下渲染代码</li><li><strong>@import</strong>：GUI渲染线程会暂时停止渲染，去服务器加载资源文件，资源文件没有返回之前不会继续渲染(阻碍浏览器渲染)</li><li><strong>style</strong>：GUI直接渲染</li></ul><p>外部样式如果长时间没有加载完毕，浏览器为了用户体验，会使用浏览器会默认样式，确保首次渲染的速度。所以CSS一般写在headr中，让浏览器尽快发送请求去获取css样式。</p><p>所以，在开发过程中，导入外部样式使用link，而不用@import。如果css少，尽可能采用内嵌样式，直接写在style标签中。</p><p><strong>（3）针对DOM树、CSSOM树：</strong> 可以通过以下几种方式来减少渲染的时间：</p><ul><li>HTML文件的代码层级尽量不要太深</li><li>使用语义化的标签，来避免不标准语义化的特殊处理</li><li>减少CSSD代码的层级，因为选择器是从左向右进行解析的</li></ul><p><strong>（4）减少回流与重绘：</strong></p><ul><li>操作DOM时，尽量在低层级的DOM节点进行操作</li><li>不要使用<code>table</code>布局， 一个小的改动可能会使整个<code>table</code>进行重新布局</li><li>使用CSS的表达式</li><li>不要频繁操作元素的样式，对于静态页面，可以修改类名，而不是样式。</li><li>使用absolute或者fixed，使元素脱离文档流，这样他们发生变化就不会影响其他元素</li><li>避免频繁操作DOM，可以创建一个文档片段<code>documentFragment</code>，在它上面应用所有DOM操作，最后再把它添加到文档中</li><li>将元素先设置<code>display: none</code>，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘。</li><li>将DOM的多个读操作（或者写操作）放在一起，而不是读写操作穿插着写。这得益于<strong>浏览器的渲染队列机制</strong>。</li></ul><p>浏览器针对页面的回流与重绘，进行了自身的优化——<strong>渲染队列</strong></p><p><strong>浏览器会将所有的回流、重绘的操作放在一个队列中，当队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会对队列进行批处理。这样就会让多次的回流、重绘变成一次回流重绘。</strong></p><p>将多个读操作（或者写操作）放在一起，就会等所有的读操作进入队列之后执行，这样，原本应该是触发多次回流，变成了只触发一次回流。</p><h3 id="3-渲染过程中遇到-JS-文件如何处理？"><a href="#3-渲染过程中遇到-JS-文件如何处理？" class="headerlink" title="3. 渲染过程中遇到 JS 文件如何处理？"></a>3. 渲染过程中遇到 JS 文件如何处理？</h3><p>JavaScript 的加载、解析与执行会阻塞文档的解析，也就是说，在构建 DOM 时，HTML 解析器若遇到了 JavaScript，那么它会暂停文档的解析，将控制权移交给 JavaScript 引擎，等 JavaScript 引擎运行完毕，浏览器再从中断的地方恢复继续解析文档。也就是说，如果想要首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的原因。当然在当下，并不是说 script 标签必须放在底部，因为你可以给 script 标签添加 defer 或者 async 属性。</p><h3 id="4-什么是文档的预解析？"><a href="#4-什么是文档的预解析？" class="headerlink" title="4. 什么是文档的预解析？"></a>4. 什么是文档的预解析？</h3><p>Webkit 和 Firefox 都做了这个优化，当执行 JavaScript 脚本时，另一个线程解析剩下的文档，并加载后面需要通过网络加载的资源。这种方式可以使资源并行加载从而使整体速度更快。需要注意的是，预解析并不改变 DOM 树，它将这个工作留给主解析过程，自己只解析外部资源的引用，比如外部脚本、样式表及图片。</p><h3 id="5-CSS-如何阻塞文档解析？"><a href="#5-CSS-如何阻塞文档解析？" class="headerlink" title="5. CSS 如何阻塞文档解析？"></a>5. CSS 如何阻塞文档解析？</h3><p>理论上，既然样式表不改变 DOM 树，也就没有必要停下文档的解析等待它们。然而，存在一个问题，JavaScript 脚本执行时可能在文档的解析过程中请求样式信息，如果样式还没有加载和解析，脚本将得到错误的值，显然这将会导致很多问题。所以如果浏览器尚未完成 CSSOM 的下载和构建，而我们却想在此时运行脚本，那么浏览器将延迟 JavaScript 脚本执行和文档的解析，直至其完成 CSSOM 的下载和构建。也就是说，在这种情况下，浏览器会先下载和构建 CSSOM，然后再执行 JavaScript，最后再继续文档的解析。</p><h3 id="6-如何优化关键渲染路径？"><a href="#6-如何优化关键渲染路径？" class="headerlink" title="6. 如何优化关键渲染路径？"></a>6. 如何优化关键渲染路径？</h3><p>为尽快完成首次渲染，我们需要最大限度减小以下三种可变因素：</p><p>（1）关键资源的数量。</p><p>（2）关键路径长度。</p><p>（3）关键字节的数量。</p><p>关键资源是可能阻止网页首次渲染的资源。这些资源越少，浏览器的工作量就越小，对 CPU 以及其他资源的占用也就越少。同样，关键路径长度受所有关键资源与其字节大小之间依赖关系图的影响：某些资源只能在上一资源处理完毕之后才能开始下载，并且资源越大，下载所需的往返次数就越多。最后，浏览器需要下载的关键字节越少，处理内容并让其出现在屏幕上的速度就越快。要减少字节数，我们可以减少资源数（将它们删除或设为非关键资源），此外还要压缩和优化各项资源，确保最大限度减小传送大小。</p><p>优化关键渲染路径的常规步骤如下：</p><p>（1）对关键路径进行分析和特性描述：资源数、字节数、长度。</p><p>（2）最大限度减少关键资源的数量：删除它们，延迟它们的下载，将它们标记为异步等。</p><p>（3）优化关键字节数以缩短下载时间（往返次数）。</p><p>（4）优化其余关键资源的加载顺序：您需要尽早下载所有关键资产，以缩短关键路径长度</p><h3 id="7-什么情况会阻塞渲染？"><a href="#7-什么情况会阻塞渲染？" class="headerlink" title="7. 什么情况会阻塞渲染？"></a>7. 什么情况会阻塞渲染？</h3><p>首先渲染的前提是生成渲染树，所以 HTML 和 CSS 肯定会阻塞渲染。如果你想渲染的越快，你越应该降低一开始需要渲染的文件大小，并且扁平层级，优化选择器。然后当浏览器在解析到 script 标签时，会暂停构建 DOM，完成后才会从暂停的地方重新开始。也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的原因。</p><p>当然在当下，并不是说 script 标签必须放在底部，因为你可以给 script 标签添加 defer 或者 async 属性。当 script 标签加上 defer 属性以后，表示该 JS 文件会并行下载，但是会放到 HTML 解析完成后顺序执行，所以对于这种情况你可以把 script 标签放在任意位置。对于没有任何依赖的 JS 文件可以加上 async 属性，表示 JS 文件下载和解析不会阻塞渲染。</p><h2 id="六、浏览器本地存储"><a href="#六、浏览器本地存储" class="headerlink" title="六、浏览器本地存储"></a>六、浏览器本地存储</h2><h3 id="1-浏览器本地存储方式及使用场景"><a href="#1-浏览器本地存储方式及使用场景" class="headerlink" title="1. 浏览器本地存储方式及使用场景"></a>1. 浏览器本地存储方式及使用场景</h3><h4 id="（1）Cookie"><a href="#（1）Cookie" class="headerlink" title="（1）Cookie"></a>（1）Cookie</h4><p>Cookie是最早被提出来的本地存储方式，在此之前，服务端是无法判断网络中的两个请求是否是同一用户发起的，为解决这个问题，Cookie就出现了。Cookie的大小只有4kb，它是一种纯文本文件，每次发起HTTP请求都会携带Cookie。</p><p><strong>Cookie的特性：</strong></p><ul><li>Cookie一旦创建成功，名称就无法修改</li><li>Cookie是无法跨域名的，也就是说a域名和b域名下的cookie是无法共享的，这也是由Cookie的隐私安全性决定的，这样就能够阻止非法获取其他网站的Cookie</li><li>每个域名下Cookie的数量不能超过20个，每个Cookie的大小不能超过4kb</li><li>有安全问题，如果Cookie被拦截了，那就可获得session的所有信息，即使加密也于事无补，无需知道cookie的意义，只要转发cookie就能达到目的</li><li>Cookie在请求一个新的页面的时候都会被发送过去</li></ul><p>如果需要域名之间跨域共享Cookie，有两种方法：</p><ol><li>使用Nginx反向代理</li><li>在一个站点登陆之后，往其他网站写Cookie。服务端的Session存储到一个节点，Cookie存储sessionId</li></ol><p><strong>Cookie的使用场景：</strong></p><ul><li>最常见的使用场景就是Cookie和session结合使用，我们将sessionId存储到Cookie中，每次发请求都会携带这个sessionId，这样服务端就知道是谁发起的请求，从而响应相应的信息。</li><li>可以用来统计页面的点击次数</li></ul><h4 id="（2）LocalStorage"><a href="#（2）LocalStorage" class="headerlink" title="（2）LocalStorage"></a>（2）LocalStorage</h4><p>LocalStorage是HTML5新引入的特性，由于有的时候我们存储的信息较大，Cookie就不能满足我们的需求，这时候LocalStorage就派上用场了。</p><p><strong>LocalStorage的优点：</strong></p><ul><li>在大小方面，LocalStorage的大小一般为5MB，可以储存更多的信息</li><li>LocalStorage是持久储存，并不会随着页面的关闭而消失，除非主动清理，不然会永久存在</li><li>仅储存在本地，不像Cookie那样每次HTTP请求都会被携带</li></ul><p><strong>LocalStorage的缺点：</strong></p><ul><li>存在浏览器兼容问题，IE8以下版本的浏览器不支持</li><li>如果浏览器设置为隐私模式，那我们将无法读取到LocalStorage</li><li>LocalStorage受到同源策略的限制，即端口、协议、主机地址有任何一个不相同，都不会访问</li></ul><p><strong>LocalStorage的常用API：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保存数据到 localStorage</span></span><br><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&#x27;key&#x27;</span>, <span class="string">&#x27;value&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 localStorage 获取数据</span></span><br><span class="line"><span class="keyword">let</span> data = <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;key&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 localStorage 删除保存的数据</span></span><br><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">removeItem</span>(<span class="string">&#x27;key&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 localStorage 删除所有保存的数据</span></span><br><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">clear</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取某个索引的Key</span></span><br><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">key</span>(index)</span><br></pre></td></tr></table></figure><p><strong>LocalStorage的使用场景：</strong></p><ul><li>有些网站有换肤的功能，这时候就可以将换肤的信息存储在本地的LocalStorage中，当需要换肤的时候，直接操作LocalStorage即可</li><li>在网站中的用户浏览信息也会存储在LocalStorage中，还有网站的一些不常变动的个人信息等也可以存储在本地的LocalStorage中</li></ul><h4 id="（3）SessionStorage"><a href="#（3）SessionStorage" class="headerlink" title="（3）SessionStorage"></a>（3）SessionStorage</h4><p>SessionStorage和LocalStorage都是在HTML5才提出来的存储方案，SessionStorage 主要用于临时保存同一窗口(或标签页)的数据，刷新页面时不会删除，关闭窗口或标签页之后将会删除这些数据。</p><p><strong>SessionStorage与LocalStorage对比：</strong></p><ul><li>SessionStorage和LocalStorage都在<strong>本地进行数据存储</strong>；</li><li>SessionStorage也有同源策略的限制，但是SessionStorage有一条更加严格的限制，SessionStorage<strong>只有在同一浏览器的同一窗口下才能够共享</strong>；</li><li>LocalStorage和SessionStorage<strong>都不能被爬虫爬取</strong>；</li></ul><p><strong>SessionStorage的常用API：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保存数据到 sessionStorage</span></span><br><span class="line">sessionStorage.<span class="title function_">setItem</span>(<span class="string">&#x27;key&#x27;</span>, <span class="string">&#x27;value&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 sessionStorage 获取数据</span></span><br><span class="line"><span class="keyword">let</span> data = sessionStorage.<span class="title function_">getItem</span>(<span class="string">&#x27;key&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 sessionStorage 删除保存的数据</span></span><br><span class="line">sessionStorage.<span class="title function_">removeItem</span>(<span class="string">&#x27;key&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 sessionStorage 删除所有保存的数据</span></span><br><span class="line">sessionStorage.<span class="title function_">clear</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取某个索引的Key</span></span><br><span class="line">sessionStorage.<span class="title function_">key</span>(index)</span><br></pre></td></tr></table></figure><p><strong>SessionStorage的使用场景</strong></p><ul><li>由于SessionStorage具有时效性，所以可以用来存储一些网站的游客登录的信息，还有临时的浏览记录的信息。当关闭网站之后，这些信息也就随之消除了。</li></ul><h3 id="2-Cookie有哪些字段，作用分别是什么"><a href="#2-Cookie有哪些字段，作用分别是什么" class="headerlink" title="2. Cookie有哪些字段，作用分别是什么"></a>2. Cookie有哪些字段，作用分别是什么</h3><p><strong>Cookie由以下字段组成：</strong></p><ul><li><strong>Name</strong>：cookie的名称</li><li><strong>Value</strong>：cookie的值，对于认证cookie，value值包括web服务器所提供的访问令牌；</li><li><strong>Size</strong>： cookie的大小</li><li><strong>Path</strong>：可以访问此cookie的页面路径。 比如domain是abc.com，path是<code>/test</code>，那么只有<code>/test</code>路径下的页面可以读取此cookie。</li><li><strong>Secure</strong>： 指定是否使用HTTPS安全协议发送Cookie。使用HTTPS安全协议，可以保护Cookie在浏览器和Web服务器间的传输过程中不被窃取和篡改。该方法也可用于Web站点的身份鉴别，即在HTTPS的连接建立阶段，浏览器会检查Web网站的SSL证书的有效性。但是基于兼容性的原因（比如有些网站使用自签署的证书）在检测到SSL证书无效时，浏览器并不会立即终止用户的连接请求，而是显示安全风险信息，用户仍可以选择继续访问该站点。</li><li><strong>Domain</strong>：可以访问该cookie的域名，Cookie 机制并未遵循严格的同源策略，允许一个子域可以设置或获取其父域的 Cookie。当需要实现单点登录方案时，Cookie 的上述特性非常有用，然而也增加了 Cookie受攻击的危险，比如攻击者可以借此发动会话定置攻击。因而，浏览器禁止在 Domain 属性中设置.org、.com 等通用顶级域名、以及在国家及地区顶级域下注册的二级域名，以减小攻击发生的范围。</li><li><strong>HTTP</strong>： 该字段包含<code>HTTPOnly</code> 属性 ，该属性用来设置cookie能否通过脚本来访问，默认为空，即可以通过脚本访问。在客户端是不能通过js代码去设置一个httpOnly类型的cookie的，这种类型的cookie只能通过服务端来设置。该属性用于防止客户端脚本通过<code>document.cookie</code>属性访问Cookie，有助于保护Cookie不被跨站脚本攻击窃取或篡改。但是，HTTPOnly的应用仍存在局限性，一些浏览器可以阻止客户端脚本对Cookie的读操作，但允许写操作；此外大多数浏览器仍允许通过XMLHTTP对象读取HTTP响应中的Set-Cookie头。</li><li><strong>Expires/Max-size</strong> ： 此cookie的超时时间。若设置其值为一个时间，那么当到达此时间后，此cookie失效。不设置的话默认值是Session，意思是cookie会和session一起失效。当浏览器关闭(不是浏览器标签页，而是整个浏览器) 后，此cookie失效。</li></ul><p><strong>总结：</strong> 服务器端可以使用 Set-Cookie 的响应头部来配置 cookie 信息。一条cookie 包括了5个属性值 expires、domain、path、secure、HttpOnly。其中 expires 指定了 cookie 失效的时间，domain 是域名、path是路径，domain 和 path 一起限制了 cookie 能够被哪些 url 访问。secure 规定了 cookie 只能在确保安全的情况下传输，HttpOnly 规定了这个 cookie 只能被服务器访问，不能使用 js 脚本访问。</p><h3 id="3-Cookie、LocalStorage、SessionStorage区别"><a href="#3-Cookie、LocalStorage、SessionStorage区别" class="headerlink" title="3. Cookie、LocalStorage、SessionStorage区别"></a>3. Cookie、LocalStorage、SessionStorage区别</h3><p>浏览器端常用的存储技术是 cookie 、localStorage 和 sessionStorage。</p><ul><li><strong>cookie：</strong> 其实最开始是服务器端用于记录用户状态的一种方式，由服务器设置，在客户端存储，然后每次发起同源请求时，发送给服务器端。cookie 最多能存储 4 k 数据，它的生存时间由 expires 属性指定，并且 cookie 只能被同源的页面访问共享。</li><li><strong>sessionStorage：</strong> html5 提供的一种浏览器本地存储的方法，它借鉴了服务器端 session 的概念，代表的是一次会话中所保存的数据。它一般能够存储 5M 或者更大的数据，它在当前窗口关闭后就失效了，并且 sessionStorage 只能被同一个窗口的同源页面所访问共享。</li><li><strong>localStorage：</strong> html5 提供的一种浏览器本地存储的方法，它一般也能够存储 5M 或者更大的数据。它和 sessionStorage 不同的是，除非手动删除它，否则它不会失效，并且 localStorage 也只能被同源页面所访问共享。</li></ul><p>上面几种方式都是存储少量数据的时候的存储方式，当需要在本地存储大量数据的时候，我们可以使用浏览器的 indexDB 这是浏览器提供的一种本地的数据库存储机制。它不是关系型数据库，它内部采用对象仓库的形式存储数据，它更接近 NoSQL 数据库。</p><h3 id="4-前端储存的⽅式有哪些？"><a href="#4-前端储存的⽅式有哪些？" class="headerlink" title="4. 前端储存的⽅式有哪些？"></a>4. 前端储存的⽅式有哪些？</h3><ul><li>cookies： 在HTML5标准前本地储存的主要⽅式，优点是兼容性好，请求头⾃带cookie⽅便，缺点是⼤⼩只有4k，⾃动请求头加⼊cookie浪费流量，每个domain限制20个cookie，使⽤起来麻烦，需要⾃⾏封装；</li><li>localStorage：HTML5加⼊的以键值对(Key-Value)为标准的⽅式，优点是操作⽅便，永久性储存（除⾮⼿动删除），⼤⼩为5M，兼容IE8+ ；</li><li>sessionStorage：与localStorage基本类似，区别是sessionStorage当⻚⾯关闭后会被清理，⽽且与cookie、localStorage不同，他不能在所有同源窗⼝中共享，是会话级别的储存⽅式；</li><li>Web SQL：2010年被W3C废弃的本地数据库数据存储⽅案，但是主流浏览器（⽕狐除外）都已经有了相关的实现，web sql类似于SQLite，是真正意义上的关系型数据库，⽤sql进⾏操作，当我们⽤JavaScript时要进⾏转换，较为繁琐；</li><li>IndexedDB： 是被正式纳⼊HTML5标准的数据库储存⽅案，它是NoSQL数据库，⽤键值对进⾏储存，可以进⾏快速读取操作，⾮常适合web场景，同时⽤JavaScript进⾏操作会⾮常便。</li></ul><h3 id="5-IndexedDB有哪些特点？"><a href="#5-IndexedDB有哪些特点？" class="headerlink" title="5. IndexedDB有哪些特点？"></a>5. IndexedDB有哪些特点？</h3><p>IndexedDB 具有以下特点：</p><ul><li><strong>键值对储存</strong>：IndexedDB 内部采用对象仓库（object store）存放数据。所有类型的数据都可以直接存入，包括 JavaScript 对象。对象仓库中，数据以”键值对”的形式保存，每一个数据记录都有对应的主键，主键是独一无二的，不能有重复，否则会抛出一个错误。</li><li><strong>异步</strong>：IndexedDB 操作时不会锁死浏览器，用户依然可以进行其他操作，这与 LocalStorage 形成对比，后者的操作是同步的。异步设计是为了防止大量数据的读写，拖慢网页的表现。</li><li><strong>支持事务</strong>：IndexedDB 支持事务（transaction），这意味着一系列操作步骤之中，只要有一步失败，整个事务就都取消，数据库回滚到事务发生之前的状态，不存在只改写一部分数据的情况。</li><li><strong>同源限制：</strong> IndexedDB 受到同源限制，每一个数据库对应创建它的域名。网页只能访问自身域名下的数据库，而不能访问跨域的数据库。</li><li><strong>储存空间大</strong>：IndexedDB 的储存空间比 LocalStorage 大得多，一般来说不少于 250MB，甚至没有上限。</li><li><strong>支持二进制储存</strong>：IndexedDB 不仅可以储存字符串，还可以储存二进制数据（ArrayBuffer 对象和 Blob 对象）。</li></ul><h2 id="七、浏览器同源策略"><a href="#七、浏览器同源策略" class="headerlink" title="七、浏览器同源策略"></a>七、浏览器同源策略</h2><h3 id="1-什么是同源策略"><a href="#1-什么是同源策略" class="headerlink" title="1. 什么是同源策略"></a>1. 什么是同源策略</h3><p>跨域问题其实就是浏览器的同源策略造成的。</p><blockquote><p>同源策略限制了从同一个源加载的文档或脚本如何与另一个源的资源进行交互。这是浏览器的一个用于隔离潜在恶意文件的重要的安全机制。同源指的是：<strong>协议</strong>、<strong>端口号</strong>、<strong>域名</strong>必须一致。</p></blockquote><p>下表给出了与 URL <a href="https://link.juejin.cn/?target=http://store.company.com/dir/page.html">store.company.com/dir/page.ht…</a> 的源进行对比的示例:</p><table><thead><tr><th>URL</th><th>是否跨域</th><th>原因</th></tr></thead><tbody><tr><td><a href="https://link.juejin.cn/?target=http://store.company.com/dir/page.html">store.company.com/dir/page.ht…</a></td><td>同源</td><td>完全相同</td></tr><tr><td><a href="https://link.juejin.cn/?target=http://store.company.com/dir/inner/another.html">store.company.com/dir/inner/a…</a></td><td>同源</td><td>只有路径不同</td></tr><tr><td><a href="https://link.juejin.cn/?target=https://store.company.com/secure.html">store.company.com/secure.html</a></td><td>跨域</td><td>协议不同</td></tr><tr><td><a href="https://link.juejin.cn/?target=http://store.company.com:81/dir/etc.html">store.company.com:81/dir/etc.htm…</a></td><td>跨域</td><td>端口不同 ( http:// 默认端口是80)</td></tr><tr><td><a href="https://link.juejin.cn/?target=http://news.company.com/dir/other.html">news.company.com/dir/other.h…</a></td><td>跨域</td><td>主机不同</td></tr></tbody></table><p><strong>同源策略：protocol（协议）、domain（域名）、port（端口）三者必须一致。</strong></p><p><strong>同源政策主要限制了三个方面：</strong></p><ul><li>当前域下的 js 脚本不能够访问其他域下的 cookie、localStorage 和 indexDB。</li><li>当前域下的 js 脚本不能够操作访问操作其他域下的 DOM。</li><li>当前域下 ajax 无法发送跨域请求。</li></ul><p>同源政策的目的主要是为了保证用户的信息安全，它只是对 js 脚本的一种限制，并不是对浏览器的限制，对于一般的 img、或者script 脚本请求都不会有跨域的限制，这是因为这些操作都不会通过响应结果来进行可能出现安全问题的操作。</p><h3 id="2-如何解决跨越问题"><a href="#2-如何解决跨越问题" class="headerlink" title="2. 如何解决跨越问题"></a>2. 如何解决跨越问题</h3><h4 id="（1）CORS"><a href="#（1）CORS" class="headerlink" title="（1）CORS"></a>（1）CORS</h4><p>下面是MDN对于CORS的定义：</p><blockquote><p>跨域资源共享(CORS) 是一种机制，它使用额外的 HTTP 头来告诉浏览器  让运行在一个 origin (domain)上的Web应用被准许访问来自不同源服务器上的指定的资源。当一个资源从与该资源本身所在的服务器不同的域、协议或端口请求一个资源时，资源会发起一个跨域HTTP 请求。</p></blockquote><p>CORS需要浏览器和服务器同时支持，整个CORS过程都是浏览器完成的，无需用户参与。因此实现<strong>CORS的关键就是服务器，只要服务器实现了CORS请求</strong>，就可以跨源通信了。</p><p>浏览器将CORS分为<strong>简单请求</strong>和<strong>非简单请求</strong>：</p><p>简单请求不会触发CORS预检请求。若该请求满足以下两个条件，就可以看作是简单请求：</p><p><strong>1）请求方法是以下三种方法之一：</strong></p><ul><li>HEAD</li><li>GET</li><li>POST</li></ul><p><strong>2）HTTP的头信息不超出以下几种字段：</strong></p><ul><li>Accept</li><li>Accept-Language</li><li>Content-Language</li><li>Last-Event-ID</li><li>Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain</li></ul><p>若不满足以上条件，就属于非简单请求了。</p><p><strong>（1）简单请求过程：</strong></p><p>对于简单请求，浏览器会直接发出CORS请求，它会在请求的头信息中增加一个Orign字段，该字段用来说明本次请求来自哪个源（协议+端口+域名），服务器会根据这个值来决定是否同意这次请求。如果Orign指定的域名在许可范围之内，服务器返回的响应就会多出以下信息头：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Allow</span>-<span class="title class_">Origin</span>: <span class="attr">http</span>:<span class="comment">//api.bob.com  // 和Orign一直</span></span><br><span class="line"><span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Allow</span>-<span class="title class_">Credentials</span>: <span class="literal">true</span>   <span class="comment">// 表示是否允许发送Cookie</span></span><br><span class="line"><span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Expose</span>-<span class="title class_">Headers</span>: <span class="title class_">FooBar</span>   <span class="comment">// 指定返回其他字段的值</span></span><br><span class="line"><span class="title class_">Content</span>-<span class="title class_">Type</span>: text/html; charset=utf-<span class="number">8</span>   <span class="comment">// 表示文档类型</span></span><br></pre></td></tr></table></figure><p>如果Orign指定的域名不在许可范围之内，服务器会返回一个正常的HTTP回应，浏览器发现没有上面的Access-Control-Allow-Origin头部信息，就知道出错了。这个错误无法通过状态码识别，因为返回的状态码可能是200。</p><p><strong>在简单请求中，在服务器内，至少需要设置字段：</strong><code>Access-Control-Allow-Origin</code></p><p><strong>（2）非简单请求过程</strong></p><p>非简单请求是对服务器有特殊要求的请求，比如请求方法为DELETE或者PUT等。非简单请求的CORS请求会在正式通信之前进行一次HTTP查询请求，<strong>称为预检请求</strong>。</p><p>浏览器会询问服务器，当前所在的网页是否在服务器允许访问的范围内，以及可以使用哪些HTTP请求方式和头信息字段，只有得到肯定的回复，才会进行正式的HTTP请求，否则就会报错。</p><p>预检请求使用的<strong>请求方法是OPTIONS</strong>，表示这个请求是来询问的。他的头信息中的关键字段是Orign，表示请求来自哪个源。除此之外，头信息中还包括两个字段：</p><ul><li><strong>Access-Control-Request-Method</strong>：该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法。</li><li><strong>Access-Control-Request-Headers</strong>： 该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段。</li></ul><p>服务器在收到浏览器的预检请求之后，会根据头信息的三个字段来进行判断，如果返回的头信息在中有Access-Control-Allow-Origin这个字段就是允许跨域请求，如果没有，就是不同意这个预检请求，就会报错。</p><p>服务器回应的CORS的字段如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Allow</span>-<span class="title class_">Origin</span>: <span class="attr">http</span>:<span class="comment">//api.bob.com  // 允许跨域的源地址</span></span><br><span class="line"><span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Allow</span>-<span class="title class_">Methods</span>: <span class="variable constant_">GET</span>, <span class="variable constant_">POST</span>, <span class="variable constant_">PUT</span> <span class="comment">// 服务器支持的所有跨域请求的方法</span></span><br><span class="line"><span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Allow</span>-<span class="title class_">Headers</span>: X-<span class="title class_">Custom</span>-<span class="title class_">Header</span>  <span class="comment">// 服务器支持的所有头信息字段</span></span><br><span class="line"><span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Allow</span>-<span class="title class_">Credentials</span>: <span class="literal">true</span>   <span class="comment">// 表示是否允许发送Cookie</span></span><br><span class="line"><span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Max</span>-<span class="title class_">Age</span>: <span class="number">1728000</span>  <span class="comment">// 用来指定本次预检请求的有效期，单位为秒</span></span><br></pre></td></tr></table></figure><p>只要服务器通过了预检请求，在以后每次的CORS请求都会自带一个Origin头信息字段。服务器的回应，也都会有一个Access-Control-Allow-Origin头信息字段。</p><p><strong>在非简单请求中，至少需要设置以下字段：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>  </span><br><span class="line"><span class="string">&#x27;Access-Control-Allow-Methods&#x27;</span></span><br><span class="line"><span class="string">&#x27;Access-Control-Allow-Headers&#x27;</span></span><br></pre></td></tr></table></figure><h5 id="减少OPTIONS请求次数："><a href="#减少OPTIONS请求次数：" class="headerlink" title="减少OPTIONS请求次数："></a>减少OPTIONS请求次数：</h5><p>OPTIONS请求次数过多就会损耗页面加载的性能，降低用户体验度。所以尽量要减少OPTIONS请求次数，可以后端在请求的返回头部添加：Access-Control-Max-Age：number。它表示预检请求的返回结果可以被缓存多久，单位是秒。该字段只对完全一样的URL的缓存设置生效，所以设置了缓存时间，在这个时间范围内，再次发送请求就不需要进行预检请求了。</p><h5 id="CORS中Cookie相关问题："><a href="#CORS中Cookie相关问题：" class="headerlink" title="CORS中Cookie相关问题："></a>CORS中Cookie相关问题：</h5><p>在CORS请求中，如果想要传递Cookie，就要满足以下三个条件：</p><ul><li>在请求中设置 <code>withCredentials</code></li></ul><p>默认情况下在跨域请求，浏览器是不带 cookie 的。但是我们可以通过设置 withCredentials 来进行传递 cookie.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原生 xml 的设置方式</span></span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xhr.<span class="property">withCredentials</span> = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// axios 设置方式</span></span><br><span class="line">axios.<span class="property">defaults</span>.<span class="property">withCredentials</span> = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><ul><li>Access-Control-Allow-Credentials 设置为 true</li><li>Access-Control-Allow-Origin 设置为非 <code>*</code></li></ul><h4 id="（2）JSONP"><a href="#（2）JSONP" class="headerlink" title="（2）JSONP"></a>（2）JSONP</h4><p><strong>jsonp</strong>的原理就是利用<code>&lt;script&gt;</code>标签没有跨域限制，通过<code>&lt;script&gt;</code>标签src属性，发送带有callback参数的GET请求，服务端将接口返回数据拼凑到callback函数中，返回给浏览器，浏览器解析执行，从而前端拿到callback函数返回的数据。 1）原生JS实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">    script.<span class="property">type</span> = <span class="string">&#x27;text/javascript&#x27;</span>;</span><br><span class="line">    <span class="comment">// 传参一个回调函数名给后端，方便后端返回时执行这个在前端定义的回调函数</span></span><br><span class="line">    script.<span class="property">src</span> = <span class="string">&#x27;http://www.domain2.com:8080/login?user=admin&amp;callback=handleCallback&#x27;</span>;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">head</span>.<span class="title function_">appendChild</span>(script);</span><br><span class="line">    <span class="comment">// 回调执行函数</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">handleCallback</span>(<span class="params">res</span>) &#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(res));</span><br><span class="line">    &#125;</span><br><span class="line"> &lt;/script&gt;</span><br></pre></td></tr></table></figure><p>服务端返回如下（返回时即执行全局函数）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">handleCallback</span>(&#123;<span class="string">&quot;success&quot;</span>: <span class="literal">true</span>, <span class="string">&quot;user&quot;</span>: <span class="string">&quot;admin&quot;</span>&#125;)</span><br></pre></td></tr></table></figure><p>2）Vue axios实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">$http</span> = axios;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$http</span>.<span class="title function_">jsonp</span>(<span class="string">&#x27;http://www.domain2.com:8080/login&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">params</span>: &#123;&#125;,</span><br><span class="line">    <span class="attr">jsonp</span>: <span class="string">&#x27;handleCallback&#x27;</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res); </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>后端node.js代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> querystring = <span class="built_in">require</span>(<span class="string">&#x27;querystring&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> server = http.<span class="title function_">createServer</span>();</span><br><span class="line">server.<span class="title function_">on</span>(<span class="string">&#x27;request&#x27;</span>, <span class="keyword">function</span>(<span class="params">req, res</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> params = querystring.<span class="title function_">parse</span>(req.<span class="property">url</span>.<span class="title function_">split</span>(<span class="string">&#x27;?&#x27;</span>)[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">var</span> fn = params.<span class="property">callback</span>;</span><br><span class="line">    <span class="comment">// jsonp返回设置</span></span><br><span class="line">    res.<span class="title function_">writeHead</span>(<span class="number">200</span>, &#123; <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;text/javascript&#x27;</span> &#125;);</span><br><span class="line">    res.<span class="title function_">write</span>(fn + <span class="string">&#x27;(&#x27;</span> + <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(params) + <span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">    res.<span class="title function_">end</span>();</span><br><span class="line">&#125;);</span><br><span class="line">server.<span class="title function_">listen</span>(<span class="string">&#x27;8080&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Server is running at port 8080...&#x27;</span>);</span><br></pre></td></tr></table></figure><p><strong>JSONP的缺点：</strong></p><ul><li>具有局限性， 仅支持get方法</li><li>不安全，可能会遭受XSS攻击</li></ul><h4 id="（3）postMessage-跨域"><a href="#（3）postMessage-跨域" class="headerlink" title="（3）postMessage 跨域"></a>（3）postMessage 跨域</h4><p>postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题：</p><ul><li>页面和其打开的新窗口的数据传递</li><li>多窗口之间消息传递</li><li>页面与嵌套的iframe消息传递</li><li>上面三个场景的跨域数据传递</li></ul><p>用法：postMessage(data,origin)方法接受两个参数：</p><ul><li><strong>data</strong>： html5规范支持任意基本类型或可复制的对象，但部分浏览器只支持字符串，所以传参时最好用JSON.stringify()序列化。</li><li><strong>origin</strong>： 协议+主机+端口号，也可以设置为”*”，表示可以传递给任意窗口，如果要指定和当前窗口同源的话设置为”/“。</li></ul><p>1）a.html：(domain1.com/a.html)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe id=<span class="string">&quot;iframe&quot;</span> src=<span class="string">&quot;http://www.domain2.com/b.html&quot;</span> style=<span class="string">&quot;display:none;&quot;</span>&gt;&lt;/iframe&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript">       </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">var</span> iframe = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;iframe&#x27;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    iframe.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">var</span> data = &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="attr">name</span>: <span class="string">&#x27;aym&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="comment">// 向domain2传送跨域数据</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        iframe.<span class="property">contentWindow</span>.<span class="title function_">postMessage</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(data), <span class="string">&#x27;http://www.domain2.com&#x27;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// 接受domain2返回数据</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;message&#x27;</span>, <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="title function_">alert</span>(<span class="string">&#x27;data from domain2 ---&gt; &#x27;</span> + e.<span class="property">data</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;, <span class="literal">false</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>2）b.html：(domain2.com/b.html)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="comment">// 接收domain1的数据</span></span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;message&#x27;</span>, <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">&#x27;data from domain1 ---&gt; &#x27;</span> + e.<span class="property">data</span>);</span><br><span class="line">        <span class="keyword">var</span> data = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(e.<span class="property">data</span>);</span><br><span class="line">        <span class="keyword">if</span> (data) &#123;</span><br><span class="line">            data.<span class="property">number</span> = <span class="number">16</span>;</span><br><span class="line">            <span class="comment">// 处理后再发回domain1</span></span><br><span class="line">            <span class="variable language_">window</span>.<span class="property">parent</span>.<span class="title function_">postMessage</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(data), <span class="string">&#x27;http://www.domain1.com&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="literal">false</span>);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="（4）nginx代理跨域"><a href="#（4）nginx代理跨域" class="headerlink" title="（4）nginx代理跨域"></a>（4）nginx代理跨域</h4><p>nginx代理跨域，实质和CORS跨域原理一样，通过配置文件设置请求响应头Access-Control-Allow-Origin…等字段。</p><p>1）nginx配置解决iconfont跨域 浏览器跨域访问js、css、img等常规静态资源被同源策略许可，但iconfont字体文件(eot|otf|ttf|woff|svg)例外，此时可在nginx的静态资源服务器中加入以下配置。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">  add_header Access-Control-Allow-Origin *;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2）nginx反向代理接口跨域 跨域问题：同源策略仅是针对浏览器的安全策略。服务器端调用HTTP接口只是使用HTTP协议，不需要同源策略，也就不存在跨域问题。 实现思路：通过Nginx配置一个代理服务器域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域访问。</p><p>nginx具体配置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#proxy服务器</span><br><span class="line">server &#123;</span><br><span class="line">    listen       <span class="number">81</span>;</span><br><span class="line">    server_name  www.<span class="property">domain1</span>.<span class="property">com</span>;</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass   <span class="attr">http</span>:<span class="comment">//www.domain2.com:8080;  #反向代理</span></span><br><span class="line">        proxy_cookie_domain www.<span class="property">domain2</span>.<span class="property">com</span> www.<span class="property">domain1</span>.<span class="property">com</span>; #修改cookie里域名</span><br><span class="line">        index  index.<span class="property">html</span> index.<span class="property">htm</span>;</span><br><span class="line">        # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用</span><br><span class="line">        add_header <span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Allow</span>-<span class="title class_">Origin</span> <span class="attr">http</span>:<span class="comment">//www.domain1.com;  #当前端只跨域不带cookie时，可为*</span></span><br><span class="line">        add_header <span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Allow</span>-<span class="title class_">Credentials</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="（5）nodejs-中间件代理跨域"><a href="#（5）nodejs-中间件代理跨域" class="headerlink" title="（5）nodejs 中间件代理跨域"></a>（5）nodejs 中间件代理跨域</h4><p>node中间件实现跨域代理，原理大致与nginx相同，都是通过启一个代理服务器，实现数据的转发，也可以通过设置cookieDomainRewrite参数修改响应头中cookie中域名，实现当前域的cookie写入，方便接口登录认证。</p><p><strong>1）非vue框架的跨域</strong> 使用node + express + http-proxy-middleware搭建一个proxy服务器。</p><ul><li>前端代码：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line"><span class="comment">// 前端开关：浏览器是否读写cookie</span></span><br><span class="line">xhr.<span class="property">withCredentials</span> = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// 访问http-proxy-middleware代理服务器</span></span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;get&#x27;</span>, <span class="string">&#x27;http://www.domain1.com:3000/login?user=admin&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.<span class="title function_">send</span>();</span><br></pre></td></tr></table></figure><ul><li>中间件服务器代码：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> proxy = <span class="built_in">require</span>(<span class="string">&#x27;http-proxy-middleware&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> app = <span class="title function_">express</span>();</span><br><span class="line">app.<span class="title function_">use</span>(<span class="string">&#x27;/&#x27;</span>, <span class="title function_">proxy</span>(&#123;</span><br><span class="line">    <span class="comment">// 代理跨域目标接口</span></span><br><span class="line">    <span class="attr">target</span>: <span class="string">&#x27;http://www.domain2.com:8080&#x27;</span>,</span><br><span class="line">    <span class="attr">changeOrigin</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 修改响应头信息，实现跨域并允许带cookie</span></span><br><span class="line">    <span class="attr">onProxyRes</span>: <span class="keyword">function</span>(<span class="params">proxyRes, req, res</span>) &#123;</span><br><span class="line">        res.<span class="title function_">header</span>(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="string">&#x27;http://www.domain1.com&#x27;</span>);</span><br><span class="line">        res.<span class="title function_">header</span>(<span class="string">&#x27;Access-Control-Allow-Credentials&#x27;</span>, <span class="string">&#x27;true&#x27;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 修改响应信息中的cookie域名</span></span><br><span class="line">    <span class="attr">cookieDomainRewrite</span>: <span class="string">&#x27;www.domain1.com&#x27;</span>  <span class="comment">// 可以为false，表示不修改</span></span><br><span class="line">&#125;));</span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3000</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Proxy server is listen at port 3000...&#x27;</span>);</span><br></pre></td></tr></table></figure><p><strong>2）vue框架的跨域</strong></p><p>node + vue + webpack + webpack-dev-server搭建的项目，跨域请求接口，直接修改webpack.config.js配置。开发环境下，vue渲染服务和接口代理服务都是webpack-dev-server同一个，所以页面与代理接口之间不再跨域。</p><p>webpack.config.js部分配置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">entry</span>: &#123;&#125;,</span><br><span class="line">    <span class="attr">module</span>: &#123;&#125;,</span><br><span class="line">    ...</span><br><span class="line">    <span class="attr">devServer</span>: &#123;</span><br><span class="line">        <span class="attr">historyApiFallback</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">proxy</span>: [&#123;</span><br><span class="line">            <span class="attr">context</span>: <span class="string">&#x27;/login&#x27;</span>,</span><br><span class="line">            <span class="attr">target</span>: <span class="string">&#x27;http://www.domain2.com:8080&#x27;</span>,  <span class="comment">// 代理跨域目标接口</span></span><br><span class="line">            <span class="attr">changeOrigin</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">secure</span>: <span class="literal">false</span>,  <span class="comment">// 当代理某些https服务报错时用</span></span><br><span class="line">            <span class="attr">cookieDomainRewrite</span>: <span class="string">&#x27;www.domain1.com&#x27;</span>  <span class="comment">// 可以为false，表示不修改</span></span><br><span class="line">        &#125;],</span><br><span class="line">        <span class="attr">noInfo</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="（6）document-domain-iframe跨域"><a href="#（6）document-domain-iframe跨域" class="headerlink" title="（6）document.domain + iframe跨域"></a>（6）document.domain + iframe跨域</h4><p>此方案仅限主域相同，子域不同的跨域应用场景。实现原理：两个页面都通过js强制设置document.domain为基础主域，就实现了同域。 1）父窗口：(domain.com/a.html)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe id=<span class="string">&quot;iframe&quot;</span> src=<span class="string">&quot;http://child.domain.com/b.html&quot;</span>&gt;&lt;/iframe&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">document</span>.<span class="property">domain</span> = <span class="string">&#x27;domain.com&#x27;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">var</span> user = <span class="string">&#x27;admin&#x27;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>1）子窗口：(child.domain.com/a.html)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">domain</span> = <span class="string">&#x27;domain.com&#x27;</span>;</span><br><span class="line">    <span class="comment">// 获取父窗口中变量</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;get js data from parent ---&gt; &#x27;</span> + <span class="variable language_">window</span>.<span class="property">parent</span>.<span class="property">user</span>);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="（7）location-hash-iframe跨域"><a href="#（7）location-hash-iframe跨域" class="headerlink" title="（7）location.hash + iframe跨域"></a>（7）location.hash + iframe跨域</h4><p>实现原理：a欲与b跨域相互通信，通过中间页c来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。</p><p>具体实现：A域：a.html -&gt; B域：b.html -&gt; A域：c.html，a与b不同域只能通过hash值单向通信，b与c也不同域也只能单向通信，但c与a同域，所以c可通过parent.parent访问a页面所有对象。</p><p>1）a.html：(domain1.com/a.html)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe id=<span class="string">&quot;iframe&quot;</span> src=<span class="string">&quot;http://www.domain2.com/b.html&quot;</span> style=<span class="string">&quot;display:none;&quot;</span>&gt;&lt;/iframe&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">var</span> iframe = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;iframe&#x27;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// 向b.html传hash值</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        iframe.<span class="property">src</span> = iframe.<span class="property">src</span> + <span class="string">&#x27;#user=admin&#x27;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;, <span class="number">1000</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// 开放给同域c.html的回调方法</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">function</span> <span class="title function_">onCallback</span>(<span class="params">res</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="title function_">alert</span>(<span class="string">&#x27;data from c.html ---&gt; &#x27;</span> + res);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>2）b.html：(.domain2.com/b.html)</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe <span class="attr">id</span>=<span class="string">&quot;iframe&quot;</span> src=<span class="string">&quot;http://www.domain1.com/c.html&quot;</span> style=<span class="string">&quot;display:none;&quot;</span>&gt;&lt;/iframe&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var <span class="attr">iframe</span> = document.getElementById(<span class="string">&#x27;iframe&#x27;</span>)<span class="comment">;</span></span><br><span class="line">    // 监听a.html传来的hash值，再传给c.html</span><br><span class="line">    <span class="attr">window.onhashchange</span> = function () &#123;</span><br><span class="line">        <span class="attr">iframe.src</span> = iframe.src + location.hash<span class="comment">;</span></span><br><span class="line">    &#125;<span class="comment">;</span></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>3）c.html：(<a href="https://link.juejin.cn/?target=https://link.zhihu.com/?target=http://www.domain1.com/c.html">www.domain1.com/c.html</a>)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="comment">// 监听b.html传来的hash值</span></span><br><span class="line">    <span class="variable language_">window</span>.<span class="property">onhashchange</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// 再通过操作同域a.html的js回调，将结果传回</span></span><br><span class="line">        <span class="variable language_">window</span>.<span class="property">parent</span>.<span class="property">parent</span>.<span class="title function_">onCallback</span>(<span class="string">&#x27;hello: &#x27;</span> + location.<span class="property">hash</span>.<span class="title function_">replace</span>(<span class="string">&#x27;#user=&#x27;</span>, <span class="string">&#x27;&#x27;</span>));</span><br><span class="line">    &#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="（8）window-name-iframe跨域"><a href="#（8）window-name-iframe跨域" class="headerlink" title="（8）window.name + iframe跨域"></a>（8）window.name + iframe跨域</h4><p>window.name属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。</p><p>1）a.html：(domain1.com/a.html)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">function</span>(<span class="params">url, callback</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> state = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> iframe = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;iframe&#x27;</span>);</span><br><span class="line">    <span class="comment">// 加载跨域页面</span></span><br><span class="line">    iframe.<span class="property">src</span> = url;</span><br><span class="line">    <span class="comment">// onload事件会触发2次，第1次加载跨域页，并留存数据于window.name</span></span><br><span class="line">    iframe.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (state === <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 第2次onload(同域proxy页)成功后，读取同域window.name中数据</span></span><br><span class="line">            <span class="title function_">callback</span>(iframe.<span class="property">contentWindow</span>.<span class="property">name</span>);</span><br><span class="line">            <span class="title function_">destoryFrame</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state === <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 第1次onload(跨域页)成功后，切换到同域代理页面</span></span><br><span class="line">            iframe.<span class="property">contentWindow</span>.<span class="property">location</span> = <span class="string">&#x27;http://www.domain1.com/proxy.html&#x27;</span>;</span><br><span class="line">            state = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(iframe);</span><br><span class="line">    <span class="comment">// 获取数据以后销毁这个iframe，释放内存；这也保证了安全（不被其他域frame js访问）</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">destoryFrame</span>(<span class="params"></span>) &#123;</span><br><span class="line">        iframe.<span class="property">contentWindow</span>.<span class="property">document</span>.<span class="title function_">write</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">        iframe.<span class="property">contentWindow</span>.<span class="title function_">close</span>();</span><br><span class="line">        <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">removeChild</span>(iframe);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 请求跨域b页面数据</span></span><br><span class="line"><span class="title function_">proxy</span>(<span class="string">&#x27;http://www.domain2.com/b.html&#x27;</span>, <span class="keyword">function</span>(<span class="params">data</span>)&#123;</span><br><span class="line">    <span class="title function_">alert</span>(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>2）proxy.html：(domain1.com/proxy.html)</p><p>中间代理页，与a.html同域，内容为空即可。 3）b.html：(domain2.com/b.html)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;    </span><br><span class="line">    <span class="variable language_">window</span>.<span class="property">name</span> = <span class="string">&#x27;This is domain2 data!&#x27;</span>;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。</p><h4 id="（9）WebSocket协议跨域"><a href="#（9）WebSocket协议跨域" class="headerlink" title="（9）WebSocket协议跨域"></a>（9）WebSocket协议跨域</h4><p>WebSocket protocol是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是server push技术的一种很好的实现。</p><p>原生WebSocket API使用起来不太方便，我们使用Socket.io，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。</p><p>1）前端代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;user input：&lt;input type=<span class="string">&quot;text&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcss.com/socket.io/2.2.0/socket.io.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">var</span> socket = <span class="title function_">io</span>(<span class="string">&#x27;http://www.domain2.com:8080&#x27;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="comment">// 连接成功处理</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">socket.<span class="title function_">on</span>(<span class="string">&#x27;connect&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// 监听服务端消息</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    socket.<span class="title function_">on</span>(<span class="string">&#x27;message&#x27;</span>, <span class="keyword">function</span>(<span class="params">msg</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;data from server: ---&gt; &#x27;</span> + msg); </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// 监听服务端关闭</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    socket.<span class="title function_">on</span>(<span class="string">&#x27;disconnect&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123; </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Server socket has closed.&#x27;</span>); </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;input&#x27;</span>)[<span class="number">0</span>].<span class="property">onblur</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    socket.<span class="title function_">send</span>(<span class="variable language_">this</span>.<span class="property">value</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>2）Nodejs socket后台：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> socket = <span class="built_in">require</span>(<span class="string">&#x27;socket.io&#x27;</span>);</span><br><span class="line"><span class="comment">// 启http服务</span></span><br><span class="line"><span class="keyword">var</span> server = http.<span class="title function_">createServer</span>(<span class="keyword">function</span>(<span class="params">req, res</span>) &#123;</span><br><span class="line">    res.<span class="title function_">writeHead</span>(<span class="number">200</span>, &#123;</span><br><span class="line">        <span class="string">&#x27;Content-type&#x27;</span>: <span class="string">&#x27;text/html&#x27;</span></span><br><span class="line">    &#125;);</span><br><span class="line">    res.<span class="title function_">end</span>();</span><br><span class="line">&#125;);</span><br><span class="line">server.<span class="title function_">listen</span>(<span class="string">&#x27;8080&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Server is running at port 8080...&#x27;</span>);</span><br><span class="line"><span class="comment">// 监听socket连接</span></span><br><span class="line">socket.<span class="title function_">listen</span>(server).<span class="title function_">on</span>(<span class="string">&#x27;connection&#x27;</span>, <span class="keyword">function</span>(<span class="params">client</span>) &#123;</span><br><span class="line">    <span class="comment">// 接收信息</span></span><br><span class="line">    client.<span class="title function_">on</span>(<span class="string">&#x27;message&#x27;</span>, <span class="keyword">function</span>(<span class="params">msg</span>) &#123;</span><br><span class="line">        client.<span class="title function_">send</span>(<span class="string">&#x27;hello：&#x27;</span> + msg);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;data from client: ---&gt; &#x27;</span> + msg);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 断开处理</span></span><br><span class="line">    client.<span class="title function_">on</span>(<span class="string">&#x27;disconnect&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Client socket has closed.&#x27;</span>); </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="3-正向代理和反向代理的区别"><a href="#3-正向代理和反向代理的区别" class="headerlink" title="3. 正向代理和反向代理的区别"></a>3. 正向代理和反向代理的区别</h3><ul><li><strong>正向代理：</strong></li></ul><p>客户端想获得一个服务器的数据，但是因为种种原因无法直接获取。于是客户端设置了一个代理服务器，并且指定目标服务器，之后代理服务器向目标服务器转交请求并将获得的内容发送给客户端。这样本质上起到了对真实服务器隐藏真实客户端的目的。实现正向代理需要修改客户端，比如修改浏览器配置。</p><ul><li><strong>反向代理：</strong></li></ul><p>服务器为了能够将工作负载分不到多个服务器来提高网站性能 (负载均衡)等目的，当其受到请求后，会首先根据转发规则来确定请求应该被转发到哪个服务器上，然后将请求转发到对应的真实服务器上。这样本质上起到了对客户端隐藏真实服务器的作用。 一般使用反向代理后，需要通过修改 DNS 让域名解析到代理服务器 IP，这时浏览器无法察觉到真正服务器的存在，当然也就不需要修改配置了。</p><p>两者区别如图示： </p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230611144510837.png" alt="image-20230611144510837"></p><p> 正向代理和反向代理的结构是一样的，都是 client-proxy-server 的结构，它们主要的区别就在于中间这个 proxy 是哪一方设置的。在正向代理中，proxy 是 client 设置的，用来隐藏 client；而在反向代理中，proxy 是 server 设置的，用来隐藏 server。</p><h3 id="4-Nginx的概念及其工作原理"><a href="#4-Nginx的概念及其工作原理" class="headerlink" title="4. Nginx的概念及其工作原理"></a>4. Nginx的概念及其工作原理</h3><p>Nginx 是一款轻量级的 Web 服务器，也可以用于反向代理、负载平衡和 HTTP 缓存等。Nginx 使用异步事件驱动的方法来处理请求，是一款面向性能设计的 HTTP 服务器。</p><p>传统的 Web 服务器如 Apache 是 process-based 模型的，而 Nginx 是基于event-driven模型的。正是这个主要的区别带给了 Nginx 在性能上的优势。</p><p>Nginx 架构的最顶层是一个 master process，这个 master process 用于产生其他的 worker process，这一点和Apache 非常像，但是 Nginx 的 worker process 可以同时处理大量的HTTP请求，而每个 Apache process 只能处理一个。</p><h2 id="八、浏览器事件机制"><a href="#八、浏览器事件机制" class="headerlink" title="八、浏览器事件机制"></a>八、浏览器事件机制</h2><h3 id="1-事件是什么？事件模型？"><a href="#1-事件是什么？事件模型？" class="headerlink" title="1. 事件是什么？事件模型？"></a>1. 事件是什么？事件模型？</h3><p>事件是用户操作网页时发生的交互动作，比如 click/move， 事件除了用户触发的动作外，还可以是文档加载，窗口滚动和大小调整。事件被封装成一个 event 对象，包含了该事件发生时的所有相关信息（ event 的属性）以及可以对事件进行的操作（ event 的方法）。</p><p>事件是用户操作网页时发生的交互动作或者网页本身的一些操作，现代浏览器一共有三种事件模型：</p><ul><li><strong>DOM0 级事件模型</strong>，这种模型不会传播，所以没有事件流的概念，但是现在有的浏览器支持以冒泡的方式实现，它可以在网页中直接定义监听函数，也可以通过 js 属性来指定监听函数。所有浏览器都兼容这种方式。直接在dom对象上注册事件名称，就是DOM0写法。</li><li><strong>IE 事件模型</strong>，在该事件模型中，一次事件共有两个过程，事件处理阶段和事件冒泡阶段。事件处理阶段会首先执行目标元素绑定的监听事件。然后是事件冒泡阶段，冒泡指的是事件从目标元素冒泡到 document，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。这种模型通过attachEvent 来添加监听函数，可以添加多个监听函数，会按顺序依次执行。</li><li><strong>DOM2 级事件模型</strong>，在该事件模型中，一次事件共有三个过程，第一个过程是事件捕获阶段。捕获指的是事件从 document 一直向下传播到目标元素，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。后面两个阶段和 IE 事件模型的两个阶段相同。这种事件模型，事件绑定的函数是addEventListener，其中第三个参数可以指定事件是否在捕获阶段执行。</li></ul><h3 id="2-如何阻止事件冒泡"><a href="#2-如何阻止事件冒泡" class="headerlink" title="2. 如何阻止事件冒泡"></a>2. 如何阻止事件冒泡</h3><ul><li>普通浏览器使用：event.stopPropagation()</li><li>IE浏览器使用：event.cancelBubble = true;</li></ul><h3 id="3-对事件委托的理解"><a href="#3-对事件委托的理解" class="headerlink" title="3. 对事件委托的理解"></a>3. 对事件委托的理解</h3><h4 id="（1）事件委托的概念"><a href="#（1）事件委托的概念" class="headerlink" title="（1）事件委托的概念"></a>（1）事件委托的概念</h4><p>事件委托本质上是利用了<strong>浏览器事件冒泡</strong>的机制。因为事件在冒泡过程中会上传到父节点，父节点可以通过事件对象获取到目标节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件，这种方式称为事件委托（事件代理）。</p><p>使用事件委托可以不必要为每一个子元素都绑定一个监听事件，这样减少了内存上的消耗。并且使用事件代理还可以实现事件的动态绑定，比如说新增了一个子节点，并不需要单独地为它添加一个监听事件，它绑定的事件会交给父元素中的监听函数来处理。</p><h4 id="（2）事件委托的特点"><a href="#（2）事件委托的特点" class="headerlink" title="（2）事件委托的特点"></a>（2）事件委托的特点</h4><ul><li><strong>减少内存消耗</strong></li></ul><p>如果有一个列表，列表之中有大量的列表项，需要在点击列表项的时候响应一个事件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  ......</span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>item n<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果给每个列表项一一都绑定一个函数，那对于内存消耗是非常大的，效率上需要消耗很多性能。因此，比较好的方法就是把这个点击事件绑定到他的父层，也就是 ul 上，然后在执行事件时再去匹配判断目标元素，所以事件委托可以减少大量的内存消耗，节约效率。</p><ul><li><strong>动态绑定事件</strong></li></ul><p>给上述的例子中每个列表项都绑定事件，在很多时候，需要通过 AJAX 或者用户操作动态的增加或者去除列表项元素，那么在每一次改变的时候都需要重新给新增的元素绑定事件，给即将删去的元素解绑事件；如果用了事件委托就没有这种麻烦了，因为事件是绑定在父层的，和目标元素的增减是没有关系的，执行到目标元素是在真正响应执行事件函数的过程中去匹配的，所以使用事件在动态绑定事件的情况下是可以减少很多重复工作的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 来实现把 #list 下的 li 元素的事件代理委托到它的父层元素也就是 #list 上：</span></span><br><span class="line"><span class="comment">// 给父层元素绑定事件</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;list&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="comment">// 兼容性处理</span></span><br><span class="line">  <span class="keyword">var</span> event = e || <span class="variable language_">window</span>.<span class="property">event</span>;</span><br><span class="line">  <span class="keyword">var</span> target = event.<span class="property">target</span> || event.<span class="property">srcElement</span>;</span><br><span class="line">  <span class="comment">// 判断是否匹配目标元素</span></span><br><span class="line">  <span class="keyword">if</span> (target.<span class="property">nodeName</span>.<span class="property">toLocaleLowerCase</span> === <span class="string">&#x27;li&#x27;</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;the content is: &#x27;</span>, target.<span class="property">innerHTML</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在上述代码中， target 元素则是在 #list 元素之下具体被点击的元素，然后通过判断 target 的一些属性（比如：nodeName，id 等等）可以更精确地匹配到某一类 #list li 元素之上；</p><h4 id="（3）局限性"><a href="#（3）局限性" class="headerlink" title="（3）局限性"></a>（3）局限性</h4><p>当然，事件委托也是有局限的。比如 focus、blur 之类的事件没有事件冒泡机制，所以无法实现事件委托；mousemove、mouseout 这样的事件，虽然有事件冒泡，但是只能不断通过位置去计算定位，对性能消耗高，因此也是不适合于事件委托的。</p><p>当然事件委托不是只有优点，它也是有<strong>缺点</strong>的，事件委托会影响页面性能，主要影响因素有：</p><ul><li>元素中，绑定事件委托的次数；</li><li>点击的最底层元素，到绑定事件元素之间的<code>DOM</code>层数；</li></ul><p>在必须使用事件委托的地方，可以进行如下的处理：</p><ul><li>只在必须的地方，使用事件委托，比如：<code>ajax</code>的局部刷新区域</li><li>尽量的减少绑定的层级，不在<code>body</code>元素上，进行绑定</li><li>减少绑定的次数，如果可以，那么把多个事件的绑定，合并到一次事件委托中去，由这个事件委托的回调，来进行分发。</li></ul><h3 id="4-事件委托的使用场景"><a href="#4-事件委托的使用场景" class="headerlink" title="4. 事件委托的使用场景"></a>4. 事件委托的使用场景</h3><p>场景：给页面的所有的a标签添加click事件，代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (e.<span class="property">target</span>.<span class="property">nodeName</span> == <span class="string">&quot;A&quot;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>但是这些a标签可能包含一些像span、img等元素，如果点击到了这些a标签中的元素，就不会触发click事件，因为事件绑定上在a标签元素上，而触发这些内部的元素时，e.target指向的是触发click事件的元素（span、img等其他元素）。</p><p>这种情况下就可以使用事件委托来处理，将事件绑定在a标签的内部元素上，当点击它的时候，就会逐级向上查找，知道找到a标签为止，代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line"><span class="keyword">var</span> node = e.<span class="property">target</span>;</span><br><span class="line"><span class="keyword">while</span> (node.<span class="property">parentNode</span>.<span class="property">nodeName</span> != <span class="string">&quot;BODY&quot;</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (node.<span class="property">nodeName</span> == <span class="string">&quot;A&quot;</span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">node = node.<span class="property">parentNode</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><h3 id="5-同步和异步的区别"><a href="#5-同步和异步的区别" class="headerlink" title="5. 同步和异步的区别"></a>5. 同步和异步的区别</h3><ul><li><strong>同步</strong>指的是当一个进程在执行某个请求时，如果这个请求需要等待一段时间才能返回，那么这个进程会一直等待下去，直到消息返回为止再继续向下执行。</li><li><strong>异步</strong>指的是当一个进程在执行某个请求时，如果这个请求需要等待一段时间才能返回，这个时候进程会继续往下执行，不会阻塞等待消息的返回，当消息返回时系统再通知进程进行处理。</li></ul><h3 id="6-对事件循环的理解"><a href="#6-对事件循环的理解" class="headerlink" title="6. 对事件循环的理解"></a>6. 对事件循环的理解</h3><p>因为 js 是单线程运行的，在代码执行时，通过将不同函数的执行上下文压入执行栈中来保证代码的有序执行。在执行同步代码时，如果遇到异步事件，js 引擎并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务。当异步事件执行完毕后，再将异步事件对应的回调加入到一个任务队列中等待执行。任务队列可以分为宏任务队列和微任务队列，当当前执行栈中的事件执行完毕后，js 引擎首先会判断微任务队列中是否有任务可以执行，如果有就将微任务队首的事件压入栈中执行。当微任务队列中的任务都执行完成后再去执行宏任务队列中的任务。</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230611144740579.png" alt="image-20230611144740579"></p><p>Event Loop 执行顺序如下所示：</p><ul><li>首先执行同步代码，这属于宏任务</li><li>当执行完所有同步代码后，执行栈为空，查询是否有异步代码需要执行</li><li>执行所有微任务</li><li>当执行完所有微任务后，如有必要会渲染页面</li><li>然后开始下一轮 Event Loop，执行宏任务中的异步代码</li></ul><h3 id="7-宏任务和微任务分别有哪些"><a href="#7-宏任务和微任务分别有哪些" class="headerlink" title="7. 宏任务和微任务分别有哪些"></a>7. 宏任务和微任务分别有哪些</h3><ul><li>微任务包括： promise 的回调、node 中的 process.nextTick 、对 Dom 变化监听的 MutationObserver。</li><li>宏任务包括： script 脚本的执行、setTimeout ，setInterval ，setImmediate 一类的定时事件，还有如 I/O 操作、UI 渲染等。</li></ul><h3 id="8-什么是执行栈"><a href="#8-什么是执行栈" class="headerlink" title="8. 什么是执行栈"></a>8. 什么是执行栈</h3><p>可以把执行栈认为是一个存储函数调用的<strong>栈结构</strong>，遵循先进后出的原则。 <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/391e7d7e880f42d59809dbc16af5d7bf~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img"> 当开始执行 JS 代码时，根据先进后出的原则，后执行的函数会先弹出栈，可以看到，<code>foo</code> 函数后执行，当执行完毕后就从栈中弹出了。</p><p>平时在开发中，可以在报错中找到执行栈的痕迹：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;error&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">foo</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">bar</span>()</span><br></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ab3646b742d946659e4bce34d5af6751~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img"> 可以看到报错在 <code>foo</code> 函数，<code>foo</code> 函数又是在 <code>bar</code> 函数中调用的。当使用递归时，因为栈可存放的函数是有<strong>限制</strong>的，一旦存放了过多的函数且没有得到释放的话，就会出现爆栈的问题</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;  <span class="title function_">bar</span>()&#125;<span class="title function_">bar</span>()</span><br></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cac7e59102dc4c3a9efa53aecd64bf9d~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img"></p><h3 id="9-Node-中的-Event-Loop-和浏览器中的有什么区别？process-nextTick-执行顺序？"><a href="#9-Node-中的-Event-Loop-和浏览器中的有什么区别？process-nextTick-执行顺序？" class="headerlink" title="9. Node 中的 Event Loop 和浏览器中的有什么区别？process.nextTick 执行顺序？"></a>9. Node 中的 Event Loop 和浏览器中的有什么区别？process.nextTick 执行顺序？</h3><p>Node 中的 Event Loop 和浏览器中的是完全不相同的东西。</p><p>Node 的 Event Loop 分为 6 个阶段，它们会按照<strong>顺序</strong>反复运行。每当进入某一个阶段的时候，都会从对应的回调队列中取出函数去执行。当队列为空或者执行的回调函数数量到达系统设定的阈值，就会进入下一阶段。 <img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230611145205128.png" alt="image-20230611145205128"></p><p>（1）<strong>Timers（计时器阶段）</strong>：初次进入事件循环，会从计时器阶段开始。此阶段会判断是否存在过期的计时器回调（包含 setTimeout 和 setInterval），如果存在则会执行所有过期的计时器回调，执行完毕后，如果回调中触发了相应的微任务，会接着执行所有微任务，执行完微任务后再进入 Pending callbacks 阶段。</p><p>（2）<strong>Pending callbacks</strong>：执行推迟到下一个循环迭代的I / O回调（系统调用相关的回调）。</p><p>（3）<strong>Idle/Prepare</strong>：仅供内部使用。</p><p>（4）<strong>Poll（轮询阶段）</strong>：</p><ul><li>当回调队列不为空时：会执行回调，若回调中触发了相应的微任务，这里的微任务执行时机和其他地方有所不同，不会等到所有回调执行完毕后才执行，而是针对每一个回调执行完毕后，就执行相应微任务。执行完所有的回调后，变为下面的情况。</li><li>当回调队列为空时（没有回调或所有回调执行完毕）：但如果存在有计时器（setTimeout、setInterval和setImmediate）没有执行，会结束轮询阶段，进入 Check 阶段。否则会阻塞并等待任何正在执行的I/O操作完成，并马上执行相应的回调，直到所有回调执行完毕。</li></ul><p>（5）<strong>Check（查询阶段）</strong>：会检查是否存在 setImmediate 相关的回调，如果存在则执行所有回调，执行完毕后，如果回调中触发了相应的微任务，会接着执行所有微任务，执行完微任务后再进入 Close callbacks 阶段。</p><p>（6）<strong>Close callbacks</strong>：执行一些关闭回调，比如socket.on(‘close’, …)等。</p><p>下面来看一个例子，首先在有些情况下，定时器的执行顺序其实是<strong>随机</strong>的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;setTimeout&#x27;</span>)&#125;, <span class="number">0</span>)<span class="title function_">setImmediate</span>(<span class="function">() =&gt;</span> &#123;    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;setImmediate&#x27;</span>)&#125;)</span><br></pre></td></tr></table></figure><p>对于以上代码来说，<code>setTimeout</code> 可能执行在前，也可能执行在后</p><ul><li>首先 <code>setTimeout(fn, 0) === setTimeout(fn, 1)</code>，这是由源码决定的</li><li>进入事件循环也是需要成本的，如果在准备时候花费了大于 1ms 的时间，那么在 timer 阶段就会直接执行 <code>setTimeout</code> 回调</li><li>那么如果准备时间花费小于 1ms，那么就是 <code>setImmediate</code> 回调先执行了</li></ul><p>当然在某些情况下，他们的执行顺序一定是固定的，比如以下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line">fs.<span class="title function_">readFile</span>(__filename, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timeout&#x27;</span>);</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">    <span class="title function_">setImmediate</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;immediate&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在上述代码中，<code>setImmediate</code> 永远<strong>先执行</strong>。因为两个代码写在 IO 回调中，IO 回调是在 poll 阶段执行，当回调执行完毕后队列为空，发现存在 <code>setImmediate</code> 回调，所以就直接跳转到 check 阶段去执行回调了。</p><p>上面都是 macrotask 的执行情况，对于 microtask 来说，它会在以上每个阶段完成前<strong>清空</strong> microtask 队列，下图中的 Tick 就代表了 microtask <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8ea27044a0124facaab3e4a8da89d709~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timer21&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise1&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>对于以上代码来说，其实和浏览器中的输出是一样的，microtask 永远执行在 macrotask 前面。</p><p>最后来看 Node 中的 <code>process.nextTick</code>，这个函数其实是独立于 Event Loop 之外的，它有一个自己的队列，当每个阶段完成后，如果存在 nextTick 队列，就会<strong>清空队列中的所有回调函数</strong>，并且优先于其他 microtask 执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timer1&#x27;</span>)</span><br><span class="line"> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise1&#x27;</span>)</span><br><span class="line"> &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line">process.<span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;nextTick&#x27;</span>)</span><br><span class="line"> process.<span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;nextTick&#x27;</span>)</span><br><span class="line">   process.<span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;nextTick&#x27;</span>)</span><br><span class="line">     process.<span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;nextTick&#x27;</span>)</span><br><span class="line">     &#125;)</span><br><span class="line">   &#125;)</span><br><span class="line"> &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>对于以上代码，永远都是先把 nextTick 全部打印出来。</p><h3 id="10-事件触发的过程是怎样的"><a href="#10-事件触发的过程是怎样的" class="headerlink" title="10. 事件触发的过程是怎样的"></a>10. 事件触发的过程是怎样的</h3><p>事件触发有三个阶段：</p><ul><li><code>window</code> 往事件触发处传播，遇到注册的捕获事件会触发</li><li>传播到事件触发处时触发注册的事件</li><li>从事件触发处往 <code>window</code> 传播，遇到注册的冒泡事件会触发</li></ul><p>事件触发一般来说会按照上面的顺序进行，但是也有特例，<strong>如果给一个 *<em><code>body</code>*</em> 中的子节点同时注册冒泡和捕获事件，事件触发会按照注册的顺序执行。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下会先打印冒泡然后是捕获</span></span><br><span class="line">node.<span class="title function_">addEventListener</span>(</span><br><span class="line">  <span class="string">&#x27;click&#x27;</span>,</span><br><span class="line">  <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;冒泡&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">)</span><br><span class="line">node.<span class="title function_">addEventListener</span>(</span><br><span class="line">  <span class="string">&#x27;click&#x27;</span>,</span><br><span class="line">  <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;捕获 &#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">true</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>通常使用 <code>addEventListener</code> 注册事件，该函数的第三个参数可以是布尔值，也可以是对象。对于布尔值 <code>useCapture</code> 参数来说，该参数默认值为 <code>false</code> ，<code>useCapture</code> 决定了注册的事件是捕获事件还是冒泡事件。对于对象参数来说，可以使用以下几个属性：</p><ul><li><code>capture</code>：布尔值，和 <code>useCapture</code> 作用一样</li><li><code>once</code>：布尔值，值为 <code>true</code> 表示该回调只会调用一次，调用后会移除监听</li><li><code>passive</code>：布尔值，表示永远不会调用 <code>preventDefault</code></li></ul><p>一般来说，如果只希望事件只触发在目标上，这时候可以使用 <code>stopPropagation</code> 来阻止事件的进一步传播。通常认为 <code>stopPropagation</code> 是用来阻止事件冒泡的，其实该函数也可以阻止捕获事件。</p><p><code>stopImmediatePropagation</code> 同样也能实现阻止事件，但是还能阻止该事件目标执行别的注册事件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">node.<span class="title function_">addEventListener</span>(</span><br><span class="line">  <span class="string">&#x27;click&#x27;</span>,</span><br><span class="line">  <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">    event.<span class="title function_">stopImmediatePropagation</span>()</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;冒泡&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 点击 node 只会执行上面的函数，该函数不会执行</span></span><br><span class="line">node.<span class="title function_">addEventListener</span>(</span><br><span class="line">  <span class="string">&#x27;click&#x27;</span>,</span><br><span class="line">  <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;捕获 &#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">true</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="九、浏览器垃圾回收机制"><a href="#九、浏览器垃圾回收机制" class="headerlink" title="九、浏览器垃圾回收机制"></a>九、浏览器垃圾回收机制</h2><h3 id="1-V8的垃圾回收机制是怎样的"><a href="#1-V8的垃圾回收机制是怎样的" class="headerlink" title="1. V8的垃圾回收机制是怎样的"></a>1. V8的垃圾回收机制是怎样的</h3><p>V8 实现了准确式 GC，GC 算法采用了分代式垃圾回收机制。因此，V8 将内存（堆）分为新生代和老生代两部分。</p><p><strong>（1）新生代算法</strong></p><p>新生代中的对象一般存活时间较短，使用 Scavenge GC 算法。</p><p>在新生代空间中，内存空间分为两部分，分别为 From 空间和 To 空间。在这两个空间中，必定有一个空间是使用的，另一个空间是空闲的。新分配的对象会被放入 From 空间中，当 From 空间被占满时，新生代 GC 就会启动了。算法会检查 From 空间中存活的对象并复制到 To 空间中，如果有失活的对象就会销毁。当复制完成后将 From 空间和 To 空间互换，这样 GC 就结束了。</p><p><strong>（2）老生代算法</strong></p><p>老生代中的对象一般存活时间较长且数量也多，使用了两个算法，分别是标记清除算法和标记压缩算法。</p><p>先来说下什么情况下对象会出现在老生代空间中：</p><ul><li>新生代中的对象是否已经经历过一次 Scavenge 算法，如果经历过的话，会将对象从新生代空间移到老生代空间中。</li><li>To 空间的对象占比大小超过 25 %。在这种情况下，为了不影响到内存分配，会将对象从新生代空间移到老生代空间中。</li></ul><p>老生代中的空间很复杂，有如下几个空间</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">enum <span class="title class_">AllocationSpace</span> &#123;</span><br><span class="line">  <span class="comment">// TODO(v8:7464): Actually map this space&#x27;s memory as read-only.</span></span><br><span class="line">  <span class="variable constant_">RO_SPACE</span>,    <span class="comment">// 不变的对象空间</span></span><br><span class="line">  <span class="variable constant_">NEW_SPACE</span>,   <span class="comment">// 新生代用于 GC 复制算法的空间</span></span><br><span class="line">  <span class="variable constant_">OLD_SPACE</span>,   <span class="comment">// 老生代常驻对象空间</span></span><br><span class="line">  <span class="variable constant_">CODE_SPACE</span>,  <span class="comment">// 老生代代码对象空间</span></span><br><span class="line">  <span class="variable constant_">MAP_SPACE</span>,   <span class="comment">// 老生代 map 对象</span></span><br><span class="line">  <span class="variable constant_">LO_SPACE</span>,    <span class="comment">// 老生代大空间对象</span></span><br><span class="line">  <span class="variable constant_">NEW_LO_SPACE</span>,  <span class="comment">// 新生代大空间对象</span></span><br><span class="line">  <span class="variable constant_">FIRST_SPACE</span> = <span class="variable constant_">RO_SPACE</span>,</span><br><span class="line">  <span class="variable constant_">LAST_SPACE</span> = <span class="variable constant_">NEW_LO_SPACE</span>,</span><br><span class="line">  <span class="variable constant_">FIRST_GROWABLE_PAGED_SPACE</span> = <span class="variable constant_">OLD_SPACE</span>,</span><br><span class="line">  <span class="variable constant_">LAST_GROWABLE_PAGED_SPACE</span> = <span class="variable constant_">MAP_SPACE</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在老生代中，以下情况会先启动标记清除算法：</p><ul><li>某一个空间没有分块的时候</li><li>空间中被对象超过一定限制</li><li>空间不能保证新生代中的对象移动到老生代中</li></ul><p>在这个阶段中，会遍历堆中所有的对象，然后标记活的对象，在标记完成后，销毁所有没有被标记的对象。在标记大型对内存时，可能需要几百毫秒才能完成一次标记。这就会导致一些性能上的问题。为了解决这个问题，2011 年，V8 从 stop-the-world 标记切换到增量标志。在增量标记期间，GC 将标记工作分解为更小的模块，可以让 JS 应用逻辑在模块间隙执行一会，从而不至于让应用出现停顿情况。但在 2018 年，GC 技术又有了一个重大突破，这项技术名为并发标记。该技术可以让 GC 扫描和标记对象时，同时允许 JS 运行。</p><p>清除对象后会造成堆内存出现碎片的情况，当碎片超过一定限制后会启动压缩算法。在压缩过程中，将活的对象向一端移动，直到所有对象都移动完成然后清理掉不需要的内存。</p><h3 id="2-哪些操作会造成内存泄漏？"><a href="#2-哪些操作会造成内存泄漏？" class="headerlink" title="2. 哪些操作会造成内存泄漏？"></a>2. 哪些操作会造成内存泄漏？</h3><ul><li>第一种情况是由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。</li><li>第二种情况是设置了 setInterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。</li><li>第三种情况是获取一个 DOM 元素的引用，而后面这个元素被删除，由于我们一直保留了对这个元素的引用，所以它也无法被回收。</li><li>第四种情况是不合理的使用闭包，从而导致某些变量一直被留在内存当中。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>性能优化</title>
      <link href="/posts/fc854d4d.html"/>
      <url>/posts/fc854d4d.html</url>
      
        <content type="html"><![CDATA[<p>摘要</p><span id="more"></span><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230611132932201.png" alt="image-20230611132932201"></p><h2 id="一、CDN"><a href="#一、CDN" class="headerlink" title="一、CDN"></a>一、CDN</h2><h3 id="1-CDN的概念"><a href="#1-CDN的概念" class="headerlink" title="1. CDN的概念"></a>1. CDN的概念</h3><p>CDN（Content Delivery Network，<strong>内容分发网络</strong>）是指一种通过互联网互相连接的电脑网络系统，利用最靠近每位用户的服务器，更快、更可靠地将音乐、图片、视频、应用程序及其他文件发送给用户，来提供高性能、可扩展性及低成本的网络内容传递给用户。</p><p>典型的CDN系统由下面三个部分组成：</p><ul><li><strong>分发服务系统：</strong> 最基本的工作单元就是Cache设备，cache（边缘cache）负责直接响应最终用户的访问请求，把缓存在本地的内容快速地提供给用户。同时cache还负责与源站点进行内容同步，把更新的内容以及本地没有的内容从源站点获取并保存在本地。Cache设备的数量、规模、总服务能力是衡量一个CDN系统服务能力的最基本的指标。</li><li><strong>负载均衡系统：</strong> 主要功能是负责对所有发起服务请求的用户进行访问调度，确定提供给用户的最终实际访问地址。两级调度体系分为全局负载均衡（GSLB）和本地负载均衡（SLB）。<strong>全局负载均衡</strong>主要根据用户就近性原则，通过对每个服务节点进行“最优”判断，确定向用户提供服务的cache的物理位置。<strong>本地负载均衡</strong>主要负责节点内部的设备负载均衡</li><li><strong>运营管理系统：</strong> 运营管理系统分为运营管理和网络管理子系统，负责处理业务层面的与外界系统交互所必须的收集、整理、交付工作，包含客户管理、产品管理、计费管理、统计分析等功能。</li></ul><h3 id="2-CDN的作用"><a href="#2-CDN的作用" class="headerlink" title="2. CDN的作用"></a>2. CDN的作用</h3><p>CDN一般会用来托管Web资源（包括文本、图片和脚本等），可供下载的资源（媒体文件、软件、文档等），应用程序（门户网站等）。使用CDN来加速这些资源的访问。</p><p>（1）在性能方面，引入CDN的作用在于：</p><ul><li>用户收到的内容来自最近的数据中心，延迟更低，内容加载更快</li><li>部分资源请求分配给了CDN，减少了服务器的负载</li></ul><p>（2）在安全方面，CDN有助于防御DDoS、MITM等网络攻击：</p><ul><li>针对DDoS：通过监控分析异常流量，限制其请求频率</li><li>针对MITM：从源服务器到 CDN 节点到 ISP（Internet Service Provider），全链路 HTTPS 通信</li></ul><p>除此之外，CDN作为一种基础的云服务，同样具有资源托管、按需扩展（能够应对流量高峰）等方面的优势。</p><h3 id="3-CDN的原理"><a href="#3-CDN的原理" class="headerlink" title="3. CDN的原理"></a>3. CDN的原理</h3><p>CDN和DNS有着密不可分的联系，先来看一下DNS的解析域名过程，在浏览器输入 <a href="https://link.juejin.cn/?target=http://www.test.com">www.test.com</a> 的解析过程如下： （1） 检查浏览器缓存 （2）检查操作系统缓存，常见的如hosts文件 （3）检查路由器缓存 （4）如果前几步都没没找到，会向ISP(网络服务提供商)的LDNS服务器查询 （5）如果LDNS服务器没找到，会向根域名服务器(Root Server)请求解析，分为以下几步：</p><ul><li>根服务器返回顶级域名(TLD)服务器如<code>.com</code>，<code>.cn</code>，<code>.org</code>等的地址，该例子中会返回<code>.com</code>的地址</li><li>接着向顶级域名服务器发送请求，然后会返回次级域名(SLD)服务器的地址，本例子会返回<code>.test</code>的地址</li><li>接着向次级域名服务器发送请求，然后会返回通过域名查询到的目标IP，本例子会返回<code>www.test.com</code>的地址</li><li>Local DNS Server会缓存结果，并返回给用户，缓存在系统中</li></ul><p><strong>CDN的工作原理：</strong> （1）用户未使用CDN缓存资源的过程：</p><ol><li>浏览器通过DNS对域名进行解析（就是上面的DNS解析过程），依次得到此域名对应的IP地址</li><li>浏览器根据得到的IP地址，向域名的服务主机发送数据请求</li><li>服务器向浏览器返回响应数据</li></ol><p>（2）用户使用CDN缓存资源的过程：</p><ol><li>对于点击的数据的URL，经过本地DNS系统的解析，发现该URL对应的是一个CDN专用的DNS服务器，DNS系统就会将域名解析权交给CNAME指向的CDN专用的DNS服务器。</li><li>CND专用DNS服务器将CND的全局负载均衡设备IP地址返回给用户</li><li>用户向CDN的全局负载均衡设备发起数据请求</li><li>CDN的全局负载均衡设备根据用户的IP地址，以及用户请求的内容URL，选择一台用户所属区域的区域负载均衡设备，告诉用户向这台设备发起请求</li><li>区域负载均衡设备选择一台合适的缓存服务器来提供服务，将该缓存服务器的IP地址返回给全局负载均衡设备</li><li>全局负载均衡设备把服务器的IP地址返回给用户</li><li>用户向该缓存服务器发起请求，缓存服务器响应用户的请求，将用户所需内容发送至用户终端。</li></ol><p>如果缓存服务器没有用户想要的内容，那么缓存服务器就会向它的上一级缓存服务器请求内容，以此类推，直到获取到需要的资源。最后如果还是没有，就会回到自己的服务器去获取资源。</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230611133124070.png" alt="image-20230611133124070"> CNAME（意为：别名)：在域名解析中，实际上解析出来的指定域名对应的IP地址，或者该域名的一个CNAME，然后再根据这个CNAME来查找对应的IP地址。</p><h3 id="4-CDN的使用场景"><a href="#4-CDN的使用场景" class="headerlink" title="4. CDN的使用场景"></a>4. CDN的使用场景</h3><ul><li><strong>使用第三方的CDN服务：</strong>如果想要开源一些项目，可以使用第三方的CDN服务</li><li><strong>使用CDN进行静态资源的缓存：</strong>将自己网站的静态资源放在CDN上，比如js、css、图片等。可以将整个项目放在CDN上，完成一键部署。</li><li><strong>直播传送：</strong>直播本质上是使用流媒体进行传送，CDN也是支持流媒体传送的，所以直播完全可以使用CDN来提高访问速度。CDN在处理流媒体的时候与处理普通静态文件有所不同，普通文件如果在边缘节点没有找到的话，就会去上一层接着寻找，但是流媒体本身数据量就非常大，如果使用回源的方式，必然会带来性能问题，所以流媒体一般采用的都是主动推送的方式来进行。</li></ul><h2 id="二、懒加载"><a href="#二、懒加载" class="headerlink" title="二、懒加载"></a>二、懒加载</h2><h3 id="1-懒加载的概念"><a href="#1-懒加载的概念" class="headerlink" title="1. 懒加载的概念"></a>1. 懒加载的概念</h3><p>懒加载也叫做延迟加载、按需加载，指的是在长网页中延迟加载图片数据，是一种较好的网页性能优化的方式。在比较长的网页或应用中，如果图片很多，所有的图片都被加载出来，而用户只能看到可视窗口的那一部分图片数据，这样就浪费了性能。</p><p>如果使用图片的懒加载就可以解决以上问题。在滚动屏幕之前，可视化区域之外的图片不会进行加载，在滚动屏幕时才加载。这样使得网页的加载速度更快，减少了服务器的负载。懒加载适用于图片较多，页面列表较长（长列表）的场景中。</p><h3 id="2-懒加载的特点"><a href="#2-懒加载的特点" class="headerlink" title="2. 懒加载的特点"></a>2. 懒加载的特点</h3><ul><li><strong>减少无用资源的加载</strong>：使用懒加载明显减少了服务器的压力和流量，同时也减小了浏览器的负担。</li><li><strong>提升用户体验</strong>: 如果同时加载较多图片，可能需要等待的时间较长，这样影响了用户体验，而使用懒加载就能大大的提高用户体验。</li><li><strong>防止加载过多图片而影响其他资源文件的加载</strong> ：会影响网站应用的正常使用。</li></ul><h3 id="3-懒加载的实现原理"><a href="#3-懒加载的实现原理" class="headerlink" title="3. 懒加载的实现原理"></a>3. 懒加载的实现原理</h3><p>图片的加载是由<code>src</code>引起的，当对<code>src</code>赋值时，浏览器就会请求图片资源。根据这个原理，我们使用HTML5 的<code>data-xxx</code>属性来储存图片的路径，在需要加载图片的时候，将<code>data-xxx</code>中图片的路径赋值给<code>src</code>，这样就实现了图片的按需加载，即懒加载。</p><p>注意：<code>data-xxx</code> 中的<code>xxx</code>可以自定义，这里我们使用<code>data-src</code>来定义。</p><p>懒加载的实现重点在于确定用户需要加载哪张图片，在浏览器中，可视区域内的资源就是用户需要的资源。所以当图片出现在可视区域时，获取图片的真实地址并赋值给图片即可。</p><p>使用原生JavaScript实现懒加载：</p><p><strong>知识点：</strong></p><p>（1）<code>window.innerHeight</code> 是浏览器可视区的高度</p><p>（2）<code>document.body.scrollTop || document.documentElement.scrollTop</code> 是浏览器滚动的过的距离</p><p>（3）<code>imgs.offsetTop</code> 是元素顶部距离文档顶部的高度（包括滚动条的距离）</p><p>（4）图片加载条件：<code>img.offsetTop &lt; window.innerHeight + document.body.scrollTop;</code></p><p><strong>图示：</strong> <img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230611133256879.png" alt="image-20230611133256879"> <strong>代码实现：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;div <span class="keyword">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span><br><span class="line">     &lt;img src=&quot;loading.gif&quot;  data-src=&quot;pic.png&quot;&gt;</span><br><span class="line">     &lt;img src=&quot;loading.gif&quot;  data-src=&quot;pic.png&quot;&gt;</span><br><span class="line">     &lt;img src=&quot;loading.gif&quot;  data-src=&quot;pic.png&quot;&gt;</span><br><span class="line">     &lt;img src=&quot;loading.gif&quot;  data-src=&quot;pic.png&quot;&gt;</span><br><span class="line">     &lt;img src=&quot;loading.gif&quot;  data-src=&quot;pic.png&quot;&gt;</span><br><span class="line">     &lt;img src=&quot;loading.gif&quot;  data-src=&quot;pic.png&quot;&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var imgs = document.querySelectorAll(&#x27;img&#x27;);</span><br><span class="line">function lozyLoad()&#123;</span><br><span class="line">var scrollTop = document.body.scrollTop || document.documentElement.scrollTop;</span><br><span class="line">var winHeight= window.innerHeight;</span><br><span class="line">for(var i=0;i &lt; imgs.length;i++)&#123;</span><br><span class="line">if(imgs[i].offsetTop &lt; scrollTop + winHeight )&#123;</span><br><span class="line">imgs[i].src = imgs[i].getAttribute(&#x27;data-src&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">  window.onscroll = lozyLoad();</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="4-懒加载与预加载的区别"><a href="#4-懒加载与预加载的区别" class="headerlink" title="4. 懒加载与预加载的区别"></a>4. 懒加载与预加载的区别</h3><p>这两种方式都是提高网页性能的方式，两者主要区别是一个是提前加载，一个是迟缓甚至不加载。懒加载对服务器前端有一定的缓解压力作用，预加载则会增加服务器前端压力。</p><ul><li><strong>懒加载也叫延迟加载，指的是在长网页中延迟加载图片的时机，当用户需要访问时，再去加载</strong>，这样可以提高网站的首屏加载速度，提升用户的体验，并且可以减少服务器的压力。它适用于图片很多，页面很长的电商网站的场景。懒加载的实现原理是，将页面上的图片的 src 属性设置为空字符串，将图片的真实路径保存在一个自定义属性中，当页面滚动的时候，进行判断，如果图片进入页面可视区域内，则从自定义属性中取出真实路径赋值给图片的 src 属性，以此来实现图片的延迟加载。</li><li><strong>预加载指的是将所需的资源提前请求加载到本地，这样后面在需要用到时就直接从缓存取资源。</strong> 通过预加载能够减少用户的等待时间，提高用户的体验。我了解的预加载的最常用的方式是使用 js 中的 image 对象，通过为 image 对象来设置 scr 属性，来实现图片的预加载。</li></ul><h2 id="三、回流与重绘"><a href="#三、回流与重绘" class="headerlink" title="三、回流与重绘"></a>三、回流与重绘</h2><h3 id="1-回流与重绘的概念及触发条件"><a href="#1-回流与重绘的概念及触发条件" class="headerlink" title="1. 回流与重绘的概念及触发条件"></a>1. 回流与重绘的概念及触发条件</h3><h4 id="（1）回流"><a href="#（1）回流" class="headerlink" title="（1）回流"></a>（1）回流</h4><p>当渲染树中部分或者全部元素的尺寸、结构或者属性发生变化时，浏览器会重新渲染部分或者全部文档的过程就称为<strong>回流</strong>。</p><p>下面这些操作会导致回流：</p><ul><li>页面的首次渲染</li><li>浏览器的窗口大小发生变化</li><li>元素的内容发生变化</li><li>元素的尺寸或者位置发生变化</li><li>元素的字体大小发生变化</li><li>激活CSS伪类</li><li>查询某些属性或者调用某些方法</li><li>添加或者删除可见的DOM元素</li></ul><p>在触发回流（重排）的时候，由于浏览器渲染页面是基于流式布局的，所以当触发回流时，会导致周围的DOM元素重新排列，它的影响范围有两种：</p><ul><li>全局范围：从根节点开始，对整个渲染树进行重新布局</li><li>局部范围：对渲染树的某部分或者一个渲染对象进行重新布局</li></ul><h4 id="（2）重绘"><a href="#（2）重绘" class="headerlink" title="（2）重绘"></a>（2）重绘</h4><p>当页面中某些元素的样式发生变化，但是不会影响其在文档流中的位置时，浏览器就会对元素进行重新绘制，这个过程就是<strong>重绘</strong>。</p><p>下面这些操作会导致回流：</p><ul><li>color、background 相关属性：background-color、background-image 等</li><li>outline 相关属性：outline-color、outline-width 、text-decoration</li><li>border-radius、visibility、box-shadow</li></ul><p>注意： <strong>当触发回流时，一定会触发重绘，但是重绘不一定会引发回流。</strong></p><h3 id="2-如何避免回流与重绘？"><a href="#2-如何避免回流与重绘？" class="headerlink" title="2. 如何避免回流与重绘？"></a>2. 如何避免回流与重绘？</h3><p><strong>减少回流与重绘的措施：</strong></p><ul><li>操作DOM时，尽量在低层级的DOM节点进行操作</li><li>不要使用<code>table</code>布局， 一个小的改动可能会使整个<code>table</code>进行重新布局</li><li>使用CSS的表达式</li><li>不要频繁操作元素的样式，对于静态页面，可以修改类名，而不是样式。</li><li>使用absolute或者fixed，使元素脱离文档流，这样他们发生变化就不会影响其他元素</li><li>避免频繁操作DOM，可以创建一个文档片段<code>documentFragment</code>，在它上面应用所有DOM操作，最后再把它添加到文档中</li><li>将元素先设置<code>display: none</code>，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘。</li><li>将DOM的多个读操作（或者写操作）放在一起，而不是读写操作穿插着写。这得益于<strong>浏览器的渲染队列机制</strong>。</li></ul><p>浏览器针对页面的回流与重绘，进行了自身的优化——<strong>渲染队列</strong></p><p><strong>浏览器会将所有的回流、重绘的操作放在一个队列中，当队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会对队列进行批处理。这样就会让多次的回流、重绘变成一次回流重绘。</strong></p><p>上面，将多个读操作（或者写操作）放在一起，就会等所有的读操作进入队列之后执行，这样，原本应该是触发多次回流，变成了只触发一次回流。</p><h3 id="3-如何优化动画？"><a href="#3-如何优化动画？" class="headerlink" title="3. 如何优化动画？"></a>3. 如何优化动画？</h3><p>对于如何优化动画，我们知道，一般情况下，动画需要频繁的操作DOM，就就会导致页面的性能问题，我们可以将动画的<code>position</code>属性设置为<code>absolute</code>或者<code>fixed</code>，将动画脱离文档流，这样他的回流就不会影响到页面了。</p><h3 id="4-documentFragment-是什么？用它跟直接操作-DOM-的区别是什么？"><a href="#4-documentFragment-是什么？用它跟直接操作-DOM-的区别是什么？" class="headerlink" title="4. documentFragment 是什么？用它跟直接操作 DOM 的区别是什么？"></a>4. documentFragment 是什么？用它跟直接操作 DOM 的区别是什么？</h3><p>MDN中对<code>documentFragment</code>的解释：</p><blockquote><p>DocumentFragment，文档片段接口，一个没有父对象的最小文档对象。它被作为一个轻量版的 Document使用，就像标准的document一样，存储由节点（nodes）组成的文档结构。与document相比，最大的区别是DocumentFragment不是真实 DOM 树的一部分，它的变化不会触发 DOM 树的重新渲染，且不会导致性能等问题。</p></blockquote><p>当我们把一个 DocumentFragment 节点插入文档树时，插入的不是 DocumentFragment 自身，而是它的所有子孙节点。在频繁的DOM操作时，我们就可以将DOM元素插入DocumentFragment，之后一次性的将所有的子孙节点插入文档中。和直接操作DOM相比，将DocumentFragment 节点插入DOM树时，不会触发页面的重绘，这样就大大提高了页面的性能。</p><h2 id="四、节流与防抖"><a href="#四、节流与防抖" class="headerlink" title="四、节流与防抖"></a>四、节流与防抖</h2><h3 id="1-对节流与防抖的理解"><a href="#1-对节流与防抖的理解" class="headerlink" title="1. 对节流与防抖的理解"></a>1. 对节流与防抖的理解</h3><ul><li>函数防抖是指在事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。这可以使用在一些点击请求的事件上，避免因为用户的多次点击向后端发送多次请求。</li><li>函数节流是指规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。节流可以使用在 scroll 函数的事件监听上，通过事件节流来降低事件调用的频率。</li></ul><p><strong>节流函数的适⽤场景：</strong></p><ul><li>按钮提交场景：防⽌多次提交按钮，只执⾏最后提交的⼀次</li><li>服务端验证场景：表单验证需要服务端配合，只执⾏⼀段连续的输⼊事件的最后⼀次，还有搜索联想词功能类似⽣存环境请⽤lodash.debounce</li></ul><p><strong>防抖函数的应用场景：</strong></p><ul><li>拖拽场景：固定时间内只执⾏⼀次，防⽌超⾼频次触发位置变动</li><li>缩放场景：监控浏览器resize</li><li>动画场景：避免短时间内多次触发动画引起性能问题</li></ul><h3 id="2-实现节流函数和防抖函数"><a href="#2-实现节流函数和防抖函数" class="headerlink" title="2. 实现节流函数和防抖函数"></a>2. 实现节流函数和防抖函数</h3><p><strong>函数防抖的实现：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">fn, wait</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> timer = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> context = <span class="variable language_">this</span>,</span><br><span class="line">      args = [...<span class="variable language_">arguments</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果此时存在定时器的话，则取消之前的定时器重新记时</span></span><br><span class="line">    <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">      <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">      timer = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置定时器，使事件间隔指定事件后执行</span></span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      fn.<span class="title function_">apply</span>(context, args);</span><br><span class="line">    &#125;, wait);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>函数节流的实现：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间戳版</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">fn, delay</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> preTime = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> context = <span class="variable language_">this</span>,</span><br><span class="line">      args = [...<span class="variable language_">arguments</span>],</span><br><span class="line">      nowTime = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果两次时间间隔超过了指定时间，则执行函数。</span></span><br><span class="line">    <span class="keyword">if</span> (nowTime - preTime &gt;= delay) &#123;</span><br><span class="line">      preTime = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">      <span class="keyword">return</span> fn.<span class="title function_">apply</span>(context, args);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定时器版</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span> (fun, wait)&#123;</span><br><span class="line">  <span class="keyword">let</span> timeout = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> context = <span class="variable language_">this</span></span><br><span class="line">    <span class="keyword">let</span> args = [...<span class="variable language_">arguments</span>]</span><br><span class="line">    <span class="keyword">if</span>(!timeout)&#123;</span><br><span class="line">      timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        fun.<span class="title function_">apply</span>(context, args)</span><br><span class="line">        timeout = <span class="literal">null</span> </span><br><span class="line">      &#125;, wait)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五、图片优化"><a href="#五、图片优化" class="headerlink" title="五、图片优化"></a>五、图片优化</h2><h3 id="1-如何对项目中的图片进行优化？"><a href="#1-如何对项目中的图片进行优化？" class="headerlink" title="1. 如何对项目中的图片进行优化？"></a>1. 如何对项目中的图片进行优化？</h3><ol><li>不用图片。很多时候会使用到很多修饰类图片，其实这类修饰图片完全可以用 CSS 去代替。</li><li>对于移动端来说，屏幕宽度就那么点，完全没有必要去加载原图浪费带宽。一般图片都用 CDN 加载，可以计算出适配屏幕的宽度，然后去请求相应裁剪好的图片。</li><li>小图使用 base64 格式</li><li>将多个图标文件整合到一张图片中（雪碧图）</li><li>选择正确的图片格式：<ul><li>对于能够显示 WebP 格式的浏览器尽量使用 WebP 格式。因为 WebP 格式具有更好的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量，缺点就是兼容性并不好</li><li>小图使用 PNG，其实对于大部分图标这类图片，完全可以使用 SVG 代替</li><li>照片使用 JPEG</li></ul></li></ol><h3 id="2-常见的图片格式及使用场景"><a href="#2-常见的图片格式及使用场景" class="headerlink" title="2. 常见的图片格式及使用场景"></a>2. 常见的图片格式及使用场景</h3><p>（1）<strong>BMP</strong>，是无损的、既支持索引色也支持直接色的点阵图。这种图片格式几乎没有对数据进行压缩，所以BMP格式的图片通常是较大的文件。</p><p>（2）<strong>GIF</strong>是无损的、采用索引色的点阵图。采用LZW压缩算法进行编码。文件小，是GIF格式的优点，同时，GIF格式还具有支持动画以及透明的优点。但是GIF格式仅支持8bit的索引色，所以GIF格式适用于对色彩要求不高同时需要文件体积较小的场景。</p><p>（3）<strong>JPEG</strong>是有损的、采用直接色的点阵图。JPEG的图片的优点是采用了直接色，得益于更丰富的色彩，JPEG非常适合用来存储照片，与GIF相比，JPEG不适合用来存储企业Logo、线框类的图。因为有损压缩会导致图片模糊，而直接色的选用，又会导致图片文件较GIF更大。</p><p>（4）<strong>PNG-8</strong>是无损的、使用索引色的点阵图。PNG是一种比较新的图片格式，PNG-8是非常好的GIF格式替代者，在可能的情况下，应该尽可能的使用PNG-8而不是GIF，因为在相同的图片效果下，PNG-8具有更小的文件体积。除此之外，PNG-8还支持透明度的调节，而GIF并不支持。除非需要动画的支持，否则没有理由使用GIF而不是PNG-8。</p><p>（5）<strong>PNG-24</strong>是无损的、使用直接色的点阵图。PNG-24的优点在于它压缩了图片的数据，使得同样效果的图片，PNG-24格式的文件大小要比BMP小得多。当然，PNG24的图片还是要比JPEG、GIF、PNG-8大得多。</p><p>（6）<strong>SVG</strong>是无损的矢量图。SVG是矢量图意味着SVG图片由直线和曲线以及绘制它们的方法组成。当放大SVG图片时，看到的还是线和曲线，而不会出现像素点。这意味着SVG图片在放大时，不会失真，所以它非常适合用来绘制Logo、Icon等。</p><p>（7）<strong>WebP</strong>是谷歌开发的一种新图片格式，WebP是同时支持有损和无损压缩的、使用直接色的点阵图。从名字就可以看出来它是为Web而生的，什么叫为Web而生呢？就是说相同质量的图片，WebP具有更小的文件体积。现在网站上充满了大量的图片，如果能够降低每一个图片的文件大小，那么将大大减少浏览器和服务器之间的数据传输量，进而降低访问延迟，提升访问体验。目前只有Chrome浏览器和Opera浏览器支持WebP格式，兼容性不太好。</p><ul><li>在无损压缩的情况下，相同质量的WebP图片，文件大小要比PNG小26%；</li><li>在有损压缩的情况下，具有相同图片精度的WebP图片，文件大小要比JPEG小25%~34%；</li><li>WebP图片格式支持图片透明度，一个无损压缩的WebP图片，如果要支持透明度只需要22%的格外文件大小。</li></ul><h2 id="六、Webpack优化"><a href="#六、Webpack优化" class="headerlink" title="六、Webpack优化"></a>六、Webpack优化</h2><h3 id="1-如何提⾼webpack的打包速度"><a href="#1-如何提⾼webpack的打包速度" class="headerlink" title="1. 如何提⾼webpack的打包速度?"></a>1. 如何提⾼<strong>webpack</strong>的打包速度?</h3><h4 id="（1）优化-Loader"><a href="#（1）优化-Loader" class="headerlink" title="（1）优化 Loader"></a>（1）优化 Loader</h4><p>对于 Loader 来说，影响打包效率首当其冲必属 Babel 了。因为 Babel 会将代码转为字符串生成 AST，然后对 AST 继续进行转变最后再生成新的代码，项目越大，<strong>转换代码越多，效率就越低</strong>。当然了，这是可以优化的。</p><p>首先我们<strong>优化 Loader 的文件搜索范围</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// js 文件才使用 babel</span></span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        <span class="attr">loader</span>: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">        <span class="comment">// 只在 src 文件夹下查找</span></span><br><span class="line">        <span class="attr">include</span>: [<span class="title function_">resolve</span>(<span class="string">&#x27;src&#x27;</span>)],</span><br><span class="line">        <span class="comment">// 不会去查找的路径</span></span><br><span class="line">        <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 Babel 来说，希望只作用在 JS 代码上的，然后 <code>node_modules</code> 中使用的代码都是编译过的，所以完全没有必要再去处理一遍。</p><p>当然这样做还不够，还可以将 Babel 编译过的文件<strong>缓存</strong>起来，下次只需要编译更改过的代码文件即可，这样可以大幅度加快打包时间</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">loader</span>: <span class="string">&#x27;babel-loader?cacheDirectory=true&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="（2）HappyPack"><a href="#（2）HappyPack" class="headerlink" title="（2）HappyPack"></a>（2）HappyPack</h4><p>受限于 Node 是单线程运行的，所以 Webpack 在打包的过程中也是单线程的，特别是在执行 Loader 的时候，长时间编译的任务很多，这样就会导致等待的情况。</p><p><strong>HappyPack 可以将 Loader 的同步执行转换为并行的</strong>，这样就能充分利用系统资源来加快打包效率了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">module</span>: &#123;</span><br><span class="line">  <span class="attr">loaders</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">      <span class="attr">include</span>: [<span class="title function_">resolve</span>(<span class="string">&#x27;src&#x27;</span>)],</span><br><span class="line">      <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>,</span><br><span class="line">      <span class="comment">// id 后面的内容对应下面</span></span><br><span class="line">      <span class="attr">loader</span>: <span class="string">&#x27;happypack/loader?id=happybabel&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">plugins</span>: [</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">HappyPack</span>(&#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="string">&#x27;happybabel&#x27;</span>,</span><br><span class="line">    <span class="attr">loaders</span>: [<span class="string">&#x27;babel-loader?cacheDirectory&#x27;</span>],</span><br><span class="line">    <span class="comment">// 开启 4 个线程</span></span><br><span class="line">    <span class="attr">threads</span>: <span class="number">4</span></span><br><span class="line">  &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h4 id="（3）DllPlugin"><a href="#（3）DllPlugin" class="headerlink" title="（3）DllPlugin"></a>（3）DllPlugin</h4><p><strong>DllPlugin 可以将特定的类库提前打包然后引入</strong>。这种方式可以极大的减少打包类库的次数，只有当类库更新版本才有需要重新打包，并且也实现了将公共代码抽离成单独文件的优化方案。DllPlugin的使用方法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单独配置在一个文件中</span></span><br><span class="line"><span class="comment">// webpack.dll.conf.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>)</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">entry</span>: &#123;</span><br><span class="line">    <span class="comment">// 想统一打包的类库</span></span><br><span class="line">    <span class="attr">vendor</span>: [<span class="string">&#x27;react&#x27;</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">path</span>: path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;[name].dll.js&#x27;</span>,</span><br><span class="line">    <span class="attr">library</span>: <span class="string">&#x27;[name]-[hash]&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> webpack.<span class="title class_">DllPlugin</span>(&#123;</span><br><span class="line">      <span class="comment">// name 必须和 output.library 一致</span></span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;[name]-[hash]&#x27;</span>,</span><br><span class="line">      <span class="comment">// 该属性需要与 DllReferencePlugin 中一致</span></span><br><span class="line">      <span class="attr">context</span>: __dirname,</span><br><span class="line">      <span class="attr">path</span>: path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;dist&#x27;</span>, <span class="string">&#x27;[name]-manifest.json&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后需要执行这个配置文件生成依赖文件，接下来需要使用 <code>DllReferencePlugin</code> 将依赖文件引入项目中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.conf.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="comment">// ...省略其他配置</span></span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> webpack.<span class="title class_">DllReferencePlugin</span>(&#123;</span><br><span class="line">      <span class="attr">context</span>: __dirname,</span><br><span class="line">      <span class="comment">// manifest 就是之前打包出来的 json 文件</span></span><br><span class="line">      <span class="attr">manifest</span>: <span class="built_in">require</span>(<span class="string">&#x27;./dist/vendor-manifest.json&#x27;</span>),</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="（4）代码压缩"><a href="#（4）代码压缩" class="headerlink" title="（4）代码压缩"></a>（4）代码压缩</h4><p>在 Webpack3 中，一般使用 <code>UglifyJS</code> 来压缩代码，但是这个是单线程运行的，为了加快效率，可以使用 <code>webpack-parallel-uglify-plugin</code> 来并行运行 <code>UglifyJS</code>，从而提高效率。</p><p>在 Webpack4 中，不需要以上这些操作了，只需要将 <code>mode</code> 设置为 <code>production</code> 就可以默认开启以上功能。代码压缩也是我们必做的性能优化方案，当然我们不止可以压缩 JS 代码，还可以压缩 HTML、CSS 代码，并且在压缩 JS 代码的过程中，我们还可以通过配置实现比如删除 <code>console.log</code> 这类代码的功能。</p><h4 id="（5）其他"><a href="#（5）其他" class="headerlink" title="（5）其他"></a>（5）其他</h4><p>可以通过一些小的优化点来加快打包速度</p><ul><li><code>resolve.extensions</code>：用来表明文件后缀列表，默认查找顺序是 <code>[&#39;.js&#39;, &#39;.json&#39;]</code>，如果你的导入文件没有添加后缀就会按照这个顺序查找文件。我们应该尽可能减少后缀列表长度，然后将出现频率高的后缀排在前面</li><li><code>resolve.alias</code>：可以通过别名的方式来映射一个路径，能让 Webpack 更快找到路径</li><li><code>module.noParse</code>：如果你确定一个文件下没有其他依赖，就可以使用该属性让 Webpack 不扫描该文件，这种方式对于大型的类库很有帮助</li></ul><h3 id="2-如何减少-Webpack-打包体积"><a href="#2-如何减少-Webpack-打包体积" class="headerlink" title="2. 如何减少 Webpack 打包体积"></a>2. 如何减少 Webpack 打包体积</h3><h4 id="（1）按需加载"><a href="#（1）按需加载" class="headerlink" title="（1）按需加载"></a>（1）按需加载</h4><p>在开发 SPA 项目的时候，项目中都会存在很多路由页面。如果将这些页面全部打包进一个 JS 文件的话，虽然将多个请求合并了，但是同样也加载了很多并不需要的代码，耗费了更长的时间。那么为了首页能更快地呈现给用户，希望首页能加载的文件体积越小越好，<strong>这时候就可以使用按需加载，将每个路由页面单独打包为一个文件</strong>。当然不仅仅路由可以按需加载，对于 <code>loadash</code> 这种大型类库同样可以使用这个功能。</p><p>按需加载的代码实现这里就不详细展开了，因为鉴于用的框架不同，实现起来都是不一样的。当然了，虽然他们的用法可能不同，但是底层的机制都是一样的。都是当使用的时候再去下载对应文件，返回一个 <code>Promise</code>，当 <code>Promise</code> 成功以后去执行回调。</p><h4 id="（2）Scope-Hoisting"><a href="#（2）Scope-Hoisting" class="headerlink" title="（2）Scope Hoisting"></a>（2）Scope Hoisting</h4><p><strong>Scope Hoisting 会分析出模块之间的依赖关系，尽可能的把打包出来的模块合并到一个函数中去。</strong></p><p>比如希望打包两个文件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> a = <span class="number">1</span></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; a &#125; <span class="keyword">from</span> <span class="string">&#x27;./test.js&#x27;</span></span><br></pre></td></tr></table></figure><p>对于这种情况，打包出来的代码会类似这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  <span class="comment">/* 0 */</span></span><br><span class="line">  <span class="keyword">function</span> (<span class="params"><span class="variable language_">module</span>, <span class="built_in">exports</span>, <span class="built_in">require</span></span>) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">/* 1 */</span></span><br><span class="line">  <span class="keyword">function</span> (<span class="params"><span class="variable language_">module</span>, <span class="built_in">exports</span>, <span class="built_in">require</span></span>) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>但是如果使用 Scope Hoisting ，代码就会尽可能的合并到一个函数中去，也就变成了这样的类似代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  <span class="comment">/* 0 */</span></span><br><span class="line">  <span class="keyword">function</span> (<span class="params"><span class="variable language_">module</span>, <span class="built_in">exports</span>, <span class="built_in">require</span></span>) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>这样的打包方式生成的代码明显比之前的少多了。如果在 Webpack4 中你希望开启这个功能，只需要启用 <code>optimization.concatenateModules</code> 就可以了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">optimization</span>: &#123;</span><br><span class="line">    <span class="attr">concatenateModules</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="（3）Tree-Shaking"><a href="#（3）Tree-Shaking" class="headerlink" title="（3）Tree Shaking"></a>（3）Tree Shaking</h4><p><strong>Tree Shaking 可以实现删除项目中未被引用的代码</strong>，比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> b = <span class="number">2</span></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; a &#125; <span class="keyword">from</span> <span class="string">&#x27;./test.js&#x27;</span></span><br></pre></td></tr></table></figure><p>对于以上情况，<code>test</code> 文件中的变量 <code>b</code> 如果没有在项目中使用到的话，就不会被打包到文件中。</p><p>如果使用 Webpack 4 的话，开启生产环境就会自动启动这个优化功能。</p><h3 id="3-如何⽤webpack来优化前端性能？"><a href="#3-如何⽤webpack来优化前端性能？" class="headerlink" title="3. 如何⽤webpack来优化前端性能？"></a>3. 如何⽤<strong>webpack</strong>来优化前端性能？</h3><p>⽤webpack优化前端性能是指优化webpack的输出结果，让打包的最终结果在浏览器运⾏快速⾼效。</p><ul><li><strong>压缩代码</strong>：删除多余的代码、注释、简化代码的写法等等⽅式。可以利⽤webpack的 UglifyJsPlugin 和 ParallelUglifyPlugin 来压缩JS⽂件， 利⽤ cssnano （css-loader?minimize）来压缩css</li><li><strong>利⽤CDN加速</strong>: 在构建过程中，将引⽤的静态资源路径修改为CDN上对应的路径。可以利⽤webpack对于 output 参数和各loader的 publicPath 参数来修改资源路径</li><li><strong>Tree Shaking</strong>: 将代码中永远不会⾛到的⽚段删除掉。可以通过在启动webpack时追加参数 –optimize-minimize 来实现</li><li><strong>Code Splitting:</strong> 将代码按路由维度或者组件分块(chunk),这样做到按需加载,同时可以充分利⽤浏览器缓存</li><li><strong>提取公共第三⽅库</strong>: SplitChunksPlugin插件来进⾏公共模块抽取,利⽤浏览器缓存可以⻓期缓存这些⽆需频繁变动的公共代码</li></ul><h3 id="4-如何提⾼webpack的构建速度？"><a href="#4-如何提⾼webpack的构建速度？" class="headerlink" title="4. 如何提⾼webpack的构建速度？"></a>4. 如何提⾼<strong>webpack</strong>的构建速度？</h3><ol><li>多⼊⼝情况下，使⽤ CommonsChunkPlugin 来提取公共代码</li><li>通过 externals 配置来提取常⽤库</li><li>利⽤ DllPlugin 和 DllReferencePlugin 预编译资源模块 通过 DllPlugin 来对那些我们引⽤但是绝对不会修改的npm包来进⾏预编译，再通过 DllReferencePlugin 将预编译的模块加载进来。</li><li>使⽤ Happypack 实现多线程加速编译</li><li>使⽤ webpack-uglify-parallel 来提升 uglifyPlugin 的压缩速度。 原理上 webpack-uglify-parallel 采⽤了多核并⾏压缩来提升压缩速度</li><li>使⽤ Tree-shaking 和 Scope Hoisting 来剔除多余代码</li></ol>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css复习</title>
      <link href="/posts/ed9fe6ee.html"/>
      <url>/posts/ed9fe6ee.html</url>
      
        <content type="html"><![CDATA[<p>摘要</p><span id="more"></span><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230608144415180.png" alt="image-20230608144415180"></p><h2 id="一、CSS基础"><a href="#一、CSS基础" class="headerlink" title="一、CSS基础"></a>一、CSS基础</h2><h3 id="1-CSS选择器及其优先级"><a href="#1-CSS选择器及其优先级" class="headerlink" title="1. CSS选择器及其优先级"></a>1. CSS选择器及其优先级</h3><table><thead><tr><th><strong>选择器</strong></th><th><strong>格式</strong></th><th><strong>优先级权重</strong></th></tr></thead><tbody><tr><td>id选择器</td><td>#id</td><td>100</td></tr><tr><td>类选择器</td><td>#classname</td><td>10</td></tr><tr><td>属性选择器</td><td>a[ref=“eee”]</td><td>10</td></tr><tr><td>伪类选择器</td><td>li:last-child</td><td>10</td></tr><tr><td>标签选择器</td><td>div</td><td>1</td></tr><tr><td>伪元素选择器</td><td>li:after</td><td>1</td></tr><tr><td>相邻兄弟选择器</td><td>h1+p</td><td>0</td></tr><tr><td>子选择器</td><td>ul&gt;li</td><td>0</td></tr><tr><td>后代选择器</td><td>li a</td><td>0</td></tr><tr><td>通配符选择器</td><td>*</td><td>0</td></tr></tbody></table><p>对于选择器的<strong>优先级</strong>：</p><ul><li>标签选择器、伪元素选择器：1</li><li>类选择器、伪类选择器、属性选择器：10</li><li>id 选择器：100</li><li>内联样式：1000</li></ul><p><strong>注意事项：</strong></p><ul><li>!important声明的样式的优先级最高；</li><li>如果优先级相同，则最后出现的样式生效；</li><li>继承得到的样式的优先级最低；</li><li>通用选择器（*）、子选择器（&gt;）和相邻同胞选择器（+）并不在这四个等级中，所以它们的权值都为 0 ；</li><li>样式表的来源不同时，优先级顺序为：内联样式 &gt; 内部样式 &gt; 外部样式 &gt; 浏览器用户自定义样式 &gt; 浏览器默认样式。</li></ul><h3 id="2-CSS中可继承与不可继承属性有哪些"><a href="#2-CSS中可继承与不可继承属性有哪些" class="headerlink" title="2. CSS中可继承与不可继承属性有哪些"></a>2. CSS中可继承与不可继承属性有哪些</h3><p><strong>一、无继承性的属性</strong></p><ol><li><strong>display</strong>：规定元素应该生成的框的类型</li><li><strong>文本属性</strong>：</li></ol><ul><li>vertical-align：垂直文本对齐</li><li>text-decoration：规定添加到文本的装饰</li><li>text-shadow：文本阴影效果</li><li>white-space：空白符的处理</li><li>unicode-bidi：设置文本的方向</li></ul><ol><li><strong>盒子模型的属性</strong>：width、height、margin、border、padding</li><li><strong>背景属性</strong>：background、background-color、background-image、background-repeat、background-position、background-attachment</li><li><strong>定位属性</strong>：float、clear、position、top、right、bottom、left、min-width、min-height、max-width、max-height、overflow、clip、z-index</li><li><strong>生成内容属性</strong>：content、counter-reset、counter-increment</li><li><strong>轮廓样式属性</strong>：outline-style、outline-width、outline-color、outline</li><li><strong>页面样式属性</strong>：size、page-break-before、page-break-after</li><li><strong>声音样式属性</strong>：pause-before、pause-after、pause、cue-before、cue-after、cue、play-during</li></ol><p><strong>二、有继承性的属性</strong></p><ol><li><strong>字体系列属性</strong></li></ol><ul><li>font-family：字体系列</li><li>font-weight：字体的粗细</li><li>font-size：字体的大小</li><li>font-style：字体的风格</li></ul><ol><li><strong>文本系列属性</strong></li></ol><ul><li>text-indent：文本缩进</li><li>text-align：文本水平对齐</li><li>line-height：行高</li><li>word-spacing：单词之间的间距</li><li>letter-spacing：中文或者字母之间的间距</li><li>text-transform：控制文本大小写（就是uppercase、lowercase、capitalize这三个）</li><li>color：文本颜色</li></ul><ol><li><strong>元素可见性</strong></li></ol><ul><li>visibility：控制元素显示隐藏</li></ul><ol><li><strong>列表布局属性</strong></li></ol><ul><li>list-style：列表风格，包括list-style-type、list-style-image等</li></ul><ol><li><strong>光标属性</strong></li></ol><ul><li>cursor：光标显示为何种形态</li></ul><h3 id="3-display的属性值及其作用"><a href="#3-display的属性值及其作用" class="headerlink" title="3. display的属性值及其作用"></a>3. display的属性值及其作用</h3><table><thead><tr><th><strong>属性值</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td>none</td><td>元素不显示，并且会从文档流中移除。</td></tr><tr><td>block</td><td>块类型。默认宽度为父元素宽度，可设置宽高，换行显示。</td></tr><tr><td>inline</td><td>行内元素类型。默认宽度为内容宽度，不可设置宽高，同行显示。</td></tr><tr><td>inline-block</td><td>默认宽度为内容宽度，可以设置宽高，同行显示。</td></tr><tr><td>list-item</td><td>像块类型元素一样显示，并添加样式列表标记。</td></tr><tr><td>table</td><td>此元素会作为块级表格来显示。</td></tr><tr><td>inherit</td><td>规定应该从父元素继承display属性的值。</td></tr></tbody></table><h3 id="4-display的block、inline和inline-block的区别"><a href="#4-display的block、inline和inline-block的区别" class="headerlink" title="4. display的block、inline和inline-block的区别"></a>4. display的block、inline和inline-block的区别</h3><p>（1）<strong>block：</strong> 会独占一行，多个元素会另起一行，可以设置width、height、margin和padding属性；</p><p>（2）<strong>inline：</strong> 元素不会独占一行，设置width、height属性无效。但可以设置水平方向的margin和padding属性，不能设置垂直方向的padding和margin；</p><p>（3）<strong>inline-block：</strong> 将对象设置为inline对象，但对象的内容作为block对象呈现，之后的内联对象会被排列在同一行内。</p><p>对于行内元素和块级元素，其特点如下：</p><p><strong>（1）行内元素</strong></p><ul><li>设置宽高无效；</li><li>可以设置水平方向的margin和padding属性，不能设置垂直方向的padding和margin；</li><li>不会自动换行；</li></ul><p><strong>（2）块级元素</strong></p><ul><li>可以设置宽高；</li><li>设置margin和padding都有效；</li><li>可以自动换行；</li><li>多个块状，默认排列从上到下。</li></ul><h3 id="5-隐藏元素的方法有哪些"><a href="#5-隐藏元素的方法有哪些" class="headerlink" title="5. 隐藏元素的方法有哪些"></a>5. 隐藏元素的方法有哪些</h3><ul><li><strong>display: none</strong>：渲染树不会包含该渲染对象，因此该元素不会在页面中占据位置，也不会响应绑定的监听事件。</li><li><strong>visibility: hidden</strong>：元素在页面中仍占据空间，但是不会响应绑定的监听事件。</li><li><strong>opacity: 0</strong>：将元素的透明度设置为 0，以此来实现元素的隐藏。元素在页面中仍然占据空间，并且能够响应元素绑定的监听事件。</li><li><strong>position: absolute</strong>：通过使用绝对定位将元素移除可视区域内，以此来实现元素的隐藏。</li><li><strong>z-index: 负值</strong>：来使其他元素遮盖住该元素，以此来实现隐藏。</li><li><strong>clip/clip-path</strong> ：使用元素裁剪的方法来实现元素的隐藏，这种方法下，元素仍在页面中占据位置，但是不会响应绑定的监听事件。</li><li>**transform: scale(0,0)**：将元素缩放为 0，来实现元素的隐藏。这种方法下，元素仍在页面中占据位置，但是不会响应绑定的监听事件。</li></ul><h3 id="6-link和-import的区别"><a href="#6-link和-import的区别" class="headerlink" title="6. link和@import的区别"></a>6. link和@import的区别</h3><p>两者都是外部引用CSS的方式，它们的区别如下：</p><ul><li>link是XHTML标签，除了加载CSS外，还可以定义RSS等其他事务；@import属于CSS范畴，只能加载CSS。</li><li>link引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载。</li><li>link是XHTML标签，无兼容问题；@import是在CSS2.1提出的，低版本的浏览器不支持。</li><li>link支持使用Javascript控制DOM去改变样式；而@import不支持。</li></ul><h3 id="7-transition和animation的区别"><a href="#7-transition和animation的区别" class="headerlink" title="7. transition和animation的区别"></a>7. transition和animation的区别</h3><ul><li><strong>transition是过度属性</strong>，强调过度，它的实现需要触发一个事件（比如鼠标移动上去，焦点，点击等）才执行动画。它类似于flash的补间动画，设置一个开始关键帧，一个结束关键帧。</li><li><strong>animation是动画属性</strong>，它的实现不需要触发事件，设定好时间之后可以自己执行，且可以循环一个动画。它也类似于flash的补间动画，但是它可以设置多个关键帧（用@keyframe定义）完成动画。</li></ul><h3 id="8-display-none与visibility-hidden的区别"><a href="#8-display-none与visibility-hidden的区别" class="headerlink" title="8. display:none与visibility:hidden的区别"></a>8. display:none与visibility:hidden的区别</h3><p>这两个属性都是让元素隐藏，不可见。<strong>两者区别如下：</strong></p><p>（1）<strong>在渲染树中</strong></p><ul><li><code>display:none</code>会让元素完全从渲染树中消失，渲染时不会占据任何空间；</li><li><code>visibility:hidden</code>不会让元素从渲染树中消失，渲染的元素还会占据相应的空间，只是内容不可见。</li></ul><p>（2）<strong>是否是继承属性</strong></p><ul><li><code>display:none</code>是非继承属性，子孙节点会随着父节点从渲染树消失，通过修改子孙节点的属性也无法显示；</li><li><code>visibility:hidden</code>是继承属性，子孙节点消失是由于继承了<code>hidden</code>，通过设置<code>visibility:visible</code>可以让子孙节点显示； （3）修改常规文档流中元素的 <code>display</code> 通常会造成文档的重排，但是修改<code>visibility</code>属性只会造成本元素的重绘；</li></ul><p>（4）如果使用读屏器，设置为<code>display:none</code>的内容不会被读取，设置为<code>visibility:hidden</code>的内容会被读取。</p><h3 id="9-伪元素和伪类的区别和作用？"><a href="#9-伪元素和伪类的区别和作用？" class="headerlink" title="9. 伪元素和伪类的区别和作用？"></a>9. <strong>伪元素和伪类的区别和作用？</strong></h3><ul><li>伪元素：在内容元素的前后插入额外的元素或样式，但是这些元素实际上并不在文档中生成。它们只在外部显示可见，但不会在文档的源代码中找到它们，因此，称为“伪”元素。例如：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">::before</span> &#123;<span class="attribute">content</span>:<span class="string">&quot;第一章：&quot;</span>;&#125;</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">::after</span> &#123;<span class="attribute">content</span>:<span class="string">&quot;Hot!&quot;</span>;&#125;</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">::first-line</span> &#123;<span class="attribute">background</span>:red;&#125;</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">::first-letter</span> &#123;<span class="attribute">font-size</span>:<span class="number">30px</span>;&#125;</span><br></pre></td></tr></table></figure><ul><li>伪类：将特殊的效果添加到特定选择器上。它是已有元素上添加类别的，不会产生新的元素。例如：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;<span class="attribute">color</span>: <span class="number">#FF00FF</span>&#125;</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:first</span>-child &#123;<span class="attribute">color</span>: red&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong> 伪类是通过在元素选择器上加⼊伪类改变元素状态，⽽伪元素通过对元素的操作进⾏对元素的改变。</p><h3 id="10-对requestAnimationframe的理解"><a href="#10-对requestAnimationframe的理解" class="headerlink" title="10. 对requestAnimationframe的理解"></a>10. 对requestAnimationframe的理解</h3><p>实现动画效果的方法比较多，Javascript 中可以通过定时器 setTimeout 来实现，CSS3 中可以使用 transition 和 animation 来实现，HTML5 中的 canvas 也可以实现。除此之外，HTML5 提供一个专门用于请求动画的API，那就是 requestAnimationFrame，顾名思义就是<strong>请求动画帧</strong>。</p><p>MDN对该方法的描述：</p><blockquote><p>window.requestAnimationFrame() 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行。</p></blockquote><p><strong>语法：</strong> <code>window.requestAnimationFrame(callback);</code>  其中，callback是<strong>下一次重绘之前更新动画帧所调用的函数</strong>(即上面所说的回调函数)。该回调函数会被传入DOMHighResTimeStamp参数，它表示requestAnimationFrame() 开始去执行回调函数的时刻。该方法属于<strong>宏任务</strong>，所以会在执行完微任务之后再去执行。</p><p><strong>取消动画：</strong> 使用cancelAnimationFrame()来取消执行动画，该方法接收一个参数——requestAnimationFrame默认返回的id，只需要传入这个id就可以取消动画了。</p><p><strong>优势：</strong></p><ul><li><strong>CPU节能</strong>：使用SetTinterval 实现的动画，当页面被隐藏或最小化时，SetTinterval 仍然在后台执行动画任务，由于此时页面处于不可见或不可用状态，刷新动画是没有意义的，完全是浪费CPU资源。而RequestAnimationFrame则完全不同，当页面处理未激活的状态下，该页面的屏幕刷新任务也会被系统暂停，因此跟着系统走的RequestAnimationFrame也会停止渲染，当页面被激活时，动画就从上次停留的地方继续执行，有效节省了CPU开销。</li><li><strong>函数节流</strong>：在高频率事件( resize, scroll 等)中，为了防止在一个刷新间隔内发生多次函数执行，RequestAnimationFrame可保证每个刷新间隔内，函数只被执行一次，这样既能保证流畅性，也能更好的节省函数执行的开销，一个刷新间隔内函数执行多次时没有意义的，因为多数显示器每16.7ms刷新一次，多次绘制并不会在屏幕上体现出来。</li><li><strong>减少DOM操作</strong>：requestAnimationFrame 会把每一帧中的所有DOM操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率，一般来说，这个频率为每秒60帧。</li></ul><p><strong>setTimeout执行动画的缺点</strong>：它通过设定间隔时间来不断改变图像位置，达到动画效果。但是容易出现卡顿、抖动的现象；原因是：</p><ul><li>settimeout任务被放入异步队列，只有当主线程任务执行完后才会执行队列中的任务，因此实际执行时间总是比设定时间要晚；</li><li>settimeout的固定时间间隔不一定与屏幕刷新间隔时间相同，会引起丢帧。</li></ul><h3 id="11-对盒模型的理解"><a href="#11-对盒模型的理解" class="headerlink" title="11. 对盒模型的理解"></a>11. 对盒模型的理解</h3><p>CSS3中的盒模型有以下两种：标准盒子模型、IE盒子模型 <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4544d45b5a0c47a58c0c33a7d8fbac09~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img"> <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4040de9fef1a49f4ae0ae66039edcfe0~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img"> 盒模型都是由四个部分组成的，分别是margin、border、padding和content。</p><p>标准盒模型和IE盒模型的区别在于设置width和height时，所对应的范围不同：</p><ul><li>标准盒模型的width和height属性的范围只包含了content，</li><li>IE盒模型的width和height属性的范围包含了border、padding和content。</li></ul><p>可以通过修改元素的box-sizing属性来改变元素的盒模型：</p><ul><li><code>box-sizeing: content-box</code>表示标准盒模型（默认值）</li><li><code>box-sizeing: border-box</code>表示IE盒模型（怪异盒模型）</li></ul><h3 id="12-为什么有时候⽤translate来改变位置⽽不是定位？"><a href="#12-为什么有时候⽤translate来改变位置⽽不是定位？" class="headerlink" title="12. 为什么有时候⽤translate来改变位置⽽不是定位？"></a>12. 为什么有时候⽤<strong>translate</strong>来改变位置⽽不是定位？</h3><p>translate 是 transform 属性的⼀个值。改变transform或opacity不会触发浏览器重新布局（reflow）或重绘（repaint），只会触发复合（compositions）。⽽改变绝对定位会触发重新布局，进⽽触发重绘和复合。transform使浏览器为元素创建⼀个 GPU 图层，但改变绝对定位会使⽤到 CPU。 因此translate()更⾼效，可以缩短平滑动画的绘制时间。 ⽽translate改变位置时，元素依然会占据其原始空间，绝对定位就不会发⽣这种情况。</p><h3 id="13-li-与-li-之间有看不见的空白间隔是什么原因引起的？如何解决？"><a href="#13-li-与-li-之间有看不见的空白间隔是什么原因引起的？如何解决？" class="headerlink" title="13. li 与 li 之间有看不见的空白间隔是什么原因引起的？如何解决？"></a>13. li 与 li 之间有看不见的空白间隔是什么原因引起的？如何解决？</h3><p>浏览器会把inline内联元素间的空白字符（空格、换行、Tab等）渲染成一个空格。为了美观，通常是一个<code>&lt;li&gt;</code>放在一行，这导致<code>&lt;li&gt;</code>换行后产生换行字符，它变成一个空格，占用了一个字符的宽度。</p><p><strong>解决办法：</strong></p><p>（1）为<code>&lt;li&gt;</code>设置float:left。不足：有些容器是不能设置浮动，如左右切换的焦点图等。</p><p>（2）将所有<code>&lt;li&gt;</code>写在同一行。不足：代码不美观。</p><p>（3）将<code>&lt;ul&gt;</code>内的字符尺寸直接设为0，即font-size:0。不足：<code>&lt;ul&gt;</code>中的其他字符尺寸也被设为0，需要额外重新设定其他字符尺寸，且在Safari浏览器依然会出现空白间隔。</p><p>（4）消除<code>&lt;ul&gt;</code>的字符间隔letter-spacing:-8px，不足：这也设置了<code>&lt;li&gt;</code>内的字符间隔，因此需要将<code>&lt;li&gt;</code>内的字符间隔设为默认letter-spacing:normal。</p><h3 id="14-CSS3中有哪些新特性"><a href="#14-CSS3中有哪些新特性" class="headerlink" title="14. CSS3中有哪些新特性"></a>14. CSS3中有哪些新特性</h3><ul><li>新增各种CSS选择器 （: not(.input)：所有 class 不是“input”的节点）</li><li>圆角 （border-radius:8px）</li><li>多列布局 （multi-column layout）</li><li>阴影和反射 （Shadoweflect）</li><li>文字特效 （text-shadow）</li><li>文字渲染 （Text-decoration）</li><li>线性渐变 （gradient）</li><li>旋转 （transform）</li><li>增加了旋转,缩放,定位,倾斜,动画,多背景</li></ul><h3 id="15-替换元素的概念及计算规则"><a href="#15-替换元素的概念及计算规则" class="headerlink" title="15. 替换元素的概念及计算规则"></a>15. 替换元素的概念及计算规则</h3><p>通过修改某个属性值呈现的内容就可以被替换的元素就称为“替换元素”。</p><p>替换元素除了内容可替换这一特性以外，还有以下特性：</p><ul><li><strong>内容的外观不受页面上的CSS的影响</strong>：用专业的话讲就是在样式表现在CSS作用域之外。如何更改替换元素本身的外观需要类似appearance属性，或者浏览器自身暴露的一些样式接口。</li><li><strong>有自己的尺寸</strong>：在Web中，很多替换元素在没有明确尺寸设定的情况下，其默认的尺寸（不包括边框）是300像素×150像素，如</li><li><strong>在很多CSS属性上有自己的一套表现规则</strong>：比较具有代表性的就是vertical-align属性，对于替换元素和非替换元素，vertical-align属性值的解释是不一样的。比方说vertical-align的默认值的baseline，很简单的属性值，基线之意，被定义为字符x的下边缘，而替换元素的基线却被硬生生定义成了元素的下边缘。</li><li><strong>所有的替换元素都是内联水平元素</strong>：也就是替换元素和替换元素、替换元素和文字都是可以在一行显示的。但是，替换元素默认的display值却是不一样的，有的是inline，有的是inline-block。</li></ul><p>替换元素的尺寸从内而外分为三类：</p><ul><li><strong>固有尺寸：</strong> 指的是替换内容原本的尺寸。例如，图片、视频作为一个独立文件存在的时候，都是有着自己的宽度和高度的。</li><li><strong>HTML尺寸：</strong> 只能通过HTML原生属性改变，这些HTML原生属性包括的width和height属性、的size属性。</li><li><strong>CSS尺寸：</strong> 特指可以通过CSS的width和height或者max-width/min-width和max-height/min-height设置的尺寸，对应盒尺寸中的content box。</li></ul><p>这三层结构的计算规则具体如下： （1）如果没有CSS尺寸和HTML尺寸，则使用固有尺寸作为最终的宽高。 （2）如果没有CSS尺寸，则使用HTML尺寸作为最终的宽高。 （3）如果有CSS尺寸，则最终尺寸由CSS属性决定。 （4）如果“固有尺寸”含有固有的宽高比例，同时仅设置了宽度或仅设置了高度，则元素依然按照固有的宽高比例显示。 （5）如果上面的条件都不符合，则最终宽度表现为300像素，高度为150像素。 （6）内联替换元素和块级替换元素使用上面同一套尺寸计算规则。</p><h3 id="16-常见的图片格式及使用场景"><a href="#16-常见的图片格式及使用场景" class="headerlink" title="16. 常见的图片格式及使用场景"></a>16. 常见的图片格式及使用场景</h3><p>（1）<strong>BMP</strong>，是无损的、既支持索引色也支持直接色的点阵图。这种图片格式几乎没有对数据进行压缩，所以BMP格式的图片通常是较大的文件。</p><p>（2）<strong>GIF</strong>是无损的、采用索引色的点阵图。采用LZW压缩算法进行编码。文件小，是GIF格式的优点，同时，GIF格式还具有支持动画以及透明的优点。但是GIF格式仅支持8bit的索引色，所以GIF格式适用于对色彩要求不高同时需要文件体积较小的场景。</p><p>（3）<strong>JPEG</strong>是有损的、采用直接色的点阵图。JPEG的图片的优点是采用了直接色，得益于更丰富的色彩，JPEG非常适合用来存储照片，与GIF相比，JPEG不适合用来存储企业Logo、线框类的图。因为有损压缩会导致图片模糊，而直接色的选用，又会导致图片文件较GIF更大。</p><p>（4）<strong>PNG-8</strong>是无损的、使用索引色的点阵图。PNG是一种比较新的图片格式，PNG-8是非常好的GIF格式替代者，在可能的情况下，应该尽可能的使用PNG-8而不是GIF，因为在相同的图片效果下，PNG-8具有更小的文件体积。除此之外，PNG-8还支持透明度的调节，而GIF并不支持。除非需要动画的支持，否则没有理由使用GIF而不是PNG-8。</p><p>（5）<strong>PNG-24</strong>是无损的、使用直接色的点阵图。PNG-24的优点在于它压缩了图片的数据，使得同样效果的图片，PNG-24格式的文件大小要比BMP小得多。当然，PNG24的图片还是要比JPEG、GIF、PNG-8大得多。</p><p>（6）<strong>SVG</strong>是无损的矢量图。SVG是矢量图意味着SVG图片由直线和曲线以及绘制它们的方法组成。当放大SVG图片时，看到的还是线和曲线，而不会出现像素点。SVG图片在放大时，不会失真，所以它适合用来绘制Logo、Icon等。</p><p>（7）<strong>WebP</strong>是谷歌开发的一种新图片格式，WebP是同时支持有损和无损压缩的、使用直接色的点阵图。从名字就可以看出来它是为Web而生的，什么叫为Web而生呢？就是说相同质量的图片，WebP具有更小的文件体积。现在网站上充满了大量的图片，如果能够降低每一个图片的文件大小，那么将大大减少浏览器和服务器之间的数据传输量，进而降低访问延迟，提升访问体验。目前只有Chrome浏览器和Opera浏览器支持WebP格式，兼容性不太好。</p><ul><li>在无损压缩的情况下，相同质量的WebP图片，文件大小要比PNG小26%；</li><li>在有损压缩的情况下，具有相同图片精度的WebP图片，文件大小要比JPEG小25%~34%；</li><li>WebP图片格式支持图片透明度，一个无损压缩的WebP图片，如果要支持透明度只需要22%的格外文件大小。</li></ul><h3 id="17-对-CSSSprites-的理解"><a href="#17-对-CSSSprites-的理解" class="headerlink" title="17. 对 CSSSprites 的理解"></a>17. 对 CSSSprites 的理解</h3><p>CSSSprites（精灵图），将一个页面涉及到的所有图片都包含到一张大图中去，然后利用CSS的 background-image，background-repeat，background-position属性的组合进行背景定位。</p><p><strong>优点：</strong></p><ul><li>利用<code>CSS Sprites</code>能很好地减少网页的http请求，从而大大提高了页面的性能，这是<code>CSS Sprites</code>最大的优点；</li><li><code>CSS Sprites</code>能减少图片的字节，把3张图片合并成1张图片的字节总是小于这3张图片的字节总和。</li></ul><p><strong>缺点：</strong></p><ul><li>在图片合并时，要把多张图片有序的、合理的合并成一张图片，还要留好足够的空间，防止板块内出现不必要的背景。在宽屏及高分辨率下的自适应页面，如果背景不够宽，很容易出现背景断裂；</li><li><code>CSSSprites</code>在开发的时候相对来说有点麻烦，需要借助<code>photoshop</code>或其他工具来对每个背景单元测量其准确的位置。</li><li>维护方面：<code>CSS Sprites</code>在维护的时候比较麻烦，页面背景有少许改动时，就要改这张合并的图片，无需改的地方尽量不要动，这样避免改动更多的<code>CSS</code>，如果在原来的地方放不下，又只能（最好）往下加图片，这样图片的字节就增加了，还要改动<code>CSS</code>。</li></ul><h3 id="18-什么是物理像素，逻辑像素和像素密度，为什么在移动端开发时需要用到-3x-2x这种图片？"><a href="#18-什么是物理像素，逻辑像素和像素密度，为什么在移动端开发时需要用到-3x-2x这种图片？" class="headerlink" title="18. 什么是物理像素，逻辑像素和像素密度，为什么在移动端开发时需要用到@3x, @2x这种图片？"></a>18. 什么是物理像素，逻辑像素和像素密度，为什么在移动端开发时需要用到@3x, @2x这种图片？</h3><p>以 iPhone XS 为例，当写 CSS 代码时，针对于单位 px，其宽度为 414px &amp; 896px，也就是说当赋予一个 DIV元素宽度为 414px，这个 DIV 就会填满手机的宽度；</p><p>而如果有一把尺子来实际测量这部手机的物理像素，实际为 1242*2688 物理像素；经过计算可知，1242/414=3，也就是说，在单边上，一个逻辑像素=3个物理像素，就说这个屏幕的像素密度为 3，也就是常说的 3 倍屏。</p><p>对于图片来说，为了保证其不失真，1 个图片像素至少要对应一个物理像素，假如原始图片是 500300 像素，那么在 3 倍屏上就要放一个 1500900 像素的图片才能保证 1 个物理像素至少对应一个图片像素，才能不失真。 <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5f1da1cbae9b45528cc2b33f74eb32f2~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img"> 当然，也可以针对所有屏幕，都只提供最高清图片。虽然低密度屏幕用不到那么多图片像素，而且会因为下载多余的像素造成带宽浪费和下载延迟，但从结果上说能保证图片在所有屏幕上都不会失真。</p><p>还可以使用 CSS 媒体查询来判断不同的像素密度，从而选择不同的图片:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">my-image &#123; <span class="attr">background</span>: (low.<span class="property">png</span>); &#125;</span><br><span class="line">@media only screen and (min-device-pixel-<span class="attr">ratio</span>: <span class="number">1.5</span>) &#123;</span><br><span class="line">  #my-image &#123; <span class="attr">background</span>: (high.<span class="property">png</span>); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="19-margin-和-padding-的使用场景"><a href="#19-margin-和-padding-的使用场景" class="headerlink" title="19. margin 和 padding 的使用场景"></a>19. <strong>margin 和 padding 的使用场景</strong></h3><ul><li>需要在border外侧添加空白，且空白处不需要背景（色）时，使用 margin；</li><li>需要在border内测添加空白，且空白处需要背景（色）时，使用 padding。</li></ul><h3 id="20-对line-height-的理解及其赋值方式"><a href="#20-对line-height-的理解及其赋值方式" class="headerlink" title="20. 对line-height 的理解及其赋值方式"></a>20. 对<strong>line-height 的理解及其赋值方式</strong></h3><p><strong>（1）line-height的概念：</strong></p><ul><li>line-height 指一行文本的高度，包含了字间距，实际上是下一行基线到上一行基线距离；</li><li>如果一个标签没有定义 height 属性，那么其最终表现的高度由 line-height 决定；</li><li>一个容器没有设置高度，那么撑开容器高度的是 line-height，而不是容器内的文本内容；</li><li>把 line-height 值设置为 height 一样大小的值可以实现单行文字的垂直居中；</li><li>line-height 和 height 都能撑开一个高度；</li></ul><p><strong>（2）line-height 的赋值方式：</strong></p><ul><li>带单位：px 是固定值，而 em 会参考父元素 font-size 值计算自身的行高</li><li>纯数字：会把比例传递给后代。例如，父级行高为 1.5，子元素字体为 18px，则子元素行高为 1.5 * 18 = 27px</li><li>百分比：将计算后的值传递给后代</li></ul><h3 id="21-CSS-优化和提高性能的方法有哪些？"><a href="#21-CSS-优化和提高性能的方法有哪些？" class="headerlink" title="21. CSS 优化和提高性能的方法有哪些？"></a>21. CSS 优化和提高性能的方法有哪些？</h3><p><strong>加载性能：</strong></p><p>（1）css压缩：将写好的css进行打包压缩，可以减小文件体积。</p><p>（2）css单一样式：当需要下边距和左边距的时候，很多时候会选择使用 margin:top 0 bottom 0；但margin-bottom:bottom;margin-left:left;执行效率会更高。</p><p>（3）减少使用@import，建议使用link，因为后者在页面加载时一起加载，前者是等待页面加载完成之后再进行加载。</p><p><strong>选择器性能：</strong></p><p>（1）关键选择器（key selector）。选择器的最后面的部分为关键选择器（即用来匹配目标元素的部分）。CSS选择符是从右到左进行匹配的。当使用后代选择器的时候，浏览器会遍历所有子元素来确定是否是指定的元素等等；</p><p>（2）如果规则拥有ID选择器作为其关键选择器，则不要为规则增加标签。过滤掉无关的规则（这样样式系统就不会浪费时间去匹配它们了）。</p><p>（3）避免使用通配规则，如*{}计算次数惊人，只对需要用到的元素进行选择。</p><p>（4）尽量少的去对标签进行选择，而是用class。</p><p>（5）尽量少的去使用后代选择器，降低选择器的权重值。后代选择器的开销是最高的，尽量将选择器的深度降到最低，最高不要超过三层，更多的使用类来关联每一个标签元素。</p><p>（6）了解哪些属性是可以通过继承而来的，然后避免对这些属性重复指定规则。</p><p><strong>渲染性能：</strong></p><p>（1）慎重使用高性能属性：浮动、定位。</p><p>（2）尽量减少页面重排、重绘。</p><p>（3）去除空规则：｛｝。空规则的产生原因一般来说是为了预留样式。去除这些空规则无疑能减少css文档体积。</p><p>（4）属性值为0时，不加单位。</p><p>（5）属性值为浮动小数0.**，可以省略小数点之前的0。</p><p>（6）标准化各种浏览器前缀：带浏览器前缀的在前。标准属性在后。</p><p>（7）不使用@import前缀，它会影响css的加载速度。</p><p>（8）选择器优化嵌套，尽量避免层级过深。</p><p>（9）css雪碧图，同一页面相近部分的小图标，方便使用，减少页面的请求次数，但是同时图片本身会变大，使用时，优劣考虑清楚，再使用。</p><p>（10）正确使用display的属性，由于display的作用，某些样式组合会无效，徒增样式体积的同时也影响解析性能。</p><p>（11）不滥用web字体。对于中文网站来说WebFonts可能很陌生，国外却很流行。web fonts通常体积庞大，而且一些浏览器在下载web fonts时会阻塞页面渲染损伤性能。</p><p><strong>可维护性、健壮性：</strong></p><p>（1）将具有相同属性的样式抽离出来，整合并通过class在页面中进行使用，提高css的可维护性。</p><p>（2）样式与内容分离：将css代码定义到外部css中。</p><h3 id="22-CSS预处理器-后处理器是什么？为什么要使用它们？"><a href="#22-CSS预处理器-后处理器是什么？为什么要使用它们？" class="headerlink" title="22. CSS预处理器/后处理器是什么？为什么要使用它们？"></a>22. CSS预处理器/后处理器是什么？为什么要使用它们？</h3><p><strong>预处理器，</strong> 如：<code>less</code>，<code>sass</code>，<code>stylus</code>，用来预编译<code>sass</code>或者<code>less</code>，增加了<code>css</code>代码的复用性。层级，<code>mixin</code>， 变量，循环， 函数等对编写以及开发UI组件都极为方便。</p><p><strong>后处理器，</strong> 如： <code>postCss</code>，通常是在完成的样式表中根据<code>css</code>规范处理<code>css</code>，让其更加有效。目前最常做的是给<code>css</code>属性添加浏览器私有前缀，实现跨浏览器兼容性的问题。</p><p><code>css</code>预处理器为<code>css</code>增加一些编程特性，无需考虑浏览器的兼容问题，可以在<code>CSS</code>中使用变量，简单的逻辑程序，函数等在编程语言中的一些基本的性能，可以让<code>css</code>更加的简洁，增加适应性以及可读性，可维护性等。</p><p>其它<code>css</code>预处理器语言：<code>Sass（Scss）</code>, <code>Less</code>, <code>Stylus</code>, <code>Turbine</code>, <code>Swithch css</code>, <code>CSS Cacheer</code>, <code>DT Css</code>。</p><p>使用原因：</p><ul><li>结构清晰， 便于扩展</li><li>可以很方便的屏蔽浏览器私有语法的差异</li><li>可以轻松实现多重继承</li><li>完美的兼容了<code>CSS</code>代码，可以应用到老项目中</li></ul><h3 id="23-before-和-after-的双冒号和单冒号有什么区别？"><a href="#23-before-和-after-的双冒号和单冒号有什么区别？" class="headerlink" title="23. ::before 和 :after 的双冒号和单冒号有什么区别？"></a>23. ::before 和 :after 的双冒号和单冒号有什么区别？</h3><p>（1）冒号(<code>:</code>)用于<code>CSS3</code>伪类，双冒号(<code>::</code>)用于<code>CSS3</code>伪元素。 （2）<code>::before</code>就是以一个子元素的存在，定义在元素主体内容之前的一个伪元素。并不存在于<code>dom</code>之中，只存在在页面之中。</p><p><strong>注意：</strong> <code>:before </code>和 <code>:after</code> 这两个伪元素，是在<code>CSS2.1</code>里新出现的。起初，伪元素的前缀使用的是单冒号语法，但随着<code>Web</code>的进化，在<code>CSS3</code>的规范里，伪元素的语法被修改成使用双冒号，成为<code>::before</code>、<code>::after</code>。</p><h3 id="24-display-inline-block-什么时候会显示间隙？"><a href="#24-display-inline-block-什么时候会显示间隙？" class="headerlink" title="24. display:inline-block 什么时候会显示间隙？"></a>24. display:inline-block 什么时候会显示间隙？</h3><ul><li>有空格时会有间隙，可以删除空格解决；</li><li><code>margin</code>正值时，可以让<code>margin</code>使用负值解决；</li><li>使用<code>font-size</code>时，可通过设置<code>font-size:0</code>、<code>letter-spacing</code>、<code>word-spacing</code>解决；</li></ul><h3 id="25-单行、多行文本溢出隐藏"><a href="#25-单行、多行文本溢出隐藏" class="headerlink" title="25. 单行、多行文本溢出隐藏"></a>25. 单行、多行文本溢出隐藏</h3><ul><li>单行文本溢出</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">overflow</span>: hidden;            // 溢出隐藏</span><br><span class="line"><span class="attribute">text-overflow</span>: ellipsis;      // 溢出用省略号显示</span><br><span class="line"><span class="attribute">white-space</span>: nowrap;         // 规定段落中的文本不进行换行</span><br></pre></td></tr></table></figure><ul><li>多行文本溢出</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">overflow</span>: hidden;            // 溢出隐藏</span><br><span class="line"><span class="attribute">text-overflow</span>: ellipsis;     // 溢出用省略号显示</span><br><span class="line"><span class="attribute">display</span>:-webkit-box;         // 作为弹性伸缩盒子模型显示。</span><br><span class="line">-webkit-box-orient:vertical; // 设置伸缩盒子的子元素排列方式：从上到下垂直排列</span><br><span class="line">-webkit-line-clamp:<span class="number">3</span>;        // 显示的行数</span><br></pre></td></tr></table></figure><p>注意：由于上面的三个属性都是 CSS3 的属性，没有浏览器可以兼容，所以要在前面加一个<code>-webkit-</code> 来兼容一部分浏览器。</p><h3 id="26-Sass、Less-是什么？为什么要使用他们？"><a href="#26-Sass、Less-是什么？为什么要使用他们？" class="headerlink" title="26. Sass、Less 是什么？为什么要使用他们？"></a>26. Sass、Less 是什么？为什么要使用他们？</h3><p>他们都是 CSS 预处理器，是 CSS 上的一种抽象层。他们是一种特殊的语法/语言编译成 CSS。 例如 Less 是一种动态样式语言，将 CSS 赋予了动态语言的特性，如变量，继承，运算， 函数，LESS 既可以在客户端上运行 (支持 IE 6+, Webkit, Firefox)，也可以在服务端运行 (借助 Node.js)。</p><p><strong>为什么要使用它们？</strong></p><ul><li>结构清晰，便于扩展。 可以方便地屏蔽浏览器私有语法差异。封装对浏览器语法差异的重复处理， 减少无意义的机械劳动。</li><li>可以轻松实现多重继承。 完全兼容 CSS 代码，可以方便地应用到老项目中。LESS 只是在 CSS 语法上做了扩展，所以老的 CSS 代码也可以与 LESS 代码一同编译。</li></ul><h3 id="27-对媒体查询的理解？"><a href="#27-对媒体查询的理解？" class="headerlink" title="27. 对媒体查询的理解？"></a>27. 对媒体查询的理解？</h3><p>媒体查询由⼀个可选的媒体类型和零个或多个使⽤媒体功能的限制了样式表范围的表达式组成，例如宽度、⾼度和颜⾊。媒体查询，添加⾃CSS3，允许内容的呈现针对⼀个特定范围的输出设备⽽进⾏裁剪，⽽不必改变内容本身，适合web⽹⻚应对不同型号的设备⽽做出对应的响应适配。</p><p>媒体查询包含⼀个可选的媒体类型和满⾜CSS3规范的条件下，包含零个或多个表达式，这些表达式描述了媒体特征，最终会被解析为true或false。如果媒体查询中指定的媒体类型匹配展示⽂档所使⽤的设备类型，并且所有的表达式的值都是true，那么该媒体查询的结果为true。那么媒体查询内的样式将会⽣效。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- link元素中的<span class="variable constant_">CSS</span>媒体查询 --&gt; </span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">media</span>=<span class="string">&quot;(max-width: 800px)&quot;</span> <span class="attr">href</span>=<span class="string">&quot;example.css&quot;</span> /&gt;</span></span> </span><br><span class="line">&lt;!-- 样式表中的<span class="variable constant_">CSS</span>媒体查询 --&gt; </span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"> </span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"><span class="keyword">@media</span> (<span class="attribute">max-width</span>: <span class="number">600px</span>) &#123; </span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">  <span class="selector-class">.facet_sidebar</span> &#123; </span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    <span class="attribute">display</span>: none; </span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">  &#125; </span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>简单来说，使用 @media 查询，可以针对不同的媒体类型定义不同的样式。@media 可以针对不同的屏幕尺寸设置不同的样式，特别是需要设置设计响应式的页面，@media 是非常有用的。当重置浏览器大小的过程中，页面也会根据浏览器的宽度和高度重新渲染页面。</p><h3 id="28-对-CSS-工程化的理解"><a href="#28-对-CSS-工程化的理解" class="headerlink" title="28. 对 CSS 工程化的理解"></a>28. 对 CSS 工程化的理解</h3><p>CSS 工程化是为了解决以下问题：</p><ol><li><strong>宏观设计</strong>：CSS 代码如何组织、如何拆分、模块结构怎样设计？</li><li><strong>编码优化</strong>：怎样写出更好的 CSS？</li><li><strong>构建</strong>：如何处理我的 CSS，才能让它的打包结果最优？</li><li><strong>可维护性</strong>：代码写完了，如何最小化它后续的变更成本？如何确保任何一个同事都能轻松接手？</li></ol><p>以下三个方向都是时下比较流行的、普适性非常好的 CSS 工程化实践：</p><ul><li>预处理器：Less、 Sass 等；</li><li>重要的工程化插件： PostCss；</li><li>Webpack loader 等 。</li></ul><p>基于这三个方向，可以衍生出一些具有典型意义的子问题，这里我们逐个来看：</p><p><strong>（1）预处理器：为什么要用预处理器？它的出现是为了解决什么问题？</strong></p><p>预处理器，其实就是 CSS 世界的“轮子”。预处理器支持我们写一种类似 CSS、但实际并不是 CSS 的语言，然后把它编译成 CSS 代码： <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3d58c5313e884e38b1545a5896613250~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img"> 那为什么写 CSS 代码写得好好的，偏偏要转去写“类 CSS”呢？这就和本来用 JS 也可以实现所有功能，但最后却写 React 的 jsx 或者 Vue 的模板语法一样——为了爽！要想知道有了预处理器有多爽，首先要知道的是传统 CSS 有多不爽。随着前端业务复杂度的提高，前端工程中对 CSS 提出了以下的诉求：</p><ol><li>宏观设计上：我们希望能优化 CSS 文件的目录结构，对现有的 CSS 文件实现复用；</li><li>编码优化上：我们希望能写出结构清晰、简明易懂的 CSS，需要它具有一目了然的嵌套层级关系，而不是无差别的一铺到底写法；我们希望它具有变量特征、计算能力、循环能力等等更强的可编程性，这样我们可以少写一些无用的代码；</li><li>可维护性上：更强的可编程性意味着更优质的代码结构，实现复用意味着更简单的目录结构和更强的拓展能力，这两点如果能做到，自然会带来更强的可维护性。</li></ol><p>这三点是传统 CSS 所做不到的，也正是预处理器所解决掉的问题。预处理器普遍会具备这样的特性：</p><ul><li>嵌套代码的能力，通过嵌套来反映不同 css 属性之间的层级关系 ；</li><li>支持定义 css 变量；</li><li>提供计算函数；</li><li>允许对代码片段进行 extend 和 mixin；</li><li>支持循环语句的使用；</li><li>支持将 CSS 文件模块化，实现复用。</li></ul><p><strong>（2）PostCss：PostCss 是如何工作的？我们在什么场景下会使用 PostCss？</strong></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2911f98bbacf4b1cbffbb9e1527a4977~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img"> 它和预处理器的不同就在于，预处理器处理的是 类CSS，而 PostCss 处理的就是 CSS 本身。Babel 可以将高版本的 JS 代码转换为低版本的 JS 代码。PostCss 做的是类似的事情：它可以编译尚未被浏览器广泛支持的先进的 CSS 语法，还可以自动为一些需要额外兼容的语法增加前缀。更强的是，由于 PostCss 有着强大的插件机制，支持各种各样的扩展，极大地强化了 CSS 的能力。</p><p>PostCss 在业务中的使用场景非常多：</p><ul><li>提高 CSS 代码的可读性：PostCss 其实可以做类似预处理器能做的工作；</li><li>当我们的 CSS 代码需要适配低版本浏览器时，PostCss 的 <a href="https://link.juejin.cn/?target=https://github.com/postcss/autoprefixer">Autoprefixer</a> 插件可以帮助我们自动增加浏览器前缀；</li><li>允许我们编写面向未来的 CSS：PostCss 能够帮助我们编译 CSS next 代码；</li></ul><p><strong>（3）Webpack 能处理 CSS 吗？如何实现？</strong> Webpack 能处理 CSS 吗：</p><ul><li><strong>Webpack 在裸奔的状态下，是不能处理 CSS 的</strong>，Webpack 本身是一个面向 JavaScript 且只能处理 JavaScript 代码的模块化打包工具；</li><li>Webpack 在 loader 的辅助下，是可以处理 CSS 的。</li></ul><p>如何用 Webpack 实现对 CSS 的处理：</p><ul><li>Webpack 中操作 CSS 需要使用的两个关键的 loader：css-loader 和 style-loader</li><li>注意，答出“用什么”有时候可能还不够，面试官会怀疑你是不是在背答案，所以你还需要了解每个 loader 都做了什么事情：<ul><li>css-loader：导入 CSS 模块，对 CSS 代码进行编译处理；</li><li>style-loader：创建style标签，把 CSS 内容写入标签。</li></ul></li></ul><p>在实际使用中，<strong>css-loader 的执行顺序一定要安排在 style-loader 的前面</strong>。因为只有完成了编译过程，才可以对 css 代码进行插入；若提前插入了未编译的代码，那么 webpack 是无法理解这坨东西的，它会无情报错。</p><h3 id="29-如何判断元素是否到达可视区域"><a href="#29-如何判断元素是否到达可视区域" class="headerlink" title="29. 如何判断元素是否到达可视区域"></a>29. 如何判断元素是否到达可视区域</h3><p>以图片显示为例：</p><ul><li><code>window.innerHeight</code> 是浏览器可视区的高度；</li><li><code>document.body.scrollTop || document.documentElement.scrollTop</code> 是浏览器滚动的过的距离；</li><li><code>imgs.offsetTop</code> 是元素顶部距离文档顶部的高度（包括滚动条的距离）；</li><li>内容达到显示区域的：<code>img.offsetTop &lt; window.innerHeight + document.body.scrollTop;</code></li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c57fc165a4ce4d5b9a2885867d4f1cab~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img"></p><h3 id="30-z-index属性在什么情况下会失效"><a href="#30-z-index属性在什么情况下会失效" class="headerlink" title="30. z-index属性在什么情况下会失效"></a>30. z-index属性在什么情况下会失效</h3><p>通常 z-index 的使用是在有两个重叠的标签，在一定的情况下控制其中一个在另一个的上方或者下方出现。z-index值越大就越是在上层。z-index元素的position属性需要是relative，absolute或是fixed。</p><p>z-index属性在下列情况下会失效：</p><ul><li>父元素position为relative时，子元素的z-index失效。解决：父元素position改为absolute或static；</li><li>元素没有设置position属性为非static属性。解决：设置该元素的position属性为relative，absolute或是fixed中的一种；</li><li>元素在设置z-index的同时还设置了float浮动。解决：float去除，改为display：inline-block；</li></ul><h3 id="31-CSS3中的transform有哪些属性"><a href="#31-CSS3中的transform有哪些属性" class="headerlink" title="31. CSS3中的transform有哪些属性"></a>31. CSS3中的transform有哪些属性</h3><h2 id="二、页面布局"><a href="#二、页面布局" class="headerlink" title="二、页面布局"></a>二、页面布局</h2><h3 id="1-常见的CSS布局单位"><a href="#1-常见的CSS布局单位" class="headerlink" title="1. 常见的CSS布局单位"></a>1. 常见的CSS布局单位</h3><p>常用的布局单位包括像素（<code>px</code>），百分比（<code>%</code>），<code>em</code>，<code>rem</code>，<code>vw/vh</code>。</p><p><strong>（1）像素</strong>（<code>px</code>）是页面布局的基础，一个像素表示终端（电脑、手机、平板等）屏幕所能显示的最小的区域，像素分为两种类型：CSS像素和物理像素：</p><ul><li><strong>CSS像素</strong>：为web开发者提供，在CSS中使用的一个抽象单位；</li><li><strong>物理像素</strong>：只与设备的硬件密度有关，任何设备的物理像素都是固定的。</li></ul><p><strong>（2）百分比</strong>（<code>%</code>），当浏览器的宽度或者高度发生变化时，通过百分比单位可以使得浏览器中的组件的宽和高随着浏览器的变化而变化，从而实现响应式的效果。一般认为子元素的百分比相对于直接父元素。</p><p><strong>（3）em和rem</strong>相对于px更具灵活性，它们都是相对长度单位，它们之间的区别：<strong>em相对于父元素，rem相对于根元素。</strong></p><ul><li><strong>em：</strong> 文本相对长度单位。相对于当前对象内文本的字体尺寸。如果当前行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸(默认16px)。(相对父元素的字体大小倍数)。</li><li><strong>rem：</strong> rem是CSS3新增的一个相对单位，相对于根元素（html元素）的font-size的倍数。<strong>作用</strong>：利用rem可以实现简单的响应式布局，可以利用html元素中字体的大小与屏幕间的比值来设置font-size的值，以此实现当屏幕分辨率变化时让元素也随之变化。</li></ul><p><strong>（4）vw/vh</strong>是与视图窗口有关的单位，vw表示相对于视图窗口的宽度，vh表示相对于视图窗口高度，除了vw和vh外，还有vmin和vmax两个相关的单位。</p><ul><li>vw：相对于视窗的宽度，视窗宽度是100vw；</li><li>vh：相对于视窗的高度，视窗高度是100vh；</li><li>vmin：vw和vh中的较小值；</li><li>vmax：vw和vh中的较大值；</li></ul><p><strong>vw/vh</strong> 和百分比很类似，两者的区别：</p><ul><li>百分比（<code>%</code>）：大部分相对于祖先元素，也有相对于自身的情况比如（border-radius、translate等)</li><li>vw/vm：相对于视窗的尺寸</li></ul><h3 id="2-px、em、rem的区别及使用场景"><a href="#2-px、em、rem的区别及使用场景" class="headerlink" title="2. px、em、rem的区别及使用场景"></a>2. px、em、rem的区别及使用场景</h3><p><strong>三者的区别：</strong></p><ul><li>px是固定的像素，一旦设置了就无法因为适应页面大小而改变。</li><li>em和rem相对于px更具有灵活性，他们是相对长度单位，其长度不是固定的，更适用于响应式布局。</li><li>em是相对于其父元素来设置字体大小，这样就会存在一个问题，进行任何元素设置，都有可能需要知道他父元素的大小。而rem是相对于根元素，这样就意味着，只需要在根元素确定一个参考值。</li></ul><p><strong>使用场景：</strong></p><ul><li>对于只需要适配少部分移动设备，且分辨率对页面影响不大的，使用px即可 。</li><li>对于需要适配各种移动设备，使用rem，例如需要适配iPhone和iPad等分辨率差别比较挺大的设备。</li></ul><h3 id="3-两栏布局的实现"><a href="#3-两栏布局的实现" class="headerlink" title="3. 两栏布局的实现"></a>3. 两栏布局的实现</h3><p>一般两栏布局指的是<strong>左边一栏宽度固定，右边一栏宽度自适应</strong>，两栏布局的具体实现：</p><ul><li>利用浮动，将左边元素宽度设置为200px，并且设置向左浮动。将右边元素的margin-left设置为200px，宽度设置为auto（默认为auto，撑满整个父元素）。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background</span>: tomato;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">width</span>: auto;</span><br><span class="line">  <span class="attribute">background</span>: gold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>利用浮动，左侧元素设置固定大小，并左浮动，右侧元素设置overflow: hidden; 这样右边就触发了BFC，BFC的区域不会与浮动元素发生重叠，所以两侧就不会发生重叠。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.left</span>&#123;</span><br><span class="line">     <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">     <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">     <span class="attribute">background</span>: red;</span><br><span class="line">     <span class="attribute">float</span>: left;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="selector-class">.right</span>&#123;</span><br><span class="line">     <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">     <span class="attribute">background</span>: blue;</span><br><span class="line">     <span class="attribute">overflow</span>: hidden;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ul><li>利用flex布局，将左边元素设置为固定宽度200px，将右边的元素设置为flex:1。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background</span>: tomato;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">background</span>: gold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>利用绝对定位，将父级元素设置为相对定位。左边元素设置为absolute定位，并且宽度设置为200px。将右边元素的margin-left的值设置为200px。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: tomato;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background</span>: gold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>利用绝对定位，将父级元素设置为相对定位。左边元素宽度设置为200px，右边元素设置为绝对定位，左边定位为200px，其余方向定位为0。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background</span>: tomato;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background</span>: gold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-三栏布局的实现"><a href="#4-三栏布局的实现" class="headerlink" title="4. 三栏布局的实现"></a>4. 三栏布局的实现</h3><p>三栏布局一般指的是页面中一共有三栏，<strong>左右两栏宽度固定，中间自适应的布局</strong>，三栏布局的具体实现：</p><ul><li>利用<strong>绝对定位</strong>，左右两栏设置为绝对定位，中间设置对应方向大小的margin的值。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: tomato;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: gold;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.center</span> &#123;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">margin-right</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: lightgreen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>利用flex布局，左右两栏设置固定大小，中间一栏设置为flex:1。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: tomato;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: gold;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.center</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">background</span>: lightgreen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>利用浮动，左右两栏设置固定大小，并设置对应方向的浮动。中间一栏设置左右两个方向的margin值，注意这种方式<strong>，中间一栏必须放到最后：</strong></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: tomato;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: right;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: gold;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.center</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">margin-right</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background</span>: lightgreen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>圣杯布局，利用浮动和负边距来实现。父级元素设置左右的 padding，三列均设置向左浮动，中间一列放在最前面，宽度设置为父级元素的宽度，因此后面两列都被挤到了下一行，通过设置 margin 负值将其移动到上一行，再利用相对定位，定位到两边。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">padding-left</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">padding-right</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">left</span>: -<span class="number">100px</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">100%</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: tomato;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">200px</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">float</span>: right;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">200px</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: gold;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.center</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: lightgreen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>双飞翼布局，双飞翼布局相对于圣杯布局来说，左右位置的保留是通过中间列的 margin 值来实现的，而不是通过父元素的 padding 来实现的。本质上来说，也是通过浮动和外边距负值来实现的。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">100%</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: tomato;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">200px</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: gold;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.wrapper</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: lightgreen;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.center</span> &#123;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">margin-right</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-水平垂直居中的实现"><a href="#5-水平垂直居中的实现" class="headerlink" title="5. 水平垂直居中的实现"></a>5. 水平垂直居中的实现</h3><ul><li>利用绝对定位，先将元素的左上角通过top:50%和left:50%定位到页面的中心，然后再通过translate来调整元素的中心点到页面的中心。该方法需要<strong>考虑浏览器兼容问题。</strong></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;    <span class="attribute">position</span>: relative;&#125; <span class="selector-class">.child</span> &#123;    <span class="attribute">position</span>: absolute;    <span class="attribute">left</span>: <span class="number">50%</span>;    <span class="attribute">top</span>: <span class="number">50%</span>;    <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>,-<span class="number">50%</span>);&#125;</span><br></pre></td></tr></table></figure><ul><li>利用绝对定位，设置四个方向的值都为0，并将margin设置为auto，由于宽高固定，因此对应方向实现平分，可以实现水平和垂直方向上的居中。该方法适用于<strong>盒子有宽高</strong>的情况：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">margin</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>利用绝对定位，先将元素的左上角通过top:50%和left:50%定位到页面的中心，然后再通过margin负值来调整元素的中心点到页面的中心。该方法适用于<strong>盒子宽高已知</strong>的情况</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: -<span class="number">50px</span>;     <span class="comment">/* 自身 height 的一半 */</span></span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">50px</span>;    <span class="comment">/* 自身 width 的一半 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用flex布局，通过align-items:center和justify-content:center设置容器的垂直和水平方向上为居中对齐，然后它的子元素也可以实现垂直和水平的居中。该方法要<strong>考虑兼容的问题</strong>，该方法在移动端用的较多：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">justify-content</span>:center;</span><br><span class="line">    <span class="attribute">align-items</span>:center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-如何根据设计稿进行移动端适配？"><a href="#6-如何根据设计稿进行移动端适配？" class="headerlink" title="6. 如何根据设计稿进行移动端适配？"></a>6. 如何根据设计稿进行移动端适配？</h3><p>移动端适配主要有两个维度：</p><ul><li><strong>适配不同像素密度，</strong> 针对不同的像素密度，使用 CSS 媒体查询，选择不同精度的图片，以保证图片不会失真；</li><li><strong>适配不同屏幕大小，</strong> 由于不同的屏幕有着不同的逻辑像素大小，所以如果直接使用 px 作为开发单位，会使得开发的页面在某一款手机上可以准确显示，但是在另一款手机上就会失真。为了适配不同屏幕的大小，应按照比例来还原设计稿的内容。</li></ul><p>为了能让页面的尺寸自适应，可以使用 rem，em，vw，vh 等相对单位。</p><h3 id="7-对Flex布局的理解及其使用场景"><a href="#7-对Flex布局的理解及其使用场景" class="headerlink" title="7. 对Flex布局的理解及其使用场景"></a>7. 对Flex布局的理解及其使用场景</h3><p>Flex是FlexibleBox的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。任何一个容器都可以指定为Flex布局。行内元素也可以使用Flex布局。注意，设为Flex布局以后，<strong>子元素的float、clear和vertical-align属性将失效</strong>。采用Flex布局的元素，称为Flex容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称”项目”。容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis），项目默认沿水平主轴排列。</p><p>以下6个属性设置在<strong>容器上</strong>：</p><ul><li>flex-direction属性决定主轴的方向（即项目的排列方向）。</li><li>flex-wrap属性定义，如果一条轴线排不下，如何换行。</li><li>flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。</li><li>justify-content属性定义了项目在主轴上的对齐方式。</li><li>align-items属性定义项目在交叉轴上如何对齐。</li><li>align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</li></ul><p>以下6个属性设置在<strong>项目上</strong>：</p><ul><li>order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。</li><li>flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。</li><li>flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</li><li>flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。</li><li>flex属性是flex-grow，flex-shrink和flex-basis的简写，默认值为0 1 auto。</li><li>align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。</li></ul><p><strong>简单来说：</strong> flex布局是CSS3新增的一种布局方式，可以通过将一个元素的display属性值设置为flex从而使它成为一个flex容器，它的所有子元素都会成为它的项目。一个容器默认有两条轴：一个是水平的主轴，一个是与主轴垂直的交叉轴。可以使用flex-direction来指定主轴的方向。可以使用justify-content来指定元素在主轴上的排列方式，使用align-items来指定元素在交叉轴上的排列方式。还可以使用flex-wrap来规定当一行排列不下时的换行方式。对于容器中的项目，可以使用order属性来指定项目的排列顺序，还可以使用flex-grow来指定当排列空间有剩余的时候，项目的放大比例，还可以使用flex-shrink来指定当排列空间不足时，项目的缩小比例。</p><h3 id="8-响应式设计的概念及基本原理"><a href="#8-响应式设计的概念及基本原理" class="headerlink" title="8. 响应式设计的概念及基本原理"></a>8. 响应式设计的概念及基本原理</h3><p>响应式网站设计<code>（Responsive Web design</code>）是一个网站能够兼容多个终端，而不是为每一个终端做一个特定的版本。</p><p>关于原理： 基本原理是通过媒体查询<code>（@media）</code>查询检测不同的设备屏幕尺寸做处理。 关于兼容： 页面头部必须有mate声明的<code>viewport</code>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;’viewport’&quot;</span> <span class="attr">content</span>=<span class="string">&quot;”width=device-width,&quot;</span> <span class="attr">initial-scale</span>=<span class="string">&quot;1.&quot;</span> <span class="attr">maximum-scale</span>=<span class="string">&quot;1,user-scalable=no”&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h2 id="三、定位与浮动"><a href="#三、定位与浮动" class="headerlink" title="三、定位与浮动"></a>三、定位与浮动</h2><h3 id="1-为什么需要清除浮动？清除浮动的方式"><a href="#1-为什么需要清除浮动？清除浮动的方式" class="headerlink" title="1. 为什么需要清除浮动？清除浮动的方式"></a>1. 为什么需要清除浮动？清除浮动的方式</h3><p><strong>浮动的定义：</strong> 非IE浏览器下，容器不设高度且子元素浮动时，容器高度不能被内容撑开。 此时，内容会溢出到容器外面而影响布局。这种现象被称为浮动（溢出）。</p><p><strong>浮动的工作原理：</strong></p><ul><li>浮动元素脱离文档流，不占据空间（引起“高度塌陷”现象）</li><li>浮动元素碰到包含它的边框或者其他浮动元素的边框停留</li></ul><p>浮动元素可以左右移动，直到遇到另一个浮动元素或者遇到它外边缘的包含框。浮动框不属于文档流中的普通流，当元素浮动之后，不会影响块级元素的布局，只会影响内联元素布局。此时文档流中的普通流就会表现得该浮动框不存在一样的布局模式。当包含框的高度小于浮动框的时候，此时就会出现“高度塌陷”。</p><p><strong>浮动元素引起的问题？</strong></p><ul><li>父元素的高度无法被撑开，影响与父元素同级的元素</li><li>与浮动元素同级的非浮动元素会跟随其后</li><li>若浮动的元素不是第一个元素，则该元素之前的元素也要浮动，否则会影响页面的显示结构</li></ul><p><strong>清除浮动的方式如下：</strong></p><ul><li>给父级div定义<code>height</code>属性</li><li>最后一个浮动元素之后添加一个空的div标签，并添加<code>clear:both</code>样式</li><li>包含浮动元素的父级标签添加<code>overflow:hidden</code>或者<code>overflow:auto</code></li><li>使用 :after 伪元素。由于IE6-7不支持 :after，使用 zoom:1 触发 hasLayout**</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span>&#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&quot;\200B&quot;</span>;</span><br><span class="line">    <span class="attribute">display</span>: table; </span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">clear</span>: both;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.clearfix</span>&#123;</span><br><span class="line">    *zoom: <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="2-使用-clear-属性清除浮动的原理？"><a href="#2-使用-clear-属性清除浮动的原理？" class="headerlink" title="2. 使用 clear 属性清除浮动的原理？"></a>2. 使用 clear 属性清除浮动的原理？</h3><p>使用clear属性清除浮动，其语法如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">clear</span>:none|left|right|both</span><br></pre></td></tr></table></figure><p>如果单看字面意思，clear:left 是“清除左浮动”，clear:right 是“清除右浮动”，实际上，这种解释是有问题的，因为浮动一直还在，并没有清除。</p><p>官方对clear属性解释：“<strong>元素盒子的边不能和前面的浮动元素相邻</strong>”，对元素设置clear属性是为了避免浮动元素对该元素的影响，而不是清除掉浮动。</p><p>还需要注意 clear 属性指的是元素盒子的边不能和前面的浮动元素相邻，注意这里“<strong>前面的</strong>”3个字，也就是clear属性对“后面的”浮动元素是不闻不问的。考虑到float属性要么是left，要么是right，不可能同时存在，同时由于clear属性对“后面的”浮动元素不闻不问，因此，当clear:left有效的时候，clear:right必定无效，也就是此时clear:left等同于设置clear:both；同样地，clear:right如果有效也是等同于设置clear:both。由此可见，clear:left和clear:right这两个声明就没有任何使用的价值，至少在CSS世界中是如此，直接使用clear:both吧。</p><p>一般使用伪元素的方式清除浮动：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clear</span><span class="selector-pseudo">::after</span>&#123;  <span class="attribute">content</span>:<span class="string">&#x27;&#x27;</span>;  <span class="attribute">display</span>: block;   <span class="attribute">clear</span>:both;&#125;</span><br></pre></td></tr></table></figure><p>clear属性只有块级元素才有效的，而::after等伪元素默认都是内联水平，这就是借助伪元素清除浮动影响时需要设置display属性值的原因。</p><h3 id="3-对BFC的理解，如何创建BFC"><a href="#3-对BFC的理解，如何创建BFC" class="headerlink" title="3. 对BFC的理解，如何创建BFC"></a>3. 对BFC的理解，如何创建BFC</h3><p>先来看两个相关的概念：</p><ul><li>Box: Box 是 CSS 布局的对象和基本单位，⼀个⻚⾯是由很多个 Box 组成的，这个Box就是我们所说的盒模型。</li><li>Formatting context：块级上下⽂格式化，它是⻚⾯中的⼀块渲染区域，并且有⼀套渲染规则，它决定了其⼦元素将如何定位，以及和其他元素的关系和相互作⽤。</li></ul><p>块格式化上下文（Block Formatting Context，BFC）是Web页面的可视化CSS渲染的一部分，是布局过程中生成块级盒子的区域，也是浮动元素与其他元素的交互限定区域。</p><p>通俗来讲：BFC是一个独立的布局环境，可以理解为一个容器，在这个容器中按照一定规则进行物品摆放，并且不会影响其它环境中的物品。如果一个元素符合触发BFC的条件，则BFC中的元素布局不受外部影响。</p><p><strong>创建BFC的条件：</strong></p><ul><li>根元素：body；</li><li>元素设置浮动：float 除 none 以外的值；</li><li>元素设置绝对定位：position (absolute、fixed)；</li><li>display 值为：inline-block、table-cell、table-caption、flex等；</li><li>overflow 值为：hidden、auto、scroll；</li></ul><p><strong>BFC的特点：</strong></p><ul><li>垂直方向上，自上而下排列，和文档流的排列方式一致。</li><li>在BFC中上下相邻的两个容器的margin会重叠</li><li>计算BFC的高度时，需要计算浮动元素的高度</li><li>BFC区域不会与浮动的容器发生重叠</li><li>BFC是独立的容器，容器内部元素不会影响外部元素</li><li>每个元素的左margin值和容器的左border相接触</li></ul><p><strong>BFC的作用：</strong></p><ul><li><strong>解决margin的重叠问题</strong>：由于BFC是一个独立的区域，内部的元素和外部的元素互不影响，将两个元素变为两个BFC，就解决了margin重叠的问题。</li><li><strong>解决高度塌陷的问题</strong>：在对子元素设置浮动后，父元素会发生高度塌陷，也就是父元素的高度变为0。解决这个问题，只需要把父元素变成一个BFC。常用的办法是给父元素设置<code>overflow:hidden</code>。</li><li><strong>创建自适应两栏布局</strong>：可以用来创建自适应两栏布局：左边的宽度固定，右边的宽度自适应。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.left</span>&#123;</span><br><span class="line">     <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">     <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">     <span class="attribute">background</span>: red;</span><br><span class="line">     <span class="attribute">float</span>: left;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="selector-class">.right</span>&#123;</span><br><span class="line">     <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">     <span class="attribute">background</span>: blue;</span><br><span class="line">     <span class="attribute">overflow</span>: hidden;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">&lt;<span class="selector-tag">div</span> class=&quot;<span class="attribute">left</span>&quot;&gt;&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">&lt;<span class="selector-tag">div</span> class=&quot;<span class="attribute">right</span>&quot;&gt;&lt;/<span class="selector-tag">div</span>&gt;</span><br></pre></td></tr></table></figure><p>左侧设置<code>float:left</code>，右侧设置<code>overflow: hidden</code>。这样右边就触发了BFC，BFC的区域不会与浮动元素发生重叠，所以两侧就不会发生重叠，实现了自适应两栏布局。</p><h3 id="4-什么是margin重叠问题？如何解决？"><a href="#4-什么是margin重叠问题？如何解决？" class="headerlink" title="4. 什么是margin重叠问题？如何解决？"></a>4. 什么是margin重叠问题？如何解决？</h3><p><strong>问题描述：</strong> 两个块级元素的上外边距和下外边距可能会合并（折叠）为一个外边距，其大小会取其中外边距值大的那个，这种行为就是外边距折叠。需要注意的是，<strong>浮动的元素和绝对定位</strong>这种脱离文档流的元素的外边距不会折叠。重叠只会出现在<strong>垂直方向</strong>。</p><p><strong>计算原则：</strong> 折叠合并后外边距的计算原则如下：</p><ul><li>如果两者都是正数，那么就去最大者</li><li>如果是一正一负，就会正值减去负值的绝对值</li><li>两个都是负值时，用0减去两个中绝对值大的那个</li></ul><p><strong>解决办法：</strong> 对于折叠的情况，主要有两种：<strong>兄弟之间重叠</strong>和<strong>父子之间重叠</strong> （1）兄弟之间重叠</p><ul><li>底部元素变为行内盒子：<code>display: inline-block</code></li><li>底部元素设置浮动：<code>float</code></li><li>底部元素的position的值为<code>absolute/fixed</code></li></ul><p>（2）父子之间重叠</p><ul><li>父元素加入：<code>overflow: hidden</code></li><li>父元素添加透明边框：<code>border:1px solid transparent</code></li><li>子元素变为行内盒子：<code>display: inline-block</code></li><li>子元素加入浮动属性或定位</li></ul><h3 id="5-元素的层叠顺序"><a href="#5-元素的层叠顺序" class="headerlink" title="5. 元素的层叠顺序"></a>5. 元素的层叠顺序</h3><p>层叠顺序，英文称作 stacking order，表示元素发生层叠时有着特定的垂直显示顺序。下面是盒模型的层叠规则： <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fbc59ae1adb5454c8c7f60582df10ff9~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img"> 对于上图，由上到下分别是： （1）背景和边框：建立当前层叠上下文元素的背景和边框。 （2）负的z-index：当前层叠上下文中，z-index属性值为负的元素。 （3）块级盒：文档流内非行内级非定位后代元素。 （4）浮动盒：非定位浮动元素。 （5）行内盒：文档流内行内级非定位后代元素。 （6）z-index:0：层叠级数为0的定位元素。 （7）正z-index：z-index属性值为正的定位元素。</p><p><strong>注意:</strong> 当定位元素z-index:auto，生成盒在当前层叠上下文中的层级为 0，不会建立新的层叠上下文，除非是根元素。</p><h3 id="6-position的属性有哪些，区别是什么"><a href="#6-position的属性有哪些，区别是什么" class="headerlink" title="6. position的属性有哪些，区别是什么"></a>6. position的属性有哪些，区别是什么</h3><p>position有以下属性值：</p><table><thead><tr><th>属性值</th><th>概述</th></tr></thead><tbody><tr><td>absolute</td><td>生成绝对定位的元素，相对于static定位以外的一个父元素进行定位。元素的位置通过left、top、right、bottom属性进行规定。</td></tr><tr><td>relative</td><td>生成相对定位的元素，相对于其原来的位置进行定位。元素的位置通过left、top、right、bottom属性进行规定。</td></tr><tr><td>fixed</td><td>生成绝对定位的元素，指定元素相对于屏幕视⼝（viewport）的位置来指定元素位置。元素的位置在屏幕滚动时不会改变，⽐如回到顶部的按钮⼀般都是⽤此定位⽅式。</td></tr><tr><td>static</td><td>默认值，没有定位，元素出现在正常的文档流中，会忽略 top, bottom, left, right 或者 z-index 声明，块级元素从上往下纵向排布，⾏级元素从左向右排列。</td></tr><tr><td>inherit</td><td>规定从父元素继承position属性的值</td></tr></tbody></table><p>前面三者的定位方式如下：</p><ul><li><strong>relative：</strong> 元素的定位永远是相对于元素自身位置的，和其他元素没关系，也不会影响其他元素。</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6523548b65834c578202acc5e6388af4~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img"></p><ul><li><strong>fixed：</strong> 元素的定位是相对于 window （或者 iframe）边界的，和其他元素没有关系。但是它具有破坏性，会导致其他元素位置的变化。</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4b35e646aa3c4d9cac803753d8b67c39~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img"></p><ul><li><strong>absolute：</strong> 元素的定位相对于前两者要复杂许多。如果为 absolute 设置了 top、left，浏览器会根据什么去确定它的纵向和横向的偏移量呢？答案是浏览器会递归查找该元素的所有父元素，如果找到一个设置了<code>position:relative/absolute/fixed</code>的元素，就以该元素为基准定位，如果没找到，就以浏览器边界定位。如下两个图所示：</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d6d4f199b3f842f090890eea32318e11~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img"> <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d2c7150bd7614a548f04a2919f1ea12a~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img"></p><h3 id="7-display、float、position的关系"><a href="#7-display、float、position的关系" class="headerlink" title="7. display、float、position的关系"></a>7. <strong>display、float、position的关系</strong></h3><p>（1）首先判断display属性是否为none，如果为none，则position和float属性的值不影响元素最后的表现。</p><p>（2）然后判断position的值是否为absolute或者fixed，如果是，则float属性失效，并且display的值应该被设置为table或者block，具体转换需要看初始转换值。</p><p>（3）如果position的值不为absolute或者fixed，则判断float属性的值是否为none，如果不是，则display的值则按上面的规则转换。注意，如果position的值为relative并且float属性的值存在，则relative相对于浮动后的最终位置定位。</p><p>（4）如果float的值为none，则判断元素是否为根元素，如果是根元素则display属性按照上面的规则转换，如果不是，则保持指定的display属性值不变。</p><p>总的来说，可以把它看作是一个类似优先级的机制，”position:absolute”和”position:fixed”优先级最高，有它存在的时候，浮动不起作用，’display’的值也需要调整；其次，元素的’float’特性的值不是”none”的时候或者它是根元素的时候，调整’display’的值；最后，非根元素，并且非浮动元素，并且非绝对定位的元素，’display’特性值同设置值。</p><h3 id="8-absolute与fixed共同点与不同点"><a href="#8-absolute与fixed共同点与不同点" class="headerlink" title="8. absolute与fixed共同点与不同点"></a>8. absolute与fixed共同点与不同点</h3><p><strong>共同点：</strong></p><ul><li>改变行内元素的呈现方式，将display置为inline-block </li><li>使元素脱离普通文档流，不再占据文档物理空间</li><li>覆盖非定位文档元素</li></ul><p><strong>不同点：</strong></p><ul><li>abuselute与fixed的根元素不同，abuselute的根元素可以设置，fixed根元素是浏览器。</li><li>在有滚动条的页面中，absolute会跟着父元素进行移动，fixed固定在页面的具体位置。</li></ul><h3 id="9-对-sticky-定位的理解"><a href="#9-对-sticky-定位的理解" class="headerlink" title="9. 对 sticky 定位的理解"></a>9. 对 sticky 定位的理解</h3><p>sticky 英文字面意思是粘贴，所以可以把它称之为粘性定位。语法：<strong>position: sticky;</strong> 基于用户的滚动位置来定位。</p><p>粘性定位的元素是依赖于用户的滚动，在 <strong>position:relative</strong> 与 <strong>position:fixed</strong> 定位之间切换。它的行为就像 <strong>position:relative;</strong> 而当页面滚动超出目标区域时，它的表现就像 **position:fixed;**，它会固定在目标位置。元素定位表现为在跨越特定阈值前为相对定位，之后为固定定位。这个特定阈值指的是 top, right, bottom 或 left 之一，换言之，指定 top, right, bottom 或 left 四个阈值其中之一，才可使粘性定位生效。否则其行为与相对定位相同。</p><h2 id="四、场景应用"><a href="#四、场景应用" class="headerlink" title="四、场景应用"></a>四、场景应用</h2><h3 id="1-实现一个三角形"><a href="#1-实现一个三角形" class="headerlink" title="1. 实现一个三角形"></a>1. 实现一个三角形</h3><p>CSS绘制三角形主要用到的是border属性，也就是边框。</p><p>平时在给盒子设置边框时，往往都设置很窄，就可能误以为边框是由矩形组成的。实际上，border属性是右三角形组成的，下面看一个例子：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">100px</span> solid;</span><br><span class="line">    <span class="attribute">border-color</span>: orange blue red green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将元素的长宽都设置为0，显示出来的效果是这样的： <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cba8731fea9842a8b8103c2b387fe64f~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img"> 所以可以根据border这个特性来绘制三角形： <strong>（1）三角1</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;    <span class="attribute">width</span>: <span class="number">0</span>;    <span class="attribute">height</span>: <span class="number">0</span>;    <span class="attribute">border-top</span>: <span class="number">50px</span> solid red;    <span class="attribute">border-right</span>: <span class="number">50px</span> solid transparent;    <span class="attribute">border-left</span>: <span class="number">50px</span> solid transparent;&#125;</span><br></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ab996951a0cc42cf9e6d9e12eb827f8b~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img"> <strong>（2）三角2</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">50px</span> solid red;</span><br><span class="line">    <span class="attribute">border-right</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-left</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/531c6c250dd8446fb0f264e7b3df6fba~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img"> <strong>（3）三角3</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border-left</span>: <span class="number">50px</span> solid red;</span><br><span class="line">    <span class="attribute">border-top</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e4beaf4e4a0140ad9e7252f8a6e4e8e6~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img"> <strong>（4）三角4</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border-right</span>: <span class="number">50px</span> solid red;</span><br><span class="line">    <span class="attribute">border-top</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/445f50ad19164b0f863ad8dfef2a29b1~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img"> <strong>（5）三角5</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border-top</span>: <span class="number">100px</span> solid red;</span><br><span class="line">    <span class="attribute">border-right</span>: <span class="number">100px</span> solid transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a1ac630463164e42a027b54bb95f56ba~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img"> 还有很多，就不一一实现了，总体的原则就是通过上下左右边框来控制三角形的方向，用边框的宽度比来控制三角形的角度。</p><h3 id="2-实现一个扇形"><a href="#2-实现一个扇形" class="headerlink" title="2. 实现一个扇形"></a>2. 实现一个扇形</h3><p>用CSS实现扇形的思路和三角形基本一致，就是多了一个圆角的样式，实现一个90°的扇形：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">100px</span> solid transparent;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">    heigt: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">border-top-color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/db5e46aea0ce4805a0c2bbec2743546e~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img"></p><h3 id="3-实现一个宽高自适应的正方形"><a href="#3-实现一个宽高自适应的正方形" class="headerlink" title="3. 实现一个宽高自适应的正方形"></a>3. 实现一个宽高自适应的正方形</h3><ul><li>利用vw来实现：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.square</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">10%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">10vw</span>;</span><br><span class="line">  <span class="attribute">background</span>: tomato;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>利用元素的margin/padding百分比是相对父元素width的性质来实现：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.square</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">20%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding-top</span>: <span class="number">20%</span>;</span><br><span class="line">  <span class="attribute">background</span>: orange;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>利用子元素的margin-top的值来实现：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.square</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">30%</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  <span class="attribute">background</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.square</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">margin-top</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-画一条0-5px的线"><a href="#4-画一条0-5px的线" class="headerlink" title="4. 画一条0.5px的线"></a>4. 画一条0.5px的线</h3><ul><li><strong>采用transform: scale()的方式</strong>，该方法用来定义元素的2D 缩放转换：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">0.5</span>,<span class="number">0.5</span>);</span><br></pre></td></tr></table></figure><ul><li><strong>采用meta viewport的方式</strong></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; <span class="attribute">content</span>=&quot;<span class="attribute">width</span>=device-<span class="attribute">width</span>, initial-scale=<span class="number">0.5</span>, minimum-scale=<span class="number">0.5</span>, maximum-scale=<span class="number">0.5</span>&quot;/&gt;</span><br></pre></td></tr></table></figure><p>这样就能缩放到原来的0.5倍，如果是1px那么就会变成0.5px。viewport只针对于移动端，只在移动端上才能看到效果</p><h3 id="5-设置小于12px的字体"><a href="#5-设置小于12px的字体" class="headerlink" title="5. 设置小于12px的字体"></a>5. 设置小于12px的字体</h3><p>在谷歌下css设置字体大小为12px及以下时，显示都是一样大小，都是默认12px。</p><p><strong>解决办法：</strong></p><ul><li>使用Webkit的内核的-webkit-text-size-adjust的私有CSS属性来解决，只要加了-webkit-text-size-adjust:none;字体大小就不受限制了。但是chrome更新到27版本之后就不可以用了。所以高版本chrome谷歌浏览器已经不再支持-webkit-text-size-adjust样式，所以要使用时候慎用。</li><li>使用css3的transform缩放属性-webkit-transform:scale(0.5); 注意-webkit-transform:scale(0.75);收缩的是整个元素的大小，这时候，如果是内联元素，必须要将内联元素转换成块元素，可以使用display：block/inline-block/…；</li><li>使用图片：如果是内容固定不变情况下，使用将小于12px文字内容切出做图片，这样不影响兼容也不影响美观。</li></ul><h3 id="6-如何解决-1px-问题？"><a href="#6-如何解决-1px-问题？" class="headerlink" title="6. 如何解决 1px 问题？"></a>6. 如何解决 1px 问题？</h3><p>1px 问题指的是：在一些 <code>Retina屏幕</code> 的机型上，移动端页面的 1px 会变得很粗，呈现出不止 1px 的效果。原因很简单——CSS 中的 1px 并不能和移动设备上的 1px 划等号。它们之间的比例关系有一个专门的属性来描述：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.devicePixelRatio = 设备的物理像素 / CSS像素。</span><br></pre></td></tr></table></figure><p>打开 Chrome 浏览器，启动移动端调试模式，在控制台去输出这个 <code>devicePixelRatio</code> 的值。这里选中 iPhone6/7/8 这系列的机型，输出的结果就是2： <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a8af7dca29f84b7e9d1f94232713ef07~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img"> 这就意味着设置的 1px CSS 像素，在这个设备上实际会用 2 个物理像素单元来进行渲染，所以实际看到的一定会比 1px 粗一些。 <strong>解决1px 问题的三种思路：</strong></p><h4 id="思路一：直接写-0-5px"><a href="#思路一：直接写-0-5px" class="headerlink" title="思路一：直接写 0.5px"></a>思路一：直接写 0.5px</h4><p>如果之前 1px 的样式这样写：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">border</span>:<span class="number">1px</span> solid <span class="number">#333</span></span><br></pre></td></tr></table></figure><p>可以先在 JS 中拿到 window.devicePixelRatio 的值，然后把这个值通过 JSX 或者模板语法给到 CSS 的 data 里，达到这样的效果（这里用 JSX 语法做示范）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;container&quot;</span> data-device=&#123;&#123;<span class="variable language_">window</span>.<span class="property">devicePixelRatio</span>&#125;&#125;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>然后就可以在 CSS 中用属性选择器来命中 devicePixelRatio 为某一值的情况，比如说这里尝试命中 devicePixelRatio 为2的情况：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#container</span><span class="selector-attr">[data-device=<span class="string">&quot;2&quot;</span>]</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>:<span class="number">0.5px</span> solid <span class="number">#333</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接把 1px 改成 1/devicePixelRatio 后的值，这是目前为止最简单的一种方法。这种方法的缺陷在于兼容性不行，IOS 系统需要8及以上的版本，安卓系统则直接不兼容。</p><h4 id="思路二：伪元素先放大后缩小"><a href="#思路二：伪元素先放大后缩小" class="headerlink" title="思路二：伪元素先放大后缩小"></a>思路二：伪元素先放大后缩小</h4><p>这个方法的可行性会更高，兼容性也更好。唯一的缺点是代码会变多。</p><p>思路是<strong>先放大、后缩小：在目标元素的后面追加一个 ::after 伪元素，让这个元素布局为 absolute 之后、整个伸展开铺在目标元素上，然后把它的宽和高都设置为目标元素的两倍，border值设为 1px。接着借助 CSS 动画特效中的放缩能力，把整个伪元素缩小为原来的 50%。此时，伪元素的宽高刚好可以和原有的目标元素对齐，而 border 也缩小为了 1px 的二分之一，间接地实现了 0.5px 的效果。</strong></p><p>代码如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#container</span><span class="selector-attr">[data-device=<span class="string">&quot;2&quot;</span>]</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#container</span><span class="selector-attr">[data-device=<span class="string">&quot;2&quot;</span>]</span><span class="selector-pseudo">::after</span>&#123;</span><br><span class="line">      <span class="attribute">position</span>:absolute;</span><br><span class="line">      <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">      <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">      <span class="attribute">width</span>: <span class="number">200%</span>;</span><br><span class="line">      <span class="attribute">height</span>: <span class="number">200%</span>;</span><br><span class="line">      <span class="attribute">content</span>:<span class="string">&quot;&quot;</span>;</span><br><span class="line">      <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">0.5</span>);</span><br><span class="line">      <span class="attribute">transform-origin</span>: left top;</span><br><span class="line">      <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">      <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#333</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="思路三：viewport-缩放来解决"><a href="#思路三：viewport-缩放来解决" class="headerlink" title="思路三：viewport 缩放来解决"></a>思路三：viewport 缩放来解决</h4><p>这个思路就是对 meta 标签里几个关键属性下手：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;initial-scale=0.5, maximum-scale=0.5, minimum-scale=0.5, user-scalable=no&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里针对像素比为2的页面，把整个页面缩放为了原来的1/2大小。这样，本来占用2个物理像素的 1px 样式，现在占用的就是标准的一个物理像素。根据像素比的不同，这个缩放比例可以被计算为不同的值，用 js 代码实现如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> scale = <span class="number">1</span> / <span class="variable language_">window</span>.<span class="property">devicePixelRatio</span>;</span><br><span class="line"><span class="comment">// 这里 metaEl 指的是 meta 标签对应的 Dom</span></span><br><span class="line">metaEl.<span class="title function_">setAttribute</span>(<span class="string">&#x27;content&#x27;</span>, <span class="string">`width=device-width,user-scalable=no,initial-scale=<span class="subst">$&#123;scale&#125;</span>,maximum-scale=<span class="subst">$&#123;scale&#125;</span>,minimum-scale=<span class="subst">$&#123;scale&#125;</span>`</span>);</span><br></pre></td></tr></table></figure><p>这样解决了，但这样做的副作用也很大，整个页面被缩放了。这时 1px 已经被处理成物理像素大小，这样的大小在手机上显示边框很合适。但是，一些原本不需要被缩小的内容，比如文字、图片等，也被无差别缩小掉了。</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js面试手写</title>
      <link href="/posts/a09ef191.html"/>
      <url>/posts/a09ef191.html</url>
      
        <content type="html"><![CDATA[<p>js面试手写</p><span id="more"></span><h2 id="一、JavaScript-基础"><a href="#一、JavaScript-基础" class="headerlink" title="一、JavaScript 基础"></a>一、JavaScript 基础</h2><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230607140248211.png" alt="image-20230607140248211"></p><h3 id="1-手写-Object-create"><a href="#1-手写-Object-create" class="headerlink" title="1. 手写 Object.create"></a>1. 手写 Object.create</h3><p>思路：将传入的对象作为原型</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">create</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">F</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">  F.<span class="property"><span class="keyword">prototype</span></span> = obj</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">F</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-手写-instanceof-方法"><a href="#2-手写-instanceof-方法" class="headerlink" title="2. 手写 instanceof 方法"></a>2. 手写 instanceof 方法</h3><p>instanceof 运算符用于判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。</p><p>实现步骤：</p><ol><li>首先获取类型的原型</li><li>然后获得对象的原型</li><li>然后一直循环判断对象的原型是否等于类型的原型，直到对象原型为 <code>null</code>，因为原型链最终为 <code>null</code></li></ol><p>具体实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myInstanceof</span>(<span class="params">left, right</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> proto = <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(left), <span class="comment">// 获取对象的原型</span></span><br><span class="line">      prototype = right.<span class="property"><span class="keyword">prototype</span></span>; <span class="comment">// 获取构造函数的 prototype 对象</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断构造函数的 prototype 对象是否在对象的原型链上</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!proto) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (proto === prototype) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    proto = <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(proto);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-手写-new-操作符"><a href="#3-手写-new-操作符" class="headerlink" title="3. 手写 new 操作符"></a>3. 手写 new 操作符</h3><p>在调用 <code>new</code> 的过程中会发生以上四件事情：</p><p>（1）首先创建了一个新的空对象</p><p>（2）设置原型，将对象的原型设置为函数的 prototype 对象。</p><p>（3）让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）</p><p>（4）判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">objectFactory</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> newObject = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> constructor = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">shift</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>);</span><br><span class="line">  <span class="keyword">let</span> result = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 判断参数是否是一个函数</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> constructor !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;type error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 新建一个空对象，对象的原型为构造函数的 prototype 对象</span></span><br><span class="line">  newObject = <span class="title class_">Object</span>.<span class="title function_">create</span>(constructor.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line">  <span class="comment">// 将 this 指向新建对象，并执行函数</span></span><br><span class="line">  result = constructor.<span class="title function_">apply</span>(newObject, <span class="variable language_">arguments</span>);</span><br><span class="line">  <span class="comment">// 判断返回对象</span></span><br><span class="line">  <span class="keyword">let</span> flag = result &amp;&amp; (<span class="keyword">typeof</span> result === <span class="string">&quot;object&quot;</span> || <span class="keyword">typeof</span> result === <span class="string">&quot;function&quot;</span>);</span><br><span class="line">  <span class="comment">// 判断返回结果</span></span><br><span class="line">  <span class="keyword">return</span> flag ? result : newObject;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用方法</span></span><br><span class="line"><span class="title function_">objectFactory</span>(构造函数, 初始化参数);</span><br></pre></td></tr></table></figure><h3 id="4-手写-Promise"><a href="#4-手写-Promise" class="headerlink" title="4. 手写 Promise"></a>4. 手写 Promise</h3><h4 id="常见-Promise-面试题"><a href="#常见-Promise-面试题" class="headerlink" title="常见 Promise 面试题"></a>常见 Promise 面试题</h4><p>首先，我们以常见的 Promise 面试题为切入点，我们看看面试官们都爱考什么：</p><ol><li>Promise 解决了什么问题？</li><li>Promise 的业界实现都有哪些？</li><li>Promise 常用的 API 有哪些？</li><li>能不能手写一个符合 Promise/A+ 规范的 Promise?</li><li>Promise 在事件循环中的执行过程是怎样的？</li><li>Promise 有什么缺陷，可以如何解决？</li></ol><p>这几个问题由浅入深，我们一个一个来看：</p><h4 id="Promise-出现的原因-amp-业界实现"><a href="#Promise-出现的原因-amp-业界实现" class="headerlink" title="Promise 出现的原因 &amp; 业界实现"></a>Promise 出现的原因 &amp; 业界实现</h4><p>在 Promise 出现以前，在我们处理多个异步请求嵌套时，代码往往是这样的。。。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"></span><br><span class="line">fs.<span class="title function_">readFile</span>(<span class="string">&#x27;./name.txt&#x27;</span>,<span class="string">&#x27;utf8&#x27;</span>,<span class="keyword">function</span>(<span class="params">err,data</span>)&#123;</span><br><span class="line">  fs.<span class="title function_">readFile</span>(data, <span class="string">&#x27;utf8&#x27;</span>,<span class="keyword">function</span>(<span class="params">err,data</span>)&#123;</span><br><span class="line">    fs.<span class="title function_">readFile</span>(data,<span class="string">&#x27;utf8&#x27;</span>,<span class="keyword">function</span>(<span class="params">err,data</span>)&#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>为了拿到回调的结果，我们必须一层一层的嵌套，可以说是相当恶心了。而且基本上我们还要对每次请求的结果进行一系列的处理，使得代码变的更加难以阅读和难以维护，这就是传说中臭名昭著的<strong>回调地狱</strong>～产生<strong>回调地狱</strong>的原因归结起来有两点：</p><p>1.<strong>嵌套调用</strong>，第一个函数的输出往往是第二个函数的输入；</p><p>2.<strong>处理多个异步请求并发</strong>，开发时往往需要同步请求最终的结果。</p><p>原因分析出来后，那么问题的解决思路就很清晰了：</p><p>1.<strong>消灭嵌套调用</strong>：通过 Promise 的链式调用可以解决；</p><p>2.<strong>合并多个任务的请求结果</strong>：使用 Promise.all 获取合并多个任务的错误处理。</p><p>Promise 正是用一种更加友好的代码组织方式，解决了异步嵌套的问题。</p><p>我们来看看上面的例子用 Promise 实现是什么样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">read</span>(<span class="params">filename</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    fs.<span class="title function_">readFile</span>(filename, <span class="string">&#x27;utf8&#x27;</span>, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) <span class="title function_">reject</span>(err);</span><br><span class="line">      <span class="title function_">resolve</span>(data);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">read</span>(<span class="string">&#x27;./name.txt&#x27;</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">read</span>(data) </span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">read</span>(data)  </span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">&#125;,<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>臃肿的嵌套变得线性多了有木有？没错，他就是我们的异步神器 Promise！</p><p>让我们再次回归刚才的问题，<strong>Promise 为我们解决了什么问题？</strong>在传统的异步编程中，如果异步之间存在依赖关系，就需要通过层层嵌套回调的方式满足这种依赖，如果嵌套层数过多，可读性和可以维护性都会变得很差，产生所谓的“回调地狱”，而 Promise 将嵌套调用改为链式调用，增加了可阅读性和可维护性。也就是说，Promise 解决的是异步编码风格的问题。<strong>那 Promise 的业界实现都有哪些呢？</strong>业界比较著名的实现 Promise 的类库有 bluebird、Q、ES6-Promise。</p><h4 id="从零开始，手写-Promise"><a href="#从零开始，手写-Promise" class="headerlink" title="从零开始，手写 Promise"></a>从零开始，手写 Promise</h4><h5 id="Promise-A"><a href="#Promise-A" class="headerlink" title="Promise/A+"></a>Promise/A+</h5><p>我们想要手写一个 Promise，就要遵循 <a href="https://link.zhihu.com/?target=https://promisesaplus.com/">Promise/A+</a> 规范，业界所有 Promise 的类库都遵循这个规范。</p><p>其实 Promise/A+ 规范对如何实现一个符合标准的 Promise 类库已经阐述的很详细了。每一行代码在 Promise/A+ 规范中都有迹可循，所以在下面的实现的过程中，我会尽可能的将代码和 Promise/A+ 规范一一对应起来。</p><p>下面开始步入正题啦～</p><h4 id="基础版-Promise"><a href="#基础版-Promise" class="headerlink" title="基础版 Promise"></a>基础版 Promise</h4><p>我们先来回顾下最简单的 Promise 使用方式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;create a promise&#x27;</span>);</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&#x27;成功了&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;after new promise&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = p1.<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data)</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;失败了&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p3 = p2.<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;success&#x27;</span>, data)</span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;faild&#x27;</span>, err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>控制台输出：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;create a promise&quot;</span></span><br><span class="line"><span class="string">&quot;after new promise&quot;</span></span><br><span class="line"><span class="string">&quot;成功了&quot;</span></span><br><span class="line"><span class="string">&quot;faild Error: 失败了&quot;</span></span><br></pre></td></tr></table></figure><ul><li>首先我们在调用 Promise 时，会返回一个 Promise 对象。</li><li>构建 Promise 对象时，需要传入一个 <strong>executor 函数</strong>，Promise 的主要业务流程都在 executor 函数中执行。</li><li>如果运行在 excutor 函数中的业务执行成功了，会调用 resolve 函数；如果执行失败了，则调用 reject 函数。</li><li>Promise 的状态不可逆，同时调用 resolve 函数和 reject 函数，默认会采取第一次调用的结果。</li></ul><p>以上简单介绍了 Promise 的一些主要的使用方法，结合 <a href="https://link.zhihu.com/?target=https://promisesaplus.com/">Promise/A+</a> 规范，我们可以分析出 Promise 的基本特征：</p><ol><li>promise 有三个状态：<code>pending</code>，<code>fulfilled</code>，or <code>rejected</code>；「规范 Promise/A+ 2.1」</li><li><code>new promise</code>时， 需要传递一个<code>executor()</code>执行器，执行器立即执行；</li><li><code>executor</code>接受两个参数，分别是<code>resolve</code>和<code>reject</code>；</li><li>promise 的默认状态是 <code>pending</code>；</li><li>promise 有一个<code>value</code>保存成功状态的值，可以是<code>undefined/thenable/promise</code>；「规范 Promise/A+ 1.3」</li><li>promise 有一个<code>reason</code>保存失败状态的值；「规范 Promise/A+ 1.5」</li><li>promise 只能从<code>pending</code>到<code>rejected</code>, 或者从<code>pending</code>到<code>fulfilled</code>，状态一旦确认，就不会再改变；</li><li>promise 必须有一个<code>then</code>方法，then 接收两个参数，分别是 promise 成功的回调 onFulfilled, 和 promise 失败的回调 onRejected；「规范 Promise/A+ 2.2」</li><li>如果调用 then 时，promise 已经成功，则执行<code>onFulfilled</code>，参数是<code>promise</code>的<code>value</code>；</li><li>如果调用 then 时，promise 已经失败，那么执行<code>onRejected</code>, 参数是<code>promise</code>的<code>reason</code>；</li><li>如果 then 中抛出了异常，那么就会把这个异常作为参数，传递给下一个 then 的失败的回调<code>onRejected</code>；</li></ol><p>按照上面的特征，我们试着勾勒下 Promise 的形状：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 三个状态：PENDING、FULFILLED、REJECTED</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">PENDING</span> = <span class="string">&#x27;PENDING&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">FULFILLED</span> = <span class="string">&#x27;FULFILLED&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">REJECTED</span> = <span class="string">&#x27;REJECTED&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Promise</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">executor</span>) &#123;</span><br><span class="line">    <span class="comment">// 默认状态为 PENDING</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">status</span> = <span class="variable constant_">PENDING</span>;</span><br><span class="line">    <span class="comment">// 存放成功状态的值，默认为 undefined</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = <span class="literal">undefined</span>;</span><br><span class="line">    <span class="comment">// 存放失败状态的值，默认为 undefined</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">reason</span> = <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用此方法就是成功</span></span><br><span class="line">    <span class="keyword">let</span> <span class="title function_">resolve</span> = (<span class="params">value</span>) =&gt; &#123;</span><br><span class="line">      <span class="comment">// 状态为 PENDING 时才可以更新状态，防止 executor 中调用了两次 resovle/reject 方法</span></span><br><span class="line">      <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">status</span> ===  <span class="variable constant_">PENDING</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">status</span> = <span class="variable constant_">FULFILLED</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">value</span> = value;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用此方法就是失败</span></span><br><span class="line">    <span class="keyword">let</span> <span class="title function_">reject</span> = (<span class="params">reason</span>) =&gt; &#123;</span><br><span class="line">      <span class="comment">// 状态为 PENDING 时才可以更新状态，防止 executor 中调用了两次 resovle/reject 方法</span></span><br><span class="line">      <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">status</span> ===  <span class="variable constant_">PENDING</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">status</span> = <span class="variable constant_">REJECTED</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">reason</span> = reason;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 立即执行，将 resolve 和 reject 函数传给使用者  </span></span><br><span class="line">      <span class="title function_">executor</span>(resolve,reject)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      <span class="comment">// 发生异常时执行失败逻辑</span></span><br><span class="line">      <span class="title function_">reject</span>(error)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 包含一个 then 方法，并接收两个参数 onFulfilled、onRejected</span></span><br><span class="line">  <span class="title function_">then</span>(<span class="params">onFulfilled, onRejected</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">FULFILLED</span>) &#123;</span><br><span class="line">      <span class="title function_">onFulfilled</span>(<span class="variable language_">this</span>.<span class="property">value</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">REJECTED</span>) &#123;</span><br><span class="line">      <span class="title function_">onRejected</span>(<span class="variable language_">this</span>.<span class="property">reason</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写完代码我们可以测试一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&#x27;成功&#x27;</span>);</span><br><span class="line">&#125;).<span class="title function_">then</span>(</span><br><span class="line">  <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;success&#x27;</span>, data)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;faild&#x27;</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>控制台输出：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;success 成功&quot;</span></span><br></pre></td></tr></table></figure><p>现在我们已经实现了一个基础版的 Promise，但是还不要高兴的太早噢，这里我们只处理了同步操作的 promise。如果在 <code>executor()</code>中传入一个异步操作的话呢，我们试一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 传入一个异步操作</span></span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&#x27;成功&#x27;</span>);</span><br><span class="line">  &#125;,<span class="number">1000</span>);</span><br><span class="line">&#125;).<span class="title function_">then</span>(</span><br><span class="line">  <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;success&#x27;</span>, data)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;faild&#x27;</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>执行测试脚本后发现，promise 没有任何返回。</p><p>因为 promise 调用 then 方法时，当前的 promise 并没有成功，一直处于 pending 状态。所以如果当调用 then 方法时，当前状态是 pending，我们需要先将成功和失败的回调分别存放起来，在<code>executor()</code>的异步任务被执行时，触发 resolve 或 reject，依次调用成功或失败的回调。</p><p>结合这个思路，我们优化一下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">PENDING</span> = <span class="string">&#x27;PENDING&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">FULFILLED</span> = <span class="string">&#x27;FULFILLED&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">REJECTED</span> = <span class="string">&#x27;REJECTED&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Promise</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">executor</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">status</span> = <span class="variable constant_">PENDING</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = <span class="literal">undefined</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">reason</span> = <span class="literal">undefined</span>;</span><br><span class="line">    <span class="comment">// 存放成功的回调</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">onResolvedCallbacks</span> = [];</span><br><span class="line">    <span class="comment">// 存放失败的回调</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">onRejectedCallbacks</span>= [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="title function_">resolve</span> = (<span class="params">value</span>) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">status</span> ===  <span class="variable constant_">PENDING</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">status</span> = <span class="variable constant_">FULFILLED</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">value</span> = value;</span><br><span class="line">        <span class="comment">// 依次将对应的函数执行</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">onResolvedCallbacks</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">fn</span>=&gt;</span><span class="title function_">fn</span>());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="title function_">reject</span> = (<span class="params">reason</span>) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">status</span> ===  <span class="variable constant_">PENDING</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">status</span> = <span class="variable constant_">REJECTED</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">reason</span> = reason;</span><br><span class="line">        <span class="comment">// 依次将对应的函数执行</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">onRejectedCallbacks</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">fn</span>=&gt;</span><span class="title function_">fn</span>());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="title function_">executor</span>(resolve,reject)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      <span class="title function_">reject</span>(error)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">then</span>(<span class="params">onFulfilled, onRejected</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">FULFILLED</span>) &#123;</span><br><span class="line">      <span class="title function_">onFulfilled</span>(<span class="variable language_">this</span>.<span class="property">value</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">REJECTED</span>) &#123;</span><br><span class="line">      <span class="title function_">onRejected</span>(<span class="variable language_">this</span>.<span class="property">reason</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">PENDING</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果promise的状态是 pending，需要将 onFulfilled 和 onRejected 函数存放起来，等待状态确定后，再依次将对应的函数执行</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">onResolvedCallbacks</span>.<span class="title function_">push</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">onFulfilled</span>(<span class="variable language_">this</span>.<span class="property">value</span>)</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果promise的状态是 pending，需要将 onFulfilled 和 onRejected 函数存放起来，等待状态确定后，再依次将对应的函数执行</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">onRejectedCallbacks</span>.<span class="title function_">push</span>(<span class="function">()=&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">onRejected</span>(<span class="variable language_">this</span>.<span class="property">reason</span>);</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&#x27;成功&#x27;</span>);</span><br><span class="line">  &#125;,<span class="number">1000</span>);</span><br><span class="line">&#125;).<span class="title function_">then</span>(</span><br><span class="line">  <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;success&#x27;</span>, data)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;faild&#x27;</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>控制台等待 <code>1s</code> 后输出：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;success 成功&quot;</span></span><br></pre></td></tr></table></figure><p>ok！大功告成，异步问题已经解决了！</p><p>熟悉设计模式的同学，应该意识到了这其实是一个<strong>发布订阅模式</strong>，这种<code>收集依赖 -&gt; 触发通知 -&gt; 取出依赖执行</code>的方式，被广泛运用于发布订阅模式的实现。</p><h4 id="then-的链式调用-amp-值穿透特性"><a href="#then-的链式调用-amp-值穿透特性" class="headerlink" title="then 的链式调用&amp;值穿透特性"></a>then 的链式调用&amp;值穿透特性</h4><p>我们都知道，promise 的优势在于可以链式调用。在我们使用 Promise 的时候，当 then 函数中 return 了一个值，不管是什么值，我们都能在下一个 then 中获取到，这就是所谓的<strong>then 的链式调用</strong>。而且，当我们不在 then 中放入参数，例：<code>promise.then().then()</code>，那么其后面的 then 依旧可以得到之前 then 返回的值，这就是所谓的<strong>值的穿透</strong>。那具体如何实现呢？简单思考一下，如果每次调用 then 的时候，我们都重新创建一个 promise 对象，并把上一个 then 的返回结果传给这个新的 promise 的 then 方法，不就可以一直 then 下去了么？那我们来试着实现一下。这也是手写 Promise 源码的重中之重，所以，打起精神来，重头戏来咯！</p><p>有了上面的想法，我们再结合 <a href="https://link.zhihu.com/?target=https://promisesaplus.com/">Promise/A+</a> 规范梳理一下思路：</p><ol><li>then 的参数 <code>onFulfilled</code> 和 <code>onRejected</code> 可以缺省，如果 <code>onFulfilled</code> 或者 <code>onRejected</code>不是函数，将其忽略，且依旧可以在下面的 then 中获取到之前返回的值；「规范 Promise/A+ 2.2.1、2.2.1.1、2.2.1.2」</li><li>promise 可以 then 多次，每次执行完 promise.then 方法后返回的都是一个“新的promise”；「规范 Promise/A+ 2.2.7」</li><li>如果 then 的返回值 x 是一个普通值，那么就会把这个结果作为参数，传递给下一个 then 的成功的回调中；</li><li>如果 then 中抛出了异常，那么就会把这个异常作为参数，传递给下一个 then 的失败的回调中；「规范 Promise/A+ 2.2.7.2」</li><li>如果 then 的返回值 x 是一个 promise，那么会等这个 promise 执行完，promise 如果成功，就走下一个 then 的成功；如果失败，就走下一个 then 的失败；如果抛出异常，就走下一个 then 的失败；「规范 Promise/A+ 2.2.7.3、2.2.7.4」</li><li>如果 then 的返回值 x 和 promise 是同一个引用对象，造成循环引用，则抛出异常，把异常传递给下一个 then 的失败的回调中；「规范 Promise/A+ 2.3.1」</li><li>如果 then 的返回值 x 是一个 promise，且 x 同时调用 resolve 函数和 reject 函数，则第一次调用优先，其他所有调用被忽略；「规范 Promise/A+ 2.3.3.3.3」</li></ol><p>我们将代码补充完整：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">PENDING</span> = <span class="string">&#x27;PENDING&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">FULFILLED</span> = <span class="string">&#x27;FULFILLED&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">REJECTED</span> = <span class="string">&#x27;REJECTED&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">resolvePromise</span> = (<span class="params">promise2, x, resolve, reject</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 自己等待自己完成是错误的实现，用一个类型错误，结束掉 promise  Promise/A+ 2.3.1</span></span><br><span class="line">  <span class="keyword">if</span> (promise2 === x) &#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;Chaining cycle detected for promise #&lt;Promise&gt;&#x27;</span>))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Promise/A+ 2.3.3.3.3 只能调用一次</span></span><br><span class="line">  <span class="keyword">let</span> called;</span><br><span class="line">  <span class="comment">// 后续的条件要严格判断 保证代码能和别的库一起使用</span></span><br><span class="line">  <span class="keyword">if</span> ((<span class="keyword">typeof</span> x === <span class="string">&#x27;object&#x27;</span> &amp;&amp; x != <span class="literal">null</span>) || <span class="keyword">typeof</span> x === <span class="string">&#x27;function&#x27;</span>) &#123; </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 为了判断 resolve 过的就不用再 reject 了（比如 reject 和 resolve 同时调用的时候）  Promise/A+ 2.3.3.1</span></span><br><span class="line">      <span class="keyword">let</span> then = x.<span class="property">then</span>;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">&#x27;function&#x27;</span>) &#123; </span><br><span class="line">        <span class="comment">// 不要写成 x.then，直接 then.call 就可以了 因为 x.then 会再次取值，Object.defineProperty  Promise/A+ 2.3.3.3</span></span><br><span class="line">        then.<span class="title function_">call</span>(x, <span class="function"><span class="params">y</span> =&gt;</span> &#123; <span class="comment">// 根据 promise 的状态决定是成功还是失败</span></span><br><span class="line">          <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">          called = <span class="literal">true</span>;</span><br><span class="line">          <span class="comment">// 递归解析的过程（因为可能 promise 中还有 promise） Promise/A+ 2.3.3.3.1</span></span><br><span class="line">          <span class="title function_">resolvePromise</span>(promise2, y, resolve, reject); </span><br><span class="line">        &#125;, <span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// 只要失败就失败 Promise/A+ 2.3.3.3.2</span></span><br><span class="line">          <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">          called = <span class="literal">true</span>;</span><br><span class="line">          <span class="title function_">reject</span>(r);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果 x.then 是个普通值就直接返回 resolve 作为结果  Promise/A+ 2.3.3.4</span></span><br><span class="line">        <span class="title function_">resolve</span>(x);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="comment">// Promise/A+ 2.3.3.2</span></span><br><span class="line">      <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">      called = <span class="literal">true</span>;</span><br><span class="line">      <span class="title function_">reject</span>(e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果 x 是个普通值就直接返回 resolve 作为结果  Promise/A+ 2.3.4  </span></span><br><span class="line">    <span class="title function_">resolve</span>(x)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Promise</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">executor</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">status</span> = <span class="variable constant_">PENDING</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = <span class="literal">undefined</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">reason</span> = <span class="literal">undefined</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">onResolvedCallbacks</span> = [];</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">onRejectedCallbacks</span>= [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="title function_">resolve</span> = (<span class="params">value</span>) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">status</span> ===  <span class="variable constant_">PENDING</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">status</span> = <span class="variable constant_">FULFILLED</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">value</span> = value;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">onResolvedCallbacks</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">fn</span>=&gt;</span><span class="title function_">fn</span>());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="title function_">reject</span> = (<span class="params">reason</span>) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">status</span> ===  <span class="variable constant_">PENDING</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">status</span> = <span class="variable constant_">REJECTED</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">reason</span> = reason;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">onRejectedCallbacks</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">fn</span>=&gt;</span><span class="title function_">fn</span>());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="title function_">executor</span>(resolve,reject)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      <span class="title function_">reject</span>(error)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">then</span>(<span class="params">onFulfilled, onRejected</span>) &#123;</span><br><span class="line">    <span class="comment">//解决 onFufilled，onRejected 没有传值的问题</span></span><br><span class="line">    <span class="comment">//Promise/A+ 2.2.1 / Promise/A+ 2.2.5 / Promise/A+ 2.2.7.3 / Promise/A+ 2.2.7.4</span></span><br><span class="line">    onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">&#x27;function&#x27;</span> ? onFulfilled : <span class="function"><span class="params">v</span> =&gt;</span> v;</span><br><span class="line">    <span class="comment">//因为错误的值要让后面访问到，所以这里也要跑出个错误，不然会在之后 then 的 resolve 中捕获</span></span><br><span class="line">    onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">&#x27;function&#x27;</span> ? onRejected : <span class="function"><span class="params">err</span> =&gt;</span> &#123; <span class="keyword">throw</span> err &#125;;</span><br><span class="line">    <span class="comment">// 每次调用 then 都返回一个新的 promise  Promise/A+ 2.2.7</span></span><br><span class="line">    <span class="keyword">let</span> promise2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">FULFILLED</span>) &#123;</span><br><span class="line">        <span class="comment">//Promise/A+ 2.2.2</span></span><br><span class="line">        <span class="comment">//Promise/A+ 2.2.4 --- setTimeout</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//Promise/A+ 2.2.7.1</span></span><br><span class="line">            <span class="keyword">let</span> x = <span class="title function_">onFulfilled</span>(<span class="variable language_">this</span>.<span class="property">value</span>);</span><br><span class="line">            <span class="comment">// x可能是一个proimise</span></span><br><span class="line">            <span class="title function_">resolvePromise</span>(promise2, x, resolve, reject);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            <span class="comment">//Promise/A+ 2.2.7.2</span></span><br><span class="line">            <span class="title function_">reject</span>(e)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, <span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">REJECTED</span>) &#123;</span><br><span class="line">        <span class="comment">//Promise/A+ 2.2.3</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> x = <span class="title function_">onRejected</span>(<span class="variable language_">this</span>.<span class="property">reason</span>);</span><br><span class="line">            <span class="title function_">resolvePromise</span>(promise2, x, resolve, reject);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            <span class="title function_">reject</span>(e)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, <span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">PENDING</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">onResolvedCallbacks</span>.<span class="title function_">push</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">let</span> x = <span class="title function_">onFulfilled</span>(<span class="variable language_">this</span>.<span class="property">value</span>);</span><br><span class="line">              <span class="title function_">resolvePromise</span>(promise2, x, resolve, reject);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">              <span class="title function_">reject</span>(e)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;, <span class="number">0</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">onRejectedCallbacks</span>.<span class="title function_">push</span>(<span class="function">()=&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">let</span> x = <span class="title function_">onRejected</span>(<span class="variable language_">this</span>.<span class="property">reason</span>);</span><br><span class="line">              <span class="title function_">resolvePromise</span>(promise2, x, resolve, reject)</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">              <span class="title function_">reject</span>(e)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;, <span class="number">0</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> promise2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">reject</span>(<span class="string">&#x27;失败&#x27;</span>);</span><br><span class="line">&#125;).<span class="title function_">then</span>().<span class="title function_">then</span>().<span class="title function_">then</span>(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">&#125;,<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;err&#x27;</span>,err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>控制台输出：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;失败 err&quot;</span></span><br></pre></td></tr></table></figure><p>至此，我们已经完成了 promise 最关键的部分：then 的链式调用和值的穿透。搞清楚了 then 的链式调用和值的穿透，你也就搞清楚了 Promise。</p><h4 id="测试-Promise-是否符合规范"><a href="#测试-Promise-是否符合规范" class="headerlink" title="测试 Promise 是否符合规范"></a>测试 Promise 是否符合规范</h4><p>Promise/A+规范提供了一个专门的测试脚本，可以测试所编写的代码是否符合Promise/A+的规范。</p><p>首先，在 promise 实现的代码中，增加以下代码:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="property">defer</span> = <span class="title class_">Promise</span>.<span class="property">deferred</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> dfd = &#123;&#125;;</span><br><span class="line">  dfd.<span class="property">promise</span> = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">      dfd.<span class="property">resolve</span> = resolve;</span><br><span class="line">      dfd.<span class="property">reject</span> = reject;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> dfd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>安装测试脚本:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g promises-aplus-tests</span><br></pre></td></tr></table></figure><p>如果当前的 promise 源码的文件名为 promise.js</p><p>那么在对应的目录执行以下命令:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">promises-aplus-tests promise.<span class="property">js</span></span><br></pre></td></tr></table></figure><p>promises-aplus-tests 中共有 872 条测试用例。以上代码，可以完美通过所有用例。</p><p><strong>感谢小伙伴的提醒，由于文章中使用 setTimeout 实现 promise 的异步，会对大家造成误解。所以这里添加一些标注:</strong></p><p>由于原生的 Promise 是V8引擎提供的微任务，我们无法还原V8引擎的实现，所以这里使用 setTimeout 模拟异步，所以原生的是微任务，这里是宏任务。</p><p>Promise A+ 规范3.1 中也提到了：这可以通过“宏任务”机制（例如setTimeout或setImmediate）或“微任务”机制（例如MutatonObserver或）来实现process.nextTick。</p><p>如果你想实现 promise 的微任务，可以 mutationObserver 替代 seiTimeout 来实现微任务。</p><p>有小伙伴说可以使用 queueMicrotask 实现微任务，我也查阅了一些资料，是可以的。不过 queueMicrotask 兼容性不是很好，IE 下完全不支持。据我所知 queueMicrotask 的 polyfill 是基于 promise 实现的，如果不支持 promise 会转成 setTimeout。</p><p>总的来说，queueMicrotask 和 mutationObserver 都可以实现微任务机制，不过更建议有执念的小伙伴用 mutationObserver 实现一下，没有执念的小伙伴了解 promise 的微任务机制就好了～</p><h3 id="Promise-的-API"><a href="#Promise-的-API" class="headerlink" title="Promise 的 API"></a>Promise 的 API</h3><p>虽然上述的 promise 源码已经符合 Promise/A+ 的规范，但是原生的 Promise 还提供了一些其他方法，如:</p><ul><li>Promise.resolve()</li><li>Promise.reject()</li><li>Promise.prototype.catch()</li><li>Promise.prototype.finally()</li><li>Promise.all()</li><li>Promise.race(）</li></ul><p>下面具体说一下每个方法的实现:</p><h4 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve"></a>Promise.resolve</h4><p>默认产生一个成功的 promise。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="title function_">resolve</span>(<span class="params">data</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="title function_">resolve</span>(data);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要注意的是，<strong>promise.resolve 是具备等待功能的</strong>。如果参数是 promise 会等待这个 promise 解析完毕，在向下执行，所以这里需要在 resolve 方法中做一个小小的处理：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">resolve</span> = (<span class="params">value</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// ======新增逻辑======</span></span><br><span class="line">  <span class="comment">// 如果 value 是一个promise，那我们的库中应该也要实现一个递归解析</span></span><br><span class="line">  <span class="keyword">if</span>(value <span class="keyword">instanceof</span> <span class="title class_">Promise</span>)&#123;</span><br><span class="line">      <span class="comment">// 递归解析 </span></span><br><span class="line">      <span class="keyword">return</span> value.<span class="title function_">then</span>(resolve,reject)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ===================</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">status</span> ===  <span class="variable constant_">PENDING</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">status</span> = <span class="variable constant_">FULFILLED</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = value;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">onResolvedCallbacks</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">fn</span>=&gt;</span><span class="title function_">fn</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&#x27;ok&#x27;</span>);</span><br><span class="line">  &#125;, <span class="number">3000</span>);</span><br><span class="line">&#125;)).<span class="title function_">then</span>(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data,<span class="string">&#x27;success&#x27;</span>)</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(err,<span class="string">&#x27;error&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>控制台等待 <code>3s</code> 后输出：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;ok success&quot;</span></span><br></pre></td></tr></table></figure><h4 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject"></a>Promise.reject</h4><p>默认产生一个失败的 promise，Promise.reject 是直接将值变成错误结果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="title function_">reject</span>(<span class="params">reason</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="title function_">reject</span>(reason);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Promise-prototype-catch"><a href="#Promise-prototype-catch" class="headerlink" title="Promise.prototype.catch"></a>Promise.prototype.catch</h4><p>Promise.prototype.catch 用来捕获 promise 的异常，<strong>就相当于一个没有成功的 then</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">catch</span> = <span class="keyword">function</span>(<span class="params">errCallback</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">then</span>(<span class="literal">null</span>,errCallback)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Promise-prototype-finally"><a href="#Promise-prototype-finally" class="headerlink" title="Promise.prototype.finally"></a>Promise.prototype.finally</h4><p>finally 表示不是最终的意思，而是无论如何都会执行的意思。 如果返回一个 promise 会等待这个 promise 也执行完毕。如果返回的是成功的 promise，会采用上一次的结果；如果返回的是失败的 promise，会用这个失败的结果，传到 catch 中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">finally</span> = <span class="keyword">function</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="title function_">callback</span>()).<span class="title function_">then</span>(<span class="function">()=&gt;</span>value)</span><br><span class="line">  &#125;,<span class="function">(<span class="params">reason</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="title function_">callback</span>()).<span class="title function_">then</span>(<span class="function">()=&gt;</span>&#123;<span class="keyword">throw</span> reason&#125;)</span><br><span class="line">  &#125;)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">456</span>).<span class="title function_">finally</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="number">123</span>)</span><br><span class="line">    &#125;, <span class="number">3000</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data,<span class="string">&#x27;success&#x27;</span>)</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(err,<span class="string">&#x27;error&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>控制台等待 <code>3s</code> 后输出：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;456 success&quot;</span></span><br></pre></td></tr></table></figure><h4 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h4><p>promise.all 是解决并发问题的，多个异步并发获取最终的结果（如果有一个失败则失败）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="property">all</span> = <span class="keyword">function</span>(<span class="params">values</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="title class_">Array</span>.<span class="title function_">isArray</span>(values)) &#123;</span><br><span class="line">    <span class="keyword">const</span> type = <span class="keyword">typeof</span> values;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">`TypeError: <span class="subst">$&#123;type&#125;</span> <span class="subst">$&#123;values&#125;</span> is not iterable`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> resultArr = [];</span><br><span class="line">    <span class="keyword">let</span> orderIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">processResultByKey</span> = (<span class="params">value, index</span>) =&gt; &#123;</span><br><span class="line">      resultArr[index] = value;</span><br><span class="line">      <span class="keyword">if</span> (++orderIndex === values.<span class="property">length</span>) &#123;</span><br><span class="line">          <span class="title function_">resolve</span>(resultArr)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; values.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> value = values[i];</span><br><span class="line">      <span class="keyword">if</span> (value &amp;&amp; <span class="keyword">typeof</span> value.<span class="property">then</span> === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        value.<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="title function_">processResultByKey</span>(value, i);</span><br><span class="line">        &#125;, reject);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">processResultByKey</span>(value, i);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&#x27;ok1&#x27;</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">reject</span>(<span class="string">&#x27;ok2&#x27;</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,p1,p2]).<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;resolve&#x27;</span>, data);</span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;reject&#x27;</span>, err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>控制台等待 <code>1s</code> 后输出：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;resolve [ 1, 2, 3, &#x27;ok1&#x27;, &#x27;ok2&#x27; ]&quot;</span></span><br></pre></td></tr></table></figure><h4 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a>Promise.race</h4><p>Promise.race 用来处理多个请求，采用最快的（谁先完成用谁的）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="property">race</span> = <span class="keyword">function</span>(<span class="params">promises</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 一起执行就是for循环</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promises.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> val = promises[i];</span><br><span class="line">      <span class="keyword">if</span> (val &amp;&amp; <span class="keyword">typeof</span> val.<span class="property">then</span> === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        val.<span class="title function_">then</span>(resolve, reject);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">// 普通值</span></span><br><span class="line">        <span class="title function_">resolve</span>(val)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特别需要注意的是：因为<strong>Promise 是没有中断方法的</strong>，xhr.abort()、ajax 有自己的中断方法，axios 是基于 ajax 实现的；fetch 基于 promise，所以他的请求是无法中断的。</p><p>这也是 promise 存在的缺陷，我们可以使用 race 来自己封装中断方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">wrap</span>(<span class="params">promise</span>) &#123;</span><br><span class="line">  <span class="comment">// 在这里包装一个 promise，可以控制原来的promise是成功还是失败</span></span><br><span class="line">  <span class="keyword">let</span> abort;</span><br><span class="line">  <span class="keyword">let</span> newPromise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123; <span class="comment">// defer 方法</span></span><br><span class="line">      abort = reject;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">let</span> p = <span class="title class_">Promise</span>.<span class="title function_">race</span>([promise, newPromise]); <span class="comment">// 任何一个先成功或者失败 就可以获取到结果</span></span><br><span class="line">  p.<span class="property">abort</span> = abort;</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; <span class="comment">// 模拟的接口调用 ajax 肯定有超时设置</span></span><br><span class="line">      <span class="title function_">resolve</span>(<span class="string">&#x27;成功&#x27;</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> newPromise = <span class="title function_">wrap</span>(promise);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 超过3秒 就算超时 应该让 proimise 走到失败态</span></span><br><span class="line">  newPromise.<span class="title function_">abort</span>(<span class="string">&#x27;超时了&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line">newPromise.<span class="title function_">then</span>((<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;成功的结果&#x27;</span> + data)</span><br><span class="line">&#125;)).<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;失败的结果&#x27;</span> + e)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>控制台等待 <code>1s</code> 后输出：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;成功的结果成功&quot;</span></span><br></pre></td></tr></table></figure><h4 id="promisify"><a href="#promisify" class="headerlink" title="promisify"></a>promisify</h4><p>promisify 是把一个 node 中的 api 转换成 promise 的写法。 在 node 版本 12.18 以上，已经支持了原生的 promisify 方法：<code>const fs = require(&#39;fs&#39;).promises</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">promisify</span> = (<span class="params">fn</span>) =&gt; &#123; <span class="comment">// 典型的高阶函数 参数是函数 返回值是函数 </span></span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="title function_">fn</span>(...args,<span class="keyword">function</span> (<span class="params">err,data</span>) &#123; <span class="comment">// node中的回调函数的参数 第一个永远是error</span></span><br><span class="line">        <span class="keyword">if</span>(err) <span class="keyword">return</span> <span class="title function_">reject</span>(err);</span><br><span class="line">        <span class="title function_">resolve</span>(data);</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想要把 node 中所有的 api 都转换成 promise 的写法呢：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">promisifyAll</span> = (<span class="params">target</span>) =&gt;&#123;</span><br><span class="line">  <span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(target).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> target[key] === <span class="string">&#x27;function&#x27;</span>)&#123;</span><br><span class="line">      <span class="comment">// 默认会将原有的方法 全部增加一个 Async 后缀 变成 promise 写法</span></span><br><span class="line">      target[key+<span class="string">&#x27;Async&#x27;</span>] = <span class="title function_">promisify</span>(target[key]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-手写防抖函数"><a href="#5-手写防抖函数" class="headerlink" title="5. 手写防抖函数"></a>5. 手写防抖函数</h3><p>函数防抖是指在事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。这可以使用在一些点击请求的事件上，避免因为用户的多次点击向后端发送多次请求。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数防抖的实现</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">fn, wait</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> context = <span class="variable language_">this</span>,</span><br><span class="line">        args = <span class="variable language_">arguments</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果此时存在定时器的话，则取消之前的定时器重新记时</span></span><br><span class="line">    <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">      <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">      timer = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置定时器，使事件间隔指定事件后执行</span></span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      fn.<span class="title function_">apply</span>(context, args);</span><br><span class="line">    &#125;, wait);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-手写节流函数"><a href="#6-手写节流函数" class="headerlink" title="6. 手写节流函数"></a>6. 手写节流函数</h3><p>函数节流是指规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。节流可以使用在 scroll 函数的事件监听上，通过事件节流来降低事件调用的频率。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数节流的实现;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">fn, delay</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> curTime = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> context = <span class="variable language_">this</span>,</span><br><span class="line">        args = <span class="variable language_">arguments</span>,</span><br><span class="line">        nowTime = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果两次时间间隔超过了指定时间，则执行函数。</span></span><br><span class="line">    <span class="keyword">if</span> (nowTime - curTime &gt;= delay) &#123;</span><br><span class="line">      curTime = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">      <span class="keyword">return</span> fn.<span class="title function_">apply</span>(context, args);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-手写类型判断函数"><a href="#7-手写类型判断函数" class="headerlink" title="7. 手写类型判断函数"></a>7. 手写类型判断函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getType</span>(<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="comment">// 判断数据是 null 的情况</span></span><br><span class="line">  <span class="keyword">if</span> (value === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> value + <span class="string">&quot;&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 判断数据是引用类型的情况</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> value === <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> valueClass = <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(value),</span><br><span class="line">      type = valueClass.<span class="title function_">split</span>(<span class="string">&quot; &quot;</span>)[<span class="number">1</span>].<span class="title function_">split</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    type.<span class="title function_">pop</span>();</span><br><span class="line">    <span class="keyword">return</span> type.<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>).<span class="title function_">toLowerCase</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 判断数据是基本数据类型的情况和函数的情况</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-手写-call-函数"><a href="#8-手写-call-函数" class="headerlink" title="8. 手写 call 函数"></a>8. 手写 call 函数</h3><p>call 函数的实现步骤：</p><ol><li>判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li><li>判断传入上下文对象是否存在，如果不存在，则设置为 window 。</li><li>处理传入的参数，截取第一个参数后的所有参数。</li><li>将函数作为上下文对象的一个属性。</li><li>使用上下文对象来调用这个方法，并保存返回结果。</li><li>删除刚才新增的属性。</li><li>返回结果。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// call函数实现</span></span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myCall</span> = <span class="keyword">function</span>(<span class="params">context</span>) &#123;</span><br><span class="line">  <span class="comment">// 判断调用对象</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">this</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;type error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 获取参数</span></span><br><span class="line">  <span class="keyword">let</span> args = [...<span class="variable language_">arguments</span>].<span class="title function_">slice</span>(<span class="number">1</span>),</span><br><span class="line">      result = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 判断 context 是否传入，如果未传入则设置为 window</span></span><br><span class="line">  context = context || <span class="variable language_">window</span>;</span><br><span class="line">  <span class="comment">// 将调用函数设为对象的方法</span></span><br><span class="line">  context.<span class="property">fn</span> = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="comment">// 调用函数</span></span><br><span class="line">  result = context.<span class="title function_">fn</span>(...args);</span><br><span class="line">  <span class="comment">// 将属性删除</span></span><br><span class="line">  <span class="keyword">delete</span> context.<span class="property">fn</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="9-手写-apply-函数"><a href="#9-手写-apply-函数" class="headerlink" title="9. 手写 apply 函数"></a>9. 手写 apply 函数</h3><p>apply 函数的实现步骤：</p><ol><li>判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li><li>判断传入上下文对象是否存在，如果不存在，则设置为 window 。</li><li>将函数作为上下文对象的一个属性。</li><li>判断参数值是否传入</li><li>使用上下文对象来调用这个方法，并保存返回结果。</li><li>删除刚才新增的属性</li><li>返回结果</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// apply 函数实现</span></span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myApply</span> = <span class="keyword">function</span>(<span class="params">context</span>) &#123;</span><br><span class="line">  <span class="comment">// 判断调用对象是否为函数</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">this</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&quot;Error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 判断 context 是否存在，如果未传入则为 window</span></span><br><span class="line">  context = context || <span class="variable language_">window</span>;</span><br><span class="line">  <span class="comment">// 将函数设为对象的方法</span></span><br><span class="line">  context.<span class="property">fn</span> = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="comment">// 调用方法</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">arguments</span>[<span class="number">1</span>]) &#123;</span><br><span class="line">    result = context.<span class="title function_">fn</span>(...<span class="variable language_">arguments</span>[<span class="number">1</span>]);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    result = context.<span class="title function_">fn</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将属性删除</span></span><br><span class="line">  <span class="keyword">delete</span> context.<span class="property">fn</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="10-手写-bind-函数"><a href="#10-手写-bind-函数" class="headerlink" title="10. 手写 bind 函数"></a>10. 手写 bind 函数</h3><p>bind 函数的实现步骤：</p><ol><li>判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li><li>保存当前函数的引用，获取其余传入参数值。</li><li>创建一个函数返回</li><li>函数内部使用 apply 来绑定函数调用，需要判断函数作为构造函数的情况，这个时候需要传入当前函数的 this 给 apply 调用，其余情况都传入指定的上下文对象。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bind 函数实现</span></span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myBind</span> = <span class="keyword">function</span>(<span class="params">context</span>) &#123;</span><br><span class="line">  <span class="comment">// 判断调用对象是否为函数</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">this</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&quot;Error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 获取参数</span></span><br><span class="line">  <span class="keyword">var</span> args = [...<span class="variable language_">arguments</span>].<span class="title function_">slice</span>(<span class="number">1</span>),</span><br><span class="line">      fn = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">Fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 根据调用方式，传入不同绑定值</span></span><br><span class="line">    <span class="keyword">return</span> fn.<span class="title function_">apply</span>(</span><br><span class="line">      <span class="variable language_">this</span> <span class="keyword">instanceof</span> <span class="title class_">Fn</span> ? <span class="variable language_">this</span> : context,</span><br><span class="line">      args.<span class="title function_">concat</span>(...<span class="variable language_">arguments</span>)</span><br><span class="line">    );</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="11-函数柯里化的实现"><a href="#11-函数柯里化的实现" class="headerlink" title="11. 函数柯里化的实现"></a>11. 函数柯里化的实现</h3><p>函数柯里化指的是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">curry</span>(<span class="params">fn, args</span>) &#123;</span><br><span class="line">  <span class="comment">// 获取函数需要的参数长度</span></span><br><span class="line">  <span class="keyword">let</span> length = fn.<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line">  args = args || [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> subArgs = args.<span class="title function_">slice</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拼接得到现有的所有参数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">arguments</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      subArgs.<span class="title function_">push</span>(<span class="variable language_">arguments</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断参数的长度是否已经满足函数所需参数的长度</span></span><br><span class="line">    <span class="keyword">if</span> (subArgs.<span class="property">length</span> &gt;= length) &#123;</span><br><span class="line">      <span class="comment">// 如果满足，执行函数</span></span><br><span class="line">      <span class="keyword">return</span> fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, subArgs);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果不满足，递归返回科里化的函数，等待参数的传入</span></span><br><span class="line">      <span class="keyword">return</span> curry.<span class="title function_">call</span>(<span class="variable language_">this</span>, fn, subArgs);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// es6 实现</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">curry</span>(<span class="params">fn, ...args</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> fn.<span class="property">length</span> &lt;= args.<span class="property">length</span> ? <span class="title function_">fn</span>(...args) : curry.<span class="title function_">bind</span>(<span class="literal">null</span>, fn, ...args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12-实现AJAX请求"><a href="#12-实现AJAX请求" class="headerlink" title="12. 实现AJAX请求"></a>12. 实现AJAX请求</h3><p>AJAX是 Asynchronous JavaScript and XML 的缩写，指的是通过 JavaScript 的 异步通信，从服务器获取 XML 文档从中提取数据，再更新当前网页的对应部分，而不用刷新整个网页。</p><p>创建AJAX请求的步骤：</p><ul><li><strong>创建一个 XMLHttpRequest 对象。</strong></li><li>在这个对象上<strong>使用 open 方法创建一个 HTTP 请求</strong>，open 方法所需要的参数是请求的方法、请求的地址、是否异步和用户的认证信息。</li><li>在发起请求前，可以为这个对象<strong>添加一些信息和监听函数</strong>。比如说可以通过 setRequestHeader 方法来为请求添加头信息。还可以为这个对象添加一个状态监听函数。一个 XMLHttpRequest 对象一共有 5 个状态，当它的状态变化时会触发onreadystatechange 事件，可以通过设置监听函数，来处理请求成功后的结果。当对象的 readyState 变为 4 的时候，代表服务器返回的数据接收完成，这个时候可以通过判断请求的状态，如果状态是 2xx 或者 304 的话则代表返回正常。这个时候就可以通过 response 中的数据来对页面进行更新了。</li><li>当对象的属性和监听函数设置完成后，最后调<strong>用 sent 方法来向服务器发起请求</strong>，可以传入参数作为发送的数据体。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">SERVER_URL</span> = <span class="string">&quot;/server&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line"><span class="comment">// 创建 Http 请求</span></span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&quot;GET&quot;</span>, <span class="variable constant_">SERVER_URL</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="comment">// 设置状态监听函数</span></span><br><span class="line">xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">readyState</span> !== <span class="number">4</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// 当请求成功时</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="title function_">handle</span>(<span class="variable language_">this</span>.<span class="property">response</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="variable language_">this</span>.<span class="property">statusText</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 设置请求失败时的监听函数</span></span><br><span class="line">xhr.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="variable language_">this</span>.<span class="property">statusText</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 设置请求头信息</span></span><br><span class="line">xhr.<span class="property">responseType</span> = <span class="string">&quot;json&quot;</span>;</span><br><span class="line">xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&quot;Accept&quot;</span>, <span class="string">&quot;application/json&quot;</span>);</span><br><span class="line"><span class="comment">// 发送 Http 请求</span></span><br><span class="line">xhr.<span class="title function_">send</span>(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure><h3 id="13-使用Promise封装AJAX请求"><a href="#13-使用Promise封装AJAX请求" class="headerlink" title="13. 使用Promise封装AJAX请求"></a>13. 使用Promise封装AJAX请求</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// promise 封装实现：</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getJSON</span>(<span class="params">url</span>) &#123;</span><br><span class="line">  <span class="comment">// 创建一个 promise 对象</span></span><br><span class="line">  <span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">    <span class="comment">// 新建一个 http 请求</span></span><br><span class="line">    xhr.<span class="title function_">open</span>(<span class="string">&quot;GET&quot;</span>, url, <span class="literal">true</span>);</span><br><span class="line">    <span class="comment">// 设置状态的监听函数</span></span><br><span class="line">    xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">readyState</span> !== <span class="number">4</span>) <span class="keyword">return</span>;</span><br><span class="line">      <span class="comment">// 当请求成功或失败时，改变 promise 的状态</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="variable language_">this</span>.<span class="property">response</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="variable language_">this</span>.<span class="property">statusText</span>));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 设置错误监听函数</span></span><br><span class="line">    xhr.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="variable language_">this</span>.<span class="property">statusText</span>));</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 设置响应的数据类型</span></span><br><span class="line">    xhr.<span class="property">responseType</span> = <span class="string">&quot;json&quot;</span>;</span><br><span class="line">    <span class="comment">// 设置请求头信息</span></span><br><span class="line">    xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&quot;Accept&quot;</span>, <span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">    <span class="comment">// 发送 http 请求</span></span><br><span class="line">    xhr.<span class="title function_">send</span>(<span class="literal">null</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="14-实现浅拷贝"><a href="#14-实现浅拷贝" class="headerlink" title="14. 实现浅拷贝"></a>14. 实现浅拷贝</h3><p>浅拷贝是指，一个新的对象对原始对象的属性值进行精确地拷贝，如果拷贝的是基本数据类型，拷贝的就是基本数据类型的值，如果是引用数据类型，拷贝的就是内存地址。如果其中一个对象的引用内存地址发生改变，另一个对象也会发生变化。</p><h4 id="（1）Object-assign"><a href="#（1）Object-assign" class="headerlink" title="（1）Object.assign()"></a>（1）Object.assign()</h4><p><code>Object.assign()</code>是ES6中对象的拷贝方法，接受的第一个参数是目标对象，其余参数是源对象，用法：<code>Object.assign(target, source_1, ···)</code>，该方法可以实现浅拷贝，也可以实现一维对象的深拷贝。</p><p><strong>注意：</strong></p><ul><li>如果目标对象和源对象有同名属性，或者多个源对象有同名属性，则后面的属性会覆盖前面的属性。</li><li>如果该函数只有一个参数，当参数为对象时，直接返回该对象；当参数不是对象时，会先将参数转为对象然后返回。</li><li>因为<code>null</code> 和 <code>undefined</code> 不能转化为对象，所以第一个参数不能为<code>null</code>或 <code>undefined</code>，会报错。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> object2 = &#123;<span class="attr">b</span>: <span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> object3 = &#123;<span class="attr">c</span>: <span class="number">3</span>&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(target,object2,object3);  </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target);  <span class="comment">// &#123;a: 1, b: 2, c: 3&#125;</span></span><br></pre></td></tr></table></figure><h4 id="（2）扩展运算符"><a href="#（2）扩展运算符" class="headerlink" title="（2）扩展运算符"></a>（2）扩展运算符</h4><p>使用扩展运算符可以在构造字面量对象的时候，进行属性的拷贝。语法：<code>let cloneObj = &#123; ...obj &#125;;</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123;<span class="attr">a</span>:<span class="number">1</span>,<span class="attr">b</span>:&#123;<span class="attr">c</span>:<span class="number">1</span>&#125;&#125;</span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;...obj1&#125;;</span><br><span class="line">obj1.<span class="property">a</span> = <span class="number">2</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1); <span class="comment">//&#123;a:2,b:&#123;c:1&#125;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2); <span class="comment">//&#123;a:1,b:&#123;c:1&#125;&#125;</span></span><br><span class="line">obj1.<span class="property">b</span>.<span class="property">c</span> = <span class="number">2</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1); <span class="comment">//&#123;a:2,b:&#123;c:2&#125;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2); <span class="comment">//&#123;a:1,b:&#123;c:2&#125;&#125;</span></span><br></pre></td></tr></table></figure><h4 id="（3）数组方法实现数组浅拷贝"><a href="#（3）数组方法实现数组浅拷贝" class="headerlink" title="（3）数组方法实现数组浅拷贝"></a>（3）数组方法实现数组浅拷贝</h4><h6 id="1）Array-prototype-slice"><a href="#1）Array-prototype-slice" class="headerlink" title="1）Array.prototype.slice"></a><strong>1）Array.prototype.slice</strong></h6><ul><li><code>slice()</code>方法是JavaScript数组的一个方法，这个方法可以从已有数组中返回选定的元素：用法：<code>array.slice(start, end)</code>，该方法不会改变原始数组。</li><li>该方法有两个参数，两个参数都可选，如果两个参数都不写，就可以实现一个数组的浅拷贝。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">slice</span>()); <span class="comment">// [1,2,3,4]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">slice</span>() === arr); <span class="comment">//false</span></span><br></pre></td></tr></table></figure><h6 id="2）Array-prototype-concat"><a href="#2）Array-prototype-concat" class="headerlink" title="2）Array.prototype.concat"></a><strong>2）Array.prototype.concat</strong></h6><ul><li><code>concat()</code> 方法用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。</li><li>该方法有两个参数，两个参数都可选，如果两个参数都不写，就可以实现一个数组的浅拷贝。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">concat</span>()); <span class="comment">// [1,2,3,4]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">concat</span>() === arr); <span class="comment">//false</span></span><br></pre></td></tr></table></figure><h4 id="（4）手写实现浅拷贝"><a href="#（4）手写实现浅拷贝" class="headerlink" title="（4）手写实现浅拷贝"></a>（4）手写实现浅拷贝</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 浅拷贝的实现;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">shallowCopy</span>(<span class="params">object</span>) &#123;</span><br><span class="line">  <span class="comment">// 只拷贝对象</span></span><br><span class="line">  <span class="keyword">if</span> (!object || <span class="keyword">typeof</span> object !== <span class="string">&quot;object&quot;</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据 object 的类型判断是新建一个数组还是对象</span></span><br><span class="line">  <span class="keyword">let</span> newObject = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(object) ? [] : &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历 object，并且判断是 object 的属性才拷贝</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> object) &#123;</span><br><span class="line">    <span class="keyword">if</span> (object.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">      newObject[key] = object[key];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> newObject;</span><br><span class="line">&#125;<span class="comment">// 浅拷贝的实现;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">shallowCopy</span>(<span class="params">object</span>) &#123;</span><br><span class="line">  <span class="comment">// 只拷贝对象</span></span><br><span class="line">  <span class="keyword">if</span> (!object || <span class="keyword">typeof</span> object !== <span class="string">&quot;object&quot;</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据 object 的类型判断是新建一个数组还是对象</span></span><br><span class="line">  <span class="keyword">let</span> newObject = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(object) ? [] : &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历 object，并且判断是 object 的属性才拷贝</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> object) &#123;</span><br><span class="line">    <span class="keyword">if</span> (object.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">      newObject[key] = object[key];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> newObject;</span><br><span class="line">&#125;<span class="comment">// 浅拷贝的实现;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">shallowCopy</span>(<span class="params">object</span>) &#123;</span><br><span class="line">  <span class="comment">// 只拷贝对象</span></span><br><span class="line">  <span class="keyword">if</span> (!object || <span class="keyword">typeof</span> object !== <span class="string">&quot;object&quot;</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// 根据 object 的类型判断是新建一个数组还是对象</span></span><br><span class="line">  <span class="keyword">let</span> newObject = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(object) ? [] : &#123;&#125;;</span><br><span class="line">  <span class="comment">// 遍历 object，并且判断是 object 的属性才拷贝</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> object) &#123;</span><br><span class="line">    <span class="keyword">if</span> (object.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">      newObject[key] = object[key];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="15-实现深拷贝"><a href="#15-实现深拷贝" class="headerlink" title="15. 实现深拷贝"></a>15. 实现深拷贝</h3><ul><li><strong>浅拷贝：</strong> 浅拷贝指的是将一个对象的属性值复制到另一个对象，如果有的属性的值为引用类型的话，那么会将这个引用的地址复制给对象，因此两个对象会有同一个引用类型的引用。浅拷贝可以使用  Object.assign 和展开运算符来实现。</li><li><strong>深拷贝：</strong> 深拷贝相对浅拷贝而言，如果遇到属性值为引用类型的时候，它新建一个引用类型并将对应的值复制给它，因此对象获得的一个新的引用类型而不是一个原有类型的引用。深拷贝对于一些对象可以使用 JSON 的两个函数来实现，但是由于 JSON 的对象格式比 js 的对象格式更加严格，所以如果属性值里边出现函数或者 Symbol 类型的值时，会转换失败</li></ul><h4 id="（1）JSON-stringify"><a href="#（1）JSON-stringify" class="headerlink" title="（1）JSON.stringify()"></a>（1）JSON.stringify()</h4><ul><li><code>JSON.parse(JSON.stringify(obj))</code>是目前比较常用的深拷贝方法之一，它的原理就是利用<code>JSON.stringify</code> 将<code>js</code>对象序列化（JSON字符串），再使用<code>JSON.parse</code>来反序列化(还原)<code>js</code>对象。</li><li>这个方法可以简单粗暴的实现深拷贝，但是还存在问题，拷贝的对象中如果有函数，undefined，symbol，当使用过<code>JSON.stringify()</code>进行处理之后，都会消失。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123;  <span class="attr">a</span>: <span class="number">0</span>,</span><br><span class="line">              <span class="attr">b</span>: &#123;</span><br><span class="line">                 <span class="attr">c</span>: <span class="number">0</span></span><br><span class="line">                 &#125;</span><br><span class="line">            &#125;;</span><br><span class="line"><span class="keyword">let</span> obj2 = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj1));</span><br><span class="line">obj1.<span class="property">a</span> = <span class="number">1</span>;</span><br><span class="line">obj1.<span class="property">b</span>.<span class="property">c</span> = <span class="number">1</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1); <span class="comment">// &#123;a: 1, b: &#123;c: 1&#125;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2); <span class="comment">// &#123;a: 0, b: &#123;c: 0&#125;&#125;</span></span><br></pre></td></tr></table></figure><h4 id="（2）函数库lodash的-cloneDeep方法"><a href="#（2）函数库lodash的-cloneDeep方法" class="headerlink" title="（2）函数库lodash的_.cloneDeep方法"></a>（2）函数库lodash的_.cloneDeep方法</h4><p>该函数库也有提供_.cloneDeep用来做 Deep Copy</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _ = <span class="built_in">require</span>(<span class="string">&#x27;lodash&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">b</span>: &#123; <span class="attr">f</span>: &#123; <span class="attr">g</span>: <span class="number">1</span> &#125; &#125;,</span><br><span class="line">    <span class="attr">c</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = _.<span class="title function_">cloneDeep</span>(obj1);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1.<span class="property">b</span>.<span class="property">f</span> === obj2.<span class="property">b</span>.<span class="property">f</span>);<span class="comment">// false</span></span><br></pre></td></tr></table></figure><h4 id="（3）手写实现深拷贝函数"><a href="#（3）手写实现深拷贝函数" class="headerlink" title="（3）手写实现深拷贝函数"></a>（3）手写实现深拷贝函数</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 深拷贝的实现</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">deepCopy</span>(<span class="params">object</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!object || <span class="keyword">typeof</span> object !== <span class="string">&quot;object&quot;</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> newObject = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(object) ? [] : &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> object) &#123;</span><br><span class="line">    <span class="keyword">if</span> (object.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">      newObject[key] =</span><br><span class="line">        <span class="keyword">typeof</span> object[key] === <span class="string">&quot;object&quot;</span> ? <span class="title function_">deepCopy</span>(object[key]) : object[key];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> newObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、数据处理"><a href="#二、数据处理" class="headerlink" title="二、数据处理"></a>二、数据处理</h2><h3 id="1-实现日期格式化函数"><a href="#1-实现日期格式化函数" class="headerlink" title="1. 实现日期格式化函数"></a>1. 实现日期格式化函数</h3><p>输入：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">dateFormat</span>(<span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&#x27;2020-12-01&#x27;</span>), <span class="string">&#x27;yyyy/MM/dd&#x27;</span>) <span class="comment">// 2020/12/01</span></span><br><span class="line"><span class="title function_">dateFormat</span>(<span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&#x27;2020-04-01&#x27;</span>), <span class="string">&#x27;yyyy/MM/dd&#x27;</span>) <span class="comment">// 2020/04/01</span></span><br><span class="line"><span class="title function_">dateFormat</span>(<span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&#x27;2020-04-01&#x27;</span>), <span class="string">&#x27;yyyy年MM月dd日&#x27;</span>) <span class="comment">// 2020年04月01日</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">dateFormat</span> = (<span class="params">dateInput, format</span>)=&gt;&#123;</span><br><span class="line">    <span class="keyword">var</span> day = dateInput.<span class="title function_">getDate</span>() </span><br><span class="line">    <span class="keyword">var</span> month = dateInput.<span class="title function_">getMonth</span>() + <span class="number">1</span>  </span><br><span class="line">    <span class="keyword">var</span> year = dateInput.<span class="title function_">getFullYear</span>()   </span><br><span class="line">    format = format.<span class="title function_">replace</span>(<span class="regexp">/yyyy/</span>, year)</span><br><span class="line">    format = format.<span class="title function_">replace</span>(<span class="regexp">/MM/</span>,month)</span><br><span class="line">    format = format.<span class="title function_">replace</span>(<span class="regexp">/dd/</span>,day)</span><br><span class="line">    <span class="keyword">return</span> format</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-交换a-b的值，不能用临时变量"><a href="#2-交换a-b的值，不能用临时变量" class="headerlink" title="2. 交换a,b的值，不能用临时变量"></a>2. 交换a,b的值，不能用临时变量</h3><p>巧妙的利用两个数的和、差：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = a + b</span><br><span class="line">b = a - b</span><br><span class="line">a = a - b</span><br></pre></td></tr></table></figure><h3 id="3-实现数组的乱序输出"><a href="#3-实现数组的乱序输出" class="headerlink" title="3. 实现数组的乱序输出"></a>3. 实现数组的乱序输出</h3><p>主要的实现思路就是：</p><ul><li>取出数组的第一个元素，随机产生一个索引值，将该第一个元素和这个索引对应的元素进行交换。</li><li>第二次取出数据数组第二个元素，随机产生一个除了索引为1的之外的索引值，并将第二个元素与该索引值对应的元素进行交换</li><li>按照上面的规律执行，直到遍历完成</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">const</span> randomIndex = <span class="title class_">Math</span>.<span class="title function_">round</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * (arr.<span class="property">length</span> - <span class="number">1</span> - i)) + i;</span><br><span class="line">  [arr[i], arr[randomIndex]] = [arr[randomIndex], arr[i]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr)</span><br></pre></td></tr></table></figure><p>还有一方法就是倒序遍历：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>];</span><br><span class="line"><span class="keyword">let</span> length = arr.<span class="property">length</span>,</span><br><span class="line">    randomIndex,</span><br><span class="line">    temp;</span><br><span class="line">  <span class="keyword">while</span> (length) &#123;</span><br><span class="line">    randomIndex = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * length--);</span><br><span class="line">    temp = arr[length];</span><br><span class="line">    arr[length] = arr[randomIndex];</span><br><span class="line">    arr[randomIndex] = temp;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr)</span><br></pre></td></tr></table></figure><h3 id="4-实现数组元素求和"><a href="#4-实现数组元素求和" class="headerlink" title="4. 实现数组元素求和"></a>4. 实现数组元素求和</h3><ul><li>arr=[1,2,3,4,5,6,7,8,9,10]，求和</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>]</span><br><span class="line"><span class="keyword">let</span> sum = arr.<span class="title function_">reduce</span>( <span class="function">(<span class="params">total,i</span>) =&gt;</span> total += i,<span class="number">0</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sum);</span><br></pre></td></tr></table></figure><ul><li>arr=[1,2,3,[[4,5],6],7,8,9]，求和</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> = arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,[[<span class="number">4</span>,<span class="number">5</span>],<span class="number">6</span>],<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br><span class="line"><span class="keyword">let</span> arr= arr.<span class="title function_">toString</span>().<span class="title function_">split</span>(<span class="string">&#x27;,&#x27;</span>).<span class="title function_">reduce</span>( <span class="function">(<span class="params">total,i</span>) =&gt;</span> total += <span class="title class_">Number</span>(i),<span class="number">0</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr);</span><br></pre></td></tr></table></figure><p>递归实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>] </span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.<span class="property">length</span> == <span class="number">1</span>) <span class="keyword">return</span> arr[<span class="number">0</span>] </span><br><span class="line">    <span class="keyword">return</span> arr[<span class="number">0</span>] + <span class="title function_">add</span>(arr.<span class="title function_">slice</span>(<span class="number">1</span>)) </span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">add</span>(arr)) <span class="comment">// 21</span></span><br></pre></td></tr></table></figure><h3 id="5-实现数组的扁平化"><a href="#5-实现数组的扁平化" class="headerlink" title="5. 实现数组的扁平化"></a>5. 实现数组的扁平化</h3><p><strong>（1）递归实现</strong></p><p>普通的递归思路很容易理解，就是通过循环递归的方式，一项一项地去遍历，如果每一项还是一个数组，那么就继续往下遍历，利用递归程序的方法，来实现数组的每一项的连接：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]]];</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">flatten</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> result = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="title class_">Array</span>.<span class="title function_">isArray</span>(arr[i])) &#123;</span><br><span class="line">      result = result.<span class="title function_">concat</span>(<span class="title function_">flatten</span>(arr[i]));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result.<span class="title function_">push</span>(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">flatten</span>(arr);  <span class="comment">//  [1, 2, 3, 4，5]</span></span><br></pre></td></tr></table></figure><p><strong>（2）reduce 函数迭代</strong></p><p>从上面普通的递归函数中可以看出，其实就是对数组的每一项进行处理，那么其实也可以用reduce 来实现数组的拼接，从而简化第一种方法的代码，改造后的代码如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]]];</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">flatten</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> arr.<span class="title function_">reduce</span>(<span class="keyword">function</span>(<span class="params">prev, next</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> prev.<span class="title function_">concat</span>(<span class="title class_">Array</span>.<span class="title function_">isArray</span>(next) ? <span class="title function_">flatten</span>(next) : next)</span><br><span class="line">    &#125;, [])</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">flatten</span>(arr));<span class="comment">//  [1, 2, 3, 4，5]</span></span><br></pre></td></tr></table></figure><p><strong>（3）扩展运算符实现</strong></p><p>这个方法的实现，采用了扩展运算符和 some 的方法，两者共同使用，达到数组扁平化的目的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]]];</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">flatten</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (arr.<span class="title function_">some</span>(<span class="function"><span class="params">item</span> =&gt;</span> <span class="title class_">Array</span>.<span class="title function_">isArray</span>(item))) &#123;</span><br><span class="line">        arr = [].<span class="title function_">concat</span>(...arr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">flatten</span>(arr)); <span class="comment">//  [1, 2, 3, 4，5]</span></span><br></pre></td></tr></table></figure><p><strong>（4）split 和 toString</strong></p><p>可以通过 split 和 toString 两个方法来共同实现数组扁平化，由于数组会默认带一个 toString 的方法，所以可以把数组直接转换成逗号分隔的字符串，然后再用 split 方法把字符串重新转换为数组，如下面的代码所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]]];</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">flatten</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> arr.<span class="title function_">toString</span>().<span class="title function_">split</span>(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">flatten</span>(arr)); <span class="comment">//  [1, 2, 3, 4，5]</span></span><br></pre></td></tr></table></figure><p>通过这两个方法可以将多维数组直接转换成逗号连接的字符串，然后再重新分隔成数组。</p><p><strong>（5）ES6 中的 flat</strong></p><p>我们还可以直接调用 ES6 中的 flat 方法来实现数组扁平化。flat 方法的语法：<code>arr.flat([depth])</code></p><p>其中 depth 是 flat 的参数，depth 是可以传递数组的展开深度（默认不填、数值是 1），即展开一层数组。如果层数不确定，参数可以传进 Infinity，代表不论多少层都要展开：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]]];</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">flatten</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> arr.<span class="title function_">flat</span>(<span class="title class_">Infinity</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">flatten</span>(arr)); <span class="comment">//  [1, 2, 3, 4，5]</span></span><br></pre></td></tr></table></figure><p>可以看出，一个嵌套了两层的数组，通过将 flat 方法的参数设置为 Infinity，达到了我们预期的效果。其实同样也可以设置成 2，也能实现这样的效果。在编程过程中，如果数组的嵌套层数不确定，最好直接使用 Infinity，可以达到扁平化。 <strong>（6）正则和 JSON 方法</strong> 在第4种方法中已经使用 toString 方法，其中仍然采用了将 JSON.stringify 的方法先转换为字符串，然后通过正则表达式过滤掉字符串中的数组的方括号，最后再利用 JSON.parse 把它转换成数组：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]]], <span class="number">6</span>];</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">flatten</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> str = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(arr);</span><br><span class="line">  str = str.<span class="title function_">replace</span>(<span class="regexp">/(\[|\])/g</span>, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">  str = <span class="string">&#x27;[&#x27;</span> + str + <span class="string">&#x27;]&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">JSON</span>.<span class="title function_">parse</span>(str); </span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">flatten</span>(arr)); <span class="comment">//  [1, 2, 3, 4，5]</span></span><br></pre></td></tr></table></figure><h3 id="6-实现数组去重"><a href="#6-实现数组去重" class="headerlink" title="6. 实现数组去重"></a>6. 实现数组去重</h3><p>给定某无序数组，要求去除数组中的重复数字并且返回新的无重复数组。</p><p>ES6方法（使用数据结构集合）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">8</span>];</span><br><span class="line"></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="keyword">new</span> <span class="title class_">Set</span>(array)); <span class="comment">// [1, 2, 3, 5, 9, 8]</span></span><br></pre></td></tr></table></figure><p>ES5方法：使用map存储不重复的数字</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">8</span>];</span><br><span class="line"></span><br><span class="line"><span class="title function_">uniqueArray</span>(array); <span class="comment">// [1, 2, 3, 5, 9, 8]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">uniqueArray</span>(<span class="params">array</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> map = &#123;&#125;;</span><br><span class="line">  <span class="keyword">let</span> res = [];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; array.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!map.<span class="title function_">hasOwnProperty</span>([array[i]])) &#123;</span><br><span class="line">      map[array[i]] = <span class="number">1</span>;</span><br><span class="line">      res.<span class="title function_">push</span>(array[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-实现数组的flat方法"><a href="#7-实现数组的flat方法" class="headerlink" title="7. 实现数组的flat方法"></a>7. 实现数组的flat方法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">_flat</span>(<span class="params">arr, depth</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(!<span class="title class_">Array</span>.<span class="title function_">isArray</span>(arr) || depth &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">prev, cur</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(cur)) &#123;</span><br><span class="line">      <span class="keyword">return</span> prev.<span class="title function_">concat</span>(<span class="title function_">_flat</span>(cur, depth - <span class="number">1</span>))</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> prev.<span class="title function_">concat</span>(cur);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, []);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-实现数组的push方法"><a href="#8-实现数组的push方法" class="headerlink" title="8. 实现数组的push方法"></a>8. 实现数组的push方法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [];</span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">push</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">let</span> i = <span class="number">0</span> ; i &lt; <span class="variable language_">arguments</span>.<span class="property">length</span> ; i++)&#123;</span><br><span class="line"><span class="variable language_">this</span>[<span class="variable language_">this</span>.<span class="property">length</span>] = <span class="variable language_">arguments</span>[i] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">length</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-实现数组的filter方法"><a href="#9-实现数组的filter方法" class="headerlink" title="9. 实现数组的filter方法"></a>9. 实现数组的filter方法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_filter</span> = <span class="keyword">function</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> fn !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="title class_">Error</span>(<span class="string">&#x27;参数必须是一个函数&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> res = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = <span class="variable language_">this</span>.<span class="property">length</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="title function_">fn</span>(<span class="variable language_">this</span>[i]) &amp;&amp; res.<span class="title function_">push</span>(<span class="variable language_">this</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-实现数组的map方法"><a href="#10-实现数组的map方法" class="headerlink" title="10. 实现数组的map方法"></a>10. 实现数组的map方法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_map</span> = <span class="keyword">function</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">typeof</span> fn !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="title class_">Error</span>(<span class="string">&#x27;参数必须是一个函数&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> res = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = <span class="variable language_">this</span>.<span class="property">length</span>; i &lt; len; i++) &#123;</span><br><span class="line">        res.<span class="title function_">push</span>(<span class="title function_">fn</span>(<span class="variable language_">this</span>[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-实现字符串的repeat方法"><a href="#11-实现字符串的repeat方法" class="headerlink" title="11. 实现字符串的repeat方法"></a>11. 实现字符串的repeat方法</h3><p>输入字符串s，以及其重复的次数，输出重复的结果，例如输入abc，2，输出abcabc。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">repeat</span>(<span class="params">s, n</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">new</span> <span class="title class_">Array</span>(n + <span class="number">1</span>)).<span class="title function_">join</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">repeat</span>(<span class="params">s, n</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (n &gt; <span class="number">0</span>) ? s.<span class="title function_">concat</span>(<span class="title function_">repeat</span>(s, --n)) : <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12-实现字符串翻转"><a href="#12-实现字符串翻转" class="headerlink" title="12. 实现字符串翻转"></a>12. 实现字符串翻转</h3><p>在字符串的原型链上添加一个方法，实现字符串翻转：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">String</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_reverse</span> = <span class="keyword">function</span>(<span class="params">a</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> a.<span class="title function_">split</span>(<span class="string">&quot;&quot;</span>).<span class="title function_">reverse</span>().<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title class_">String</span>();</span><br><span class="line"><span class="keyword">var</span> res = obj.<span class="property">_reverse</span> (<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res);    <span class="comment">// olleh</span></span><br></pre></td></tr></table></figure><p>需要注意的是，必须通过实例化对象之后再去调用定义的方法，不然找不到该方法。</p><h3 id="13-将数字每千分位用逗号隔开"><a href="#13-将数字每千分位用逗号隔开" class="headerlink" title="13. 将数字每千分位用逗号隔开"></a>13. 将数字每千分位用逗号隔开</h3><p><strong>数字有小数版本：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">format</span> = n =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> num = n.<span class="title function_">toString</span>() <span class="comment">// 转成字符串</span></span><br><span class="line">    <span class="keyword">let</span> decimals = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="comment">// 判断是否有小数</span></span><br><span class="line">    num.<span class="title function_">indexOf</span>(<span class="string">&#x27;.&#x27;</span>) &gt; -<span class="number">1</span> ? decimals = num.<span class="title function_">split</span>(<span class="string">&#x27;.&#x27;</span>)[<span class="number">1</span>] : decimals</span><br><span class="line">    <span class="keyword">let</span> len = num.<span class="property">length</span></span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> num</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> temp = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">let</span> remainder = len % <span class="number">3</span></span><br><span class="line">        decimals ? temp = <span class="string">&#x27;.&#x27;</span> + decimals : temp</span><br><span class="line">        <span class="keyword">if</span> (remainder &gt; <span class="number">0</span>) &#123; <span class="comment">// 不是3的整数倍</span></span><br><span class="line">            <span class="keyword">return</span> num.<span class="title function_">slice</span>(<span class="number">0</span>, remainder) + <span class="string">&#x27;,&#x27;</span> + num.<span class="title function_">slice</span>(remainder, len).<span class="title function_">match</span>(<span class="regexp">/\d&#123;3&#125;/g</span>).<span class="title function_">join</span>(<span class="string">&#x27;,&#x27;</span>) + temp</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 是3的整数倍</span></span><br><span class="line">            <span class="keyword">return</span> num.<span class="title function_">slice</span>(<span class="number">0</span>, len).<span class="title function_">match</span>(<span class="regexp">/\d&#123;3&#125;/g</span>).<span class="title function_">join</span>(<span class="string">&#x27;,&#x27;</span>) + temp </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">format</span>(<span class="number">12323.33</span>)  <span class="comment">// &#x27;12,323.33&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>数字无小数版本：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">format</span> = n =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> num = n.<span class="title function_">toString</span>() </span><br><span class="line">    <span class="keyword">let</span> len = num.<span class="property">length</span></span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> num</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> remainder = len % <span class="number">3</span></span><br><span class="line">        <span class="keyword">if</span> (remainder &gt; <span class="number">0</span>) &#123; <span class="comment">// 不是3的整数倍</span></span><br><span class="line">            <span class="keyword">return</span> num.<span class="title function_">slice</span>(<span class="number">0</span>, remainder) + <span class="string">&#x27;,&#x27;</span> + num.<span class="title function_">slice</span>(remainder, len).<span class="title function_">match</span>(<span class="regexp">/\d&#123;3&#125;/g</span>).<span class="title function_">join</span>(<span class="string">&#x27;,&#x27;</span>) </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 是3的整数倍</span></span><br><span class="line">            <span class="keyword">return</span> num.<span class="title function_">slice</span>(<span class="number">0</span>, len).<span class="title function_">match</span>(<span class="regexp">/\d&#123;3&#125;/g</span>).<span class="title function_">join</span>(<span class="string">&#x27;,&#x27;</span>) </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">format</span>(<span class="number">1232323</span>)  <span class="comment">// &#x27;1,232,323&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="14-实现非负大整数相加"><a href="#14-实现非负大整数相加" class="headerlink" title="14. 实现非负大整数相加"></a>14. 实现非负大整数相加</h3><p>JavaScript对数值有范围的限制，限制如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Number</span>.<span class="property">MAX_VALUE</span> <span class="comment">// 1.7976931348623157e+308</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="property">MAX_SAFE_INTEGER</span> <span class="comment">// 9007199254740991</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="property">MIN_VALUE</span> <span class="comment">// 5e-324</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="property">MIN_SAFE_INTEGER</span> <span class="comment">// -9007199254740991</span></span><br></pre></td></tr></table></figure><p>如果想要对一个超大的整数(<code>&gt; Number.MAX_SAFE_INTEGER</code>)进行加法运算，但是又想输出一般形式，那么使用 + 是无法达到的，一旦数字超过 <code>Number.MAX_SAFE_INTEGER</code> 数字会被立即转换为科学计数法，并且数字精度相比以前将会有误差。</p><p>实现一个算法进行大数的相加：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sumBigNumber</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="keyword">let</span> temp = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  a = a.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">  b = b.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span> (a.<span class="property">length</span> || b.<span class="property">length</span> || temp) &#123;</span><br><span class="line">    temp += ~~a.<span class="title function_">pop</span>() + ~~b.<span class="title function_">pop</span>();</span><br><span class="line">    res = (temp % <span class="number">10</span>) + res;</span><br><span class="line">    temp  = temp &gt; <span class="number">9</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res.<span class="title function_">replace</span>(<span class="regexp">/^0+/</span>, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其主要的思路如下：</p><ul><li>首先用字符串的方式来保存大数，这样数字在数学表示上就不会发生变化</li><li>初始化res，temp来保存中间的计算结果，并将两个字符串转化为数组，以便进行每一位的加法运算</li><li>将两个数组的对应的位进行相加，两个数相加的结果可能大于10，所以可能要仅为，对10进行取余操作，将结果保存在当前位</li><li>判断当前位是否大于9，也就是是否会进位，若是则将temp赋值为true，因为在加法运算中，true会自动隐式转化为1，以便于下一次相加</li><li>重复上述操作，直至计算结束</li></ul><h3 id="13-实现-add-1-2-3"><a href="#13-实现-add-1-2-3" class="headerlink" title="13. 实现 add(1)(2)(3)"></a>13. 实现 add(1)(2)(3)</h3><p>函数柯里化概念： 柯里化（Currying）是把接受多个参数的函数转变为接受一个单一参数的函数，并且返回接受余下的参数且返回结果的新函数的技术。</p><p>1）粗暴版</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span> (a) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">b</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">c</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> a + b + c;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">add</span>(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><p>2）柯里化解决方案</p><ul><li>参数长度固定</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> add = <span class="keyword">function</span> (<span class="params">m</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> temp = <span class="keyword">function</span> (<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">add</span>(m + n);</span><br><span class="line">  &#125;</span><br><span class="line">  temp.<span class="property">toString</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> temp;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">add</span>(<span class="number">3</span>)(<span class="number">4</span>)(<span class="number">5</span>)); <span class="comment">// 12</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">add</span>(<span class="number">3</span>)(<span class="number">6</span>)(<span class="number">9</span>)(<span class="number">25</span>)); <span class="comment">// 43</span></span><br></pre></td></tr></table></figure><p>对于add(3)(4)(5)，其执行过程如下：</p><ol><li>先执行add(3)，此时m=3，并且返回temp函数；</li><li>执行temp(4)，这个函数内执行add(m+n)，n是此次传进来的数值4，m值还是上一步中的3，所以add(m+n)=add(3+4)=add(7)，此时m=7，并且返回temp函数</li><li>执行temp(5)，这个函数内执行add(m+n)，n是此次传进来的数值5，m值还是上一步中的7，所以add(m+n)=add(7+5)=add(12)，此时m=12，并且返回temp函数</li><li>由于后面没有传入参数，等于返回的temp函数不被执行而是打印，了解JS的朋友都知道对象的toString是修改对象转换字符串的方法，因此代码中temp函数的toString函数return m值，而m值是最后一步执行函数时的值m=12，所以返回值是12。</li></ol><ul><li>参数长度不固定</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span> (...args) &#123;</span><br><span class="line">    <span class="comment">//求和</span></span><br><span class="line">    <span class="keyword">return</span> args.<span class="title function_">reduce</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">currying</span> (fn) &#123;</span><br><span class="line">    <span class="keyword">let</span> args = []</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">temp</span> (...newArgs) &#123;</span><br><span class="line">        <span class="keyword">if</span> (newArgs.<span class="property">length</span>) &#123;</span><br><span class="line">            args = [</span><br><span class="line">                ...args,</span><br><span class="line">                ...newArgs</span><br><span class="line">            ]</span><br><span class="line">            <span class="keyword">return</span> temp</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> val = fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args)</span><br><span class="line">            args = [] <span class="comment">//保证再次调用时清空</span></span><br><span class="line">            <span class="keyword">return</span> val</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> addCurry = <span class="title function_">currying</span>(add)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">addCurry</span>(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>, <span class="number">5</span>)())  <span class="comment">//15</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">addCurry</span>(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)())  <span class="comment">//15</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">addCurry</span>(<span class="number">1</span>)(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)())  <span class="comment">//15</span></span><br></pre></td></tr></table></figure><h3 id="14-实现类数组转化为数组"><a href="#14-实现类数组转化为数组" class="headerlink" title="14. 实现类数组转化为数组"></a>14. 实现类数组转化为数组</h3><p>类数组转换为数组的方法有这样几种：</p><ul><li>通过 call 调用数组的 slice 方法来实现转换</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(arrayLike);</span><br></pre></td></tr></table></figure><ul><li>通过 call 调用数组的 splice 方法来实现转换</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">splice</span>.<span class="title function_">call</span>(arrayLike, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><ul><li>通过 apply 调用数组的 concat 方法来实现转换</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">concat</span>.<span class="title function_">apply</span>([], arrayLike);</span><br></pre></td></tr></table></figure><ul><li>通过 Array.from 方法来实现转换</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="title function_">from</span>(arrayLike);</span><br></pre></td></tr></table></figure><h3 id="15-使用-reduce-求和"><a href="#15-使用-reduce-求和" class="headerlink" title="15. 使用 reduce 求和"></a>15. 使用 reduce 求和</h3><p>arr = [1,2,3,4,5,6,7,8,9,10]，求和</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>]</span><br><span class="line">arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">prev, cur</span>) =&gt;</span> &#123; <span class="keyword">return</span> prev + cur &#125;, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>arr = [1,2,3,[[4,5],6],7,8,9]，求和</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>]</span><br><span class="line">arr.<span class="title function_">flat</span>(<span class="title class_">Infinity</span>).<span class="title function_">reduce</span>(<span class="function">(<span class="params">prev, cur</span>) =&gt;</span> &#123; <span class="keyword">return</span> prev + cur &#125;, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>arr = [{a:1, b:3}, {a:2, b:3, c:4}, {a:3}]，求和</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [&#123;<span class="attr">a</span>:<span class="number">9</span>, <span class="attr">b</span>:<span class="number">3</span>, <span class="attr">c</span>:<span class="number">4</span>&#125;, &#123;<span class="attr">a</span>:<span class="number">1</span>, <span class="attr">b</span>:<span class="number">3</span>&#125;, &#123;<span class="attr">a</span>:<span class="number">3</span>&#125;] </span><br><span class="line"></span><br><span class="line">arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">prev, cur</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> prev + cur[<span class="string">&quot;a&quot;</span>];</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><h3 id="16-将js对象转化为树形结构"><a href="#16-将js对象转化为树形结构" class="headerlink" title="16. 将js对象转化为树形结构"></a>16. 将js对象转化为树形结构</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 转换前：</span></span><br><span class="line">source = [&#123;</span><br><span class="line">            <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="attr">pid</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">name</span>: <span class="string">&#x27;body&#x27;</span></span><br><span class="line">          &#125;, &#123;</span><br><span class="line">            <span class="attr">id</span>: <span class="number">2</span>,</span><br><span class="line">            <span class="attr">pid</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="attr">name</span>: <span class="string">&#x27;title&#x27;</span></span><br><span class="line">          &#125;, &#123;</span><br><span class="line">            <span class="attr">id</span>: <span class="number">3</span>,</span><br><span class="line">            <span class="attr">pid</span>: <span class="number">2</span>,</span><br><span class="line">            <span class="attr">name</span>: <span class="string">&#x27;div&#x27;</span></span><br><span class="line">          &#125;]</span><br><span class="line"><span class="comment">// 转换为: </span></span><br><span class="line">tree = [&#123;</span><br><span class="line">          <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">          <span class="attr">pid</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">name</span>: <span class="string">&#x27;body&#x27;</span>,</span><br><span class="line">          <span class="attr">children</span>: [&#123;</span><br><span class="line">            <span class="attr">id</span>: <span class="number">2</span>,</span><br><span class="line">            <span class="attr">pid</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="attr">name</span>: <span class="string">&#x27;title&#x27;</span>,</span><br><span class="line">            <span class="attr">children</span>: [&#123;</span><br><span class="line">              <span class="attr">id</span>: <span class="number">3</span>,</span><br><span class="line">              <span class="attr">pid</span>: <span class="number">1</span>,</span><br><span class="line">              <span class="attr">name</span>: <span class="string">&#x27;div&#x27;</span></span><br><span class="line">            &#125;]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;]</span><br></pre></td></tr></table></figure><p>代码实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">jsonToTree</span>(<span class="params">data</span>) &#123;</span><br><span class="line">  <span class="comment">// 初始化结果数组，并判断输入数据的格式</span></span><br><span class="line">  <span class="keyword">let</span> result = []</span><br><span class="line">  <span class="keyword">if</span>(!<span class="title class_">Array</span>.<span class="title function_">isArray</span>(data)) &#123;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 使用map，将当前对象的id与当前对象对应存储起来</span></span><br><span class="line">  <span class="keyword">let</span> map = &#123;&#125;;</span><br><span class="line">  data.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    map[item.<span class="property">id</span>] = item;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// </span></span><br><span class="line">  data.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> parent = map[item.<span class="property">pid</span>];</span><br><span class="line">    <span class="keyword">if</span>(parent) &#123;</span><br><span class="line">      (parent.<span class="property">children</span> || (parent.<span class="property">children</span> = [])).<span class="title function_">push</span>(item);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result.<span class="title function_">push</span>(item);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="17-使用ES5和ES6求函数参数的和"><a href="#17-使用ES5和ES6求函数参数的和" class="headerlink" title="17. 使用ES5和ES6求函数参数的和"></a>17. 使用ES5和ES6求函数参数的和</h3><p>ES5：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span></span><br><span class="line">    <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">forEach</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>, <span class="keyword">function</span>(<span class="params">item</span>) &#123;</span><br><span class="line">        sum += item * <span class="number">1</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ES6：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">...nums</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span></span><br><span class="line">    nums.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">item</span>) &#123;</span><br><span class="line">        sum += item * <span class="number">1</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="18-解析-URL-Params-为对象"><a href="#18-解析-URL-Params-为对象" class="headerlink" title="18. 解析 URL Params 为对象"></a>18. 解析 URL Params 为对象</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> url = <span class="string">&#x27;http://www.domain.com/?user=anonymous&amp;id=123&amp;id=456&amp;city=%E5%8C%97%E4%BA%AC&amp;enabled&#x27;</span>;</span><br><span class="line"><span class="title function_">parseParam</span>(url)</span><br><span class="line"><span class="comment">/* 结果</span></span><br><span class="line"><span class="comment">&#123; user: &#x27;anonymous&#x27;,</span></span><br><span class="line"><span class="comment">  id: [ 123, 456 ], // 重复出现的 key 要组装成数组，能被转成数字的就转成数字类型</span></span><br><span class="line"><span class="comment">  city: &#x27;北京&#x27;, // 中文需解码</span></span><br><span class="line"><span class="comment">  enabled: true, // 未指定值得 key 约定为 true</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">parseParam</span>(<span class="params">url</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> paramsStr = <span class="regexp">/.+\?(.+)$/</span>.<span class="title function_">exec</span>(url)[<span class="number">1</span>]; <span class="comment">// 将 ? 后面的字符串取出来</span></span><br><span class="line">  <span class="keyword">const</span> paramsArr = paramsStr.<span class="title function_">split</span>(<span class="string">&#x27;&amp;&#x27;</span>); <span class="comment">// 将字符串以 &amp; 分割后存到数组中</span></span><br><span class="line">  <span class="keyword">let</span> paramsObj = &#123;&#125;;</span><br><span class="line">  <span class="comment">// 将 params 存到对象中</span></span><br><span class="line">  paramsArr.<span class="title function_">forEach</span>(<span class="function"><span class="params">param</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="regexp">/=/</span>.<span class="title function_">test</span>(param)) &#123; <span class="comment">// 处理有 value 的参数</span></span><br><span class="line">      <span class="keyword">let</span> [key, val] = param.<span class="title function_">split</span>(<span class="string">&#x27;=&#x27;</span>); <span class="comment">// 分割 key 和 value</span></span><br><span class="line">      val = <span class="built_in">decodeURIComponent</span>(val); <span class="comment">// 解码</span></span><br><span class="line">      val = <span class="regexp">/^\d+$/</span>.<span class="title function_">test</span>(val) ? <span class="built_in">parseFloat</span>(val) : val; <span class="comment">// 判断是否转为数字</span></span><br><span class="line">      <span class="keyword">if</span> (paramsObj.<span class="title function_">hasOwnProperty</span>(key)) &#123; <span class="comment">// 如果对象有 key，则添加一个值</span></span><br><span class="line">        paramsObj[key] = [].<span class="title function_">concat</span>(paramsObj[key], val);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果对象没有这个 key，创建 key 并设置值</span></span><br><span class="line">        paramsObj[key] = val;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 处理没有 value 的参数</span></span><br><span class="line">      paramsObj[param] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> paramsObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、场景应用"><a href="#三、场景应用" class="headerlink" title="三、场景应用"></a>三、场景应用</h2><h3 id="1-循环打印红黄绿"><a href="#1-循环打印红黄绿" class="headerlink" title="1. 循环打印红黄绿"></a>1. 循环打印红黄绿</h3><p>下面来看一道比较典型的问题，通过这个问题来对比几种异步编程方法：<strong>红灯 3s 亮一次，绿灯 1s 亮一次，黄灯 2s 亮一次；如何让三个灯不断交替重复亮灯？</strong></p><p>三个亮灯函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">red</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;red&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">green</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;green&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">yellow</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;yellow&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题复杂的地方在于<strong>需要“交替重复”亮灯</strong>，而不是“亮完一次”就结束了。</p><h4 id="（1）用-callback-实现"><a href="#（1）用-callback-实现" class="headerlink" title="（1）用 callback 实现"></a>（1）用 callback 实现</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">task</span> = (<span class="params">timer, light, callback</span>) =&gt; &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (light === <span class="string">&#x27;red&#x27;</span>) &#123;</span><br><span class="line">            <span class="title function_">red</span>()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (light === <span class="string">&#x27;green&#x27;</span>) &#123;</span><br><span class="line">            <span class="title function_">green</span>()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (light === <span class="string">&#x27;yellow&#x27;</span>) &#123;</span><br><span class="line">            <span class="title function_">yellow</span>()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">callback</span>()</span><br><span class="line">    &#125;, timer)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">task</span>(<span class="number">3000</span>, <span class="string">&#x27;red&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">task</span>(<span class="number">2000</span>, <span class="string">&#x27;green&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">task</span>(<span class="number">1000</span>, <span class="string">&#x27;yellow&#x27;</span>, <span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这里存在一个 bug：代码只是完成了一次流程，执行后红黄绿灯分别只亮一次。该如何让它交替重复进行呢？</p><p>上面提到过递归，可以递归亮灯的一个周期：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">step</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="title function_">task</span>(<span class="number">3000</span>, <span class="string">&#x27;red&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">task</span>(<span class="number">2000</span>, <span class="string">&#x27;green&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">task</span>(<span class="number">1000</span>, <span class="string">&#x27;yellow&#x27;</span>, step)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">step</span>()</span><br></pre></td></tr></table></figure><p><strong>注意看黄灯亮的回调里又再次调用了 step 方法</strong> 以完成循环亮灯。</p><h4 id="（2）用-promise-实现"><a href="#（2）用-promise-实现" class="headerlink" title="（2）用 promise 实现"></a>（2）用 promise 实现</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">task</span> = (<span class="params">timer, light</span>) =&gt; </span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (light === <span class="string">&#x27;red&#x27;</span>) &#123;</span><br><span class="line">                <span class="title function_">red</span>()</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (light === <span class="string">&#x27;green&#x27;</span>) &#123;</span><br><span class="line">                <span class="title function_">green</span>()</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (light === <span class="string">&#x27;yellow&#x27;</span>) &#123;</span><br><span class="line">                <span class="title function_">yellow</span>()</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="title function_">resolve</span>()</span><br><span class="line">        &#125;, timer)</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">step</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="title function_">task</span>(<span class="number">3000</span>, <span class="string">&#x27;red&#x27;</span>)</span><br><span class="line">        .<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="title function_">task</span>(<span class="number">2000</span>, <span class="string">&#x27;green&#x27;</span>))</span><br><span class="line">        .<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="title function_">task</span>(<span class="number">2100</span>, <span class="string">&#x27;yellow&#x27;</span>))</span><br><span class="line">        .<span class="title function_">then</span>(step)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">step</span>()</span><br></pre></td></tr></table></figure><p>这里将回调移除，在一次亮灯结束后，resolve 当前 promise，并依然使用递归进行。</p><h4 id="（3）用-async-await-实现"><a href="#（3）用-async-await-实现" class="headerlink" title="（3）用 async/await 实现"></a>（3）用 async/await 实现</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">taskRunner</span> =  <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">task</span>(<span class="number">3000</span>, <span class="string">&#x27;red&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">task</span>(<span class="number">2000</span>, <span class="string">&#x27;green&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">task</span>(<span class="number">2100</span>, <span class="string">&#x27;yellow&#x27;</span>)</span><br><span class="line">    <span class="title function_">taskRunner</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">taskRunner</span>()</span><br></pre></td></tr></table></figure><h3 id="2-实现每隔一秒打印-1-2-3-4"><a href="#2-实现每隔一秒打印-1-2-3-4" class="headerlink" title="2. 实现每隔一秒打印 1,2,3,4"></a>2. 实现每隔一秒打印 1,2,3,4</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用闭包实现</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  (<span class="keyword">function</span>(<span class="params">i</span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">    &#125;, i * <span class="number">1000</span>);</span><br><span class="line">  &#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用 let 块级作用域</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">  &#125;, i * <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-小孩报数问题"><a href="#3-小孩报数问题" class="headerlink" title="3. 小孩报数问题"></a>3. 小孩报数问题</h3><p>有30个小孩儿，编号从1-30，围成一圈依此报数，1、2、3 数到 3 的小孩儿退出这个圈， 然后下一个小孩 重新报数 1、2、3，问最后剩下的那个小孩儿的编号是多少?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">childNum</span>(<span class="params">num, count</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> allplayer = [];    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; num; i++)&#123;</span><br><span class="line">        allplayer[i] = i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> exitCount = <span class="number">0</span>;    <span class="comment">// 离开人数</span></span><br><span class="line">    <span class="keyword">let</span> counter = <span class="number">0</span>;      <span class="comment">// 记录报数</span></span><br><span class="line">    <span class="keyword">let</span> curIndex = <span class="number">0</span>;     <span class="comment">// 当前下标</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(exitCount &lt; num - <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(allplayer[curIndex] !== <span class="number">0</span>) counter++;    </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(counter == count)&#123;</span><br><span class="line">            allplayer[curIndex] = <span class="number">0</span>;                 </span><br><span class="line">            counter = <span class="number">0</span>;</span><br><span class="line">            exitCount++;  </span><br><span class="line">        &#125;</span><br><span class="line">        curIndex++;</span><br><span class="line">        <span class="keyword">if</span>(curIndex == num)&#123;</span><br><span class="line">            curIndex = <span class="number">0</span>               </span><br><span class="line">        &#125;;           </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; num; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(allplayer[i] !== <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> allplayer[i]</span><br><span class="line">        &#125;      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">childNum</span>(<span class="number">30</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><h3 id="4-用Promise实现图片的异步加载"><a href="#4-用Promise实现图片的异步加载" class="headerlink" title="4. 用Promise实现图片的异步加载"></a>4. 用Promise实现图片的异步加载</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">imageAsync</span>=(<span class="params">url</span>)=&gt;&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">                <span class="keyword">let</span> img = <span class="keyword">new</span> <span class="title class_">Image</span>();</span><br><span class="line">                img.<span class="property">src</span> = url;</span><br><span class="line">                img.οnlοad=<span class="function">()=&gt;</span>&#123;</span><br><span class="line">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`图片请求成功，此处进行通用操作`</span>);</span><br><span class="line">                    <span class="title function_">resolve</span>(image);</span><br><span class="line">                &#125;</span><br><span class="line">                img.οnerrοr=<span class="function">(<span class="params">err</span>)=&gt;</span>&#123;</span><br><span class="line">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`失败，此处进行失败的通用操作`</span>);</span><br><span class="line">                    <span class="title function_">reject</span>(err);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"><span class="title function_">imageAsync</span>(<span class="string">&quot;url&quot;</span>).<span class="title function_">then</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;加载成功&quot;</span>);</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;加载失败&quot;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="5-实现发布-订阅模式"><a href="#5-实现发布-订阅模式" class="headerlink" title="5. 实现发布-订阅模式"></a>5. 实现发布-订阅模式</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EventCenter</span>&#123;</span><br><span class="line">  <span class="comment">// 1. 定义事件容器，用来装事件数组</span></span><br><span class="line"><span class="keyword">let</span> handlers = &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 添加事件方法，参数：事件名 事件方法</span></span><br><span class="line">  <span class="title function_">addEventListener</span>(<span class="params">type, handler</span>) &#123;</span><br><span class="line">    <span class="comment">// 创建新数组容器</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">handlers</span>[type]) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">handlers</span>[type] = []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 存入事件</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">handlers</span>[type].<span class="title function_">push</span>(handler)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. 触发事件，参数：事件名 事件参数</span></span><br><span class="line">  <span class="title function_">dispatchEvent</span>(<span class="params">type, params</span>) &#123;</span><br><span class="line">    <span class="comment">// 若没有注册该事件则抛出错误</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">handlers</span>[type]) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;该事件未注册&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 触发事件</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">handlers</span>[type].<span class="title function_">forEach</span>(<span class="function"><span class="params">handler</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">handler</span>(...params)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4. 事件移除，参数：事件名 要删除事件，若无第二个参数则删除该事件的订阅和发布</span></span><br><span class="line">  <span class="title function_">removeEventListener</span>(<span class="params">type, handler</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">handlers</span>[type]) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;事件无效&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!handler) &#123;</span><br><span class="line">      <span class="comment">// 移除事件</span></span><br><span class="line">      <span class="keyword">delete</span> <span class="variable language_">this</span>.<span class="property">handlers</span>[type]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> index = <span class="variable language_">this</span>.<span class="property">handlers</span>[type].<span class="title function_">findIndex</span>(<span class="function"><span class="params">el</span> =&gt;</span> el === handler)</span><br><span class="line">      <span class="keyword">if</span> (index === -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;无该绑定事件&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 移除事件</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">handlers</span>[type].<span class="title function_">splice</span>(index, <span class="number">1</span>)</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">handlers</span>[type].<span class="property">length</span> === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">delete</span> <span class="variable language_">this</span>.<span class="property">handlers</span>[type]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-查找文章中出现频率最高的单词"><a href="#6-查找文章中出现频率最高的单词" class="headerlink" title="6. 查找文章中出现频率最高的单词"></a>6. 查找文章中出现频率最高的单词</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">findMostWord</span>(<span class="params">article</span>) &#123;</span><br><span class="line">  <span class="comment">// 合法性判断</span></span><br><span class="line">  <span class="keyword">if</span> (!article) <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// 参数处理</span></span><br><span class="line">  article = article.<span class="title function_">trim</span>().<span class="title function_">toLowerCase</span>();</span><br><span class="line">  <span class="keyword">let</span> wordList = article.<span class="title function_">match</span>(<span class="regexp">/[a-z]+/g</span>),</span><br><span class="line">    visited = [],</span><br><span class="line">    maxNum = <span class="number">0</span>,</span><br><span class="line">    maxWord = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  article = <span class="string">&quot; &quot;</span> + wordList.<span class="title function_">join</span>(<span class="string">&quot;  &quot;</span>) + <span class="string">&quot; &quot;</span>;</span><br><span class="line">  <span class="comment">// 遍历判断单词出现次数</span></span><br><span class="line">  wordList.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">item</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (visited.<span class="title function_">indexOf</span>(item) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 加入 visited </span></span><br><span class="line">      visited.<span class="title function_">push</span>(item);</span><br><span class="line">      <span class="keyword">let</span> word = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&quot; &quot;</span> + item + <span class="string">&quot; &quot;</span>, <span class="string">&quot;g&quot;</span>),</span><br><span class="line">        num = article.<span class="title function_">match</span>(word).<span class="property">length</span>;</span><br><span class="line">      <span class="keyword">if</span> (num &gt; maxNum) &#123;</span><br><span class="line">        maxNum = num;</span><br><span class="line">        maxWord = item;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> maxWord + <span class="string">&quot;  &quot;</span> + maxNum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-封装异步的fetch，使用async-await方式来使用"><a href="#7-封装异步的fetch，使用async-await方式来使用" class="headerlink" title="7. 封装异步的fetch，使用async await方式来使用"></a>7. 封装异步的fetch，使用async await方式来使用</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">HttpRequestUtil</span> &#123;</span><br><span class="line">        <span class="keyword">async</span> <span class="title function_">get</span>(<span class="params">url</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">fetch</span>(url);</span><br><span class="line">            <span class="keyword">const</span> data = <span class="keyword">await</span> res.<span class="title function_">json</span>();</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">async</span> <span class="title function_">post</span>(<span class="params">url, data</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">fetch</span>(url, &#123;</span><br><span class="line">                <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">                <span class="attr">headers</span>: &#123;</span><br><span class="line">                    <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">body</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(data)</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">const</span> result = <span class="keyword">await</span> res.<span class="title function_">json</span>();</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">async</span> <span class="title function_">put</span>(<span class="params">url, data</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">fetch</span>(url, &#123;</span><br><span class="line">                <span class="attr">method</span>: <span class="string">&#x27;PUT&#x27;</span>,</span><br><span class="line">                <span class="attr">headers</span>: &#123;</span><br><span class="line">                    <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">data</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(data)</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">const</span> result = <span class="keyword">await</span> res.<span class="title function_">json</span>();</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">async</span> <span class="title function_">delete</span>(<span class="params">url, data</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">fetch</span>(url, &#123;</span><br><span class="line">                <span class="attr">method</span>: <span class="string">&#x27;DELETE&#x27;</span>,</span><br><span class="line">                <span class="attr">headers</span>: &#123;</span><br><span class="line">                    <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">data</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(data)</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">const</span> result = <span class="keyword">await</span> res.<span class="title function_">json</span>();</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> httpRequestUtil = <span class="keyword">new</span> <span class="title class_">HttpRequestUtil</span>();</span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">await</span> httpRequestUtil.<span class="title function_">get</span>(<span class="string">&#x27;http://golderbrother.cn/&#x27;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h3 id="8-实现prototype继承"><a href="#8-实现prototype继承" class="headerlink" title="8. 实现prototype继承"></a>8. 实现prototype继承</h3><p>所谓的原型链继承就是让新实例的原型等于父类的实例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父方法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SupperFunction</span>(<span class="params">flag1</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">flag1</span> = flag1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子方法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SubFunction</span>(<span class="params">flag2</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">flag2</span> = flag2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//父实例</span></span><br><span class="line"><span class="keyword">var</span> superInstance = <span class="keyword">new</span> <span class="title class_">SupperFunction</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//子继承父</span></span><br><span class="line"><span class="title class_">SubFunction</span>.<span class="property"><span class="keyword">prototype</span></span> = superInstance;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子实例</span></span><br><span class="line"><span class="keyword">var</span> subInstance = <span class="keyword">new</span> <span class="title class_">SubFunction</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="comment">//子调用自己和父的属性</span></span><br><span class="line">subInstance.<span class="property">flag1</span>;   <span class="comment">// true</span></span><br><span class="line">subInstance.<span class="property">flag2</span>;   <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="9-实现双向数据绑定"><a href="#9-实现双向数据绑定" class="headerlink" title="9. 实现双向数据绑定"></a>9. 实现双向数据绑定</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> input = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;input&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> span = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;span&#x27;</span>)</span><br><span class="line"><span class="comment">// 数据劫持</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;text&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;获取数据了&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">set</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;数据更新了&#x27;</span>)</span><br><span class="line">    input.<span class="property">value</span> = newVal</span><br><span class="line">    span.<span class="property">innerHTML</span> = newVal</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 输入监听</span></span><br><span class="line">input.<span class="title function_">addEventListener</span>(<span class="string">&#x27;keyup&#x27;</span>, <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  obj.<span class="property">text</span> = e.<span class="property">target</span>.<span class="property">value</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="10-实现简单路由"><a href="#10-实现简单路由" class="headerlink" title="10. 实现简单路由"></a>10. 实现简单路由</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hash路由</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Route</span>&#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">// 路由存储对象</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">routes</span> = &#123;&#125;</span><br><span class="line">    <span class="comment">// 当前hash</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">currentHash</span> = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="comment">// 绑定this，避免监听时this指向改变</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">freshRoute</span> = <span class="variable language_">this</span>.<span class="property">freshRoute</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>)</span><br><span class="line">    <span class="comment">// 监听</span></span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;load&#x27;</span>, <span class="variable language_">this</span>.<span class="property">freshRoute</span>, <span class="literal">false</span>)</span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;hashchange&#x27;</span>, <span class="variable language_">this</span>.<span class="property">freshRoute</span>, <span class="literal">false</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 存储</span></span><br><span class="line">  storeRoute (path, cb) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">routes</span>[path] = cb || <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 更新</span></span><br><span class="line">  freshRoute () &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">currentHash</span> = location.<span class="property">hash</span>.<span class="title function_">slice</span>(<span class="number">1</span>) || <span class="string">&#x27;/&#x27;</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">routes</span>[<span class="variable language_">this</span>.<span class="property">currentHash</span>]()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-实现斐波那契数列"><a href="#11-实现斐波那契数列" class="headerlink" title="11. 实现斐波那契数列"></a>11. 实现斐波那契数列</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span> (n)&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">fn</span>(n-<span class="number">2</span>)+<span class="title function_">fn</span>(n-<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 优化</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fibonacci2</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">const</span> arrLen = arr.<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n &lt;= arrLen) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr[n];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = arrLen; i &lt; n; i++) &#123;</span><br><span class="line">        arr.<span class="title function_">push</span>(arr[i - <span class="number">1</span>] + arr[ i - <span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arr[arr.<span class="property">length</span> - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 非递归</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> pre1 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> pre2 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> current = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> current;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">        pre1 = pre2;</span><br><span class="line">        pre2 = current;</span><br><span class="line">        current = pre1 + pre2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> current;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12-字符串出现的不重复最长长度"><a href="#12-字符串出现的不重复最长长度" class="headerlink" title="12. 字符串出现的不重复最长长度"></a>12. 字符串出现的不重复最长长度</h3><p>用一个滑动窗口装没有重复的字符，枚举字符记录最大值即可。用 map 维护字符的索引，遇到相同的字符，把左边界移动过去即可。挪动的过程中记录最大长度：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lengthOfLongestSubstring = <span class="keyword">function</span> (<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">    <span class="keyword">let</span> i = -<span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> n = s.<span class="property">length</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.<span class="title function_">has</span>(s[j])) &#123;</span><br><span class="line">            i = <span class="title class_">Math</span>.<span class="title function_">max</span>(i, map.<span class="title function_">get</span>(s[j]))</span><br><span class="line">        &#125;</span><br><span class="line">        res = <span class="title class_">Math</span>.<span class="title function_">max</span>(res, j - i)</span><br><span class="line">        map.<span class="title function_">set</span>(s[j], j)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="13-使用-setTimeout-实现-setInterval"><a href="#13-使用-setTimeout-实现-setInterval" class="headerlink" title="13. 使用 setTimeout 实现 setInterval"></a>13. 使用 setTimeout 实现 setInterval</h3><p>setInterval 的作用是每隔一段指定时间执行一个函数，但是这个执行不是真的到了时间立即执行，它真正的作用是每隔一段时间将事件加入事件队列中去，只有当当前的执行栈为空的时候，才能去从事件队列中取出事件执行。所以可能会出现这样的情况，就是当前执行栈执行的时间很长，导致事件队列里边积累多个定时器加入的事件，当执行栈结束的时候，这些事件会依次执行，因此就不能到间隔一段时间执行的效果。</p><p>针对 setInterval 的这个缺点，我们可以使用 setTimeout 递归调用来模拟 setInterval，这样我们就确保了只有一个事件结束了，我们才会触发下一个定时器事件，这样解决了 setInterval 的问题。</p><p>实现思路是使用递归函数，不断地去执行 setTimeout 从而达到 setInterval 的效果</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mySetInterval</span>(<span class="params">fn, timeout</span>) &#123;</span><br><span class="line">  <span class="comment">// 控制器，控制定时器是否继续执行</span></span><br><span class="line">  <span class="keyword">var</span> timer = &#123;</span><br><span class="line">    <span class="attr">flag</span>: <span class="literal">true</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 设置递归函数，模拟定时器执行。</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">interval</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (timer.<span class="property">flag</span>) &#123;</span><br><span class="line">      <span class="title function_">fn</span>();</span><br><span class="line">      <span class="built_in">setTimeout</span>(interval, timeout);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 启动定时器</span></span><br><span class="line">  <span class="built_in">setTimeout</span>(interval, timeout);</span><br><span class="line">  <span class="comment">// 返回控制器</span></span><br><span class="line">  <span class="keyword">return</span> timer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="14-实现-jsonp"><a href="#14-实现-jsonp" class="headerlink" title="14. 实现 jsonp"></a>14. 实现 jsonp</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态的加载js文件</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addScript</span>(<span class="params">src</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">  script.<span class="property">src</span> = src;</span><br><span class="line">  script.<span class="property">type</span> = <span class="string">&quot;text/javascript&quot;</span>;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(script);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">addScript</span>(<span class="string">&quot;http://xxx.xxx.com/xxx.js?callback=handleRes&quot;</span>);</span><br><span class="line"><span class="comment">// 设置一个全局的callback函数来接收回调结果</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">handleRes</span>(<span class="params">res</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 接口返回的数据格式</span></span><br><span class="line"><span class="title function_">handleRes</span>(&#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;);</span><br></pre></td></tr></table></figure><h3 id="15-判断对象是否存在循环引用"><a href="#15-判断对象是否存在循环引用" class="headerlink" title="15. 判断对象是否存在循环引用"></a>15. 判断对象是否存在循环引用</h3><p>循环引用对象本来没有什么问题，但是序列化的时候就会发生问题，比如调用<code>JSON.stringify()</code>对该类对象进行序列化，就会报错: <code>Converting circular structure to JSON.</code></p><p>下面方法可以用来判断一个对象中是否已存在循环引用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">isCycleObject</span> = (<span class="params">obj,parent</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> parentArr = parent || [obj];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> obj[i] === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> flag = <span class="literal">false</span>;</span><br><span class="line">            parentArr.<span class="title function_">forEach</span>(<span class="function">(<span class="params">pObj</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(pObj === obj[i])&#123;</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="keyword">if</span>(flag) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            flag = <span class="title function_">isCycleObject</span>(obj[i],[...parentArr,obj[i]]);</span><br><span class="line">            <span class="keyword">if</span>(flag) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> b = &#123;a&#125;;</span><br><span class="line"><span class="keyword">const</span> c = &#123;b&#125;;</span><br><span class="line"><span class="keyword">const</span> o = &#123;<span class="attr">d</span>:&#123;<span class="attr">a</span>:<span class="number">3</span>&#125;,c&#125;</span><br><span class="line">o.<span class="property">c</span>.<span class="property">b</span>.<span class="property">aa</span> = a;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">isCycleObject</span>(o)</span><br></pre></td></tr></table></figure><p>查找有序二维数组的目标值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> findNumberIn2DArray = <span class="keyword">function</span>(<span class="params">matrix, target</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix == <span class="literal">null</span> || matrix.<span class="property">length</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> row = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> column = matrix[<span class="number">0</span>].<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (row &lt; matrix.<span class="property">length</span> &amp;&amp; column &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix[row][column] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (matrix[row][column] &gt; target) &#123;</span><br><span class="line">            column--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            row++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>二维数组斜向打印：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">printMatrix</span>(<span class="params">arr</span>)&#123;</span><br><span class="line">  <span class="keyword">let</span> m = arr.<span class="property">length</span>, n = arr[<span class="number">0</span>].<span class="property">length</span></span><br><span class="line"><span class="keyword">let</span> res = []</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 左上角，从0 到 n - 1 列进行打印</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> k = <span class="number">0</span>; k &lt; n; k++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, j = k; i &lt; m &amp;&amp; j &gt;= <span class="number">0</span>; i++, j--) &#123;</span><br><span class="line">      res.<span class="title function_">push</span>(arr[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 右下角，从1 到 n - 1 行进行打印</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> k = <span class="number">1</span>; k &lt; m; k++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = k, j = n - <span class="number">1</span>; i &lt; m &amp;&amp; j &gt;= <span class="number">0</span>; i++, j--) &#123;</span><br><span class="line">      res.<span class="title function_">push</span>(arr[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>加油</title>
      <link href="/posts/8857f1a4.html"/>
      <url>/posts/8857f1a4.html</url>
      
        <content type="html"><![CDATA[<p>文字鉴赏</p><span id="more"></span><h1 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h1><p>我从来不想鹤立鸡群，我只想快点离开那群鸡。我目睹了一场谋杀，但我看不见他，他站在道德的制高点，站在阳光下，怪异的动物会被保护起来，怪异的人会被孤立，圣人也有过去，罪人也有未来，当愚昧成为主流，清醒就成为了犯罪，你要么闭嘴，要么使用他们的语言，每个人都在愤世嫉俗，每个人都在同流合污。你是在拜佛还是在拜自己的欲望。伊洛先生说：有钱能治愈一切自卑，光善良没有用你得优秀，活着就应该遇山开路，遇水架桥，其实，真正让你好起来的只有自律和自信，没有人能阻止你变好，除了你自己，如果你每天只是在床上追逐剧集，刷抖音，不积极运动，到了晚上还为感情问题而怀疑人生，那你迟早会被这个世界抛弃，不要失去信心，在工作中努力拼搏，不努力就会失去你想要的一切，你一定要努力奋斗，努力成为一个出色的人，不要让别人知道你得计划，直到有一天，你可以自由地离开那些让你不舒服的圈子和人，让他们都对你刮目相看。现在开始悄悄努力吧，做最好的自己，等待那些值得的人，趁现在还有时间，全力以赴去完成你一直想做的事情，成为你一直梦寐以求的那种人，过上你一直向往的那种生活。不要在等待中浪费岁月，每一天都给予自己最大的努力，让自己的光芒照亮前行的路，即使面临困难和挫折，也要坚持住，因为在哪些努力中，你将发现自己的价值和无限的可能。</p>]]></content>
      
      
      <categories>
          
          <category> 加油 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 加油 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法总结</title>
      <link href="/posts/1213ac56.html"/>
      <url>/posts/1213ac56.html</url>
      
        <content type="html"><![CDATA[<p>算法总结</p><span id="more"></span><h1 id="1-动态规划"><a href="#1-动态规划" class="headerlink" title="1. 动态规划"></a>1. 动态规划</h1><h4 id="传统递归-vs-DP"><a href="#传统递归-vs-DP" class="headerlink" title="传统递归 vs. DP"></a>传统递归 vs. DP</h4><p>先用一个被大佬们举例举到烂的🌰，这个栗子很烂，但是真的<strong>很香</strong>：必须着重<strong>强调</strong>.</p><p><strong>《斐波那契（Fibonacci）数列的第n项》</strong></p><p><strong>举荐理由：</strong>在我自己看来Fibonacci是动态规划设计中的入门级案例，就好比说编程中的“hello world”，大数据中的“word count”.</p><p>Fibonacci几乎完美的诠释了<strong>动态规划带来的思想和技巧</strong>然而没有任何其他的要考虑的细枝末节，这种很清晰的方法看起来很适合整个的动态规划的思维方式，很适合入门来进行的思考方式.</p><p>接下来咱们先来看题目：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">题目复制代码写一个函数，输入n，求斐波那契（Fibonacci）数列的第 n 项。斐波那契数列的定义如下：</span><br><span class="line"></span><br><span class="line">F(0) = 0, F(1) = 1</span><br><span class="line">F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.</span><br><span class="line">斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</span><br></pre></td></tr></table></figure><p>比较一下传统递归解法和动态规划思想下的解决对比</p><h4 id="1-先-递归解决"><a href="#1-先-递归解决" class="headerlink" title="1. 先 递归解决"></a>1. 先 递归解决</h4><p>传统对于这种题目的思考方式会利用递归求解，做起来比较简单，就是不断的去递归调用，看下面代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fib_recur</span>(<span class="params">N</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line">    <span class="keyword">if</span> N &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> N</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">fib_recur</span>(N-<span class="number">1</span>) + <span class="title function_">fib_recur</span>(N-<span class="number">2</span>)  # 递归输出  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出的结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">F( <span class="number">1</span> ) =  <span class="number">3</span></span><br><span class="line">F( <span class="number">2</span> ) =  <span class="number">2</span></span><br><span class="line">F( <span class="number">3</span> ) =  <span class="number">1</span></span><br><span class="line">F( <span class="number">4</span> ) =  <span class="number">0</span></span><br><span class="line">F( <span class="number">5</span> ) =  <span class="number">1</span></span><br><span class="line">F( <span class="number">6</span> ) =  <span class="number">2</span></span><br><span class="line">F( <span class="number">7</span> ) =  <span class="number">1</span></span><br><span class="line">F( <span class="number">8</span> ) =  <span class="number">0</span></span><br></pre></td></tr></table></figure><p><strong>重复计算</strong></p><p>明显可以看到，总计 8 次的计算过程中，相同的计算结果有三对进行了<strong>重复计算</strong>（下图中同色项，不包含灰色），也就是说在递归的过程中，把曾经计算过的项进行了<strong>又一次的重复计算</strong>，这样对于时间效率是比较低的，唯一的好处可能就是代码看起来比较好懂，但是终归不是一个好的算法设计方法。</p><p>代码中，在计算N的时候就去递归计算 <code>fib(N-1) + fib(N-2)</code>，那么，这种情况下的计算过程中。会是下面图中的一个计算过程。</p><p>可以发现，会有相当一部分的重复计算，这样对于时间都是重复的消耗。</p><blockquote><p>参考图中相同颜色的项，比如说粉色的重复计算、黄色的重复计算等</p><p>注意：递归中没有对空间进行了增加，始终都是同样的长度，仅仅是不断的弹出和压入</p></blockquote><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230605114156368.png" alt="image-20230605114156368"></p><p>为了更好的说明这种重复计算带来时间效率的低下。再比如说，相比上述图中的计算节点，再增加一个节点的计算，增加计算F(5)，那么由于递归的计算方式，会有更多的项（下图中线框中部分）进行了重复的计算。在计算<code>F(5)</code>的时候，会递归调用<code>F(4)</code>和<code>F(3)</code>，而在下图中，计算<code>F(4)</code>的时候，又会完整的去计算<code>F(3)</code>。这样，如果N很大的话，会有更大的时间消耗.</p><p>这样，这棵树的规模进行进行成倍增加，时间复杂度很明显的进行了成倍的扩张。对于时间上来说是很恐怖的.</p><p>时间复杂度带来的低效率严重超过了代码的可读性，所以我们可以想办法将<strong>过去计算</strong>过的节点<strong>进行保存</strong>。这样，我们就会用到下面要说的动态规划思想带来的时间上的高效.</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230605114342318.png" alt="image-20230605114342318"></p><blockquote><p>时间复杂度：o(2**n) —&gt; 指数级</p><p>空间复杂度：o(n)</p></blockquote><h4 id="2-后-动态规划解决"><a href="#2-后-动态规划解决" class="headerlink" title="2. 后 动态规划解决"></a>2. 后 动态规划解决</h4><p><strong>大概解释一下字面意思：</strong></p><p><strong>动态规划：我们不直接去解决问题，而是在每一步解决问题的时候，达到每一步的最优情况。换句话说，就是在每一步解决问题过程中，利用过去的状态</strong>以及<strong>当前状态</strong>的情况而达到一个当前的最优状态.</p><p><em>*规划：在一般解决该类问题的时候，会有一个“填表格”的过程，无论是简单情况下的**一维表格**还是复杂一点的</em>*二维表格<strong>，都是以</strong>开辟空间换时间**的思想，以争取最佳的时间效率. （保存过程中间值，方便后续直接使用）.</p><p><strong>动态：</strong>用上面的案例来说，递归解决过程中的每一步都会从基本问题不断的“自顶向下”去求解，在每一步骤中，会有相同的计算逻辑进行了重复的计算。相比于递归思想，动态规划思想增加了对历史上计算结果的保存，逐步记录下中间的计算结果，在每一步求得最优值.</p><p>因此，动态规划可以避免重复计算，达到了时间上的最优，从O(2N)O(2^N)O(2N)指数级变为O(N)O(N)O(N)常数级别，相较于开辟的一段内存空间存放中间过程值的开销，是非常值得的.</p><p><strong>那么，接下来咱们依照动态规划的思路进行对Fibonacci进行下解决</strong></p><p>依据题中的规则：</p><p>F(0) = 0, F(1) = 1</p><p>F(N) = F(N - 1) + F(N - 2),  when N &gt; 1</p><p>那么，👇👇F(N) 的值只与他的前两个状态有关系👇👇</p><p>a. 初始化值 : F(0) = 0, F(1) = 1 b. 想要计算得到F(2)， 那么F(2) = F(0) + F(1)   –&gt;  保存 F(2) c. 想要计算得到F(3)， 那么F(3) = F(2) + F(1)   –&gt;  保存 F(3) d. 想要计算得到F(3)， 那么F(4) = F(3) + F(2)   –&gt;  保存 F(4)</p><p>利用动态规划思想，以一维数组辅助实现的Fibonacci，看下图</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230605114740415.png" alt="image-20230605114740415"></p><p>是不是很简单的思路，仅仅靠保存过程中的一些值就能很简单的利用循环就可以实现了，没必要用递归反复计算进行实现。</p><p>想要计算得到第 n 个值的多少？那么，以下几点是我们必须要做到的</p><p>​    a. <strong>定义一个一维数组</strong>   —&gt;  一般用dp来命名</p><p>​    b. <strong>动态方程的设定</strong>   —&gt;  题中的F(N) = F(N - 1) + F(N - 2)</p><p>​    c. <strong>初始化数值</strong>   —&gt;  F(0) = 0和F(1) = 1</p><p>上述的 a、b 和 c 点就是动态规划思想的几个核心要素</p><p>下面来看下要实现的代码（代码中，用dp来代替上面的F()）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fib</span>(<span class="params">self, N</span>):</span><br><span class="line">        <span class="keyword">if</span> N == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(N+<span class="number">1</span>)] <span class="comment"># 1定义dp[i]保存第i个计算得到的数值</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>   <span class="comment"># 2初始化</span></span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span><span class="comment"># 2初始化</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, N+<span class="number">1</span>):<span class="comment"># 3动态方程实现，由于0和1都实现了赋值，现在需要从第2个位置开始赋值</span></span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>]</span><br><span class="line">       </span><br><span class="line">        <span class="built_in">print</span> dp <span class="comment"># 记录计算过程中的次数，与上述递归形成对比</span></span><br><span class="line">        <span class="keyword">return</span> dp[N]</span><br></pre></td></tr></table></figure><p>输出:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p>以上，最重要的就是1 2 3 点，而执行过程参照<strong>输出</strong>对比递归算法，计算少了很多，同样的计算只计算了一次。</p><blockquote><p>时间复杂度：O(N)</p><p>空间复杂度：O(N)</p></blockquote><p>介绍了上面的内容了，此处来条分割线吧，针对上述的 <strong>递归 vs. DP</strong></p><hr><p>既然动态规划的方案也介绍了，下面咱们再仔细看看，是否有优化的空间，毕竟对于一个算法方案的设计，都有找到其优化点，无论是时间还是空间的效率都想要达到一个理想的值。</p><h4 id="3-动态规划-优化"><a href="#3-动态规划-优化" class="headerlink" title="3. 动态规划 + 优化"></a>3. 动态规划 + 优化</h4><p>咱们看下这张图解，发现每个计算节点都<strong>只与前两个项有关系</strong>。换句话说，咱们只要保存两个值就好了，计算新的节点值的时候，把新的值赋值给前两个值的第一个就好了</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230605115233956.png" alt="image-20230605115233956"></p><p>话说只要两个值，现在定义两个变量 dp1 和 dp2。那么，现在咱们一步一步模拟一下：</p><p>a. 初始化值 : F(0) = 0, F(1) = 1</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230605115254829.png" alt="image-20230605115254829"></p><p>b. 想要计算得到F(2)， 那么F(2) = F(0) + F(1) –&gt; 保存 F(2)</p><p> 顺带将F(1)赋值给dp1， f(2)赋值给dp2</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230605115319902.png" alt="image-20230605115319902"></p><p>c. 想要计算得到F(3)， 那么F(3) = F(2) + F(1) –&gt; 保存 F(3)</p><p> 顺带将F(2)赋值给dp1， F(3)赋值给dp2</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230605115336720.png" alt="image-20230605115336720"></p><p>d. 想要计算得到F(3)， 那么F(4) = F(3) + F(2) –&gt; 保存 F(4)</p><p> 顺带将F(3)赋值给dp1， F(4)赋值给dp2</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230605115356096.png" alt="image-20230605115356096"></p><p>至此为止，整个过程仅仅用到了两个变量来存储过程中产生的值，也就之前没有优化的空间效率得到了优化</p><p>咱们把代码也贴一下吧，供参考</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fib_dp1</span>(<span class="params">self, N</span>):</span><br><span class="line">        <span class="keyword">if</span> N == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        dp1, dp2 = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, N+<span class="number">1</span>):</span><br><span class="line">            dp1 = dp1 + dp2</span><br><span class="line">            dp1, dp2 = dp2, dp1</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp2</span><br></pre></td></tr></table></figure><p>看起来是不是更加简洁了。</p><p>三点说明：<strong>1.定义dp数组 2.动态方程 3.初始化数值</strong></p><p>这也说明了为什么用<strong>斐波那契数列</strong>来引入<strong>动态规划</strong>的，因为斐波那契数列本身就明确的告诉你动态方程是什么，初始化的值是什么，所以好好的体会这种思想，尤其是从传统递归 -&gt; 动态规划的思想解决，再到优化的方面，很值得深思。</p><p>那接下来，咱们就找几个有代表性的栗子来尝尝鲜</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230605115624586.png" alt="image-20230605115624586"></p><h2 id="二、动态规划四大解题步骤处理问题"><a href="#二、动态规划四大解题步骤处理问题" class="headerlink" title="二、动态规划四大解题步骤处理问题"></a>二、动态规划四大解题步骤处理问题</h2><p>上面用斐波那契数列问题，引出了下面的几点，在这里再详细赘述一下</p><p>在后面的案例中将会尽量严格按照这几个步骤进行解决问题</p><blockquote><p>步骤一：定义dp数组的含义</p><p>步骤二：定义状态转移方程</p><p>步骤三：初始化过程转移的初始值</p><p>步骤四：可优化点(可选)</p></blockquote><h4 id="步骤一：定义dp数组的含义"><a href="#步骤一：定义dp数组的含义" class="headerlink" title="步骤一：定义dp数组的含义"></a>步骤一：定义dp数组的含义</h4><p>绝大部分情况下，我们需要定义一维数组或者二维数组进行存储在计算过程中产生的最优值，这里为什么是最优值呢？是因为在解决问题过程中，一般情况dp数组用来保存<strong>从开始到当前情况的最优值</strong>，故而保存的是截止到目前的最优值，避免重复计算（这里看起来思维有混乱的同学们，想想上面Fibonacci 递归解法和动态规划的对比）</p><p><strong>所以，dp无论是一维的还是二维的，要想清楚代表什么，一般来说代表的是截止到目前情况下的最优值</strong></p><h4 id="步骤二：定义状态转移方程"><a href="#步骤二：定义状态转移方程" class="headerlink" title="步骤二：定义状态转移方程"></a>步骤二：定义状态转移方程</h4><p>什么是动态转移方程？ 如果有一个问题摆在我们面前，然后这个问题在解决的过程中，会发现有很多的重叠的子问题，重叠子结构，而通过这些子问题的解决，最终将会把该问题进行解决</p><p>通俗来说，在解决问题过程中，能够发现一个不断解决子问题的动态规律，比如说Fibonacci中的F(N) = F(N - 1) + F(N - 2)，而在其他的可以用动态规划解决的问题中，需要我们自己去发现这样的内在规律。这个是最难的也是最终于要的，只要这一步解决了，接下来我们解决这个问题基本就没问题了.</p><h4 id="步骤三：初始化过程转移的初始值"><a href="#步骤三：初始化过程转移的初始值" class="headerlink" title="步骤三：初始化过程转移的初始值"></a>步骤三：初始化过程转移的初始值</h4><p>顺着步骤二的思路来，既然动态方程定义好了，是不是需要一个<strong>支点</strong>来撬动它进行不断的计算下去。</p><p>那么，这个<strong>支点</strong>就需要我们来初始定义，将动态方程激活，进行计算。举例来说Fibonacci中的F(0) = 0和F(1) = 1，有了这两个值，它的动态方程F(N) = F(N - 1) + F(N - 2)就可以进行下去了</p><p>这个就是我们要想好的初始值，实际问题可能还需要我们想想清楚.</p><h4 id="步骤四：可优化点-可选"><a href="#步骤四：可优化点-可选" class="headerlink" title="步骤四：可优化点(可选)"></a>步骤四：可优化点(可选)</h4><p>可优化的这里，最重要的会是dp数组这块，也会有不同问题不同的优化点</p><p>在例子中，我们会进行不同的优化.</p><p>总之一点，建议大家动笔多画画图，很多细节慢慢就会出现了.</p><h3 id="案例一：打家劫舍I-「来自leetcode198」"><a href="#案例一：打家劫舍I-「来自leetcode198」" class="headerlink" title="案例一：打家劫舍I 「来自leetcode198」"></a>案例一：打家劫舍I 「来自leetcode198」</h3><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">代码输入: [1,2,3,1]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。</span><br><span class="line">     偷窃到的最高金额 = 1 + 3 = 4 。</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="number">2</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">输出: <span class="number">12</span></span><br><span class="line">解释: 偷窃 <span class="number">1</span> 号房屋 (金额 = <span class="number">2</span>), 偷窃 <span class="number">3</span> 号房屋 (金额 = <span class="number">9</span>)，接着偷窃 <span class="number">5</span> 号房屋 (金额 = <span class="number">1</span>)。</span><br><span class="line">     偷窃到的最高金额 = <span class="number">2</span> + <span class="number">9</span> + <span class="number">1</span> = <span class="number">12</span> 。</span><br></pre></td></tr></table></figure><p>把经典案例系列拆分开讨论下吧，咱们首先将「打家劫舍I」来看看</p><p>该题可以用动态规划的思想来解决的原因是，在小偷不断偷取的过程中，始终想要偷得的物品价值最大，最优，每一步骤都与之前的偷取情况有关系，而且每一步都要考虑是否能偷，是否会带来最大利益，这就使得我们可以用动态规划的思想来解决问题。  然后严格按照四步骤进行解题.</p><h5 id="步骤一：-定义dp数组的含义"><a href="#步骤一：-定义dp数组的含义" class="headerlink" title="步骤一： 定义dp数组的含义"></a>步骤一： 定义dp数组的含义</h5><p>​    之前提到的，dp数组存储的值一般代表截止目前的最优值，在该题目中，我们定义：</p><p>​    <strong>dp[i] 代表到达第 i 个房屋偷得的最高金额，也就是当前最大子序和</strong></p><p>​    无论房屋有几间，最后我们取到dp数组的最后一个值就求得小偷偷得的最高金额</p><h5 id="步骤二：找出关系元素间的动态方程"><a href="#步骤二：找出关系元素间的动态方程" class="headerlink" title="步骤二：找出关系元素间的动态方程"></a>步骤二：找出关系元素间的动态方程</h5><p>​    动态规划解决的问题，一般来说就是解决最优子问题，“自顶向下” 的去不断的计算每一步骤的最优值。</p><p>​    也就是想要得到dp[i]的值，我们必须要知道dp[i-1]，dp[i-2]，dp[i-3] … 的每一步的最优值，在这个状态转移的过程中，我们必须要想清楚怎么去定义关系式。然而在每一步的计算中，都与前几项有关系，这个固定的关系就是我们要寻找的重叠子问题，也同样是接下来要详细定义的动态方程</p><p>​    该题目中，当小偷到达第 i 个屋子的时候，他的选择有两种：一种是偷，另外一种是不偷， 然后选择价值较大者</p><p>​    a. 偷的情况计算：必然是dp[3] = nums[2] + dp[1]，如果是偷取该屋子的话，相邻屋子是不能偷取的，因此，通项式子是：dp[i] =  nums[i-1] + dp[i-2]</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230605123128436.png" alt="image-20230605123128436"></p><p> b. 不偷的情况计算：必然是dp[3] = dp[2]，如果是不偷取该屋子的话，相邻屋子就是其最优值，因此，通项式子是：dp[i] = dp[i-1]</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230605123322989.png" alt="image-20230605123322989"></p><p>​    最后，要想偷得最高金额，那么，必须选取在偷与不偷之间的最大值作为我们是否选取的关键点。即：</p><p>​    <strong>动态方程:</strong> dp[i] = max(dp[i-1], nums[i-1]+dp[i-2])</p><h5 id="步骤三：初始化数值设定"><a href="#步骤三：初始化数值设定" class="headerlink" title="步骤三：初始化数值设定"></a>步骤三：初始化数值设定</h5><p>​    初始化: 给没有房子时，dp一个位置，即：dp[0]         1 当size=0时，没有房子，dp[0]=0；         2 当size=1时，有一间房子，偷即可：dp[1]=nums[0]</p><p>那么，按照这个思路来整理一下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rob</span>(<span class="params">self, nums</span>):</span><br><span class="line">      <span class="comment"># 1.dp[i] 代表当前最大子序和</span></span><br><span class="line">      <span class="comment"># 2.动态方程: dp[i] = max(dp[i-1], nums[i-1]+dp[i-2])</span></span><br><span class="line">      <span class="comment"># 3.初始化: 给没有房子时，dp一个位置，即：dp[0]</span></span><br><span class="line">      <span class="comment">#   3.1 当size=0时，没有房子，dp[0]=0；</span></span><br><span class="line">      <span class="comment">#   3.2 当size=1时，有一间房子，偷即可：dp[1]=nums[0]</span></span><br><span class="line">      size = <span class="built_in">len</span>(nums)</span><br><span class="line">      <span class="keyword">if</span> size == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">      dp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size+<span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">      dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">      dp[<span class="number">1</span>] = nums[<span class="number">0</span>]</span><br><span class="line">      <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, size+<span class="number">1</span>):</span><br><span class="line">        dp[i] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>], nums[i-<span class="number">1</span>]+dp[i-<span class="number">2</span>])</span><br><span class="line">        <span class="keyword">return</span> dp[size]</span><br></pre></td></tr></table></figure><blockquote><p>时间复杂度：O(N)</p><p>空间复杂度：O(N)</p></blockquote><p>那下面想想看有没有可优化的地方，尽量的释放一部分计算机资源</p><h5 id="步骤四：优化"><a href="#步骤四：优化" class="headerlink" title="步骤四：优化"></a>步骤四：优化</h5><p>​    从 dp[i] = max(dp[i-1], nums[i-1]+dp[i-2]) 关系来看，每一次动态变化，都与前两次状态有关系（dp[i-1], dp[i-2])，而前面的一些值是没有必要留存的.</p><p>​    所以，dp只需要定义两个变量就好，将空间复杂度降为O(1)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rob_o</span>(<span class="params">self, nums</span>):</span><br><span class="line">        <span class="comment"># 依照上面的思路，其实我们用到的数据永远都是dp的dp[i-1]和dp[i-2]两个变量</span></span><br><span class="line">        <span class="comment"># 因此，我们可以使用两个变量来存放前两个状态值</span></span><br><span class="line">        <span class="comment"># 空间使用由O(N) -&gt; O(1)</span></span><br><span class="line"></span><br><span class="line">        size = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> size == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        dp1 = <span class="number">0</span></span><br><span class="line">        dp2 = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, size+<span class="number">1</span>):</span><br><span class="line">            dp1 = <span class="built_in">max</span>(dp2, nums[i-<span class="number">1</span>]+dp1)</span><br><span class="line">            dp1, dp2 = dp2, dp1</span><br><span class="line">        <span class="keyword">return</span> dp2</span><br></pre></td></tr></table></figure><blockquote><p>时间复杂度：O(N)</p><p>空间复杂度：O(1)</p></blockquote><p>说完《打家劫舍I 》，中间穿插另外一道题目，利用二维dp来解决的一个问题。</p><p>最后再说说《打家劫舍II 》和《打家劫舍III》，把这一系列的<strong>打家劫舍</strong>问题搞明白了，相信你对动态规划有一个较为深刻的入门体验</p><h3 id="案例二：不同路径「来自leetcode62」"><a href="#案例二：不同路径「来自leetcode62」" class="headerlink" title="案例二：不同路径「来自leetcode62」"></a>案例二：不同路径「来自leetcode62」</h3><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p><p>问总共有多少条不同的路径？</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230605130822926.png" alt="image-20230605130822926"></p><p><strong>示例 1:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: m = <span class="number">3</span>, n = <span class="number">2</span></span><br><span class="line">输出: <span class="number">3</span></span><br><span class="line">解释:</span><br><span class="line">从左上角开始，总共有 <span class="number">3</span> 条路径可以到达右下角。</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 向右 -&gt; 向右 -&gt; 向下</span><br><span class="line"><span class="number">2.</span> 向右 -&gt; 向下 -&gt; 向右</span><br><span class="line"><span class="number">3.</span> 向下 -&gt; 向右 -&gt; 向右</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python复制代码输入: m = <span class="number">7</span>, n = <span class="number">3</span></span><br><span class="line">输出: <span class="number">28</span></span><br></pre></td></tr></table></figure><p><em>提示：</em></p><p>1 &lt;= m, n &lt;= 100 题目数据保证答案小于等于 2 * 10 ^ 9</p><p>下面依然按照四个步骤来进行讨论：</p><h5 id="步骤一：定义dp数组的含义-1"><a href="#步骤一：定义dp数组的含义-1" class="headerlink" title="步骤一：定义dp数组的含义"></a>步骤一：定义dp数组的含义</h5><p>​    当前这道题是从左上角到右下角的，题目中规定只能向右或者向下走，所以我们必须要定义一个二维数组来保存计算过程中的值。所以，这块定义：</p><p>​    <strong>dp[i][j]: 代表到达位置 (i, j) 的所有路径的总数</strong></p><p>​    即：机器人从左上角到右下角所有路径的总和，dp中每个位置的值代表行走到达 (i, j) 每个位置的总共的路径数</p><h5 id="步骤二：找出关系元素间的动态方程-1"><a href="#步骤二：找出关系元素间的动态方程-1" class="headerlink" title="步骤二：找出关系元素间的动态方程"></a>步骤二：找出关系元素间的动态方程</h5><p>​    由于题目中规定只能向右或者向下走，所以在机器人行进的时候，只能是向右或向下.</p><p>​    那么，分别讨论下两种情况，想要到达位置(i, j)，可以从位置(i-1, j)或者(i, j-1)出发到达。因此，到达位置(i, j) 的总的路径数一定是 <strong>到达位置(i-1, j)路径数</strong> + <strong>到达位置(i, j-1)路径数</strong>。那么，现在可以定义动态方程：</p><p>​    <strong>动态方程：dp[i][j] = dp[i-1][j] + dp[i][j-1]</strong></p><h5 id="步骤三：初始化数值设定-1"><a href="#步骤三：初始化数值设定-1" class="headerlink" title="步骤三：初始化数值设定"></a>步骤三：初始化数值设定</h5><p>​    很明显，在机器人走第 0 行，第 0 列的时候，无论怎么走，都只有 1 种走法。</p><p>​    因此，初始化值的设定，一定是 dp[0..m][1] 或者 dp[1][0..n] 都等于1</p><p>​    因此初始值如下：</p><p>​    <strong>dp[0] [0….n-1] = 1;</strong>  // 机器人一直向右走，第 0 列统统为 1</p><p>​    <strong>dp[0…m-1] [0] = 1;</strong>  // 机器人一直向下走，第 0 列统统为 1</p><p>​    现在，按照这个思路来整理一下代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">uniquePaths1</span>(<span class="params">self, m, n</span>):</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 初始化表格，由于初始化0行 0列都为1。那么，先全部置为1</span></span><br><span class="line">        dp = [[<span class="number">1</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m):</span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j] + dp[i][j-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n-<span class="number">1</span>][m-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>上述代码中由于dp[[0..m][1] ][1]或者 dp[1][0..n] 都等于1，所以在定义二维数组dp时候，统统赋初始值为 1</p><p>然后从位置(1, 1)开始计算每个位置的总路径数</p><blockquote><p>时间复杂度：O(M*N)</p><p>空间复杂度：O(M*N)</p></blockquote><p>既然到这里了，下面再想想看有没有可优化的地方</p><h5 id="步骤四：优化-1"><a href="#步骤四：优化-1" class="headerlink" title="步骤四：优化"></a>步骤四：优化</h5><p>​    可以依照前面的解决的思路，应该也可以从空间上进行一定的优化</p><p>​    参照前面的案例，之前定义的是一维数组dp，优化点是每一步骤都只与前面的两个计算好的数值有关系，然后优化点就是将dp[N] -&gt; dp1和dp2，空间复杂度由 O(N) -&gt; O(1)，如果是很大规模的数据计算的话，空间效率提升了不少.</p><p>​    现在这个例子中的动态方程是**dp[i][j] = dp[i-1][j] + dp[i][j-1]*<em>，很明显，每一步骤中的状态值只与左边相邻的值和上面的值相关。举例（为了方便，用 3</em>4 来举例）：</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230605131507215.png" alt="image-20230605131507215"></p><p>​    这个完整的图片描述中，机器人从左上角的位置(1, 1)开始移动，逐渐每一步都根据动态方程进行前进，明显的可以看出机器人每移动一格，所得到的路径总和只与它的上方和左方数值有关系。也就是我们会发现，机器人移动到第2行的时候，第0行数据完全是没有用的状态。</p><p>​    因此，这个优化点就出来了，在算法设计的时候，dp仅仅定义2行N列的数组就ok了，省去了m-2行的空间开销。这个代码如果大家想明白了请自行设计出来，自己写出来一定会有更加深刻的理解，再强调：多思考，形成潜移默化的思维方式.</p><p>​    看完这个步骤之后，是不是很明显的优化点，为什么上面没有给出大家代码呢？是因为我看到貌似可以继续优化的点（粘住空间优化项了哈哈哈），那就继续在空间开销上做文章。</p><p>​    <strong>引导：</strong>根据上述咱们的优化方案，说道 “机器人移动到第2行的时候，第0行数据完全是没有用的状态”，其实当前聪明的读者你想想，再看看，下面的图中（从上图截取过来）。 其实，不仅仅是第 0 行完全没用了，而且在第2 行做移动的时候，移动到位置(i, j)的时候，计算好位置(i, j)，那么接下来，位置(i-1, j)的数据也就没用了。换句话说，边走，第 1 行开始的某些数据也就没用了，还在占着空间</p><p>​    <strong>这块大家一定多想想，多理解，多画图</strong></p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230605131650290.png" alt="image-20230605131650290"></p><p>下面按照这种思路，看下图的步骤，也画好了用一维数组进行解决问题，也画出来每一步骤与上图的类比过程：</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230605131721361.png" alt="image-20230605131721361"></p><p>在这里，有犯困的同学可以自己动手画一画，理解一下，个人感觉是一个很好的思维扩展</p><p>接下来，就按照这样的思路进行代码实现，会发现码起来很简单</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">uniquePaths2</span>(<span class="params">self, m, n</span>):</span><br><span class="line">        <span class="keyword">if</span> m &gt; n:</span><br><span class="line">            m, n = n, m</span><br><span class="line"></span><br><span class="line">        dp = [<span class="number">1</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m):</span><br><span class="line">                dp[j] = dp[j] + dp[j-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[m-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><blockquote><p>时间复杂度：O(m*n)</p><p>空间复杂度：O(min(m ,n))</p></blockquote><p>是不是从思维方面简单干净了许多</p><p>搞清楚上面的栗子之后呢，我们将上面的例题进行一个简单的难度增加，说白了，就是在路上打几个阻碍点</p><p>来看:</p><h3 id="案例三：不同路径II-「来自leetcode63」"><a href="#案例三：不同路径II-「来自leetcode63」" class="headerlink" title="案例三：不同路径II 「来自leetcode63」"></a>案例三：不同路径II 「来自leetcode63」</h3><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p><p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230605131800138.png" alt="image-20230605131800138"></p><blockquote><p>说明：m 和 n 的值均不超过 100。</p></blockquote><p><strong>示例 1:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">代码输入:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">  [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>],</span><br><span class="line">  [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">]</span><br><span class="line">输出: <span class="number">2</span></span><br><span class="line">解释:</span><br><span class="line">3x3 网格的正中间有一个障碍物。</span><br><span class="line">从左上角到右下角一共有 <span class="number">2</span> 条不同的路径：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下</span><br><span class="line"><span class="number">2.</span> 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右</span><br></pre></td></tr></table></figure><p><strong>咱们先看一下题中的两个关键点：</strong> 关键点1：只能向右或者向下 关键点2：有障碍物为1， 无障碍物为0</p><p>根据 关键点1 和 关键点2 依然按照四个步骤来进行讨论：</p><h5 id="步骤一：定义dp数组的含义-2"><a href="#步骤一：定义dp数组的含义-2" class="headerlink" title="步骤一：定义dp数组的含义"></a>步骤一：定义dp数组的含义</h5><p>这个题目中定义的dp数组是和上一个例题中定义的dp数组的含义是相同的，但由于该题中已经定义有数组obstacleGrid，可以直接利用，无需额外开辟空间 那么，就利用obstacleGrid作为动态规划中存储计算过程中的最优值</p><h5 id="步骤二：找出关系元素间的动态方程-2"><a href="#步骤二：找出关系元素间的动态方程-2" class="headerlink" title="步骤二：找出关系元素间的动态方程"></a>步骤二：找出关系元素间的动态方程</h5><p>参照上一题目，规定动态方程: obstacleGrid[i][j] = obstacleGrid[i-1][j] + obstacleGrid[i][j-1] 由于机器人在移动过程中有障碍物，那么，对上面动态方程加一些限制条件 a.若当前 obstacleGrid[i][j] 为0。那么，直接计算动态方程下的计算过程 b.若当前 obstacleGrid[i][j] 不为0。那么，直接置该位置的值为0</p><p>所以，在进行动态方程遍历的时候，先进行 obstacleGrid[i][j]的判断，再进行动态方程的计算执行</p><h5 id="步骤三：初始化数值设定-2"><a href="#步骤三：初始化数值设定-2" class="headerlink" title="步骤三：初始化数值设定"></a>步骤三：初始化数值设定</h5><p>​    相比于上一题目，相似的是，在机器人走第 0 行，第 0 列的时候，无论怎么走，都只有 1 种走法     但由于有障碍物，那走到障碍物的时候，后面都是走不下去的（下图用第一行来举例）。</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230605131926886.png" alt="image-20230605131926886"></p><p>​    所以，初始化第 0 行，第 0 列的时候，障碍物 1 后面的都是不可达的。所以，初始化行和列的逻辑表达：</p><p>​    <strong>该位置是否可达=前一个位置的状态and该位置能否可达 得到能否到达这个位置</strong></p><p>​    只有前一个位置为1（可达，只有1种方式） ，当前位置为0（无障碍物）这种情况才能到达该位置，然后为该位置设 1 （可达，只有1种方式）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 0 行初始化表达式: </span></span><br><span class="line">obstacleGrid[<span class="number">0</span>][row] = <span class="built_in">int</span>(obstacleGrid[<span class="number">0</span>][row] == <span class="number">0</span> <span class="keyword">and</span> obstacleGrid[<span class="number">0</span>][row-<span class="number">1</span>] == <span class="number">1</span>)</span><br><span class="line"><span class="comment"># 0 列初始化表达式: </span></span><br><span class="line">obstacleGrid[clo][<span class="number">0</span>] = <span class="built_in">int</span>(obstacleGrid[clo][<span class="number">0</span>] == <span class="number">0</span> <span class="keyword">and</span> obstacleGrid[clo-<span class="number">1</span>][<span class="number">0</span>] == <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>这些都准备就绪之后，按照相关思路进行编码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">uniquePathsWithObstacles1</span>(<span class="params">self, obstacleGrid</span>):</span><br><span class="line">      <span class="comment"># 行列长度</span></span><br><span class="line">        m = <span class="built_in">len</span>(obstacleGrid)</span><br><span class="line">        n = <span class="built_in">len</span>(obstacleGrid[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果在位置(0, 0)，哪里都去不了，直接返回0</span></span><br><span class="line">        <span class="keyword">if</span> obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 否则，位置(0, 0)可以到达</span></span><br><span class="line">        obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 初始化 0 列</span></span><br><span class="line">        <span class="keyword">for</span> clo <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m):</span><br><span class="line">            obstacleGrid[clo][<span class="number">0</span>] = <span class="built_in">int</span>(obstacleGrid[clo][<span class="number">0</span>] == <span class="number">0</span> <span class="keyword">and</span> obstacleGrid[clo-<span class="number">1</span>][<span class="number">0</span>] == <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 初始化 0 行</span></span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            obstacleGrid[<span class="number">0</span>][row] = <span class="built_in">int</span>(obstacleGrid[<span class="number">0</span>][row] == <span class="number">0</span> <span class="keyword">and</span> obstacleGrid[<span class="number">0</span>][row-<span class="number">1</span>] == <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 从位置(1, 1)根据动态方程开始计算</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">                <span class="keyword">if</span> obstacleGrid[i][j] == <span class="number">0</span>:</span><br><span class="line">                    obstacleGrid[i][j] = obstacleGrid[i-<span class="number">1</span>][j] + obstacleGrid[i][j-<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    obstacleGrid[i][j] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> obstacleGrid[m-<span class="number">1</span>][n-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><blockquote><p>时间复杂度: O(mxn)</p><p>空间复杂度: O(1)</p></blockquote><h5 id="步骤四：优化-2"><a href="#步骤四：优化-2" class="headerlink" title="步骤四：优化"></a>步骤四：优化</h5><p>​    这块的优化先不谈了，这里基本没有什么优化点，之前都是由于自己要开辟内存空间，通过空间的优化来进行，而本题是在给定的数组中进行操作的</p><p>有了这几个案例的基础之后，咱们后面把经典的《打家劫舍》系列剩下的两个题目讨论完，就先告一段落，后面也希望以不同的方式与大家多多交流，互相学习</p><p>如果有读者看着累了，可以先保存，收藏下来，待消化了前面的内容，方便再回来看看。</p><h3 id="案例四：打家劫舍II-「来自leetcode213」"><a href="#案例四：打家劫舍II-「来自leetcode213」" class="headerlink" title="案例四：打家劫舍II 「来自leetcode213」"></a>案例四：打家劫舍II 「来自leetcode213」</h3><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。</p><p><strong>示例 1:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python复制代码输入: [<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>]</span><br><span class="line">输出: <span class="number">3</span></span><br><span class="line">解释: 你不能先偷窃 <span class="number">1</span> 号房屋（金额 = <span class="number">2</span>），然后偷窃 <span class="number">3</span> 号房屋（金额 = <span class="number">2</span>）, 因为他们是相邻的。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">python复制代码输入: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">输出: <span class="number">4</span></span><br><span class="line">解释: 你可以先偷窃 <span class="number">1</span> 号房屋（金额 = <span class="number">1</span>），然后偷窃 <span class="number">3</span> 号房屋（金额 = <span class="number">3</span>）。</span><br><span class="line">     偷窃到的最高金额 = <span class="number">1</span> + <span class="number">3</span> = <span class="number">4</span> 。</span><br></pre></td></tr></table></figure><p>与《打家劫舍I》不同的是，《打家劫舍I》的屋子是线性的，而《打家劫舍II》是环状的，所以要考虑的点会增加一些，因为首位相连接的情况，咱们分为下面三种情况进行设定：</p><p>a. 不偷首偷尾</p><p>b. 偷首不偷尾</p><p>c. 首位都不偷 显然，c 种方式损失太大，不会获得最高的金额，故选取 a 和 b。 那么，下面分为两种情况，分别计算不包含首和不包含尾这两种情况来判断小偷哪种方式偷取的金额最高。</p><p>下面依然按照之前的四个步骤来进行分析</p><h5 id="步骤一：-定义dp数组的含义-1"><a href="#步骤一：-定义dp数组的含义-1" class="headerlink" title="步骤一： 定义dp数组的含义"></a>步骤一： 定义dp数组的含义</h5><p>​    dp[i] 代表的含义和之前一致，dp数组存储的值一般代表截止目前的最优值</p><p>​    所以，<strong>dp[i] 代表到达第 i 个房屋偷得的最高金额，也就是当前最大子序和</strong></p><p>​    但是最后会讨论<strong>不包含首</strong>和<strong>不包含尾</strong>这两种情况下得到的dp数组的最后一位，然后获取其中较大者，就是我们要取得的最高金额</p><h5 id="步骤二：找出关系元素间的动态方程-3"><a href="#步骤二：找出关系元素间的动态方程-3" class="headerlink" title="步骤二：找出关系元素间的动态方程"></a>步骤二：找出关系元素间的动态方程</h5><p>​    动态方程可参照《打家劫舍I》，有很详细的图解过程，该例子动态方程的变化和之前是完全一致的：</p><p>​    <strong>dp[i] = max(dp[i-1], nums[i-1]+dp[i-2])</strong></p><h5 id="步骤三：初始化设定"><a href="#步骤三：初始化设定" class="headerlink" title="步骤三：初始化设定"></a>步骤三：初始化设定</h5><p>​    初始化: 给没有房子时，dp一个位置，即：dp[0]         a. 当size=0时，没有房子，小偷没办法偷：dp[0]=0；         b. 当size=1时，有一间房子，只要偷即可：dp[1]=nums[0]</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230605150914733.png" alt="image-20230605150914733"></p><p>​    由于屋子首位相连接，所以在计算时候，直接分为两种情况。第一种略过第一个屋子，第二种略过第二个屋子，这样得到的两个数组结果。最后只要比较最后一位数值的大小就ok了。解决！</p><p>该例子步骤三之后，感兴趣的同学可以自己写一下代码，和《打家劫舍I》的代码很类似，后面我写了优化后的代码，可能会更加的明白怎么写。咱们直接到步骤四，有了上面的案例，直接来看看优化后的方案:</p><h5 id="步骤四：优化-3"><a href="#步骤四：优化-3" class="headerlink" title="步骤四：优化"></a>步骤四：优化</h5><p>​    同样从 dp[i] = max(dp[i-1], nums[i-1]+dp[i-2]) 关系来看，每一次动态变化，都与前两次状态有关系（dp[i-1], dp[i-2])，而前面的一些值是没有必要留存的，只要保存两个变量来保存过程最优值就好.</p><p>​    代码中有详细的注释：</p><pre><code>class Solution(object):def rob(self, nums):    # 点睛：与打家劫舍I的区别是屋子围成了一个环    #   那么，很明显可以分为三种情况：    #   1. 首位都不偷    #   2. 偷首不偷尾    #   3. 不偷首偷尾    # 显然，第1种方式损失太大，选取2、3。    # 那么，分为两种情况，分别计算不包含首和不包含尾这两种情况来判断哪个大哪个小    # 1.dp[i] 代表当前最大子序和    # 2.动态方程: dp[i] = max(dp[i-1] and , nums[i-1]+dp[i-2])    # 3.初始化: 给没有房子时，dp一个位置，即：dp[0]    #   3.1 当size=0时，没有房子，dp[0]=0；    #   3.2 当size=1时，有一间房子，偷即可：dp[1]=nums[0]    # 依照《打家劫舍I》的优化方案进行计算    # nums处理，分别切割出去首和去尾的子串    nums1 = nums[1:]    nums2 = nums[:-1]    size = len(nums)    if size == 0:        return 0    if size == 1:        return nums[0]    def handle(size, nums):        dp1 = 0        dp2 = nums[0]        for i in range(2, size+1):            dp1 = max(dp2, nums[i-1]+dp1)            dp1, dp2 = dp2, dp1        return dp2    res1 = handle(size-1, nums1)    res2 = handle(size-1, nums2)    return max(res1, res2)</code></pre><blockquote><p>时间复杂度：O(N)</p><p>空间复杂度：O(1)</p></blockquote><p>再看看下面小偷遇到的情况，感叹：即使当小偷，也要步步规划才能拿到最高的金额啊…</p><h3 id="案例五：打家劫舍III-「来自leetcode337」"><a href="#案例五：打家劫舍III-「来自leetcode337」" class="headerlink" title="案例五：打家劫舍III 「来自leetcode337」"></a>案例五：打家劫舍III 「来自leetcode337」</h3><p>在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。</p><p>计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。</p><p><strong>示例 1:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">代码输入: [<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,null,<span class="number">3</span>,null,<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">     <span class="number">3</span></span><br><span class="line">/ \</span><br><span class="line">   <span class="number">2</span>   <span class="number">3</span></span><br><span class="line">    \   \ </span><br><span class="line">     <span class="number">3</span>   <span class="number">1</span></span><br><span class="line"></span><br><span class="line">输出: <span class="number">7</span> </span><br><span class="line">解释: 小偷一晚能够盗取的最高金额 = <span class="number">3</span> + <span class="number">3</span> + <span class="number">1</span> = <span class="number">7.</span></span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">3</span>,null,<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">  <span class="number">3</span></span><br><span class="line">/ \</span><br><span class="line">   <span class="number">4</span>   <span class="number">5</span></span><br><span class="line">  / \   \ </span><br><span class="line"> <span class="number">1</span>   <span class="number">3</span>   <span class="number">1</span></span><br><span class="line">输出: <span class="number">9</span></span><br><span class="line">解释: 小偷一晚能够盗取的最高金额 = <span class="number">4</span> + <span class="number">5</span> = <span class="number">9.</span></span><br></pre></td></tr></table></figure><p>题目出的很好，但是立马会给人一种小偷也不是好当的的赶脚…</p><p>言归正传，咱们先来说说题目本身</p><p>《打家劫舍》的小偷从一维线性到环形，再到二维矩形的屋子？是我想简单了，直接就干到树形了，是不是看着很香，而且很想，看下去，研究研究…</p><p>来整理几点思路，再来按照四步走：</p><p>1.由于房屋是树状的，因此，我们可以使用遍历树的传统方法进行遍历(前序、中序、后续) 2.简单的思路是，从树低进行往上遍历，拿到最优的打劫值。可以选用后续遍历 3.得到每一节点的最优值，最后选取最优的结果</p><p>依然按照三个步骤来进行分析（无优化点）</p><h5 id="步骤一：-定义dp数组的含义-2"><a href="#步骤一：-定义dp数组的含义-2" class="headerlink" title="步骤一： 定义dp数组的含义"></a>步骤一： 定义dp数组的含义</h5><p>​    dp[i]代表该节点及以下打最多的劫（拿到最多的钱）</p><h5 id="步骤二：找出关系元素间的动态方程-4"><a href="#步骤二：找出关系元素间的动态方程-4" class="headerlink" title="步骤二：找出关系元素间的动态方程"></a>步骤二：找出关系元素间的动态方程</h5><p>​    根据我们每走到一个节点，都会有两种情况，那就是 <strong>偷(1)</strong> 与 **不偷(0)**。我们分开来讨论：</p><p>​    a. 用 <strong>dp[0]</strong> 代表不偷取该节点到目前为止拿到最多的钱，那么儿子节点偷不偷都ok。</p><p>​        所以： <strong>dp[0] = max(left[0], left[1]) + max(right[0], right[1])</strong></p><p>​    b. 用 <strong>dp[1]</strong> 代表偷了该节点到目前为止拿到最多的钱，则儿子节点都不能被偷。</p><p>​        所以：<strong>dp[1] = value + left[0] + right[0]</strong>  (value代表该节点的价值)</p><p>​    有看不懂的地方吗？再紧接着解释一下：</p><p>​        left[0]代表不偷取左孩子拿到最高的金额</p><p>​        left[1]代表偷取左孩子拿到最高的金额</p><p>​        right[0]代表不偷取右孩子拿到最高的金额</p><p>​        right[1]代表偷取右孩子拿到最高的金额</p><p>​    <em>如果还有不太懂的话，留言或者私信我联系我，随时骚扰我哈</em></p><h5 id="步骤三：初始化设定-1"><a href="#步骤三：初始化设定-1" class="headerlink" title="步骤三：初始化设定"></a>步骤三：初始化设定</h5><p>​    该例子的初始化比较简单，就是当前树的形状为空的时候，直接返回dp[0, 0]</p><p>下面贴出完整代码，其中包含<strong>树的初始化</strong>代码 &amp;&amp; 一大堆的注释：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x</span>):</span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rob</span>(<span class="params">self, root</span>):</span><br><span class="line">        <span class="comment"># 说明：</span></span><br><span class="line">        <span class="comment"># 1.由于房屋是树状的，因此，我们可以使用遍历树的传统方法进行遍历(前序、中序、后续)</span></span><br><span class="line">        <span class="comment"># 2.简单的思路是，从树低进行往上遍历，拿到最优的打劫值。可以选用后续遍历</span></span><br><span class="line">        <span class="comment"># 3.得到每一节点的最优值，最后选取最优的结果</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 1.dp[i]代表该节点及以下拿到的最多的钱</span></span><br><span class="line">        <span class="comment"># 2.动态方程：</span></span><br><span class="line">        <span class="comment">#   2.1 dp[0]代表不偷该节点拿到最多的钱，则儿子节点偷不偷都ok。dp[0] = max(left[0], left[1]) + max(right[0], right[1])</span></span><br><span class="line">        <span class="comment">#   2.2 dp[1]代表偷了该节点拿到最多的钱，则儿子节点都不能被偷。dp[1] = var + left[0] + right[0]</span></span><br><span class="line">        <span class="comment"># 3.初始化：当前树的形状为空的时候，直接返回dp[0, 0]</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">postTrasval</span>(<span class="params">root</span>):</span><br><span class="line">            dp = [<span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> dp</span><br><span class="line">            left = postTrasval(root.left)</span><br><span class="line">            right = postTrasval(root.right)</span><br><span class="line"></span><br><span class="line">            dp[<span class="number">0</span>] = <span class="built_in">max</span>(left[<span class="number">0</span>], left[<span class="number">1</span>]) + <span class="built_in">max</span>(right[<span class="number">0</span>], right[<span class="number">1</span>])</span><br><span class="line">            dp[<span class="number">1</span>] = root.val + left[<span class="number">0</span>] + right[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">return</span> dp</span><br><span class="line">        dp = postTrasval(root)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp[<span class="number">0</span>], dp[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># initial tree structure</span></span><br><span class="line">    T = TreeNode(<span class="number">3</span>)</span><br><span class="line">    T.left = TreeNode(<span class="number">2</span>)</span><br><span class="line">    T.right = TreeNode(<span class="number">3</span>)</span><br><span class="line">    T.left.right = TreeNode(<span class="number">3</span>)</span><br><span class="line">    T.right.right = TreeNode(<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># The solution to the Question</span></span><br><span class="line">    s = Solution()</span><br><span class="line">    <span class="built_in">print</span>(s.rob(T))</span><br></pre></td></tr></table></figure><h1 id="2-递归"><a href="#2-递归" class="headerlink" title="2. 递归"></a>2. 递归</h1>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法复习</title>
      <link href="/posts/fa264d8c.html"/>
      <url>/posts/fa264d8c.html</url>
      
        <content type="html"><![CDATA[<p>算法复习</p><span id="more"></span><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h2><p><img src="https://raw.githubusercontent.com/why862555625/images/main/images/image-20230531202054172.png" alt="image-20230531202054172"></p><p>由于会直接返回翻转链表，最后一个就是翻转后的链表头。因此只需要保留前一个链表，让后一个链表不停的指向前一个链表就可以。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">ReverseList</span>(<span class="params">pHead</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> pred =<span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span>(pHead)&#123;</span><br><span class="line">        [pHead.<span class="property">next</span>,pred,pHead] = [pred,pHead,pHead.<span class="property">next</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pred</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h2><p><img src="https://raw.githubusercontent.com/why862555625/images/main/images/image-20230531225422160.png" alt="image-20230531225422160"></p><p>首先将中间需要翻转的那段拿出来单独翻转，可以将这段的最后一个设为null作为翻转结束的标志。然后将这段在插回来就可以了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">reverse</span>(<span class="params">head</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> pre = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> cur = head;</span><br><span class="line">    <span class="keyword">let</span> next;</span><br><span class="line">    <span class="keyword">while</span>(cur) &#123;</span><br><span class="line">        next = cur.<span class="property">next</span>;</span><br><span class="line">        cur.<span class="property">next</span> = pre;</span><br><span class="line">         </span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [pre, head];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reverseBetween</span>(<span class="params"> head ,  m ,  n </span>) &#123;</span><br><span class="line">    <span class="comment">// 增加一个origin方便返回最终结果 origin.next</span></span><br><span class="line">    <span class="comment">// 因为head也有可能被翻转了</span></span><br><span class="line">    <span class="keyword">const</span> origin = &#123; <span class="attr">next</span>: head &#125;;</span><br><span class="line">    head = origin;</span><br><span class="line">    <span class="keyword">let</span> left, right;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(; i &lt; m - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        head = head.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    left = head;</span><br><span class="line">    <span class="keyword">for</span>(; i &lt; n; i++) &#123;</span><br><span class="line">        head = head.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    right = head.<span class="property">next</span>;</span><br><span class="line">    head.<span class="property">next</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">const</span> [ start, end ] = <span class="title function_">reverse</span>(left.<span class="property">next</span>);</span><br><span class="line">    left.<span class="property">next</span> = start;</span><br><span class="line">    end.<span class="property">next</span> = right;</span><br><span class="line">    <span class="keyword">return</span>  origin.<span class="property">next</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    reverseBetween : reverseBetween</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h2><p><img src="https://raw.githubusercontent.com/why862555625/images/main/images/image-20230531232244456.png" alt="image-20230531232244456"></p><p>和上一题类似 只需要翻转前记录下前一个节点 和后一个节点  然后拼接起来就可以</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">reverse</span>(<span class="params">head</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> pre = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> cur = head;</span><br><span class="line">    <span class="keyword">while</span>(cur) &#123;</span><br><span class="line">        [cur.<span class="property">next</span>,pre,cur] = [pre,cur,cur.<span class="property">next</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [pre, head];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reverseKGroup</span>(<span class="params">head, k</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!head||!head.<span class="property">next</span>||k ==<span class="number">1</span>) <span class="keyword">return</span> head</span><br><span class="line">    <span class="keyword">let</span> result =&#123;<span class="string">&#x27;next&#x27;</span>:head&#125;,</span><br><span class="line">    num = <span class="number">0</span>,</span><br><span class="line">    <span class="comment">//记录前一个翻转列表的尾结点</span></span><br><span class="line">    prev = result</span><br><span class="line">    <span class="comment">//记录下一个翻转开始节点</span></span><br><span class="line">    nextNode = head</span><br><span class="line">    <span class="keyword">while</span>(head)&#123;</span><br><span class="line">        <span class="keyword">if</span>(num+<span class="number">1</span> == k)&#123;</span><br><span class="line">            <span class="comment">//此时head为这一次翻转列表的最后一个节点  需要记录一下下一个翻转周期的开始节点</span></span><br><span class="line">            <span class="keyword">let</span> temp = head.<span class="property">next</span></span><br><span class="line">            head.<span class="property">next</span> = <span class="literal">null</span></span><br><span class="line">            <span class="keyword">let</span> [start,end] = <span class="title function_">reverse</span>(nextNode)</span><br><span class="line">            nextNode  = temp</span><br><span class="line">            prev.<span class="property">next</span> = start</span><br><span class="line">            prev = end</span><br><span class="line">            num = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span>(!nextNode)&#123;<span class="keyword">break</span>&#125;</span><br><span class="line">            head = nextNode.<span class="property">next</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            head = head.<span class="property">next</span></span><br><span class="line">        &#125;</span><br><span class="line">        num ++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(num)&#123;</span><br><span class="line">        <span class="comment">//如果还有剩余 补充到末尾</span></span><br><span class="line">        prev.<span class="property">next</span> = nextNode</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result.<span class="property">next</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">reverseKGroup</span>: reverseKGroup,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="4"><a href="#4" class="headerlink" title="4."></a>4.</h2><p><img src="https://raw.githubusercontent.com/why862555625/images/main/images/image-20230601125414404.png" alt="image-20230601125414404"></p><p>双指针遍历 小的放到新链表中、由于是引用不会增加额外空间</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">Merge</span>(<span class="params">pHead1: ListNode, pHead2: ListNode</span>): <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">let</span> cur = result</span><br><span class="line">    <span class="keyword">while</span>(pHead1&amp;&amp;pHead2)&#123;</span><br><span class="line">        <span class="keyword">if</span>(pHead1.<span class="property">val</span>&gt;pHead2.<span class="property">val</span>)&#123;</span><br><span class="line">            cur .<span class="property">next</span> = pHead2</span><br><span class="line">            pHead2 =pHead2.<span class="property">next</span></span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cur .<span class="property">next</span> = pHead1</span><br><span class="line">            pHead1 =pHead1.<span class="property">next</span></span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.<span class="property">next</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pHead1) </span><br><span class="line">            cur .<span class="property">next</span> = pHead1</span><br><span class="line">    <span class="keyword">if</span>(pHead2) </span><br><span class="line">            cur .<span class="property">next</span> = pHead2</span><br><span class="line">    <span class="keyword">return</span> result.<span class="property">next</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5"><a href="#5" class="headerlink" title="5."></a>5.</h2>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端工程化</title>
      <link href="/posts/7db00131.html"/>
      <url>/posts/7db00131.html</url>
      
        <content type="html"><![CDATA[<p>前端工程化</p><span id="more"></span><h2 id="Q1-面试官：请说说常见的loader"><a href="#Q1-面试官：请说说常见的loader" class="headerlink" title="Q1. 面试官：请说说常见的loader"></a>Q1. 面试官：请说说常见的loader</h2><ul><li><code>sass-loader</code>：将SCSS/SASS代码转换成CSS</li><li><code>postcss-loader</code>：扩展 CSS 语法，使用下一代 CSS，可以配合 autoprefixer 插件自动补齐 CSS3 前缀，加上兼容的浏览器厂商前缀</li><li><code>css-loader</code>：处理样式之间互相引用的逻辑, 加载 CSS，支持模块化、压缩、文件导入等特性</li><li><code>style-loader</code>：将 css-loader 解析后的内容挂载到 html 页面当中</li><li><code>file-loader</code>：可以指定要复制和放置资源文件的位置，以及使用版本哈希命名以获得更好的缓存，在代码中通过相对 URL 去引用输出的文件 (处理图片和字体)。</li><li><code>url-loader</code>：与 file-loader 类似，区别是用户可以设置一个阈值，大于阈值会交给 file-loader 处理，小于阈值时返回文件 base64 形式编码，减少HTTP请求</li><li><code>image-loader</code>：加载并且压缩图片文件</li><li><code>source-map-loader</code>：加载额外的 Source Map 文件，以方便断点调试</li><li><code>json-loader</code> 加载 JSON 文件（默认包含）</li><li><code>babel-loader</code>：把 ES6 转换成 ES5</li><li><code>ts-loader</code>: 将 TypeScript 转换成 JavaScript</li><li><code>tslint-loader</code>：通过 TSLint检查 TypeScript 代码</li><li><code>eslint-loader</code>：通过 ESLint 检查 JavaScript 代码</li><li><code>mocha-loader</code>：加载 Mocha 测试用例的代码</li><li><code>coverjs-loader</code>：计算测试的覆盖率</li><li><code>vue-loader</code>：将 Vue 组件转换为 JavaScript 模块</li><li><code>i18n-loader</code>: 国际化</li><li><code>awesome-typescript-loader</code>：将 TypeScript 转换成 JavaScript，性能优于 ts-loader</li></ul><blockquote><p>loader 的执行顺序要注意！css 相关的loader 要按照下图来写。因为 loader 的执行顺序是从后往前、从下往上。 所以我们要用 <code>saas-loader</code> 来处理 sass 文件, 再把它交给 <code>postcss-loader</code> 加上浏览器厂商前缀。然后通过 <code>css-loader</code> 处理样式之间的引用逻辑。最后通过 <code>style-loader</code> 将它挂在到 html上</p></blockquote><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230611211119358.png" alt="image-20230611211119358"></p><h2 id="Q2-面试官：请说说常见的-plugins"><a href="#Q2-面试官：请说说常见的-plugins" class="headerlink" title="Q2. 面试官：请说说常见的 plugins"></a>Q2. 面试官：请说说常见的 plugins</h2><ol><li><code>html-webpack-plugin</code>：在 dist 下生成 html 文件。简化 HTML 文件创建 (依赖于 html-loader)</li><li><code>clean-webpack-plugin</code>: 目录清理。把 dist 删除再生成打包结果</li><li><code>copy-webpack-plugin</code> 因为 public 文件下的资源是固定的，直接拷贝到编译后的文件夹引入使用就可以，例如 favicon.ico</li><li><code>open-browser-webpack-plugin</code> 启动webpack之后，自动打开浏览器</li><li><code>mini-css-extract-plugin</code>: 分离样式文件，CSS 提取为独立文件，支持按需加载</li><li><code>webpack-parallel-uglify-plugin</code>: 多进程执行代码压缩，提升构建速度</li><li><code>HappyPack Plugin</code>: 开启多进程打包，提升打包速度</li><li><code>webpack-bundle-analyzer</code>: 可视化 Webpack 输出文件的体积 (业务组件、依赖第三方模块)</li><li><code>Dllplugin</code>: 动态链接库，将项目中依赖的三方模块抽离出来，单独打包</li><li><code>DllReferencePlugin</code>: 配合 Dllplugin，通过 manifest.json 映射到相关的依赖上去</li><li><code>vue-skeleton-webpack-plugin</code>: vue 项目实现骨架屏</li></ol><h2 id="Q3-面试官：loaders-跟-plugin-的区别"><a href="#Q3-面试官：loaders-跟-plugin-的区别" class="headerlink" title="Q3. 面试官：loaders 跟 plugin 的区别"></a>Q3. 面试官：loaders 跟 plugin 的区别</h2><p><strong>1、概念不一样。</strong></p><p><code>Loader</code> 本质就是一个函数。对函数中接收到的内容进行转换，返回转换后的结果。Loader 的作用是让 webpack 拥有加载和解析非 JavaScript 文件的能力！ 因为 Webpack 只认识 JavaScript，所以需要对其他类型的资源进行转译的<strong>预处理</strong>工作。Loader 可以理解为「翻译官」。比如常见的 <strong>json-loader</strong>, <strong>ts-loader</strong>等。</p><p><code>Plugin</code> 就是插件，插件可以扩展 Webpack 的功能，让 Webpack 具有更多的灵活性。 在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。</p><p><strong>2、配置方式不一样</strong></p><p><code>Loader</code> 在 module.rules 中配置，作为模块的解析规则，类型为数组。每一项都是一个 Object. <code>Plugin</code> 在 plugins 中单独配置，类型为数组，每一项是一个 Plugin 的实例，参数都通过构造函数传入。</p><p><strong>3、运行时机不一样</strong></p><p><code>Loader</code> 运行在打包文件之前（loader为在模块加载时的预处理文件）。<code>plugins</code> 在整个编译周期都起作用</p><h2 id="Q4-面试官：babel-loader、babel-preset-env、babel-polyfill、babel-transform-runtime-什么区别"><a href="#Q4-面试官：babel-loader、babel-preset-env、babel-polyfill、babel-transform-runtime-什么区别" class="headerlink" title="Q4. 面试官：babel-loader、babel/preset-env、babel-polyfill、babel-transform-runtime 什么区别"></a>Q4. 面试官：babel-loader、babel/preset-env、babel-polyfill、babel-transform-runtime 什么区别</h2><ul><li><p><strong>babel-loader</strong> 把babel跟webpack连接上。相当于是桥梁。实际上还不能把es6转成es5</p></li><li><p><strong>babel/preset-env</strong> 预设，能把let语句等翻译成es5（但是promise、generator等语法不行）</p></li><li><p><strong>babel-polyfill</strong> 才真正的支持Promise等语法</p><p><em>@babel-polyfill包 = corejs包 + regenerator包</em></p></li></ul><blockquote><p><strong>corejs</strong> 少了 <strong>generator</strong>语法， 但支持其它es6甚至更高版本的 js. </p></blockquote><blockquote><p><strong>regenerator</strong> 支持 generator. 补充了corejs!</p></blockquote><ul><li><strong>babel-transform-runtime</strong> 为代码提供了一个沙盒环境，所以不会像 <strong>babel-polyfill</strong>一样污染全局变量，因此适用于开发组件库。注意：<strong>babel-polyfill</strong>会污染全局变量。在开发业务代码的时候，无需考虑该问题。</li></ul><h2 id="Q5-面试官：webpack-如何优化构建体积跟速度"><a href="#Q5-面试官：webpack-如何优化构建体积跟速度" class="headerlink" title="Q5. 面试官：webpack 如何优化构建体积跟速度"></a>Q5. 面试官：webpack 如何优化构建体积跟速度</h2><h3 id="1-Tree-Shaking（优化体积、降低构建速度）"><a href="#1-Tree-Shaking（优化体积、降低构建速度）" class="headerlink" title="1. Tree Shaking（优化体积、降低构建速度）"></a>1. Tree Shaking（优化体积、降低构建速度）</h3><p>Tree Shaking 把源代码里没用到的代码，不打包。（减少包体积，加快速度） 可以这么配置</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">optimization: &#123; <span class="comment">// 优化项</span></span><br><span class="line">   <span class="comment">// sideEffects和usedExports是两种不同的优化方式。</span></span><br><span class="line">   usedExports: <span class="literal">true</span>, <span class="comment">// 识别无用代码 未使用的导出内容不会被生成 usedExports 依赖于 terser 去检测语句中的副作用。</span></span><br><span class="line">   <span class="comment">// sideEffects: true,  // 开启副作用标识功能 sideEffects更为有效是因为它允许跳过整个模块/文件和整个文件子树。</span></span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure><blockquote><p>注意： <strong>tree Shaking</strong> 只支持 ES Module，不支持 Commonjs</p><p>vue 脚手架搭建的项目，默认已经给你配置好了 tree Shaking</p><p>了解更多，请看看这篇文章 <a href="https://link.juejin.cn/?target=https://zhuanlan.zhihu.com/p/417686391">webpack配置-tree shaking</a></p></blockquote><h3 id="2-使用懒加载"><a href="#2-使用懒加载" class="headerlink" title="2. 使用懒加载"></a>2. 使用懒加载</h3><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230611211511770.png" alt="image-20230611211511770"></p><h3 id="3-代码分割（优化构建速度）"><a href="#3-代码分割（优化构建速度）" class="headerlink" title="3. 代码分割（优化构建速度）"></a>3. 代码分割（优化构建速度）</h3><p><code>代码分割</code> 分成  <strong>js代码分割</strong> 跟 <strong>css代码分割</strong>。</p><p><strong>js代码分割（两种实现方式）</strong></p><ul><li><p>使用entry配置手动分离</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230611211558746.png" alt="image-20230611211558746"></p></li><li><p>使用 webpack 的 splitChunks 去自动分割（splitChunks 替代了 CommonsChunkPlugin 插件）</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230611211621905.png" alt="image-20230611211621905"></p></li></ul><p><strong>css代码分割</strong></p><p>没配置 css代码分割的话，css 代码会打包到 js 里去（css in js）. 我们并不希望 css 混入到 js 里，而是希望 css 作为外链单独应用，所以我们要做代码分割！</p><p>这时候就可以用 <code>mini-css-extract-plugin</code>（生产环境用就好。开发环境 css in js 没什么大问题。反而能减少 webpack 工作量，还能提高构建速度。所以配置在 webpack.prod.js 就好）</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230611211707693.png" alt="image-20230611211707693"></p><h3 id="4-file-loader"><a href="#4-file-loader" class="headerlink" title="4. file-loader"></a>4. file-loader</h3><p>file-loader 可以指定要复制和放置资源文件的位置，以及使用版本哈希命名以获得更好的缓存（hash值是根据文件内容算出来的，所以文件内容不变，hash值不变，浏览器就可以用缓存的内容。）。</p><h3 id="5-url-loader"><a href="#5-url-loader" class="headerlink" title="5. url-loader"></a>5. url-loader</h3><p>url-loader 文件大于该阈值交给file-loader去处理，小于阈值转成 base64，减少 HTTP 请求数</p><h3 id="6-DllPlugin"><a href="#6-DllPlugin" class="headerlink" title="6. DllPlugin"></a>6. DllPlugin</h3><p>什么是<code>DllPlugin</code>呢 ？</p><p>如果你使用vue技术栈来开发，你改动了一行业务代码这势必不会影响vue源码，但是你构建的时候发现了所有的代码都被重新构建了，这显然是不合理的，而 DllPlugin 就是解决这个问题的。让我们将第三方库这种无论我们怎么改业务代码构建结果都不会发生改变的模块单独拆出来构建，下次只要不改变第三方库就直接引用现成的构建结果就可以了</p><p>那我们要怎么使用呢？ 主要有两步</p><ol><li>通过 DllPlugin 打包出动态链接库</li><li>用 DllReferencePlugin 在主构建中引入动态链接库就可以了</li></ol><p>更多内容可以看看这篇文章 <a href="https://link.juejin.cn/?target=https://blog.csdn.net/riddle1981/article/details/114345250">webpack优化——Dllplugin</a></p><h3 id="7-externals（利用cdn-优化体积、优化构建速度）"><a href="#7-externals（利用cdn-优化体积、优化构建速度）" class="headerlink" title="7. externals（利用cdn, 优化体积、优化构建速度）"></a>7. externals（利用cdn, 优化体积、优化构建速度）</h3><p><strong>常用库替换成cdn文件</strong></p><p>externals 是常用优化手段。构建时，将依赖文件相关从 node_modules 导入改为外部链接引用(即：通过 script 标签，以 CDN 的方式加载)</p><p>你可以把常见的 libs 以 CDN 的方式导入，像 vue，react，jquery 等，他们的官方都提供了可靠的 CDN 服务。</p><p>我们需要在vue.config.js里定义键值对。key就是我们引入的包的名字。value就是我们引入的包挂载在全局用的变量名。</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230611211904082.png" alt="image-20230611211904082"></p><p><strong>常用ui库的css文件替换成cdn文件</strong></p><p>除了js库外，我们还可以将element ui的css通过cdn的方式引入。</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230611211918155.png" alt="image-20230611211918155"></p><h3 id="8-babel-loader-优化"><a href="#8-babel-loader-优化" class="headerlink" title="8. babel-loader 优化"></a>8. babel-loader 优化</h3><p>babel-loader 帮助我们把 es6转换为es5。但是我们仍需要对 babel-loader 进行两点优化。</p><p>一、设置 babel-loader 编译过程中需要解析的路径，以及排除 node_modules 相关依赖；<strong>include</strong>、 <strong>exclude</strong> 二者选其一</p><p>二：加上 <strong>cacheDirectory</strong> 开启缓存。</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230611211944102.png" alt="image-20230611211944102"></p><h3 id="9-ignorePlugin-跟-noParse"><a href="#9-ignorePlugin-跟-noParse" class="headerlink" title="9. ignorePlugin 跟 noParse"></a>9. ignorePlugin 跟 noParse</h3><p><strong>ignorePlugin</strong><br> <code>ignorePlugin</code> 忽略某些模块下的某个文件夹。<br> 例如 moment 这个包挺大的，里头包含了很多国家的国际化方面的东西。但是我们在实际项目中，一般中文就够了。</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230611212005701.png" alt="image-20230611212005701"></p><p><strong>noParse</strong></p><p><code>noParse</code> 不去做解析。忽略掉</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230611212019409.png" alt="image-20230611212019409"></p><p><strong>ignorePlugin 跟 noParse 的区别</strong></p><ul><li><strong>ignorePlugin</strong> 是忽略掉，最终生成的代码也不会包括该代码</li><li><strong>noParse</strong> 是不做打包，但是最后打包后的文件是包含该代码的</li></ul><h3 id="10-开启多进程"><a href="#10-开启多进程" class="headerlink" title="10. 开启多进程"></a>10. 开启多进程</h3><ol><li><strong>多进程打包</strong>：<code>happypack plugins</code> ，它将尽可能利用硬件资源，多线程方式来编译代码。</li><li><strong>多进程压缩</strong>：<code>webpack-parallel-uglify-plugin</code> 这个插件能让我们开启多进程来压缩 js 代码（生产环境配置就好了。开发环境会加大开销）</li></ol><p>讲了这么多是不是快晕啦。</p><p>别怕，附上思维导图总结（妈妈再也不用担心我记不住了😄）</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230611212120443.png" alt="image-20230611212120443"></p><h2 id="Q6-说一下-Webpack-的热更新原理吧"><a href="#Q6-说一下-Webpack-的热更新原理吧" class="headerlink" title="Q6. 说一下 Webpack 的热更新原理吧"></a>Q6. 说一下 Webpack 的热更新原理吧</h2><p><code>Webpack</code> 的热更新又称热替换（<code>Hot Module Replacement</code>），缩写为 <code>HMR</code>。 可以做到无需完全刷新整个页面的同时，保留页面状态并且更新模块。提到热更新我们不得不知道另一个概念——WDS。<code>webpack-dev-server(WDS)</code>是一个基于express的web server，server内部调用webpack，这样的好处是提供了热加载和热替换的功能</p><p>热更新的核心就是客户端从服务端拉取更新后的文件，准确的说是 chunk diff (chunk 需要更新的部分)，实际上 WDS 与浏览器之间维护了一个Websocket，当本地资源发生变化时，WDS 会向浏览器推送更新，并带上构建时的 hash，让客户端与上一次资源进行对比。客户端对比出差异后会向 WDS 发起Ajax请求来获取更改内容(文件列表、hash)，这样客户端就可以再借助这些信息继续向 WDS 发起jsonp请求获取该chunk的增量更新。</p><h2 id="Q7-面试官：Webpack-proxy-为什么能解决跨域"><a href="#Q7-面试官：Webpack-proxy-为什么能解决跨域" class="headerlink" title="Q7. 面试官：Webpack proxy 为什么能解决跨域"></a>Q7. 面试官：Webpack proxy 为什么能解决跨域</h2><blockquote><p>背景：在开发阶段， <code>webpack-dev-server</code> 会启动一个本地开发服务器，所以我们的应用在开发阶段是独立运行在 <code>localhost</code>的一个端口上，而后端服务又是运行在另外一个地址上</p><p>所以在开发阶段中，由于浏览器同源策略的原因，当本地访问后端就会出现跨域请求的问题</p></blockquote><p>通过设置<code>webpack proxy</code>实现代理请求后，相当于浏览器与服务端中添加一个代理者</p><p>当本地发送请求的时候，代理服务器响应该请求，并将请求转发到目标服务器，目标服务器响应数据后再将数据返回给代理服务器，最终再由代理服务器将数据响应给本地</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/928dca390f3440d0a6ebf0bccd01b386~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="img"></p><p><strong>这是因为：</strong> 在代理服务器传递数据给本地浏览器的过程中，两者同源，并不存在跨域行为，这时候浏览器就能正常接收数据。而服务器与服务器之间请求数据不会存在跨域行为（因为跨域行为是浏览器安全策略限制）</p><h2 id="Q8-面试官：手写一个Loader来瞧瞧"><a href="#Q8-面试官：手写一个Loader来瞧瞧" class="headerlink" title="Q8. 面试官：手写一个Loader来瞧瞧"></a>Q8. 面试官：手写一个Loader来瞧瞧</h2><p><strong>一个简单的<code>style-loader</code></strong></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 作用：将css内容，通过style标签插入到页面中</span><br><span class="line">// source为要处理的css源文件</span><br><span class="line">function loader(source) &#123;</span><br><span class="line">  let <span class="attr">style</span> = `</span><br><span class="line">    let <span class="attr">style</span> = document.createElement(<span class="string">&#x27;style&#x27;</span>)<span class="comment">;</span></span><br><span class="line">    style.setAttribute(&quot;type&quot;, &quot;text/css&quot;)<span class="comment">;</span></span><br><span class="line">    <span class="attr">style.innerHTML</span> = <span class="variable">$&#123;source&#125;</span><span class="comment">;</span></span><br><span class="line">    document.head.appendChild(style)`<span class="comment">;</span></span><br><span class="line">  return style<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="attr">module.exports</span> = loader<span class="comment">;</span></span><br></pre></td></tr></table></figure><p><strong>最后，在 vue 项目中使用自定义 loader</strong></p><p>1）在<code>vue.config.js</code>引入该 loader</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const MyStyleLoader = require(&#x27;./style-loader&#x27;)</span><br></pre></td></tr></table></figure><p>2）在<code>configureWebpack</code>中添加配置</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">module<span class="selector-class">.exports</span> = &#123;</span><br><span class="line">  configureWebpack: &#123;</span><br><span class="line">    module: &#123;</span><br><span class="line">      rules: [</span><br><span class="line">        &#123;</span><br><span class="line">          // 对<span class="selector-tag">main</span><span class="selector-class">.css</span>文件使用MyStyleLoader处理</span><br><span class="line">          test: /main.css/,</span><br><span class="line">          loader: MyStyleLoader</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>3）项目重新编译<br> <code>main.css</code>样式已加载到页面中</p><h2 id="Q9-面试官：手写一个Plugin插件"><a href="#Q9-面试官：手写一个Plugin插件" class="headerlink" title="Q9. 面试官：手写一个Plugin插件"></a>Q9. 面试官：手写一个Plugin插件</h2><p>Plugin 的组成部分</p><p>1）Plugin 的本质是一个 <code>node 模块</code>，这个模块导出一个 JavaScript 类</p><p>2）它的原型上需要定义一个<code>apply</code> 的方法</p><p>3）通过<code>compiler</code>获取 webpack 内部的钩子，获取 webpack 打包过程中的各个阶段</p><p>钩子分为同步和异步的钩子，异步钩子必须执行对应的回调</p><p>4）通过<code>compilation</code>操作 webpack 内部实例特定数据</p><p>5）功能完成后，执行 webpack 提供的 cb 回调</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义一个名为MyPlugin插件，该插件在打包完成后，在控制台输出&quot;打包已完成&quot;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyPlugin</span> &#123;</span><br><span class="line">  <span class="comment">// 原型上需要定义apply 的方法</span></span><br><span class="line">  <span class="title function_">apply</span>(<span class="params">compiler</span>) &#123;</span><br><span class="line">    <span class="comment">// 通过compiler获取webpack内部的钩子</span></span><br><span class="line">    compiler.<span class="property">hooks</span>.<span class="property">done</span>.<span class="title function_">tap</span>(<span class="string">&quot;My Plugin&quot;</span>, <span class="function">(<span class="params">compilation, cb</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;打包已完成&quot;</span>);</span><br><span class="line">      <span class="comment">// 分为同步和异步的钩子，异步钩子必须执行对应的回调</span></span><br><span class="line">      <span class="title function_">cb</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title class_">MyPlugin</span>;</span><br></pre></td></tr></table></figure><p><strong>最后， 在 vue 项目中使用自定义插件</strong></p><p>1）在<code>vue.config.js</code>引入该插件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">MyPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;./MyPlugin.js&#x27;</span>)</span><br></pre></td></tr></table></figure><p>2）在<code>configureWebpack</code>的 plugins 列表中注册该插件</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">module.exports</span> = &#123;</span><br><span class="line">  configureWebpack: &#123;</span><br><span class="line">    plugins: <span class="section">[new MyPlugin()]</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>3）执行项目的打包命令<br> 当项目打包成功后，会在控制台输出：<code>打包已完成</code></p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络</title>
      <link href="/posts/50daec4.html"/>
      <url>/posts/50daec4.html</url>
      
        <content type="html"><![CDATA[<p>摘要</p><span id="more"></span><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230610201314734.png" alt="image-20230610201314734"></p><h2 id="一、HTTP协议"><a href="#一、HTTP协议" class="headerlink" title="一、HTTP协议"></a>一、HTTP协议</h2><h3 id="1-GET和POST的请求的区别"><a href="#1-GET和POST的请求的区别" class="headerlink" title="1. GET和POST的请求的区别"></a>1. GET和POST的请求的区别</h3><p>Post 和 Get 是 HTTP 请求的两种方法，其区别如下：</p><ul><li><strong>应用场景：</strong> GET 请求是一个幂等的请求，一般 Get 请求用于对服务器资源不会产生影响的场景，比如说请求一个网页的资源。而 Post 不是一个幂等的请求，一般用于对服务器资源会产生影响的情景，比如注册用户这一类的操作。</li><li><strong>是否缓存：</strong> 因为两者应用场景不同，浏览器一般会对 Get 请求缓存，但很少对 Post 请求缓存。</li><li><strong>发送的报文格式：</strong> Get 请求的报文中实体部分为空，Post 请求的报文中实体部分一般为向服务器发送的数据。</li><li><strong>安全性：</strong> Get 请求可以将请求的参数放入 url 中向服务器发送，这样的做法相对于 Post 请求来说是不太安全的，因为请求的 url 会被保留在历史记录中。</li><li><strong>请求长度：</strong> 浏览器由于对 url 长度的限制，所以会影响 get 请求发送数据时的长度。这个限制是浏览器规定的，并不是 RFC 规定的。</li><li><strong>参数类型：</strong> post 的参数传递支持更多的数据类型。</li></ul><h3 id="2-POST和PUT请求的区别"><a href="#2-POST和PUT请求的区别" class="headerlink" title="2. POST和PUT请求的区别"></a>2. POST和PUT请求的区别</h3><ul><li>PUT请求是向服务器端发送数据，从而修改数据的内容，但是不会增加数据的种类等，也就是说无论进行多少次PUT操作，其结果并没有不同。（可以理解为时<strong>更新数据</strong>）</li><li>POST请求是向服务器端发送数据，该请求会改变数据的种类等资源，它会创建新的内容。（可以理解为是<strong>创建数据</strong>）</li></ul><h3 id="3-常见的HTTP请求头和响应头"><a href="#3-常见的HTTP请求头和响应头" class="headerlink" title="3. 常见的HTTP请求头和响应头"></a>3. 常见的HTTP请求头和响应头</h3><p><strong>HTTP Request Header 常见的请求头：</strong></p><ul><li>Accept:浏览器能够处理的内容类型</li><li>Accept-Charset:浏览器能够显示的字符集</li><li>Accept-Encoding：浏览器能够处理的压缩编码</li><li>Accept-Language：浏览器当前设置的语言</li><li>Connection：浏览器与服务器之间连接的类型</li><li>Cookie：当前页面设置的任何Cookie</li><li>Host：发出请求的页面所在的域</li><li>Referer：发出请求的页面的URL</li><li>User-Agent：浏览器的用户代理字符串</li></ul><p><strong>HTTP Responses Header 常见的响应头：</strong></p><ul><li>Date：表示消息发送的时间，时间的描述格式由rfc822定义</li><li>server:服务器名称</li><li>Connection：浏览器与服务器之间连接的类型</li><li>Cache-Control：控制HTTP缓存</li><li>content-type:表示后面的文档属于什么MIME类型</li></ul><p>常见的 Content-Type 属性值有以下四种：</p><p>（1）application/x-www-form-urlencoded：浏览器的原生 form 表单，如果不设置 enctype 属性，那么最终就会以 application/x-www-form-urlencoded 方式提交数据。该种方式提交的数据放在 body 里面，数据按照 key1=val1&amp;key2=val2 的方式进行编码，key 和 val 都进行了 URL转码。</p><p>（2）multipart/form-data：该种方式也是一个常见的 POST 提交方式，通常表单上传文件时使用该种方式。</p><p>（3）application/json：服务器消息主体是序列化后的 JSON 字符串。</p><p>（4）text/xml：该种方式主要用来提交 XML 格式的数据。</p><h3 id="4-HTTP状态码304是多好还是少好"><a href="#4-HTTP状态码304是多好还是少好" class="headerlink" title="4. HTTP状态码304是多好还是少好"></a>4. HTTP状态码304是多好还是少好</h3><p>服务器为了提高网站访问速度，对之前访问的部分页面指定缓存机制，当客户端在此对这些页面进行请求，服务器会根据缓存内容判断页面与之前是否相同，若相同便直接返回304，此时客户端调用缓存内容，不必进行二次下载。</p><p>状态码304不应该认为是一种错误，而是对客户端<strong>有缓存情况下</strong>服务端的一种响应。</p><p>搜索引擎蜘蛛会更加青睐内容源更新频繁的网站。通过特定时间内对网站抓取返回的状态码来调节对该网站的抓取频次。若网站在一定时间内一直处于304的状态，那么蜘蛛可能会降低对网站的抓取次数。相反，若网站变化的频率非常之快，每次抓取都能获取新内容，那么日积月累，的回访率也会提高。</p><p><strong>产生较多304状态码的原因：</strong></p><ul><li>页面更新周期长或不更新</li><li>纯静态页面或强制生成静态html</li></ul><p><strong>304状态码出现过多会造成以下问题：</strong></p><ul><li>网站快照停止；</li><li>收录减少；</li><li>权重下降。</li></ul><h3 id="5-常见的HTTP请求方法"><a href="#5-常见的HTTP请求方法" class="headerlink" title="5. 常见的HTTP请求方法"></a>5. 常见的HTTP请求方法</h3><ul><li>GET: 向服务器获取数据；</li><li>POST：将实体提交到指定的资源，通常会造成服务器资源的修改；</li><li>PUT：上传文件，更新数据；</li><li>DELETE：删除服务器上的对象；</li><li>HEAD：获取报文首部，与GET相比，不返回报文主体部分；</li><li>OPTIONS：询问支持的请求方法，用来跨域请求；</li><li>CONNECT：要求在与代理服务器通信时建立隧道，使用隧道进行TCP通信；</li><li>TRACE: 回显服务器收到的请求，主要⽤于测试或诊断。</li></ul><h3 id="6-OPTIONS请求方法及使用场景"><a href="#6-OPTIONS请求方法及使用场景" class="headerlink" title="6. OPTIONS请求方法及使用场景"></a>6. OPTIONS请求方法及使用场景</h3><p>OPTIONS是除了GET和POST之外的其中一种 HTTP请求方法。</p><p>OPTIONS方法是用于请求获得由<code>Request-URI</code>标识的资源在请求/响应的通信过程中可以使用的功能选项。通过这个方法，客户端可以<strong>在采取具体资源请求之前，决定对该资源采取何种必要措施，或者了解服务器的性能</strong>。该请求方法的响应不能缓存。</p><p>OPTIONS请求方法的<strong>主要用途</strong>有两个：</p><ul><li>获取服务器支持的所有HTTP请求方法；</li><li>用来检查访问权限。例如：在进行 CORS 跨域资源共享时，对于复杂请求，就是使用 OPTIONS 方法发送嗅探请求，以判断是否有对指定资源的访问权限。</li></ul><h3 id="7-HTTP-1-0-和-HTTP-1-1-之间有哪些区别？"><a href="#7-HTTP-1-0-和-HTTP-1-1-之间有哪些区别？" class="headerlink" title="7. HTTP 1.0 和 HTTP 1.1 之间有哪些区别？"></a>7. HTTP 1.0 和 HTTP 1.1 之间有哪些区别？</h3><p><strong>HTTP 1.0和 HTTP 1.1 有以下区别</strong>：</p><ul><li><strong>连接方面</strong>，http1.0 默认使用非持久连接，而 http1.1 默认使用持久连接。http1.1 通过使用持久连接来使多个 http 请求复用同一个 TCP 连接，以此来避免使用非持久连接时每次需要建立连接的时延。</li><li><strong>资源请求方面</strong>，在 http1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，http1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</li><li><strong>缓存方面</strong>，在 http1.0 中主要使用 header 里的 If-Modified-Since、Expires 来做为缓存判断的标准，http1.1 则引入了更多的缓存控制策略，例如 Etag、If-Unmodified-Since、If-Match、If-None-Match 等更多可供选择的缓存头来控制缓存策略。</li><li>http1.1 中<strong>新增了 host 字段</strong>，用来指定服务器的域名。http1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此，请求消息中的 URL 并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个IP地址。因此有了 host 字段，这样就可以将请求发往到同一台服务器上的不同网站。</li><li>http1.1 相对于 http1.0 还新增了很多<strong>请求方法</strong>，如 PUT、HEAD、OPTIONS 等。</li></ul><h3 id="8-HTTP-1-1-和-HTTP-2-0-的区别"><a href="#8-HTTP-1-1-和-HTTP-2-0-的区别" class="headerlink" title="8. HTTP 1.1 和 HTTP 2.0 的区别"></a>8. HTTP 1.1 和 HTTP 2.0 的区别</h3><ul><li><strong>二进制协议</strong>：HTTP/2 是一个二进制协议。在 HTTP/1.1 版中，报文的头信息必须是文本（ASCII 编码），数据体可以是文本，也可以是二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为”帧”，可以分为头信息帧和数据帧。 帧的概念是它实现多路复用的基础。</li><li><strong>多路复用：</strong> HTTP/2 实现了多路复用，HTTP/2 仍然复用 TCP 连接，但是在一个连接里，客户端和服务器都可以同时发送多个请求或回应，而且不用按照顺序一一发送，这样就避免了”队头堵塞”【1】的问题。</li><li><strong>数据流：</strong> HTTP/2 使用了数据流的概念，因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的请求。因此，必须要对数据包做标记，指出它属于哪个请求。HTTP/2 将每个请求或回应的所有数据包，称为一个数据流。每个数据流都有一个独一无二的编号。数据包发送时，都必须标记数据流 ID ，用来区分它属于哪个数据流。</li><li><strong>头信息压缩：</strong> HTTP/2 实现了头信息压缩，由于 HTTP 1.1 协议不带状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如 Cookie 和 User Agent ，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。HTTP/2 对这一点做了优化，引入了头信息压缩机制。一方面，头信息使用 gzip 或 compress 压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就能提高速度了。</li><li><strong>服务器推送：</strong> HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送。使用服务器推送提前给客户端推送必要的资源，这样就可以相对减少一些延迟时间。这里需要注意的是 http2 下服务器主动推送的是静态资源，和 WebSocket 以及使用 SSE 等方式向客户端发送即时数据的推送是不同的。</li></ul><p><strong>【1】队头堵塞：</strong></p><blockquote><p>队头阻塞是由 HTTP 基本的“请求 - 应答”模型所导致的。HTTP 规定报文必须是“一发一收”，这就形成了一个先进先出的“串行”队列。队列里的请求是没有优先级的，只有入队的先后顺序，排在最前面的请求会被最优先处理。如果队首的请求因为处理的太慢耽误了时间，那么队列里后面的所有请求也不得不跟着一起等待，结果就是其他的请求承担了不应有的时间成本，造成了队头堵塞的现象。</p></blockquote><h3 id="9-HTTP和HTTPS协议的区别"><a href="#9-HTTP和HTTPS协议的区别" class="headerlink" title="9. HTTP和HTTPS协议的区别"></a>9. HTTP和HTTPS协议的区别</h3><p>HTTP和HTTPS协议的主要区别如下：</p><ul><li>HTTPS协议需要CA证书，费用较高；而HTTP协议不需要；</li><li>HTTP协议是超文本传输协议，信息是明文传输的，HTTPS则是具有安全性的SSL加密传输协议；</li><li>使用不同的连接方式，端口也不同，HTTP协议端口是80，HTTPS协议端口是443；</li><li>HTTP协议连接很简单，是无状态的；HTTPS协议是有SSL和HTTP协议构建的可进行加密传输、身份认证的网络协议，比HTTP更加安全。</li></ul><h3 id="10-GET方法URL长度限制的原因"><a href="#10-GET方法URL长度限制的原因" class="headerlink" title="10. GET方法URL长度限制的原因"></a>10. GET方法URL长度限制的原因</h3><p>实际上HTTP协议规范并没有对get方法请求的url长度进行限制，这个限制是特定的浏览器及服务器对它的限制。 IE对URL长度的限制是2083字节(2K+35)。由于IE浏览器对URL长度的允许值是最小的，所以开发过程中，只要URL不超过2083字节，那么在所有浏览器中工作都不会有问题。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">GET</span>的长度值 = <span class="variable constant_">URL</span>（<span class="number">2083</span>）- （你的<span class="title class_">Domain</span>+<span class="title class_">Path</span>）-<span class="number">2</span>（<span class="number">2</span>是get请求中?=两个字符的长度）</span><br></pre></td></tr></table></figure><p>下面看一下主流浏览器对get方法中url的长度限制范围：</p><ul><li>Microsoft Internet Explorer (Browser)：IE浏览器对URL的最大限制为2083个字符，如果超过这个数字，提交按钮没有任何反应。</li><li>Firefox (Browser)：对于Firefox浏览器URL的长度限制为 65,536 个字符。</li><li>Safari (Browser)：URL最大长度限制为 80,000 个字符。</li><li>Opera (Browser)：URL最大长度限制为 190,000 个字符。</li><li>Google (chrome)：URL最大长度限制为 8182 个字符。</li></ul><p>主流的服务器对get方法中url的长度限制范围：</p><ul><li>Apache (Server)：能接受最大url长度为8192个字符。</li><li>Microsoft Internet Information Server(IIS)：能接受最大url的长度为16384个字符。</li></ul><p>根据上面的数据，可以知道，get方法中的URL长度最长不超过2083个字符，这样所有的浏览器和服务器都可能正常工作。</p><h3 id="11-当在浏览器中输入-Google-com-并且按下回车之后发生了什么？"><a href="#11-当在浏览器中输入-Google-com-并且按下回车之后发生了什么？" class="headerlink" title="11. 当在浏览器中输入 Google.com 并且按下回车之后发生了什么？"></a>11. 当在浏览器中输入 Google.com 并且按下回车之后发生了什么？</h3><p>（1）<strong>解析URL：</strong> 首先会对 URL 进行解析，分析所需要使用的传输协议和请求的资源的路径。如果输入的 URL 中的协议或者主机名不合法，将会把地址栏中输入的内容传递给搜索引擎。如果没有问题，浏览器会检查 URL 中是否出现了非法字符，如果存在非法字符，则对非法字符进行转义后再进行下一过程。</p><p>（2）<strong>缓存判断：</strong> 浏览器会判断所请求的资源是否在缓存里，如果请求的资源在缓存里并且没有失效，那么就直接使用，否则向服务器发起新的请求。</p><p>（3）<strong>DNS解析：</strong> 下一步首先需要获取的是输入的 URL 中的域名的 IP 地址，首先会判断本地是否有该域名的 IP 地址的缓存，如果有则使用，如果没有则向本地 DNS 服务器发起请求。本地 DNS 服务器也会先检查是否存在缓存，如果没有就会先向根域名服务器发起请求，获得负责的顶级域名服务器的地址后，再向顶级域名服务器请求，然后获得负责的权威域名服务器的地址后，再向权威域名服务器发起请求，最终获得域名的 IP 地址后，本地 DNS 服务器再将这个 IP 地址返回给请求的用户。用户向本地 DNS 服务器发起请求属于递归请求，本地 DNS 服务器向各级域名服务器发起请求属于迭代请求。</p><p>（4）<strong>获取MAC地址：</strong> 当浏览器得到 IP 地址后，数据传输还需要知道目的主机 MAC 地址，因为应用层下发数据给传输层，TCP 协议会指定源端口号和目的端口号，然后下发给网络层。网络层会将本机地址作为源地址，获取的 IP 地址作为目的地址。然后将下发给数据链路层，数据链路层的发送需要加入通信双方的 MAC 地址，本机的 MAC 地址作为源 MAC 地址，目的 MAC 地址需要分情况处理。通过将 IP 地址与本机的子网掩码相与，可以判断是否与请求主机在同一个子网里，如果在同一个子网里，可以使用 APR 协议获取到目的主机的 MAC 地址，如果不在一个子网里，那么请求应该转发给网关，由它代为转发，此时同样可以通过 ARP 协议来获取网关的 MAC 地址，此时目的主机的 MAC 地址应该为网关的地址。</p><p>（5）<strong>TCP三次握手：</strong> 下面是 TCP 建立连接的三次握手的过程，首先客户端向服务器发送一个 SYN 连接请求报文段和一个随机序号，服务端接收到请求后向服务器端发送一个 SYN ACK报文段，确认连接请求，并且也向客户端发送一个随机序号。客户端接收服务器的确认应答后，进入连接建立的状态，同时向服务器也发送一个ACK 确认报文段，服务器端接收到确认后，也进入连接建立状态，此时双方的连接就建立起来了。</p><p>（6）<strong>HTTPS握手：</strong> 如果使用的是 HTTPS 协议，在通信前还存在 TLS 的一个四次握手的过程。首先由客户端向服务器端发送使用的协议的版本号、一个随机数和可以使用的加密方法。服务器端收到后，确认加密的方法，也向客户端发送一个随机数和自己的数字证书。客户端收到后，首先检查数字证书是否有效，如果有效，则再生成一个随机数，并使用证书中的公钥对随机数加密，然后发送给服务器端，并且还会提供一个前面所有内容的 hash 值供服务器端检验。服务器端接收后，使用自己的私钥对数据解密，同时向客户端发送一个前面所有内容的 hash 值供客户端检验。这个时候双方都有了三个随机数，按照之前所约定的加密方法，使用这三个随机数生成一把秘钥，以后双方通信前，就使用这个秘钥对数据进行加密后再传输。</p><p>（7）<strong>返回数据：</strong> 当页面请求发送到服务器端后，服务器端会返回一个 html 文件作为响应，浏览器接收到响应后，开始对 html 文件进行解析，开始页面的渲染过程。</p><p>（8）<strong>页面渲染：</strong> 浏览器首先会根据 html 文件构建 DOM 树，根据解析到的 css 文件构建 CSSOM 树，如果遇到 script 标签，则判端是否含有 defer 或者 async 属性，要不然 script 的加载和执行会造成页面的渲染的阻塞。当 DOM 树和 CSSOM 树建立好后，根据它们来构建渲染树。渲染树构建好后，会根据渲染树来进行布局。布局完成后，最后使用浏览器的 UI 接口对页面进行绘制。这个时候整个页面就显示出来了。</p><p>（9）<strong>TCP四次挥手：</strong> 最后一步是 TCP 断开连接的四次挥手过程。若客户端认为数据发送完成，则它需要向服务端发送连接释放请求。服务端收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明客户端到服务端的连接已经释放，不再接收客户端发的数据了。但是因为 TCP 连接是双向的，所以服务端仍旧可以发送数据给客户端。服务端如果此时还有没发完的数据会继续发送，完毕后会向客户端发送连接释放请求，然后服务端便进入 LAST-ACK 状态。客户端收到释放请求后，向服务端发送确认应答，此时客户端进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有服务端的重发请求的话，就进入 CLOSED 状态。当服务端收到确认应答后，也便进入 CLOSED 状态。</p><h3 id="12-对keep-alive的理解"><a href="#12-对keep-alive的理解" class="headerlink" title="12. 对keep-alive的理解"></a>12. 对keep-alive的理解</h3><p>HTTP1.0 中默认是在每次请求/应答，客户端和服务器都要新建一个连接，完成之后立即断开连接，这就是<strong>短连接</strong>。当使用Keep-Alive模式时，Keep-Alive功能使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive功能避免了建立或者重新建立连接，这就是<strong>长连接</strong>。其使用方法如下：</p><ul><li>HTTP1.0版本是默认没有Keep-alive的（也就是默认会发送keep-alive），所以要想连接得到保持，必须手动配置发送<code>Connection: keep-alive</code>字段。若想断开keep-alive连接，需发送<code>Connection:close</code>字段；</li><li>HTTP1.1规定了默认保持长连接，数据传输完成了保持TCP连接不断开，等待在同域名下继续用这个通道传输数据。如果需要关闭，需要客户端发送<code>Connection：close</code>首部字段。</li></ul><p>Keep-Alive的<strong>建立过程</strong>：</p><ul><li>客户端向服务器在发送请求报文同时在首部添加发送Connection字段</li><li>服务器收到请求并处理 Connection字段</li><li>服务器回送Connection:Keep-Alive字段给客户端</li><li>客户端接收到Connection字段</li><li>Keep-Alive连接建立成功</li></ul><p><strong>服务端自动断开过程（也就是没有keep-alive）</strong>：</p><ul><li>客户端向服务器只是发送内容报文（不包含Connection字段）</li><li>服务器收到请求并处理</li><li>服务器返回客户端请求的资源并关闭连接</li><li>客户端接收资源，发现没有Connection字段，断开连接</li></ul><p><strong>客户端请求断开连接过程</strong>：</p><ul><li>客户端向服务器发送Connection:close字段</li><li>服务器收到请求并处理connection字段</li><li>服务器回送响应资源并断开连接</li><li>客户端接收资源并断开连接</li></ul><p>开启Keep-Alive的<strong>优点：</strong></p><ul><li>较少的CPU和内存的使⽤（由于同时打开的连接的减少了）；</li><li>允许请求和应答的HTTP管线化；</li><li>降低拥塞控制 （TCP连接减少了）；</li><li>减少了后续请求的延迟（⽆需再进⾏握⼿）；</li><li>报告错误⽆需关闭TCP连；</li></ul><p>开启Keep-Alive的<strong>缺点</strong>：</p><ul><li>长时间的Tcp连接容易导致系统资源无效占用，浪费系统资源。</li></ul><h3 id="13-页面有多张图片，HTTP是怎样的加载表现？"><a href="#13-页面有多张图片，HTTP是怎样的加载表现？" class="headerlink" title="13. 页面有多张图片，HTTP是怎样的加载表现？"></a>13. 页面有多张图片，HTTP是怎样的加载表现？</h3><ul><li>在<code>HTTP 1</code>下，浏览器对一个域名下最大TCP连接数为6，所以会请求多次。可以用<strong>多域名部署</strong>解决。这样可以提高同时请求的数目，加快页面图片的获取速度。</li><li>在<code>HTTP 2</code>下，可以一瞬间加载出来很多资源，因为，HTTP2支持多路复用，可以在一个TCP连接中发送多个HTTP请求。</li></ul><h3 id="14-HTTP2的头部压缩算法是怎样的？"><a href="#14-HTTP2的头部压缩算法是怎样的？" class="headerlink" title="14. HTTP2的头部压缩算法是怎样的？"></a>14. HTTP2的头部压缩算法是怎样的？</h3><p>HTTP2的头部压缩是HPACK算法。在客户端和服务器两端建立“字典”，用索引号表示重复的字符串，采用哈夫曼编码来压缩整数和字符串，可以达到50%~90%的高压缩率。</p><p>具体来说:</p><ul><li>在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键值对，对于相同的数据，不再通过每次请求和响应发送；</li><li>首部表在HTTP/2的连接存续期内始终存在，由客户端和服务器共同渐进地更新；</li><li>每个新的首部键值对要么被追加到当前表的末尾，要么替换表中之前的值。</li></ul><p>例如下图中的两个请求， 请求一发送了所有的头部字段，第二个请求则只需要发送差异数据，这样可以减少冗余数据，降低开销。</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230610203058046.png" alt="image-20230610203058046"></p><h3 id="15-HTTP请求报文的是什么样的？"><a href="#15-HTTP请求报文的是什么样的？" class="headerlink" title="15. HTTP请求报文的是什么样的？"></a>15. HTTP请求报文的是什么样的？</h3><p>请求报⽂有4部分组成:</p><ul><li>请求⾏</li><li>请求头部</li><li>空⾏</li><li>请求体</li></ul><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230610203120982.png" alt="image-20230610203120982"></p><p> <strong>其中：</strong> （1）请求⾏包括：请求⽅法字段、URL字段、HTTP协议版本字段。它们⽤空格分隔。例如，GET /index.html HTTP/1.1。 （2）请求头部:请求头部由关键字/值对组成，每⾏⼀对，关键字和值⽤英⽂冒号“:”分隔</p><ul><li>User-Agent：产⽣请求的浏览器类型。</li><li>Accept：客户端可识别的内容类型列表。</li><li>Host：请求的主机名，允许多个域名同处⼀个IP地址，即虚拟主机。</li></ul><p>（3）请求体: post put等请求携带的数据 </p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230610203155988.png" alt="image-20230610203155988"></p><h3 id="16-HTTP响应报文的是什么样的？"><a href="#16-HTTP响应报文的是什么样的？" class="headerlink" title="16. HTTP响应报文的是什么样的？"></a>16. HTTP响应报文的是什么样的？</h3><p>请求报⽂有4部分组成:</p><ul><li>响应⾏</li><li>响应头</li><li>空⾏</li><li>响应体</li></ul><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230610203221718.png" alt="image-20230610203221718"></p><ul><li>响应⾏：由网络协议版本，状态码和状态码的原因短语组成，例如 HTTP/1.1 200 OK 。</li><li>响应头：响应部⾸组成</li><li>响应体：服务器响应的数据</li></ul><h3 id="17-HTTP协议的优点和缺点"><a href="#17-HTTP协议的优点和缺点" class="headerlink" title="17. HTTP协议的优点和缺点"></a>17. HTTP协议的优点和缺点</h3><p>HTTP 是超文本传输协议，它定义了客户端和服务器之间交换报文的格式和方式，默认使用 80 端口。它使用 TCP 作为传输层协议，保证了数据传输的可靠性。</p><p>HTTP协议具有以下<strong>优点</strong>：</p><ul><li>支持客户端/服务器模式</li><li><strong>简单快速</strong>：客户向服务器请求服务时，只需传送请求方法和路径。由于 HTTP 协议简单，使得 HTTP 服务器的程序规模小，因而通信速度很快。</li><li><strong>无连接</strong>：无连接就是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接，采用这种方式可以节省传输时间。</li><li><strong>无状态</strong>：HTTP 协议是无状态协议，这里的状态是指通信过程的上下文信息。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能会导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就比较快。</li><li><strong>灵活</strong>：HTTP 允许传输任意类型的数据对象。正在传输的类型由 Content-Type 加以标记。</li></ul><p>HTTP协议具有以下<strong>缺点</strong>：</p><ul><li><strong>无状态：</strong> HTTP 是一个无状态的协议，HTTP 服务器不会保存关于客户的任何信息。</li><li><strong>明文传输：</strong> 协议中的报文使用的是文本形式，这就直接暴露给外界，不安全。</li><li><strong>不安全</strong></li></ul><p>（1）通信使用明文（不加密），内容可能会被窃听； （2）不验证通信方的身份，因此有可能遭遇伪装； （3）无法证明报文的完整性，所以有可能已遭篡改；</p><h3 id="18-说一下HTTP-3-0"><a href="#18-说一下HTTP-3-0" class="headerlink" title="18. 说一下HTTP 3.0"></a>18. 说一下HTTP 3.0</h3><p>HTTP/3基于UDP协议实现了类似于TCP的多路复用数据流、传输可靠性等功能，这套功能被称为QUIC协议。 </p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230610203342165.png" alt="image-20230610203342165"></p><ol><li>流量控制、传输可靠性功能：QUIC在UDP的基础上增加了一层来保证数据传输可靠性，它提供了数据包重传、拥塞控制、以及其他一些TCP中的特性。</li><li>集成TLS加密功能：目前QUIC使用TLS1.3，减少了握手所花费的RTT数。</li><li>多路复用：同一物理连接上可以有多个独立的逻辑数据流，实现了数据流的单独传输，解决了TCP的队头阻塞问题。</li></ol><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230610203435285.png" alt="image-20230610203435285"></p><ol><li>快速握手：由于基于UDP，可以实现使用0 ~ 1个RTT来建立连接。</li></ol><h3 id="19-HTTP协议的性能怎么样"><a href="#19-HTTP协议的性能怎么样" class="headerlink" title="19. HTTP协议的性能怎么样"></a>19. HTTP协议的性能怎么样</h3><p>HTTP 协议是基于 TCP/IP，并且使用了<strong>请求-应答</strong>的通信模式，所以性能的关键就在这两点里。</p><ul><li><strong>长连接</strong></li></ul><p>HTTP协议有两种连接模式，一种是持续连接，一种非持续连接。 （1）非持续连接指的是服务器必须为每一个请求的对象建立和维护一个全新的连接。 （2）持续连接下，TCP 连接默认不关闭，可以被多个请求复用。采用持续连接的好处是可以避免每次建立 TCP 连接三次握手时所花费的时间。</p><p>对于不同版本的采用不同的连接方式：</p><ul><li>在HTTP/1.0 每发起一个请求，都要新建一次 TCP 连接（三次握手），而且是串行请求，做了无畏的 TCP 连接建立和断开，增加了通信开销。该版本使用的非持续的连接，但是可以在请求时，加上 Connection: keep-a live 来要求服务器不要关闭 TCP 连接。</li><li>在HTTP/1.1 提出了<strong>长连接</strong>的通信方式，也叫持久连接。这种方式的好处在于减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。该版本及以后版本默认采用的是持续的连接。目前对于同一个域，大多数浏览器支持同时建立 6 个持久连接。</li></ul><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230610203521173.png" alt="image-20230610203521173"></p><ul><li><strong>管道网络传输</strong></li></ul><p>HTTP/1.1 采用了长连接的方式，这使得管道（pipeline）网络传输成为了可能。</p><p>管道（pipeline）网络传输是指：可以在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。但是服务器还是按照顺序回应请求。如果前面的回应特别慢，后面就会有许多请求排队等着。这称为队头堵塞。</p><ul><li><strong>队头堵塞</strong></li></ul><p>HTTP 传输的报文必须是一发一收，但是，里面的任务被放在一个任务队列中串行执行，一旦队首的请求处理太慢，就会阻塞后面请求的处理。这就是HTTP队头阻塞问题。</p><p><strong>队头阻塞的解决方案：</strong> （1）并发连接：对于一个域名允许分配多个长连接，那么相当于增加了任务队列，不至于一个队伍的任务阻塞其它所有任务。 （2）域名分片：将域名分出很多二级域名，它们都指向同样的一台服务器，能够并发的长连接数变多，解决了队头阻塞的问题。</p><h3 id="20-URL有哪些组成部分"><a href="#20-URL有哪些组成部分" class="headerlink" title="20. URL有哪些组成部分"></a>20. URL有哪些组成部分</h3><p>以下面的URL为例：**<a href="https://link.juejin.cn/?target=http://www.aspxfans.com:8080/news/index.asp?boardID=5&ID=24618&page=1%23name">www.aspxfans.com:8080/news/index.…</a>**</p><p>从上面的URL可以看出，一个完整的URL包括以下几部分：</p><ul><li><strong>协议部分</strong>：该URL的协议部分为“http：”，这代表网页使用的是HTTP协议。在Internet中可以使用多种协议，如HTTP，FTP等等本例中使用的是HTTP协议。在”HTTP”后面的“//”为分隔符；</li><li><strong>域名部分</strong>：该URL的域名部分为“<a href="https://link.juejin.cn/?target=http://www.aspxfans.com%E2%80%9D%E3%80%82%E4%B8%80%E4%B8%AAURL%E4%B8%AD%EF%BC%8C%E4%B9%9F%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8IP%E5%9C%B0%E5%9D%80%E4%BD%9C%E4%B8%BA%E5%9F%9F%E5%90%8D%E4%BD%BF%E7%94%A8">www.aspxfans.com”。一个URL中，也可以使用IP地址作为域名使用</a></li><li><strong>端口部分</strong>：跟在域名后面的是端口，域名和端口之间使用“:”作为分隔符。端口不是一个URL必须的部分，如果省略端口部分，将采用默认端口（HTTP协议默认端口是80，HTTPS协议默认端口是443）；</li><li><strong>虚拟目录部分</strong>：从域名后的第一个“/”开始到最后一个“/”为止，是虚拟目录部分。虚拟目录也不是一个URL必须的部分。本例中的虚拟目录是“/news/”；</li><li><strong>文件名部分</strong>：从域名后的最后一个“/”开始到“？”为止，是文件名部分，如果没有“?”,则是从域名后的最后一个“/”开始到“#”为止，是文件部分，如果没有“？”和“#”，那么从域名后的最后一个“/”开始到结束，都是文件名部分。本例中的文件名是“index.asp”。文件名部分也不是一个URL必须的部分，如果省略该部分，则使用默认的文件名；</li><li><strong>锚部分</strong>：从“#”开始到最后，都是锚部分。本例中的锚部分是“name”。锚部分也不是一个URL必须的部分；</li><li><strong>参数部分</strong>：从“？”开始到“#”为止之间的部分为参数部分，又称搜索部分、查询部分。本例中的参数部分为“boardID=5&amp;ID=24618&amp;page=1”。参数可以允许有多个参数，参数与参数之间用“&amp;”作为分隔符。</li></ul><h3 id="21-与缓存相关的HTTP请求头有哪些"><a href="#21-与缓存相关的HTTP请求头有哪些" class="headerlink" title="21. 与缓存相关的HTTP请求头有哪些"></a>21. 与缓存相关的HTTP请求头有哪些</h3><p>强缓存：</p><ul><li>Expires</li><li>Cache-Control</li></ul><p>协商缓存：</p><ul><li>Etag、If-None-Match</li><li>Last-Modified、If-Modified-Since</li></ul><h2 id="二、HTTPS协议"><a href="#二、HTTPS协议" class="headerlink" title="二、HTTPS协议"></a>二、HTTPS协议</h2><h3 id="1-什么是HTTPS协议？"><a href="#1-什么是HTTPS协议？" class="headerlink" title="1. 什么是HTTPS协议？"></a>1. 什么是HTTPS协议？</h3><p>超文本传输安全协议（Hypertext Transfer Protocol Secure，简称：HTTPS）是一种通过计算机网络进行安全通信的传输协议。HTTPS经由HTTP进行通信，利用SSL/TLS来加密数据包。HTTPS的主要目的是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。 <img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230610203753151.png" alt="image-20230610203753151"> HTTP协议采用<strong>明文传输</strong>信息，存在<strong>信息窃听</strong>、<strong>信息篡改</strong>和<strong>信息劫持</strong>的风险，而协议TLS/SSL具有<strong>身份验证</strong>、<strong>信息加密</strong>和<strong>完整性校验</strong>的功能，可以避免此类问题发生。</p><p>安全层的主要职责就是<strong>对发起的HTTP请求的数据进行加密操作</strong> 和 <strong>对接收到的HTTP的内容进行解密操作</strong>。</p><h3 id="2-TLS-SSL的工作原理"><a href="#2-TLS-SSL的工作原理" class="headerlink" title="2. TLS/SSL的工作原理"></a>2. TLS/SSL的工作原理</h3><p><strong>TLS/SSL</strong>全称<strong>安全传输层协议</strong>（Transport Layer Security）, 是介于TCP和HTTP之间的一层安全协议，不影响原有的TCP协议和HTTP协议，所以使用HTTPS基本上不需要对HTTP页面进行太多的改造。</p><p>TLS/SSL的功能实现主要依赖三类基本算法：<strong>散列函数hash</strong>、<strong>对称加密</strong>、<strong>非对称加密</strong>。这三类算法的作用如下：</p><ul><li>基于散列函数验证信息的完整性</li><li>对称加密算法采用协商的秘钥对数据加密</li><li>非对称加密实现身份认证和秘钥协商</li></ul><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230610203853830.png" alt="image-20230610203853830"></p><h4 id="（1）散列函数hash"><a href="#（1）散列函数hash" class="headerlink" title="（1）散列函数hash"></a>（1）散列函数hash</h4><p>常见的散列函数有MD5、SHA1、SHA256。该函数的特点是单向不可逆，对输入数据非常敏感，输出的长度固定，任何数据的修改都会改变散列函数的结果，可以用于防止信息篡改并验证数据的完整性。</p><p><strong>特点：</strong> 在信息传输过程中，散列函数不能三都实现信息防篡改，由于传输是明文传输，中间人可以修改信息后重新计算信息的摘要，所以需要对传输的信息和信息摘要进行加密。</p><h4 id="（2）对称加密"><a href="#（2）对称加密" class="headerlink" title="（2）对称加密"></a>（2）对称加密</h4><p>对称加密的方法是，双方使用同一个秘钥对数据进行加密和解密。但是对称加密的存在一个问题，就是如何保证秘钥传输的安全性，因为秘钥还是会通过网络传输的，一旦秘钥被其他人获取到，那么整个加密过程就毫无作用了。 这就要用到非对称加密的方法。</p><p>常见的对称加密算法有AES-CBC、DES、3DES、AES-GCM等。相同的秘钥可以用于信息的加密和解密。掌握秘钥才能获取信息，防止信息窃听，其通讯方式是一对一。</p><p><strong>特点：</strong> 对称加密的优势就是信息传输使用一对一，需要共享相同的密码，密码的安全是保证信息安全的基础，服务器和N个客户端通信，需要维持N个密码记录且不能修改密码。</p><h4 id="（3）非对称加密"><a href="#（3）非对称加密" class="headerlink" title="（3）非对称加密"></a>（3）非对称加密</h4><p>非对称加密的方法是，我们拥有两个秘钥，一个是公钥，一个是私钥。公钥是公开的，私钥是保密的。用私钥加密的数据，只有对应的公钥才能解密，用公钥加密的数据，只有对应的私钥才能解密。我们可以将公钥公布出去，任何想和我们通信的客户， 都可以使用我们提供的公钥对数据进行加密，这样我们就可以使用私钥进行解密，这样就能保证数据的安全了。但是非对称加密有一个缺点就是加密的过程很慢，因此如果每次通信都使用非对称加密的方式的话，反而会造成等待时间过长的问题。</p><p>常见的非对称加密算法有RSA、ECC、DH等。秘钥成对出现，一般称为公钥（公开）和私钥（保密）。公钥加密的信息只有私钥可以解开，私钥加密的信息只能公钥解开，因此掌握公钥的不同客户端之间不能相互解密信息，只能和服务器进行加密通信，服务器可以实现一对多的的通信，客户端也可以用来验证掌握私钥的服务器的身份。</p><p><strong>特点：</strong> 非对称加密的特点就是信息一对多，服务器只需要维持一个私钥就可以和多个客户端进行通信，但服务器发出的信息能够被所有的客户端解密，且该算法的计算复杂，加密的速度慢。</p><p>综合上述算法特点，TLS/SSL的工作方式就是客户端使用非对称加密与服务器进行通信，实现身份的验证并协商对称加密使用的秘钥。对称加密算法采用协商秘钥对信息以及信息摘要进行加密通信，不同节点之间采用的对称秘钥不同，从而保证信息只能通信双方获取。这样就解决了两个方法各自存在的问题。</p><h3 id="3-数字证书是什么？"><a href="#3-数字证书是什么？" class="headerlink" title="3. 数字证书是什么？"></a>3. 数字证书是什么？</h3><p>现在的方法也不一定是安全的，因为没有办法确定得到的公钥就一定是安全的公钥。可能存在一个中间人，截取了对方发给我们的公钥，然后将他自己的公钥发送给我们，当我们使用他的公钥加密后发送的信息，就可以被他用自己的私钥解密。然后他伪装成我们以同样的方法向对方发送信息，这样我们的信息就被窃取了，然而自己还不知道。为了解决这样的问题，可以使用数字证书。</p><p>首先使用一种 Hash 算法来对公钥和其他信息进行加密，生成一个信息摘要，然后让有公信力的认证中心（简称 CA ）用它的私钥对消息摘要加密，形成签名。最后将原始的信息和签名合在一起，称为数字证书。当接收方收到数字证书的时候，先根据原始信息使用同样的 Hash 算法生成一个摘要，然后使用公证处的公钥来对数字证书中的摘要进行解密，最后将解密的摘要和生成的摘要进行对比，就能发现得到的信息是否被更改了。</p><p>这个方法最要的是认证中心的可靠性，一般浏览器里会内置一些顶层的认证中心的证书，相当于我们自动信任了他们，只有这样才能保证数据的安全。 <img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230610203939423.png" alt="image-20230610203939423"></p><h3 id="4-HTTPS通信（握手）过程"><a href="#4-HTTPS通信（握手）过程" class="headerlink" title="4. HTTPS通信（握手）过程"></a>4. HTTPS通信（握手）过程</h3><p>HTTPS的通信过程如下：</p><ol><li>客户端向服务器发起请求，请求中包含使用的协议版本号、生成的一个随机数、以及客户端支持的加密方法。</li><li>服务器端接收到请求后，确认双方使用的加密方法、并给出服务器的证书、以及一个服务器生成的随机数。</li><li>客户端确认服务器证书有效后，生成一个新的随机数，并使用数字证书中的公钥，加密这个随机数，然后发给服 务器。并且还会提供一个前面所有内容的 hash 的值，用来供服务器检验。</li><li>服务器使用自己的私钥，来解密客户端发送过来的随机数。并提供前面所有内容的 hash 值来供客户端检验。</li><li>客户端和服务器端根据约定的加密方法使用前面的三个随机数，生成对话秘钥，以后的对话过程都使用这个秘钥来加密信息。</li></ol><h3 id="5-HTTPS的特点"><a href="#5-HTTPS的特点" class="headerlink" title="5. HTTPS的特点"></a>5. HTTPS的特点</h3><p>HTTPS的<strong>优点</strong>如下：</p><ul><li>使用HTTPS协议可以认证用户和服务器，确保数据发送到正确的客户端和服务器；</li><li>使用HTTPS协议可以进行加密传输、身份认证，通信更加安全，防止数据在传输过程中被窃取、修改，确保数据安全性；</li><li>HTTPS是现行架构下最安全的解决方案，虽然不是绝对的安全，但是大幅增加了中间人攻击的成本；</li></ul><p>HTTPS的<strong>缺点</strong>如下：</p><ul><li>HTTPS需要做服务器和客户端双方的加密个解密处理，耗费更多服务器资源，过程复杂；</li><li>HTTPS协议握手阶段比较费时，增加页面的加载时间；</li><li>SSL证书是收费的，功能越强大的证书费用越高；</li><li>HTTPS连接服务器端资源占用高很多，支持访客稍多的网站需要投入更大的成本；</li><li>SSL证书需要绑定IP，不能再同一个IP上绑定多个域名。</li></ul><h3 id="6-HTTPS是如何保证安全的？"><a href="#6-HTTPS是如何保证安全的？" class="headerlink" title="6. HTTPS是如何保证安全的？"></a>6. <strong>HTTPS</strong>是如何保证安全的？</h3><p>先理解两个概念：</p><ul><li>对称加密：即通信的双⽅都使⽤同⼀个秘钥进⾏加解密，对称加密虽然很简单性能也好，但是⽆法解决⾸次把秘钥发给对⽅的问题，很容易被⿊客拦截秘钥。</li><li>⾮对称加密：</li></ul><ol><li>私钥 + 公钥= 密钥对</li><li>即⽤私钥加密的数据,只有对应的公钥才能解密,⽤公钥加密的数据,只有对应的私钥才能解密</li><li>因为通信双⽅的⼿⾥都有⼀套⾃⼰的密钥对,通信之前双⽅会先把⾃⼰的公钥都先发给对⽅</li><li>然后对⽅再拿着这个公钥来加密数据响应给对⽅,等到到了对⽅那⾥,对⽅再⽤⾃⼰的私钥进⾏解密</li></ol><p>⾮对称加密虽然安全性更⾼，但是带来的问题就是速度很慢，影响性能。</p><p><strong>解决⽅案：</strong></p><p>结合两种加密⽅式，将对称加密的密钥使⽤⾮对称加密的公钥进⾏加密，然后发送出去，接收⽅使⽤私钥进⾏解密得到对称加密的密钥，然后双⽅可以使⽤对称加密来进⾏沟通。</p><p>此时⼜带来⼀个问题，中间⼈问题： 如果此时在客户端和服务器之间存在⼀个中间⼈,这个中间⼈只需要把原本双⽅通信互发的公钥,换成⾃⼰的公钥,这样中间⼈就可以轻松解密通信双⽅所发送的所有数据。</p><p>所以这个时候需要⼀个安全的第三⽅颁发证书（CA），证明身份的身份，防⽌被中间⼈攻击。 证书中包括：签发者、证书⽤途、使⽤者公钥、使⽤者私钥、使⽤者的HASH算法、证书到期时间等。</p><p>但是问题来了，如果中间⼈篡改了证书，那么身份证明是不是就⽆效了？这个证明就⽩买了，这个时候需要⼀个新的技术，数字签名。</p><p>数字签名就是⽤CA⾃带的HASH算法对证书的内容进⾏HASH得到⼀个摘要，再⽤CA的私钥加密，最终组成数字签名。当别⼈把他的证书发过来的时候,我再⽤同样的Hash算法,再次⽣成消息摘要，然后⽤CA的公钥对数字签名解密,得到CA创建的消息摘要,两者⼀⽐,就知道中间有没有被⼈篡改了。这个时候就能最⼤程度保证通信的安全了。</p><h2 id="三、HTTP状态码"><a href="#三、HTTP状态码" class="headerlink" title="三、HTTP状态码"></a>三、HTTP状态码</h2><p>状态码的类别：</p><table><thead><tr><th><strong>类别</strong></th><th><strong>原因</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>1xx</td><td>Informational(信息性状态码)</td><td>接受的请求正在处理</td></tr><tr><td>2xx</td><td>Success(成功状态码)</td><td>请求正常处理完毕</td></tr><tr><td>3xx</td><td>Redirection(重定向状态码)</td><td>需要进行附加操作一完成请求</td></tr><tr><td>4xx</td><td>Client Error (客户端错误状态码)</td><td>服务器无法处理请求</td></tr><tr><td>5xx</td><td>Server Error(服务器错误状态码)</td><td>服务器处理请求出错</td></tr></tbody></table><h3 id="1-2XX-Success-成功状态码"><a href="#1-2XX-Success-成功状态码" class="headerlink" title="1. 2XX (Success 成功状态码)"></a>1. 2XX (Success 成功状态码)</h3><p>状态码2XX表示请求被正常处理了。</p><h4 id="（1）200-OK"><a href="#（1）200-OK" class="headerlink" title="（1）200 OK"></a>（1）200 OK</h4><p>200 OK表示客户端发来的请求被服务器端正常处理了。</p><h4 id="（2）204-No-Content"><a href="#（2）204-No-Content" class="headerlink" title="（2）204 No Content"></a>（2）204 No Content</h4><p>该状态码表示客户端发送的请求已经在服务器端正常处理了，但是没有返回的内容，响应报文中不包含实体的主体部分。一般在只需要从客户端往服务器端发送信息，而服务器端不需要往客户端发送内容时使用。</p><h4 id="（3）206-Partial-Content"><a href="#（3）206-Partial-Content" class="headerlink" title="（3）206 Partial Content"></a>（3）206 Partial Content</h4><p>该状态码表示客户端进行了范围请求，而服务器端执行了这部分的 GET 请求。响应报文中包含由 Content-Range 指定范围的实体内容。</p><h3 id="2-3XX-Redirection-重定向状态码"><a href="#2-3XX-Redirection-重定向状态码" class="headerlink" title="2. 3XX (Redirection 重定向状态码)"></a>2. 3XX (Redirection 重定向状态码)</h3><p>3XX 响应结果表明浏览器需要执行某些特殊的处理以正确处理请求。</p><h4 id="（1）301-Moved-Permanently"><a href="#（1）301-Moved-Permanently" class="headerlink" title="（1）301 Moved Permanently"></a>（1）301 Moved Permanently</h4><p><strong>永久重定向。</strong> 该状态码表示请求的资源已经被分配了新的 URI，以后应使用资源指定的 URI。新的 URI 会在 HTTP 响应头中的 Location 首部字段指定。若用户已经把原来的URI保存为书签，此时会按照 Location 中新的URI重新保存该书签。同时，搜索引擎在抓取新内容的同时也将旧的网址替换为重定向之后的网址。</p><p><strong>使用场景：</strong></p><ul><li>当我们想换个域名，旧的域名不再使用时，用户访问旧域名时用301就重定向到新的域名。其实也是告诉搜索引擎收录的域名需要对新的域名进行收录。</li><li>在搜索引擎的搜索结果中出现了不带www的域名，而带www的域名却没有收录，这个时候可以用301重定向来告诉搜索引擎我们目标的域名是哪一个。</li></ul><h4 id="（2）302-Found"><a href="#（2）302-Found" class="headerlink" title="（2）302 Found"></a>（2）302 Found</h4><p><strong>临时重定向。</strong> 该状态码表示请求的资源被分配到了新的 URI，希望用户（本次）能使用新的 URI 访问资源。和 301 Moved Permanently 状态码相似，但是 302 代表的资源不是被永久重定向，只是临时性质的。也就是说已移动的资源对应的 URI 将来还有可能发生改变。若用户把 URI 保存成书签，但不会像 301 状态码出现时那样去更新书签，而是仍旧保留返回 302 状态码的页面对应的 URI。同时，搜索引擎会抓取新的内容而保留旧的网址。因为服务器返回302代码，搜索引擎认为新的网址只是暂时的。</p><p><strong>使用场景：</strong></p><ul><li>当我们在做活动时，登录到首页自动重定向，进入活动页面。</li><li>未登陆的用户访问用户中心重定向到登录页面。</li><li>访问404页面重新定向到首页。</li></ul><h4 id="（3）303-See-Other"><a href="#（3）303-See-Other" class="headerlink" title="（3）303 See Other"></a>（3）303 See Other</h4><p>该状态码表示由于请求对应的资源存在着另一个 URI，应使用 GET 方法定向获取请求的资源。 303 状态码和 302 Found 状态码有着相似的功能，但是 303 状态码明确表示客户端应当采用 GET 方法获取资源。</p><p>303 状态码通常作为 PUT 或 POST 操作的返回结果，它表示重定向链接指向的不是新上传的资源，而是另外一个页面，比如消息确认页面或上传进度页面。而请求重定向页面的方法要总是使用 GET。</p><p>注意：</p><ul><li>当 301、302、303 响应状态码返回时，几乎所有的浏览器都会把 POST 改成GET，并删除请求报文内的主体，之后请求会再次自动发送。</li><li>301、302 标准是禁止将 POST 方法变成 GET方法的，但实际大家都会这么做。</li></ul><h4 id="（4）304-Not-Modified"><a href="#（4）304-Not-Modified" class="headerlink" title="（4）304 Not Modified"></a>（4）304 Not Modified</h4><p><strong>浏览器缓存相关。</strong> 该状态码表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但未满足条件的情况。304 状态码返回时，不包含任何响应的主体部分。304 虽然被划分在 3XX 类别中，但是和重定向没有关系。</p><p>带条件的请求（Http 条件请求）：使用 Get方法 请求，请求报文中包含（<code>if-match</code>、<code>if-none-match</code>、<code>if-modified-since</code>、<code>if-unmodified-since</code>、<code>if-range</code>）中任意首部。</p><p>状态码304并不是一种错误，而是告诉客户端有缓存，直接使用缓存中的数据。返回页面的只有头部信息，是没有内容部分的，这样在一定程度上提高了网页的性能。</p><h4 id="（5）307-Temporary-Redirect"><a href="#（5）307-Temporary-Redirect" class="headerlink" title="（5）307 Temporary Redirect"></a>（5）307 Temporary Redirect</h4><p><strong>307表示临时重定向。</strong> 该状态码与 302 Found 有着相同含义，尽管 302 标准禁止 POST 变成 GET，但是实际使用时还是这样做了。</p><p>307 会遵守浏览器标准，<strong>不会从 POST 变成 GET</strong>。但是对于处理请求的行为时，不同浏览器还是会出现不同的情况。规范要求浏览器继续向 Location 的地址 POST 内容。规范要求浏览器继续向 Location 的地址 POST 内容。</p><h3 id="3-4XX-Client-Error-客户端错误状态码"><a href="#3-4XX-Client-Error-客户端错误状态码" class="headerlink" title="3. 4XX (Client Error 客户端错误状态码)"></a>3. 4XX (Client Error 客户端错误状态码)</h3><p>4XX 的响应结果表明客户端是发生错误的原因所在。</p><h4 id="（1）400-Bad-Request"><a href="#（1）400-Bad-Request" class="headerlink" title="（1）400 Bad Request"></a>（1）400 Bad Request</h4><p>该状态码表示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。另外，浏览器会像 200 OK 一样对待该状态码。</p><h4 id="（2）401-Unauthorized"><a href="#（2）401-Unauthorized" class="headerlink" title="（2）401 Unauthorized"></a>（2）401 Unauthorized</h4><p>该状态码表示发送的请求需要有通过 HTTP 认证(BASIC 认证、DIGEST 认证)的认证信息。若之前已进行过一次请求，则表示用户认证失败</p><p>返回含有 401 的响应必须包含一个适用于被请求资源的 WWW-Authenticate 首部用以质询(challenge)用户信息。当浏览器初次接收到 401 响应，会弹出认证用的对话窗口。</p><p>以下情况会出现401：</p><ul><li>401.1 - 登录失败。</li><li>401.2 - 服务器配置导致登录失败。</li><li>401.3 - 由于 ACL 对资源的限制而未获得授权。</li><li>401.4 - 筛选器授权失败。</li><li>401.5 - ISAPI/CGI 应用程序授权失败。</li><li>401.7 - 访问被 Web 服务器上的 URL 授权策略拒绝。这个错误代码为 IIS 6.0 所专用。</li></ul><h4 id="（3）403-Forbidden"><a href="#（3）403-Forbidden" class="headerlink" title="（3）403 Forbidden"></a>（3）403 Forbidden</h4><p>该状态码表明请求资源的访问被服务器拒绝了，服务器端没有必要给出详细理由，但是可以在响应报文实体的主体中进行说明。进入该状态后，不能再继续进行验证。该访问是永久禁止的，并且与应用逻辑密切相关。</p><p>IIS 定义了许多不同的 403 错误，它们指明更为具体的错误原因：</p><ul><li>403.1 - 执行访问被禁止。</li><li>403.2 - 读访问被禁止。</li><li>403.3 - 写访问被禁止。</li><li>403.4 - 要求 SSL。</li><li>403.5 - 要求 SSL 128。</li><li>403.6 - IP 地址被拒绝。</li><li>403.7 - 要求客户端证书。</li><li>403.8 - 站点访问被拒绝。</li><li>403.9 - 用户数过多。</li><li>403.10 - 配置无效。</li><li>403.11 - 密码更改。</li><li>403.12 - 拒绝访问映射表。</li><li>403.13 - 客户端证书被吊销。</li><li>403.14 - 拒绝目录列表。</li><li>403.15 - 超出客户端访问许可。</li><li>403.16 - 客户端证书不受信任或无效。</li><li>403.17 - 客户端证书已过期或尚未生效</li><li>403.18 - 在当前的应用程序池中不能执行所请求的 URL。这个错误代码为 IIS 6.0 所专用。</li><li>403.19 - 不能为这个应用程序池中的客户端执行 CGI。这个错误代码为 IIS 6.0 所专用。</li><li>403.20 - Passport 登录失败。这个错误代码为 IIS 6.0 所专用。</li></ul><h4 id="（4）404-Not-Found"><a href="#（4）404-Not-Found" class="headerlink" title="（4）404 Not Found"></a>（4）404 Not Found</h4><p>该状态码表明服务器上无法找到请求的资源。除此之外，也可以在服务器端拒绝请求且不想说明理由时使用。 以下情况会出现404：</p><ul><li>404.0 -（无） – 没有找到文件或目录。</li><li>404.1 - 无法在所请求的端口上访问 Web 站点。</li><li>404.2 - Web 服务扩展锁定策略阻止本请求。</li><li>404.3 - MIME 映射策略阻止本请求。</li></ul><h4 id="（5）405-Method-Not-Allowed"><a href="#（5）405-Method-Not-Allowed" class="headerlink" title="（5）405 Method Not Allowed"></a>（5）405 Method Not Allowed</h4><p>该状态码表示客户端请求的方法虽然能被服务器识别，但是服务器禁止使用该方法。GET 和 HEAD 方法，服务器应该总是允许客户端进行访问。客户端可以通过 OPTIONS 方法（预检）来查看服务器允许的访问方法, 如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Allow</span>-<span class="title class_">Methods</span>: <span class="variable constant_">GET</span>,<span class="variable constant_">HEAD</span>,<span class="variable constant_">PUT</span>,<span class="variable constant_">PATCH</span>,<span class="variable constant_">POST</span>,<span class="variable constant_">DELETE</span></span><br></pre></td></tr></table></figure><h3 id="4-5XX-Server-Error-服务器错误状态码"><a href="#4-5XX-Server-Error-服务器错误状态码" class="headerlink" title="4. 5XX (Server Error 服务器错误状态码)"></a>4. 5XX (Server Error 服务器错误状态码)</h3><p>5XX 的响应结果表明服务器本身发生错误.</p><h4 id="（1）500-Internal-Server-Error"><a href="#（1）500-Internal-Server-Error" class="headerlink" title="（1）500 Internal Server Error"></a>（1）500 Internal Server Error</h4><p>该状态码表明服务器端在执行请求时发生了错误。也有可能是 Web 应用存在的 bug 或某些临时的故障。</p><h4 id="（2）502-Bad-Gateway"><a href="#（2）502-Bad-Gateway" class="headerlink" title="（2）502 Bad Gateway"></a>（2）502 Bad Gateway</h4><p>该状态码表明扮演网关或代理角色的服务器，从上游服务器中接收到的响应是无效的。注意，502 错误通常不是客户端能够修复的，而是需要由途经的 Web 服务器或者代理服务器对其进行修复。以下情况会出现502：</p><ul><li>502.1 - CGI （通用网关接口）应用程序超时。</li><li>502.2 - CGI （通用网关接口）应用程序出错。</li></ul><h4 id="（3）503-Service-Unavailable"><a href="#（3）503-Service-Unavailable" class="headerlink" title="（3）503 Service Unavailable"></a>（3）503 Service Unavailable</h4><p>该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。如果事先得知解除以上状况需要的时间，最好写入 RetryAfter 首部字段再返回给客户端。</p><p><strong>使用场景：</strong></p><ul><li>服务器停机维护时，主动用503响应请求；</li><li>nginx 设置限速，超过限速，会返回503。</li></ul><h4 id="（4）504-Gateway-Timeout"><a href="#（4）504-Gateway-Timeout" class="headerlink" title="（4）504 Gateway Timeout"></a>（4）504 Gateway Timeout</h4><p>该状态码表示网关或者代理的服务器无法在规定的时间内获得想要的响应。他是HTTP 1.1中新加入的。</p><p>使用场景：代码执行时间超时，或者发生了死循环。</p><h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h3><p><strong>（1）2XX 成功</strong></p><ul><li>200 OK，表示从客户端发来的请求在服务器端被正确处理</li><li>204 No content，表示请求成功，但响应报文不含实体的主体部分</li><li>205 Reset Content，表示请求成功，但响应报文不含实体的主体部分，但是与 204 响应不同在于要求请求方重置内容</li><li>206 Partial Content，进行范围请求</li></ul><p><strong>（2）3XX 重定向</strong></p><ul><li>301 moved permanently，永久性重定向，表示资源已被分配了新的 URL</li><li>302 found，临时性重定向，表示资源临时被分配了新的 URL</li><li>303 see other，表示资源存在着另一个 URL，应使用 GET 方法获取资源</li><li>304 not modified，表示服务器允许访问资源，但因发生请求未满足条件的情况</li><li>307 temporary redirect，临时重定向，和302含义类似，但是期望客户端保持请求方法不变向新的地址发出请求</li></ul><p><strong>（3）4XX 客户端错误</strong></p><ul><li>400 bad request，请求报文存在语法错误</li><li>401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息</li><li>403 forbidden，表示对请求资源的访问被服务器拒绝</li><li>404 not found，表示在服务器上没有找到请求的资源</li></ul><p><strong>（4）5XX 服务器错误</strong></p><ul><li>500 internal sever error，表示服务器端在执行请求时发生了错误</li><li>501 Not Implemented，表示服务器不支持当前请求所需要的某个功能</li><li>503 service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求</li></ul><h3 id="6-同样是重定向，307，303，302的区别？"><a href="#6-同样是重定向，307，303，302的区别？" class="headerlink" title="6. 同样是重定向，307，303，302的区别？"></a>6. 同样是重定向，<strong>307</strong>，<strong>303</strong>，<strong>302</strong>的区别？</h3><p>302是http1.0的协议状态码，在http1.1版本的时候为了细化302状态码⼜出来了两个303和307。 303明确表示客户端应当采⽤get⽅法获取资源，他会把POST请求变为GET请求进⾏重定向。 307会遵照浏览器标准，不会从post变为get。</p><h2 id="四、DNS协议介绍"><a href="#四、DNS协议介绍" class="headerlink" title="四、DNS协议介绍"></a>四、DNS协议介绍</h2><h3 id="1-DNS-协议是什么"><a href="#1-DNS-协议是什么" class="headerlink" title="1. DNS 协议是什么"></a>1. DNS 协议是什么</h3><p><strong>概念</strong>： DNS 是域名系统 (Domain Name System) 的缩写，提供的是一种主机名到 IP 地址的转换服务，就是我们常说的域名系统。它是一个由分层的 DNS 服务器组成的分布式数据库，是定义了主机如何查询这个分布式数据库的方式的应用层协议。能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。</p><p><strong>作用</strong>： 将域名解析为IP地址，客户端向DNS服务器（DNS服务器有自己的IP地址）发送域名查询请求，DNS服务器告知客户机Web服务器的 IP 地址。</p><h3 id="2-DNS同时使用TCP和UDP协议？"><a href="#2-DNS同时使用TCP和UDP协议？" class="headerlink" title="2. DNS同时使用TCP和UDP协议？"></a>2. DNS同时使用TCP和UDP协议？</h3><p><strong>DNS占用53号端口，同时使用TCP和UDP协议。</strong> （1）在区域传输的时候使用TCP协议</p><ul><li>辅域名服务器会定时（一般3小时）向主域名服务器进行查询以便了解数据是否有变动。如有变动，会执行一次区域传送，进行数据同步。区域传送使用TCP而不是UDP，因为数据同步传送的数据量比一个请求应答的数据量要多得多。</li><li>TCP是一种可靠连接，保证了数据的准确性。</li></ul><p>（2）在域名解析的时候使用UDP协议</p><ul><li>客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP传输即可。不用经过三次握手，这样DNS服务器负载更低，响应更快。理论上说，客户端也可以指定向DNS服务器查询时用TCP，但事实上，很多DNS服务器进行配置的时候，仅支持UDP查询包。</li></ul><h3 id="3-DNS完整的查询过程"><a href="#3-DNS完整的查询过程" class="headerlink" title="3. DNS完整的查询过程"></a>3. DNS完整的查询过程</h3><p>DNS服务器解析域名的过程：</p><ul><li>首先会在<strong>浏览器的缓存</strong>中查找对应的IP地址，如果查找到直接返回，若找不到继续下一步</li><li>将请求发送给<strong>本地DNS服务器</strong>，在本地域名服务器缓存中查询，如果查找到，就直接将查找结果返回，若找不到继续下一步</li><li>本地DNS服务器向<strong>根域名服务器</strong>发送请求，根域名服务器会返回一个所查询域的顶级域名服务器地址</li><li>本地DNS服务器向<strong>顶级域名服务器</strong>发送请求，接受请求的服务器查询自己的缓存，如果有记录，就返回查询结果，如果没有就返回相关的下一级的权威域名服务器的地址</li><li>本地DNS服务器向<strong>权威域名服务器</strong>发送请求，域名服务器返回对应的结果</li><li>本地DNS服务器将返回结果保存在缓存中，便于下次使用</li><li>本地DNS服务器将返回结果返回给浏览器</li></ul><p>比如要查询 <a href="https://link.juejin.cn/?target=http://www.baidu.com/">www.baidu.com</a> 的 IP 地址，首先会在浏览器的缓存中查找是否有该域名的缓存，如果不存在就将请求发送到本地的 DNS 服务器中，本地DNS服务器会判断是否存在该域名的缓存，如果不存在，则向根域名服务器发送一个请求，根域名服务器返回负责 .com 的顶级域名服务器的 IP 地址的列表。然后本地 DNS 服务器再向其中一个负责 .com 的顶级域名服务器发送一个请求，负责 .com 的顶级域名服务器返回负责 .baidu 的权威域名服务器的 IP 地址列表。然后本地 DNS 服务器再向其中一个权威域名服务器发送一个请求，最后权威域名服务器返回一个对应的主机名的 IP 地址列表。</p><h3 id="4-迭代查询与递归查询"><a href="#4-迭代查询与递归查询" class="headerlink" title="4. 迭代查询与递归查询"></a>4. 迭代查询与递归查询</h3><p>实际上，DNS解析是一个包含迭代查询和递归查询的过程。</p><ul><li><strong>递归查询</strong>指的是查询请求发出后，域名服务器代为向下一级域名服务器发出请求，最后向用户返回查询的最终结果。使用递归 查询，用户只需要发出一次查询请求。</li><li><strong>迭代查询</strong>指的是查询请求后，域名服务器返回单次查询的结果。下一级的查询由用户自己请求。使用迭代查询，用户需要发出 多次的查询请求。</li></ul><p>一般我们向本地 DNS 服务器发送请求的方式就是递归查询，因为我们只需要发出一次请求，然后本地 DNS 服务器返回给我 们最终的请求结果。而本地 DNS 服务器向其他域名服务器请求的过程是迭代查询的过程，因为每一次域名服务器只返回单次 查询的结果，下一级的查询由本地 DNS 服务器自己进行。</p><h3 id="5-DNS-记录和报文"><a href="#5-DNS-记录和报文" class="headerlink" title="5. DNS 记录和报文"></a>5. DNS 记录和报文</h3><p>DNS 服务器中以资源记录的形式存储信息，每一个 DNS 响应报文一般包含多条资源记录。一条资源记录的具体的格式为</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">（Name，Value，Type，TTL）</span><br></pre></td></tr></table></figure><p>其中 TTL 是资源记录的生存时间，它定义了资源记录能够被其他的 DNS 服务器缓存多长时间。</p><p>常用的一共有四种 Type 的值，分别是 A、NS、CNAME 和 MX ，不同 Type 的值，对应资源记录代表的意义不同：</p><ul><li>如果 Type = A，则 Name 是主机名，Value 是主机名对应的 IP 地址。因此一条记录为 A 的资源记录，提供了标 准的主机名到 IP 地址的映射。</li><li>如果 Type = NS，则 Name 是个域名，Value 是负责该域名的 DNS 服务器的主机名。这个记录主要用于 DNS 链式 查询时，返回下一级需要查询的 DNS 服务器的信息。</li><li>如果 Type = CNAME，则 Name 为别名，Value 为该主机的规范主机名。该条记录用于向查询的主机返回一个主机名 对应的规范主机名，从而告诉查询主机去查询这个主机名的 IP 地址。主机别名主要是为了通过给一些复杂的主机名提供 一个便于记忆的简单的别名。</li><li>如果 Type = MX，则 Name 为一个邮件服务器的别名，Value 为邮件服务器的规范主机名。它的作用和 CNAME 是一 样的，都是为了解决规范主机名不利于记忆的缺点。</li></ul><h2 id="五、网络模型"><a href="#五、网络模型" class="headerlink" title="五、网络模型"></a>五、网络模型</h2><h3 id="1-OSI七层模型"><a href="#1-OSI七层模型" class="headerlink" title="1. OSI七层模型"></a>1. OSI七层模型</h3><p><code>ISO</code>为了更好的使网络应用更为普及，推出了<code>OSI</code>参考模型。 <img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230610233453602.png" alt="image-20230610233453602"></p><h4 id="（1）应用层"><a href="#（1）应用层" class="headerlink" title="（1）应用层"></a>（1）应用层</h4><p><code>OSI</code>参考模型中最靠近用户的一层，是为计算机用户提供应用接口，也为用户直接提供各种网络服务。我们常见应用层的网络服务协议有：<code>HTTP</code>，<code>HTTPS</code>，<code>FTP</code>，<code>POP3</code>、<code>SMTP</code>等。</p><ul><li>在客户端与服务器中经常会有数据的请求，这个时候就是会用到<code>http(hyper text transfer protocol)(超文本传输协议)</code>或者<code>https</code>.在后端设计数据接口时，我们常常使用到这个协议。</li><li><code>FTP</code>是文件传输协议，在开发过程中，个人并没有涉及到，但是我想，在一些资源网站，比如<code>百度网盘``迅雷</code>应该是基于此协议的。</li><li><code>SMTP</code>是<code>simple mail transfer protocol（简单邮件传输协议）</code>。在一个项目中，在用户邮箱验证码登录的功能时，使用到了这个协议。</li></ul><h4 id="（2）表示层"><a href="#（2）表示层" class="headerlink" title="（2）表示层"></a>（2）表示层</h4><p>表示层提供各种用于应用层数据的编码和转换功能,确保一个系统的应用层发送的数据能被另一个系统的应用层识别。如果必要，该层可提供一种标准表示形式，用于将计算机内部的多种数据格式转换成通信中采用的标准表示形式。数据压缩和加密也是表示层可提供的转换功能之一。</p><p>在项目开发中，为了方便数据传输，可以使用<code>base64</code>对数据进行编解码。如果按功能来划分，<code>base64</code>应该是工作在表示层。</p><h4 id="（3）会话层"><a href="#（3）会话层" class="headerlink" title="（3）会话层"></a>（3）会话层</h4><p>会话层就是负责建立、管理和终止表示层实体之间的通信会话。该层的通信由不同设备中的应用程序之间的服务请求和响应组成。</p><h4 id="（4）传输层"><a href="#（4）传输层" class="headerlink" title="（4）传输层"></a>（4）传输层</h4><p>传输层建立了主机端到端的链接，传输层的作用是为上层协议提供端到端的可靠和透明的数据传输服务，包括处理差错控制和流量控制等问题。该层向高层屏蔽了下层数据通信的细节，使高层用户看到的只是在两个传输实体间的一条主机到主机的、可由用户控制和设定的、可靠的数据通路。我们通常说的，<code>TCP</code> <code>UDP</code>就是在这一层。端口号既是这里的“端”。</p><h4 id="（5）网络层"><a href="#（5）网络层" class="headerlink" title="（5）网络层"></a>（5）网络层</h4><p>本层通过<code>IP</code>寻址来建立两个节点之间的连接，为源端的运输层送来的分组，选择合适的路由和交换节点，正确无误地按照地址传送给目的端的运输层。就是通常说的<code>IP</code>层。这一层就是我们经常说的<code>IP</code>协议层。<code>IP</code>协议是<code>Internet</code>的基础。我们可以这样理解，网络层规定了数据包的传输路线，而传输层则规定了数据包的传输方式。</p><h4 id="（6）数据链路层"><a href="#（6）数据链路层" class="headerlink" title="（6）数据链路层"></a>（6）数据链路层</h4><p>将比特组合成字节,再将字节组合成帧,使用链路层地址 (以太网使用MAC地址)来访问介质,并进行差错检测。 网络层与数据链路层的对比，通过上面的描述，我们或许可以这样理解，网络层是规划了数据包的传输路线，而数据链路层就是传输路线。不过，在数据链路层上还增加了差错控制的功能。</p><h4 id="（7）物理层"><a href="#（7）物理层" class="headerlink" title="（7）物理层"></a>（7）物理层</h4><p>实际最终信号的传输是通过物理层实现的。通过物理介质传输比特流。规定了电平、速度和电缆针脚。常用设备有（各种物理设备）集线器、中继器、调制解调器、网线、双绞线、同轴电缆。这些都是物理层的传输介质。</p><p><strong>OSI七层模型通信特点：对等通信</strong> 对等通信，为了使数据分组从源传送到目的地，源端OSI模型的每一层都必须与目的端的对等层进行通信，这种通信方式称为对等层通信。在每一层通信过程中，使用本层自己协议进行通信。</p><h3 id="2-TCP-IP五层协议"><a href="#2-TCP-IP五层协议" class="headerlink" title="2. TCP/IP五层协议"></a>2. TCP/IP五层协议</h3><p><code>TCP/IP</code>五层协议和<code>OSI</code>的七层协议对应关系如下： <img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230610233647579.png" alt="image-20230610233647579"></p><ul><li><p>**应用层 (application layer)**：直接为应用进程提供服务。应用层协议定义的是应用进程间通讯和交互的规则，不同的应用有着不同的应用层协议，如 HTTP协议（万维网服务）、FTP协议（文件传输）、SMTP协议（电子邮件）、DNS（域名查询）等。</p></li><li><p>传输层 (transport layer)</p><p>：有时也译为运输层，它负责为两台主机中的进程提供通信服务。该层主要有以下两种协议：</p><ul><li>传输控制协议 (Transmission Control Protocol，TCP)：提供面向连接的、可靠的数据传输服务，数据传输的基本单位是报文段（segment）；</li><li>用户数据报协议 (User Datagram Protocol，UDP)：提供无连接的、尽最大努力的数据传输服务，但不保证数据传输的可靠性，数据传输的基本单位是用户数据报。</li></ul></li><li><p>**网络层 (internet layer)**：有时也译为网际层，它负责为两台主机提供通信服务，并通过选择合适的路由将数据传递到目标主机。</p></li><li><p>**数据链路层 (data link layer)**：负责将网络层交下来的 IP 数据报封装成帧，并在链路的两个相邻节点间传送帧，每一帧都包含数据和必要的控制信息（如同步信息、地址信息、差错控制等）。</p></li><li><p>**物理层 (physical Layer)**：确保数据可以在各种物理媒介上进行传输，为数据的传输提供可靠的环境。</p></li></ul><p>从上图中可以看出，<code>TCP/IP</code>模型比<code>OSI</code>模型更加简洁，它把<code>应用层/表示层/会话层</code>全部整合为了<code>应用层</code>。</p><p>在每一层都工作着不同的设备，比如我们常用的交换机就工作在数据链路层的，一般的路由器是工作在网络层的。 <img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230610233716081.png" alt="image-20230610233716081"> 在每一层实现的协议也各不同，即每一层的服务也不同，下图列出了每层主要的传输协议： <img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230610233741700.png" alt="image-20230610233741700"></p><p>同样，<code>TCP/IP</code>五层协议的通信方式也是对等通信：<img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230610233754676.png" alt="image-20230610233754676"></p><h2 id="六、TCP与UDP"><a href="#六、TCP与UDP" class="headerlink" title="六、TCP与UDP"></a>六、TCP与UDP</h2><h3 id="1-TCP-和-UDP的概念及特点"><a href="#1-TCP-和-UDP的概念及特点" class="headerlink" title="1. TCP 和 UDP的概念及特点"></a>1. TCP 和 UDP的概念及特点</h3><p>TCP 和 UDP都是传输层协议，他们都属于TCP/IP协议族：</p><p><strong>（1）UDP</strong></p><p>UDP的全称是<strong>用户数据报协议</strong>，在网络中它与TCP协议一样用于处理数据包，是一种无连接的协议。在OSI模型中，在传输层，处于IP协议的上一层。UDP有不提供数据包分组、组装和不能对数据包进行排序的缺点，也就是说，当报文发送之后，是无法得知其是否安全完整到达的。</p><p>它的特点如下：</p><p><strong>1）面向无连接</strong></p><p>首先 UDP 是不需要和 TCP一样在发送数据前进行三次握手建立连接的，想发数据就可以开始发送了。并且也只是数据报文的搬运工，不会对数据报文进行任何拆分和拼接操作。</p><p>具体来说就是：</p><ul><li>在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层了</li><li>在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作</li></ul><p><strong>2）有单播，多播，广播的功能</strong></p><p>UDP 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说 UDP 提供了单播，多播，广播的功能。</p><p><strong>3）面向报文</strong></p><p>发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付IP层。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。因此，应用程序必须选择合适大小的报文</p><p><strong>4）不可靠性</strong></p><p>首先不可靠性体现在无连接上，通信都不需要建立连接，想发就发，这样的情况肯定不可靠。</p><p>并且收到什么数据就传递什么数据，并且也不会备份数据，发送数据也不会关心对方是否已经正确接收到数据了。</p><p>再者网络环境时好时坏，但是 UDP 因为没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景（比如电话会议）就需要使用 UDP 而不是 TCP。</p><p><strong>5）头部开销小，传输数据报文时是很高效的。</strong> <img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230610233920354.png" alt="image-20230610233920354"></p><p>UDP 头部包含了以下几个数据：</p><ul><li>两个十六位的端口号，分别为源端口（可选字段）和目标端口</li><li>整个数据报文的长度</li><li>整个数据报文的检验和（IPv4 可选字段），该字段用于发现头部信息和数据中的错误</li></ul><p>因此 UDP 的头部开销小，只有8字节，相比 TCP 的至少20字节要少得多，在传输数据报文时是很高效的。</p><p><strong>（2）TCP</strong> TCP的全称是传输控制协议是一种面向连接的、可靠的、基于字节流的传输层通信协议。TCP 是面向连接的、可靠的流协议（流就是指不间断的数据结构）。</p><p>它有以下几个特点：</p><p><strong>1）面向连接</strong></p><p>面向连接，是指发送数据之前必须在两端建立连接。建立连接的方法是“三次握手”，这样能建立可靠的连接。建立连接，是为数据的可靠传输打下了基础。</p><p><strong>2）仅支持单播传输</strong></p><p>每条TCP传输连接只能有两个端点，只能进行点对点的数据传输，不支持多播和广播传输方式。</p><p><strong>3）面向字节流</strong></p><p>TCP不像UDP一样那样一个个报文独立地传输，而是在不保留报文边界的情况下以字节流方式进行传输。</p><p><strong>4）可靠传输</strong></p><p>对于可靠传输，判断丢包、误码靠的是TCP的段编号以及确认号。TCP为了保证报文传输的可靠，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的字节发回一个相应的确认(ACK)；如果发送端实体在合理的往返时延(RTT)内未收到确认，那么对应的数据（假设丢失了）将会被重传。</p><p><strong>5）提供拥塞控制</strong></p><p>当网络出现拥塞的时候，TCP能够减小向网络注入数据的速率和数量，缓解拥塞。</p><p><strong>6）提供全双工通信</strong></p><p>TCP允许通信双方的应用程序在任何时候都能发送数据，因为TCP连接的两端都设有缓存，用来临时存放双向通信的数据。当然，TCP可以立即发送一个数据段，也可以缓存一段时间以便一次发送更多的数据段（最大的数据段大小取决于MSS）</p><h3 id="2-TCP和UDP的区别"><a href="#2-TCP和UDP的区别" class="headerlink" title="2. TCP和UDP的区别"></a>2. TCP和UDP的区别</h3><table><thead><tr><th></th><th>UDP</th><th>TCP</th></tr></thead><tbody><tr><td>是否连接</td><td>无连接</td><td>面向连接</td></tr><tr><td>是否可靠</td><td>不可靠传输，不使用流量控制和拥塞控制</td><td>可靠传输（数据顺序和正确性），使用流量控制和拥塞控制</td></tr><tr><td>连接对象个数</td><td>支持一对一，一对多，多对一和多对多交互通信</td><td>只能是一对一通信</td></tr><tr><td>传输方式</td><td>面向报文</td><td>面向字节流</td></tr><tr><td>首部开销</td><td>首部开销小，仅8字节</td><td>首部最小20字节，最大60字节</td></tr><tr><td>适用场景</td><td>适用于实时应用，例如视频会议、直播</td><td>适用于要求可靠传输的应用，例如文件传输</td></tr></tbody></table><h3 id="3-TCP和UDP的使用场景"><a href="#3-TCP和UDP的使用场景" class="headerlink" title="3. TCP和UDP的使用场景"></a>3. TCP和UDP的使用场景</h3><ul><li><strong>TCP应用场景：</strong> 效率要求相对低，但对准确性要求相对高的场景。因为传输中需要对数据确认、重发、排序等操作，相比之下效率没有UDP高。例如：文件传输（准确高要求高、但是速度可以相对慢）、接受邮件、远程登录。</li><li><strong>UDP应用场景：</strong> 效率要求相对高，对准确性要求相对低的场景。例如：QQ聊天、在线视频、网络语音电话（即时通讯，速度要求高，但是出现偶尔断续不是太大问题，并且此处完全不可以使用重发机制）、广播通信（广播、多播）。</li></ul><h3 id="4-UDP协议为什么不可靠？"><a href="#4-UDP协议为什么不可靠？" class="headerlink" title="4. UDP协议为什么不可靠？"></a>4. UDP协议为什么不可靠？</h3><p>UDP在传输数据之前不需要先建立连接，远地主机的运输层在接收到UDP报文后，不需要确认，提供不可靠交付。总结就以下四点：</p><ul><li>不保证消息交付：不确认，不重传，无超时</li><li>不保证交付顺序：不设置包序号，不重排，不会发生队首阻塞</li><li>不跟踪连接状态：不必建立连接或重启状态机</li><li>不进行拥塞控制：不内置客户端或网络反馈机制</li></ul><h3 id="5-TCP的重传机制"><a href="#5-TCP的重传机制" class="headerlink" title="5. TCP的重传机制"></a>5. TCP的重传机制</h3><p>由于TCP的下层网络（网络层）可能出现<strong>丢失、重复或失序</strong>的情况，TCP协议提供可靠数据传输服务。为保证数据传输的正确性，TCP会重传其认为已丢失（包括报文中的比特错误）的包。TCP使用两套独立的机制来完成重传，一是<strong>基于时间</strong>，二是<strong>基于确认信息</strong>。</p><p>TCP在发送一个数据之后，就开启一个定时器，若是在这个时间内没有收到发送数据的ACK确认报文，则对该报文进行重传，在达到一定次数还没有成功时放弃并发送一个复位信号。</p><h3 id="6-TCP的拥塞控制机制"><a href="#6-TCP的拥塞控制机制" class="headerlink" title="6. TCP的拥塞控制机制"></a>6. TCP的拥塞控制机制</h3><p>TCP的拥塞控制机制主要是以下四种机制：</p><ul><li>慢启动（慢开始）</li><li>拥塞避免</li><li>快速重传</li><li>快速恢复</li></ul><p><strong>（1）慢启动（慢开始）</strong></p><ul><li>在开始发送的时候设置cwnd = 1（cwnd指的是拥塞窗口）</li><li>思路：开始的时候不要发送大量数据，而是先测试一下网络的拥塞程度，由小到大增加拥塞窗口的大小。</li><li>为了防止cwnd增长过大引起网络拥塞，设置一个慢开始门限(ssthresh 状态变量)<ul><li>当cnwd &lt; ssthresh，使用慢开始算法</li><li>当cnwd = ssthresh，既可使用慢开始算法，也可以使用拥塞避免算法</li><li>当cnwd &gt; ssthresh，使用拥塞避免算法</li></ul></li></ul><p><strong>（2）拥塞避免</strong></p><ul><li>拥塞避免未必能够完全避免拥塞，是说在拥塞避免阶段将拥塞窗口控制为按线性增长，使网络不容易出现阻塞。</li><li>思路： 让拥塞窗口cwnd缓慢的增大，即每经过一个返回时间RTT就把发送方的拥塞控制窗口加一</li><li>无论是在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞，就把慢开始门限设置为出现拥塞时的发送窗口大小的一半。然后把拥塞窗口设置为1，执行慢开始算法。如图所示: <img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230610234044923.png" alt="image-20230610234044923"> 其中，判断网络出现拥塞的根据就是没有收到确认，虽然没有收到确认可能是其他原因的分组丢失，但是因为无法判定，所以都当做拥塞来处理。</li></ul><p><strong>（3）快速重传</strong></p><ul><li>快重传要求接收方在收到一个失序的报文段后就立即发出重复确认(为的是使发送方及早知道有报文段没有到达对方)。发送方只要连续收到三个重复确认就立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。</li><li>由于不需要等待设置的重传计时器到期，能尽早重传未被确认的报文段，能提高整个网络的吞吐量</li></ul><p><strong>（4）快速恢复</strong></p><ul><li>当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半。但是接下去并不执行慢开始算法。</li><li>考虑到如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将cwnd设置为ssthresh的大小，然后执行拥塞避免算法。 <img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230610234112038.png" alt="image-20230610234112038"></li></ul><h3 id="7-TCP的流量控制机制"><a href="#7-TCP的流量控制机制" class="headerlink" title="7. TCP的流量控制机制"></a>7. TCP的流量控制机制</h3><p>一般来说，流量控制就是为了让发送方发送数据的速度不要太快，要让接收方来得及接收。TCP采用大小可变的<strong>滑动窗口</strong>进行流量控制，窗口大小的单位是字节。这里说的窗口大小其实就是每次传输的数据大小。</p><ul><li>当一个连接建立时，连接的每一端分配一个缓冲区来保存输入的数据，并将缓冲区的大小发送给另一端。</li><li>当数据到达时，接收方发送确认，其中包含了自己剩余的缓冲区大小。（剩余的缓冲区空间的大小被称为窗口，指出窗口大小的通知称为窗口通告 。接收方在发送的每一确认中都含有一个窗口通告。）</li><li>如果接收方应用程序读数据的速度能够与数据到达的速度一样快，接收方将在每一确认中发送一个正的窗口通告。</li><li>如果发送方操作的速度快于接收方，接收到的数据最终将充满接收方的缓冲区，导致接收方通告一个零窗口 。发送方收到一个零窗口通告时，必须停止发送，直到接收方重新通告一个正的窗口。</li></ul><h3 id="8-TCP的可靠传输机制"><a href="#8-TCP的可靠传输机制" class="headerlink" title="8. TCP的可靠传输机制"></a>8. TCP的可靠传输机制</h3><p>TCP 的可靠传输机制是基于连续 ARQ 协议和滑动窗口协议的。</p><p>TCP 协议在发送方维持了一个发送窗口，发送窗口以前的报文段是已经发送并确认了的报文段，发送窗口中包含了已经发送但 未确认的报文段和允许发送但还未发送的报文段，发送窗口以后的报文段是缓存中还不允许发送的报文段。当发送方向接收方发 送报文时，会依次发送窗口内的所有报文段，并且设置一个定时器，这个定时器可以理解为是最早发送但未收到确认的报文段。 如果在定时器的时间内收到某一个报文段的确认回答，则滑动窗口，将窗口的首部向后滑动到确认报文段的后一个位置，此时如 果还有已发送但没有确认的报文段，则重新设置定时器，如果没有了则关闭定时器。如果定时器超时，则重新发送所有已经发送 但还未收到确认的报文段，并将超时的间隔设置为以前的两倍。当发送方收到接收方的三个冗余的确认应答后，这是一种指示， 说明该报文段以后的报文段很有可能发生丢失了，那么发送方会启用快速重传的机制，就是当前定时器结束前，发送所有的已发 送但确认的报文段。</p><p>接收方使用的是累计确认的机制，对于所有按序到达的报文段，接收方返回一个报文段的肯定回答。如果收到了一个乱序的报文 段，那么接方会直接丢弃，并返回一个最近的按序到达的报文段的肯定回答。使用累计确认保证了返回的确认号之前的报文段都 已经按序到达了，所以发送窗口可以移动到已确认报文段的后面。</p><p>发送窗口的大小是变化的，它是由接收窗口剩余大小和网络中拥塞程度来决定的，TCP 就是通过控制发送窗口的长度来控制报文 段的发送速率。</p><p>但是 TCP 协议并不完全和滑动窗口协议相同，因为许多的 TCP 实现会将失序的报文段给缓存起来，并且发生重传时，只会重 传一个报文段，因此 TCP 协议的可靠传输机制更像是窗口滑动协议和选择重传协议的一个混合体。</p><h3 id="9-TCP的三次握手和四次挥手"><a href="#9-TCP的三次握手和四次挥手" class="headerlink" title="9. TCP的三次握手和四次挥手"></a>9. TCP的三次握手和四次挥手</h3><h4 id="（1）三次握手"><a href="#（1）三次握手" class="headerlink" title="（1）三次握手"></a>（1）三次握手</h4><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230610234154416.png" alt="image-20230610234154416"> 三次握手（Three-way Handshake)其实就是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。进行三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备。实质上其实就是连接服务器指定端口，建立TCP连接，并同步连接双方的序列号和确认号，交换TCP窗口大小信息。</p><p>刚开始客户端处于 Closed 的状态，服务端处于 Listen 状态。</p><ul><li>第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN，此时客户端处于 SYN_SEND 状态。</li></ul><blockquote><p>首部的同步位SYN=1，初始序号seq=x，SYN=1的报文段不能携带数据，但要消耗掉一个序号。</p></blockquote><ul><li>第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN。同时会把客户端的 ISN + 1 作为ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_REVD 的状态。</li></ul><blockquote><p>在确认报文段中SYN=1，ACK=1，确认号ack=x+1，初始序号seq=y</p></blockquote><ul><li>第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 ESTABLISHED 状态。服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方已建立起了连接。</li></ul><blockquote><p>确认报文段ACK=1，确认号ack=y+1，序号seq=x+1（初始为seq=x，第二个报文段所以要+1），ACK报文段可以携带数据，不携带数据则不消耗序号。</p></blockquote><p><strong>那为什么要三次握手呢？两次不行吗？</strong></p><ul><li>为了确认双方的接收能力和发送能力都正常</li><li>如果是用两次握手，则会出现下面这种情况：</li></ul><blockquote><p>如客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端，此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接，不采用三次握手，只要服务端发出确认，就建立新的连接了，此时客户端忽略服务端发来的确认，也不发送数据，则服务端一致等待客户端发送数据，浪费资源。</p></blockquote><p><strong>简单来说就是以下三步：</strong></p><ul><li><strong>第一次握手：</strong> 客户端向服务端发送连接请求报文段。该报文段中包含自身的数据通讯初始序号。请求发送后，客户端便进入 SYN-SENT 状态。</li><li><strong>第二次握手：</strong> 服务端收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯初始序号，发送完成后便进入 SYN-RECEIVED 状态。</li><li><strong>第三次握手：</strong> 当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入 ESTABLISHED 状态，服务端收到这个应答后也进入 ESTABLISHED 状态，此时连接建立成功。</li></ul><p>TCP 三次握手的建立连接的过程就是相互确认初始序号的过程，告诉对方，什么样序号的报文段能够被正确接收。 第三次握手的作用是客户端对服务器端的初始序号的确认。如果只使用两次握手，那么服务器就没有办法知道自己的序号是否 已被确认。同时这样也是为了防止失效的请求报文段被服务器接收，而出现错误的情况。</p><h4 id="（2）四次挥手"><a href="#（2）四次挥手" class="headerlink" title="（2）四次挥手"></a>（2）四次挥手</h4><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230610234225770.png" alt="image-20230610234225770"> 刚开始双方都处于 ESTABLISHED 状态，假如是客户端先发起关闭请求。四次挥手的过程如下：</p><ul><li>第一次挥手： 客户端会发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 FIN_WAIT1 状态。</li></ul><blockquote><p>即发出连接释放报文段（FIN=1，序号seq=u），并停止再发送数据，主动关闭TCP连接，进入FIN_WAIT1（终止等待1）状态，等待服务端的确认。</p></blockquote><ul><li>第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT 状态。</li></ul><blockquote><p>即服务端收到连接释放报文段后即发出确认报文段（ACK=1，确认号ack=u+1，序号seq=v），服务端进入CLOSE_WAIT（关闭等待）状态，此时的TCP处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入FIN_WAIT2（终止等待2）状态，等待服务端发出的连接释放报文段。</p></blockquote><ul><li>第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。</li></ul><blockquote><p>即服务端没有要向客户端发出的数据，服务端发出连接释放报文段（FIN=1，ACK=1，序号seq=w，确认号ack=u+1），服务端进入LAST_ACK（最后确认）状态，等待客户端的确认。</p></blockquote><ul><li>第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。</li></ul><blockquote><p>即客户端收到服务端的连接释放报文段后，对此发出确认报文段（ACK=1，seq=u+1，ack=w+1），客户端进入TIME_WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态。</p></blockquote><p><strong>那为什么需要四次挥手呢？</strong></p><blockquote><p>因为当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，“你发的FIN报文我收到了”。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送，故需要四次挥手。</p></blockquote><p><strong>简单来说就是以下四步：</strong></p><ul><li><strong>第一次挥手：</strong> 若客户端认为数据发送完成，则它需要向服务端发送连接释放请求。</li><li><strong>第二次挥手</strong>：服务端收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明客户端到服务端的连接已经释放，不再接收客户端发的数据了。但是因为 TCP 连接是双向的，所以服务端仍旧可以发送数据给客户端。</li><li><strong>第三次挥手</strong>：服务端如果此时还有没发完的数据会继续发送，完毕后会向客户端发送连接释放请求，然后服务端便进入 LAST-ACK 状态。</li><li><strong>第四次挥手：</strong> 客户端收到释放请求后，向服务端发送确认应答，此时客户端进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有服务端的重发请求的话，就进入 CLOSED 状态。当服务端收到确认应答后，也便进入 CLOSED 状态。</li></ul><p>TCP 使用四次挥手的原因是因为 TCP 的连接是全双工的，所以需要双方分别释放到对方的连接，单独一方的连接释放，只代 表不能再向对方发送数据，连接处于的是半释放的状态。</p><p>最后一次挥手中，客户端会等待一段时间再关闭的原因，是为了防止发送给服务器的确认报文段丢失或者出错，从而导致服务器 端不能正常关闭。</p><h3 id="10-TCP粘包是怎么回事，如何处理"><a href="#10-TCP粘包是怎么回事，如何处理" class="headerlink" title="10. TCP粘包是怎么回事，如何处理?"></a>10. TCP粘包是怎么回事，如何处理?</h3><p>默认情况下, TCP 连接会启⽤延迟传送算法 (Nagle 算法), 在数据发送之前缓存他们. 如果短时间有多个数据发送, 会缓冲到⼀起作⼀次发送 (缓冲⼤⼩⻅ socket.bufferSize ), 这样可以减少 IO 消耗提⾼性能.</p><p>如果是传输⽂件的话, 那么根本不⽤处理粘包的问题, 来⼀个包拼⼀个包就好了。但是如果是多条消息, 或者是别的⽤途的数据那么就需要处理粘包.</p><p>下面看⼀个例⼦, 连续调⽤两次 send 分别发送两段数据 data1 和 data2, 在接收端有以下⼏种常⻅的情况: A. 先接收到 data1, 然后接收到 data2 . B. 先接收到 data1 的部分数据, 然后接收到 data1 余下的部分以及 data2 的全部. C. 先接收到了 data1 的全部数据和 data2 的部分数据, 然后接收到了 data2 的余下的数据. D. ⼀次性接收到了 data1 和 data2 的全部数据.</p><p>其中的 BCD 就是我们常⻅的粘包的情况. ⽽对于处理粘包的问题, 常⻅的解决⽅案有:</p><ul><li><strong>多次发送之前间隔⼀个等待时间</strong>：只需要等上⼀段时间再进⾏下⼀次 send 就好, 适⽤于交互频率特别低的场景. 缺点也很明显, 对于⽐较频繁的场景⽽⾔传输效率实在太低，不过⼏乎不⽤做什么处理.</li><li><strong>关闭 Nagle 算法</strong>：关闭 Nagle 算法, 在 Node.js 中你可以通过 socket.setNoDelay() ⽅法来关闭 Nagle 算法, 让每⼀次 send 都不缓冲直接发送。该⽅法⽐较适⽤于每次发送的数据都⽐较⼤ (但不是⽂件那么⼤), 并且频率不是特别⾼的场景。如果是每次发送的数据量⽐较⼩, 并且频率特别⾼的, 关闭 Nagle 纯属⾃废武功。另外, 该⽅法不适⽤于⽹络较差的情况, 因为 Nagle 算法是在服务端进⾏的包合并情况, 但是如果短时间内客户端的⽹络情况不好, 或者应⽤层由于某些原因不能及时将 TCP 的数据 recv, 就会造成多个包在客户端缓冲从⽽粘包的情况。 (如果是在稳定的机房内部通信那么这个概率是⽐较⼩可以选择忽略的)</li><li><strong>进⾏封包/拆包：</strong> 封包/拆包是⽬前业内常⻅的解决⽅案了。即给每个数据包在发送之前, 于其前/后放⼀些有特征的数据, 然后收到数据的时 候根据特征数据分割出来各个数据包。</li></ul><h3 id="11-为什么udp不会粘包？"><a href="#11-为什么udp不会粘包？" class="headerlink" title="11. 为什么udp不会粘包？"></a>11. 为什么<strong>udp</strong>不会粘包？</h3><ul><li>TCP协议是⾯向流的协议，UDP是⾯向消息的协议。UDP段都是⼀条消息，应⽤程序必须以消息为单位提取数据，不能⼀次提取任意字节的数据</li><li>UDP具有保护消息边界，在每个UDP包中就有了消息头（消息来源地址，端⼝等信息），这样对于接收端来说就容易进⾏区分处理了。传输协议把数据当作⼀条独⽴的消息在⽹上传输，接收端只能接收独⽴的消息。接收端⼀次只能接收发送端发出的⼀个数据包,如果⼀次接受数据的⼤⼩⼩于发送端⼀次发送的数据⼤⼩，就会丢失⼀部分数据，即使丢失，接受端也不会分两次去接收。</li></ul><h2 id="七、WebSocket"><a href="#七、WebSocket" class="headerlink" title="七、WebSocket"></a>七、WebSocket</h2><h3 id="1-对-WebSocket-的理解"><a href="#1-对-WebSocket-的理解" class="headerlink" title="1. 对 WebSocket 的理解"></a>1. 对 WebSocket 的理解</h3><p>WebSocket是HTML5提供的一种浏览器与服务器进行<strong>全双工通讯</strong>的网络技术，属于应用层协议。它基于TCP传输协议，并复用HTTP的握手通道。浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接， 并进行双向数据传输。</p><p>WebSocket 的出现就解决了半双工通信的弊端。它最大的特点是：<strong>服务器可以向客户端主动推动消息，客户端也可以主动向服务器推送消息。</strong></p><p><strong>WebSocket原理</strong>：客户端向 WebSocket 服务器通知（notify）一个带有所有接收者ID（recipients IDs）的事件（event），服务器接收后立即通知所有活跃的（active）客户端，只有ID在接收者ID序列中的客户端才会处理这个事件。 </p><p><strong>WebSocket 特点的如下：</strong></p><ul><li>支持双向通信，实时性更强</li><li>可以发送文本，也可以发送二进制数据‘’</li><li>建立在TCP协议之上，服务端的实现比较容易</li><li>数据格式比较轻量，性能开销小，通信高效</li><li>没有同源限制，客户端可以与任意服务器通信</li><li>协议标识符是ws（如果加密，则为wss），服务器网址就是 URL</li><li>与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。</li></ul><p><strong>Websocket的使用方法如下：</strong> </p><p>在客户端中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在index.html中直接写WebSocket，设置服务端的端口号为 9999</span></span><br><span class="line"><span class="keyword">let</span> ws = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="string">&#x27;ws://localhost:9999&#x27;</span>);</span><br><span class="line"><span class="comment">// 在客户端与服务端建立连接后触发</span></span><br><span class="line">ws.<span class="property">onopen</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Connection open.&quot;</span>); </span><br><span class="line">    ws.<span class="title function_">send</span>(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 在服务端给客户端发来消息的时候触发</span></span><br><span class="line">ws.<span class="property">onmessage</span> = <span class="keyword">function</span>(<span class="params">res</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res);       <span class="comment">// 打印的是MessageEvent对象</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res.<span class="property">data</span>);  <span class="comment">// 打印的是收到的消息</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 在客户端与服务端建立关闭后触发</span></span><br><span class="line">ws.<span class="property">onclose</span> = <span class="keyword">function</span>(<span class="params">evt</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Connection closed.&quot;</span>);</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><h3 id="2-即时通讯的实现：短轮询、长轮询、SSE-和-WebSocket-间的区别？"><a href="#2-即时通讯的实现：短轮询、长轮询、SSE-和-WebSocket-间的区别？" class="headerlink" title="2. 即时通讯的实现：短轮询、长轮询、SSE 和 WebSocket 间的区别？"></a>2. 即时通讯的实现：短轮询、长轮询、SSE 和 WebSocket 间的区别？</h3><p>短轮询和长轮询的目的都是用于实现客户端和服务器端的一个即时通讯。</p><p><strong>短轮询的基本思路：</strong> 浏览器每隔一段时间向浏览器发送 http 请求，服务器端在收到请求后，不论是否有数据更新，都直接进行响应。这种方式实现的即时通信，本质上还是浏览器发送请求，服务器接受请求的一个过程，通过让客户端不断的进行请求，使得客户端能够模拟实时地收到服务器端的数据的变化。这种方式的优点是比较简单，易于理解。缺点是这种方式由于需要不断的建立 http 连接，严重浪费了服务器端和客户端的资源。当用户增加时，服务器端的压力就会变大，这是很不合理的。</p><p><strong>长轮询的基本思路：</strong> 首先由客户端向服务器发起请求，当服务器收到客户端发来的请求后，服务器端不会直接进行响应，而是先将这个请求挂起，然后判断服务器端数据是否有更新。如果有更新，则进行响应，如果一直没有数据，则到达一定的时间限制才返回。客户端 JavaScript 响应处理函数会在处理完服务器返回的信息后，再次发出请求，重新建立连接。长轮询和短轮询比起来，它的优点是明显减少了很多不必要的 http 请求次数，相比之下节约了资源。长轮询的缺点在于，连接挂起也会导致资源的浪费。</p><p><strong>SSE 的基本思想：</strong> 服务器使用流信息向服务器推送信息。严格地说，http 协议无法做到服务器主动推送信息。但是，有一种变通方法，就是服务器向客户端声明，接下来要发送的是流信息。也就是说，发送的不是一次性的数据包，而是一个数据流，会连续不断地发送过来。这时，客户端不会关闭连接，会一直等着服务器发过来的新的数据流，视频播放就是这样的例子。SSE 就是利用这种机制，使用流信息向浏览器推送信息。它基于 http 协议，目前除了 IE/Edge，其他浏览器都支持。它相对于前面两种方式来说，不需要建立过多的 http 请求，相比之下节约了资源。</p><p><strong>WebSocket</strong> 是 HTML5 定义的一个新协议议，与传统的 http 协议不同，该协议允许由服务器主动的向客户端推送信息。使用 WebSocket 协议的缺点是在服务器端的配置比较复杂。WebSocket 是一个全双工的协议，也就是通信双方是平等的，可以相互发送消息，而 SSE 的方式是单向通信的，只能由服务器端向客户端推送信息，如果客户端需要发送信息就是属于下一个 http 请求了。</p><p><strong>上面的四个通信协议，前三个都是基于HTTP协议的。</strong></p><p>对于这四种即使通信协议，从性能的角度来看： <strong>WebSocket &gt; 长连接（SEE） &gt; 长轮询 &gt; 短轮询</strong> 但是，我们如果考虑浏览器的兼容性问题，顺序就恰恰相反了： <strong>短轮询 &gt; 长轮询 &gt; 长连接（SEE） &gt; WebSocket</strong> 所以，还是要根据具体的使用场景来判断使用哪种方式。</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue复习</title>
      <link href="/posts/c9a941a3.html"/>
      <url>/posts/c9a941a3.html</url>
      
        <content type="html"><![CDATA[<p>vue复习</p><span id="more"></span><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230610151409290.png" alt="image-20230610151409290"></p><h2 id="一、Vue-基础"><a href="#一、Vue-基础" class="headerlink" title="一、Vue 基础"></a>一、Vue 基础</h2><h3 id="1-Vue的基本原理"><a href="#1-Vue的基本原理" class="headerlink" title="1. Vue的基本原理"></a>1. Vue的基本原理</h3><p>当一个Vue实例创建时，Vue会遍历data中的属性，用 Object.defineProperty（vue3.0使用proxy ）将它们转为 getter/setter，并且在内部追踪相关依赖，在属性被访问和修改时通知变化。 每个组件实例都有相应的 watcher 程序实例，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的setter被调用时，会通知watcher重新计算，从而致使它关联的组件得以更新。 </p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230610151552282.png" alt="image-20230610151552282"></p><h3 id="2-双向数据绑定的原理"><a href="#2-双向数据绑定的原理" class="headerlink" title="2. 双向数据绑定的原理"></a>2. 双向数据绑定的原理</h3><p>Vue.js 是采用<strong>数据劫持</strong>结合<strong>发布者-订阅者模式</strong>的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。主要分为以下几个步骤：</p><ol><li>需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上setter和getter这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化</li><li>compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图</li><li>Watcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是: ①在自身实例化时往属性订阅器(dep)里面添加自己 ②自身必须有一个update()方法 ③待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。</li><li>MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据model变更的双向绑定效果。</li></ol><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230610151652668.png" alt="image-20230610151652668"></p><h3 id="3-使用-Object-defineProperty-来进行数据劫持有什么缺点？"><a href="#3-使用-Object-defineProperty-来进行数据劫持有什么缺点？" class="headerlink" title="3. 使用 Object.defineProperty() 来进行数据劫持有什么缺点？"></a>3. 使用 Object.defineProperty() 来进行数据劫持有什么缺点？</h3><p>在对一些属性进行操作时，使用这种方法无法拦截，比如通过下标方式修改数组数据或者给对象新增属性，这都不能触发组件的重新渲染，因为 Object.defineProperty 不能拦截到这些操作。更精确的来说，对于数组而言，大部分操作都是拦截不到的，只是 Vue 内部通过重写函数的方式解决了这个问题。</p><p>在 Vue3.0 中已经不使用这种方式了，而是通过使用 Proxy 对对象进行代理，从而实现数据劫持。使用Proxy 的好处是它可以完美的监听到任何方式的数据改变，唯一的缺点是兼容性的问题，因为 Proxy 是 ES6 的语法。</p><h3 id="4-MVVM、MVC、MVP的区别"><a href="#4-MVVM、MVC、MVP的区别" class="headerlink" title="4. MVVM、MVC、MVP的区别"></a>4. MVVM、MVC、MVP的区别</h3><p>MVC、MVP 和 MVVM 是三种常见的软件架构设计模式，主要通过分离关注点的方式来组织代码结构，优化开发效率。</p><p>在开发单页面应用时，往往一个路由页面对应了一个脚本文件，所有的页面逻辑都在一个脚本文件里。页面的渲染、数据的获取，对用户事件的响应所有的应用逻辑都混合在一起，这样在开发简单项目时，可能看不出什么问题，如果项目变得复杂，那么整个文件就会变得冗长、混乱，这样对项目开发和后期的项目维护是非常不利的。</p><p><strong>（1）MVC</strong></p><p>MVC 通过分离 Model、View 和 Controller 的方式来组织代码结构。其中 View 负责页面的显示逻辑，Model 负责存储页面的业务数据，以及对相应数据的操作。并且 View 和 Model 应用了观察者模式，当 Model 层发生改变的时候它会通知有关 View 层更新页面。Controller 层是 View 层和 Model 层的纽带，它主要负责用户与应用的响应操作，当用户与页面产生交互的时候，Controller 中的事件触发器就开始工作了，通过调用 Model 层，来完成对 Model 的修改，然后 Model 层再去通知 View 层更新</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230610151807609.png" alt="image-20230610151807609"></p><p>（2）MVVM</p><p>MVVM 分为 Model、View、ViewModel：</p><ul><li>Model代表数据模型，数据和业务逻辑都在Model层中定义；</li><li>View代表UI视图，负责数据的展示；</li><li>ViewModel负责监听Model中数据的改变并且控制视图的更新，处理用户交互操作；</li></ul><p>Model和View并无直接关联，而是通过ViewModel来进行联系的，Model和ViewModel之间有着双向数据绑定的联系。因此当Model中的数据改变时会触发View层的刷新，View中由于用户交互操作而改变的数据也会在Model中同步。</p><p>这种模式实现了 Model和View的数据自动同步，因此开发者只需要专注于数据的维护操作即可，而不需要自己操作DOM。 </p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230610151850191.png" alt="image-20230610151850191"></p><p><strong>（3）MVP</strong></p><p>MVP 模式与 MVC 唯一不同的在于 Presenter 和 Controller。在 MVC 模式中使用观察者模式，来实现当 Model 层数据发生变化的时候，通知 View 层的更新。这样 View 层和 Model 层耦合在一起，当项目逻辑变得复杂的时候，可能会造成代码的混乱，并且可能会对代码的复用性造成一些问题。MVP 的模式通过使用 Presenter 来实现对 View 层和 Model 层的解耦。MVC 中的Controller 只知道 Model 的接口，因此它没有办法控制 View 层的更新，MVP 模式中，View 层的接口暴露给了 Presenter 因此可以在 Presenter 中将 Model 的变化和 View 的变化绑定在一起，以此来实现 View 和 Model 的同步更新。这样就实现了对 View 和 Model 的解耦，Presenter 还包含了其他的响应逻辑。</p><h3 id="5-Computed-和-Watch-的区别"><a href="#5-Computed-和-Watch-的区别" class="headerlink" title="5. Computed 和 Watch 的区别"></a>5. Computed 和 Watch 的区别</h3><p><strong>对于Computed：</strong></p><ul><li>它支持缓存，只有依赖的数据发生了变化，才会重新计算</li><li>不支持异步，当Computed中有异步操作时，无法监听数据的变化</li><li>computed的值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于data声明过，或者父组件传递过来的props中的数据进行计算的。</li><li>如果一个属性是由其他属性计算而来的，这个属性依赖其他的属性，一般会使用computed</li><li>如果computed属性的属性值是函数，那么默认使用get方法，函数的返回值就是属性的属性值；在computed中，属性有一个get方法和一个set方法，当数据发生变化时，会调用set方法。</li></ul><p><strong>对于Watch：</strong></p><ul><li>它不支持缓存，数据变化时，它就会触发相应的操作</li><li>支持异步监听</li><li>监听的函数接收两个参数，第一个参数是最新的值，第二个是变化之前的值</li><li>当一个属性发生变化时，就需要执行相应的操作</li><li>监听数据必须是data中声明的或者父组件传递过来的props中的数据，当发生变化时，会触发其他操作，函数有两个的参数：<ul><li>immediate：组件加载立即触发回调函数</li><li>deep：深度监听，发现数据内部的变化，在复杂数据类型中使用，例如数组中的对象发生变化。需要注意的是，deep无法监听到数组和对象内部的变化。</li></ul></li></ul><p>当想要执行异步或者昂贵的操作以响应不断的变化时，就需要使用watch。</p><p><strong>总结：</strong></p><ul><li>computed 计算属性 : 依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值。</li><li>watch 侦听器 : 更多的是<strong>观察</strong>的作用，<strong>无缓存性</strong>，类似于某些数据的监听回调，每当监听的数据变化时都会执行回调进行后续操作。</li></ul><p><strong>运用场景：</strong></p><ul><li>当需要进行数值计算,并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时都要重新计算。</li><li>当需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许执行异步操作 ( 访问一个 API )，限制执行该操作的频率，并在得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</li></ul><h3 id="6-Computed-和-Methods-的区别"><a href="#6-Computed-和-Methods-的区别" class="headerlink" title="6. Computed 和 Methods 的区别"></a>6. Computed 和 Methods 的区别</h3><p>可以将同一函数定义为一个 method 或者一个计算属性。对于最终的结果，两种方式是相同的</p><p><strong>不同点：</strong></p><ul><li>computed: 计算属性是基于它们的依赖进行缓存的，只有在它的相关依赖发生改变时才会重新求值；</li><li>method 调用总会执行该函数。</li></ul><h3 id="7-slot是什么？有什么作用？原理是什么？"><a href="#7-slot是什么？有什么作用？原理是什么？" class="headerlink" title="7. slot是什么？有什么作用？原理是什么？"></a>7. slot是什么？有什么作用？原理是什么？</h3><p>slot又名插槽，是Vue的内容分发机制，组件内部的模板引擎使用slot元素作为承载分发内容的出口。插槽slot是子组件的一个模板标签元素，而这一个标签元素是否显示，以及怎么显示是由父组件决定的。slot又分三类，默认插槽，具名插槽和作用域插槽。</p><ul><li>默认插槽：又名匿名查抄，当slot没有指定name属性值的时候一个默认显示插槽，一个组件内只有有一个匿名插槽。</li><li>具名插槽：带有具体名字的插槽，也就是带有name属性的slot，一个组件可以出现多个具名插槽。</li><li>作用域插槽：默认插槽、具名插槽的一个变体，可以是匿名插槽，也可以是具名插槽，该插槽的不同点是在子组件渲染作用域插槽时，可以将子组件内部的数据传递给父组件，让父组件根据子组件的传递过来的数据决定如何渲染该插槽。</li></ul><p>实现原理：当子组件vm实例化时，获取到父组件传入的slot标签的内容，存放在<code>vm.$slot</code>中，默认插槽为<code>vm.$slot.default</code>，具名插槽为<code>vm.$slot.xxx</code>，xxx 为插槽名，当组件执行渲染函数时候，遇到slot标签，使用<code>$slot</code>中的内容进行替换，此时可以为插槽传递数据，若存在数据，则可称该插槽为作用域插槽。</p><h3 id="8-过滤器的作用，如何实现一个过滤器"><a href="#8-过滤器的作用，如何实现一个过滤器" class="headerlink" title="8. 过滤器的作用，如何实现一个过滤器"></a>8. 过滤器的作用，如何实现一个过滤器</h3><p>根据过滤器的名称，过滤器是用来过滤数据的，在Vue中使用<code>filters</code>来过滤数据，<code>filters</code>不会修改数据，而是过滤数据，改变用户看到的输出（计算属性 <code>computed</code> ，方法 <code>methods</code> 都是通过修改数据来处理数据格式的输出显示）。</p><p><strong>使用场景：</strong></p><ul><li>需要格式化数据的情况，比如需要处理时间、价格等数据格式的输出 / 显示。</li><li>比如后端返回一个 <strong>年月日的日期字符串</strong>，前端需要展示为 <strong>多少天前</strong> 的数据格式，此时就可以用<code>fliters</code>过滤器来处理数据。</li></ul><p>过滤器是一个函数，它会把表达式中的值始终当作函数的第一个参数。过滤器用在<strong>插值表达式 *<em><code>&#123;&#123; &#125;&#125;</code> 和 <code>v-bind</code>*</em> 表达式</strong> 中，然后放在操作符“ <code>|</code> ”后面进行指示。</p><p>例如，在显示金额，给商品价格添加单位：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;li&gt;商品价格：&#123;&#123;item.<span class="property">price</span> | filterPrice&#125;&#125;&lt;/li&gt;</span><br><span class="line"></span><br><span class="line"> <span class="attr">filters</span>: &#123;</span><br><span class="line">    filterPrice (price) &#123;</span><br><span class="line">      <span class="keyword">return</span> price ? (<span class="string">&#x27;￥&#x27;</span> + price) : <span class="string">&#x27;--&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="9-如何保存页面的当前的状态"><a href="#9-如何保存页面的当前的状态" class="headerlink" title="9. 如何保存页面的当前的状态"></a>9. 如何保存页面的当前的状态</h3><p>既然是要保持页面的状态（其实也就是组件的状态），那么会出现以下两种情况：</p><ul><li>前组件会被卸载</li><li>前组件不会被卸载</li></ul><p>那么可以按照这两种情况分别得到以下方法：</p><p><strong>组件会被卸载：</strong></p><p><strong>（1）将状态存储在LocalStorage / SessionStorage</strong></p><p>只需要在组件即将被销毁的生命周期 <code>componentWillUnmount</code> （react）中在 LocalStorage / SessionStorage 中把当前组件的 state 通过 JSON.stringify() 储存下来就可以了。在这里面需要注意的是组件更新状态的时机。</p><p>比如从 B 组件跳转到 A 组件的时候，A 组件需要更新自身的状态。但是如果从别的组件跳转到 B 组件的时候，实际上是希望 B 组件重新渲染的，也就是不要从 Storage 中读取信息。所以需要在 Storage 中的状态加入一个 flag 属性，用来控制 A 组件是否读取 Storage 中的状态。</p><p><strong>优点：</strong></p><ul><li>兼容性好，不需要额外库或工具。</li><li>简单快捷，基本可以满足大部分需求。</li></ul><p><strong>缺点：</strong></p><ul><li>状态通过 JSON 方法储存（相当于深拷贝），如果状态中有特殊情况（比如 Date 对象、Regexp 对象等）的时候会得到字符串而不是原来的值。（具体参考用 JSON 深拷贝的缺点）</li><li>如果 B 组件后退或者下一页跳转并不是前组件，那么 flag 判断会失效，导致从其他页面进入 A 组件页面时 A 组件会重新读取 Storage，会造成很奇怪的现象</li></ul><p><strong>（2）路由传值</strong></p><p>通过 react-router 的 Link 组件的 prop —— to 可以实现路由间传递参数的效果。</p><p>在这里需要用到 state 参数，在 B 组件中通过 history.location.state 就可以拿到 state 值，保存它。返回 A 组件时再次携带 state 达到路由状态保持的效果。</p><p><strong>优点：</strong></p><ul><li>简单快捷，不会污染 LocalStorage / SessionStorage。</li><li>可以传递 Date、RegExp 等特殊对象（不用担心 JSON.stringify / parse 的不足）</li></ul><p><strong>缺点：</strong></p><ul><li>如果 A 组件可以跳转至多个组件，那么在每一个跳转组件内都要写相同的逻辑。</li></ul><p><strong>组件不会被卸载：</strong></p><p><strong>（1）单页面渲染</strong></p><p>要切换的组件作为子组件全屏渲染，父组件中正常储存页面状态。</p><p><strong>优点：</strong></p><ul><li>代码量少</li><li>不需要考虑状态传递过程中的错误</li></ul><p><strong>缺点：</strong></p><ul><li>增加 A 组件维护成本</li><li>需要传入额外的 prop 到 B 组件</li><li>无法利用路由定位页面</li></ul><p>除此之外，在Vue中，还可以是用keep-alive来缓存页面，当组件在keep-alive内被切换时组件的<strong>activated、deactivated</strong>这两个生命周期钩子函数会被执行 被包裹在keep-alive中的组件的状态将会被保留：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;keep-alive&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">router-view</span> <span class="attr">v-if</span>=<span class="string">&quot;$route.meta.keepAlive&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span></span><br><span class="line">&lt;/kepp-alive&gt;</span><br></pre></td></tr></table></figure><p><strong>router.js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;xxx&#x27;</span>,</span><br><span class="line">  <span class="attr">component</span>: <span class="function">()=&gt;</span><span class="title function_">import</span>(<span class="string">&#x27;../src/views/xxx.vue&#x27;</span>),</span><br><span class="line">  <span class="attr">meta</span>:&#123;</span><br><span class="line">    <span class="attr">keepAlive</span>: <span class="literal">true</span> <span class="comment">// 需要被缓存</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h3 id="10-常见的事件修饰符及其作用"><a href="#10-常见的事件修饰符及其作用" class="headerlink" title="10. 常见的事件修饰符及其作用"></a>10. 常见的事件修饰符及其作用</h3><ul><li><code>.stop</code>：等同于 JavaScript 中的 <code>event.stopPropagation()</code> ，防止事件冒泡；</li><li><code>.prevent</code> ：等同于 JavaScript 中的 <code>event.preventDefault()</code> ，防止执行预设的行为（如果事件可取消，则取消该事件，而不停止事件的进一步传播）；</li><li><code>.capture</code> ：与事件冒泡的方向相反，事件捕获由外到内；</li><li><code>.self</code> ：只会触发自己范围内的事件，不包含子元素；</li><li><code>.once</code> ：只会触发一次。</li></ul><h3 id="11-v-if、v-show、v-html-的原理"><a href="#11-v-if、v-show、v-html-的原理" class="headerlink" title="11. v-if、v-show、v-html 的原理"></a>11. v-if、v-show、v-html 的原理</h3><ul><li>v-if会调用addIfCondition方法，生成vnode的时候会忽略对应节点，render的时候就不会渲染；</li><li>v-show会生成vnode，render的时候也会渲染成真实节点，只是在render过程中会在节点的属性中修改show属性值，也就是常说的display；</li><li>v-html会先移除节点下的所有节点，调用html方法，通过addProp添加innerHTML属性，归根结底还是设置innerHTML为v-html的值。</li></ul><h3 id="13-v-if和v-show的区别"><a href="#13-v-if和v-show的区别" class="headerlink" title="13. v-if和v-show的区别"></a>13. v-if和v-show的区别</h3><ul><li><strong>手段</strong>：v-if是动态的向DOM树内添加或者删除DOM元素；v-show是通过设置DOM元素的display样式属性控制显隐；</li><li><strong>编译过程</strong>：v-if切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；v-show只是简单的基于css切换；</li><li><strong>编译条件</strong>：v-if是惰性的，如果初始条件为假，则什么也不做；只有在条件第一次变为真时才开始局部编译; v-show是在任何条件下，无论首次条件是否为真，都被编译，然后被缓存，而且DOM元素保留；</li><li><strong>性能消耗</strong>：v-if有更高的切换消耗；v-show有更高的初始渲染消耗；</li><li><strong>使用场景</strong>：v-if适合运营条件不大可能改变；v-show适合频繁切换。</li></ul><h3 id="14-v-model-是如何实现的，语法糖实际是什么？"><a href="#14-v-model-是如何实现的，语法糖实际是什么？" class="headerlink" title="14. v-model 是如何实现的，语法糖实际是什么？"></a>14. v-model 是如何实现的，语法糖实际是什么？</h3><p><strong>（1）作用在表单元素上</strong> 动态绑定了 input 的 value 指向了 messgae 变量，并且在触发 input 事件的时候去动态把 message设置为目标值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-model=<span class="string">&quot;sth&quot;</span> /&gt;</span><br><span class="line"><span class="comment">//  等同于</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">input</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">v-bind:value</span>=<span class="string">&quot;message&quot;</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">v-on:input</span>=<span class="string">&quot;message=$event.target.value&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">&gt;</span></span></span><br><span class="line"><span class="language-xml">//$event 指代当前触发的事件对象;</span></span><br><span class="line"><span class="language-xml">//$event.target 指代当前触发的事件对象的dom;</span></span><br><span class="line"><span class="language-xml">//$event.target.value 就是当前dom的value值;</span></span><br><span class="line"><span class="language-xml">//在@input方法中，value =&gt; sth;</span></span><br><span class="line"><span class="language-xml">//在:value中,sth =&gt; value;</span></span><br></pre></td></tr></table></figure><p><strong>（2）作用在组件上</strong> 在自定义组件中，v-model 默认会利用名为 value 的 prop和名为 input 的事件</p><p><strong>本质是一个父子组件通信的语法糖，通过prop和$.emit实现。</strong> 因此父组件 v-model 语法糖本质上可以修改为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;child :value=<span class="string">&quot;message&quot;</span>  @input=<span class="string">&quot;function(e)&#123;message = e&#125;&quot;</span>&gt;&lt;/child&gt;</span><br></pre></td></tr></table></figure><p>在组件的实现中，可以通过 v-model属性来配置子组件接收的prop名称，以及派发的事件名称。 例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父组件</span></span><br><span class="line">&lt;aa-input v-model=<span class="string">&quot;aa&quot;</span>&gt;&lt;/aa-input&gt;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">aa-input</span> <span class="attr">v-bind:value</span>=<span class="string">&quot;aa&quot;</span> <span class="attr">v-on:input</span>=<span class="string">&quot;aa=$event.target.value&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aa-input</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子组件：</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-bind:value</span>=<span class="string">&quot;aa&quot;</span> <span class="attr">v-on:input</span>=<span class="string">&quot;onmessage&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aa-input</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="attr">props</span>:&#123;<span class="attr">value</span>:aa,&#125;</span><br><span class="line"><span class="attr">methods</span>:&#123;</span><br><span class="line">    <span class="title function_">onmessage</span>(<span class="params">e</span>)&#123;</span><br><span class="line">        $emit(<span class="string">&#x27;input&#x27;</span>,e.<span class="property">target</span>.<span class="property">value</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认情况下，一个组件上的v-model 会把 value 用作 prop且把 input 用作 event。但是一些输入类型比如单选框和复选框按钮可能想使用 value prop 来达到不同的目的。使用 model 选项可以回避这些情况产生的冲突。js 监听input 输入框输入数据改变，用oninput，数据改变以后就会立刻出发这个事件。通过input事件把数据$emit 出去，在父组件接受。父组件设置v-model的值为input <code>$emit</code>过来的值。</p><h3 id="15-v-model-可以被用在自定义组件上吗？如果可以，如何使用？"><a href="#15-v-model-可以被用在自定义组件上吗？如果可以，如何使用？" class="headerlink" title="15. v-model 可以被用在自定义组件上吗？如果可以，如何使用？"></a>15. v-model 可以被用在自定义组件上吗？如果可以，如何使用？</h3><p>可以。v-model 实际上是一个语法糖，如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-model=<span class="string">&quot;searchText&quot;</span>&gt;</span><br></pre></td></tr></table></figure><p>实际上相当于：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;input</span><br><span class="line">  v-<span class="attr">bind</span>:value=<span class="string">&quot;searchText&quot;</span></span><br><span class="line">  v-<span class="attr">on</span>:input=<span class="string">&quot;searchText = $event.target.value&quot;</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p>用在自定义组件上也是同理：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;custom-input v-model=<span class="string">&quot;searchText&quot;</span>&gt;</span><br></pre></td></tr></table></figure><p>相当于：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;custom-input</span><br><span class="line">  v-<span class="attr">bind</span>:value=<span class="string">&quot;searchText&quot;</span></span><br><span class="line">  v-<span class="attr">on</span>:input=<span class="string">&quot;searchText = $event&quot;</span></span><br><span class="line">&gt;&lt;/custom-input&gt;</span><br></pre></td></tr></table></figure><p>显然，custom-input 与父组件的交互如下：</p><ol><li>父组件将<code>searchText</code>变量传入custom-input 组件，使用的 prop 名为<code>value</code>；</li><li>custom-input 组件向父组件传出名为<code>input</code>的事件，父组件将接收到的值赋值给<code>searchText</code>；</li></ol><p>所以，custom-input 组件的实现应该类似于这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;custom-input&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">props</span>: [<span class="string">&#x27;value&#x27;</span>],</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;input</span></span><br><span class="line"><span class="string">      v-bind:value=&quot;value&quot;</span></span><br><span class="line"><span class="string">      v-on:input=&quot;$emit(&#x27;input&#x27;, $event.target.value)&quot;</span></span><br><span class="line"><span class="string">    &gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="16-data为什么是一个函数而不是对象"><a href="#16-data为什么是一个函数而不是对象" class="headerlink" title="16. data为什么是一个函数而不是对象"></a>16. data为什么是一个函数而不是对象</h3><p>JavaScript中的对象是引用类型的数据，当多个实例引用同一个对象时，只要一个实例对这个对象进行操作，其他实例中的数据也会发生变化。</p><p>而在Vue中，更多的是想要复用组件，那就需要每个组件都有自己的数据，这样组件之间才不会相互干扰。</p><p>所以组件的数据不能写成对象的形式，而是要写成函数的形式。数据以函数返回值的形式定义，这样当每次复用组件的时候，就会返回一个新的data，也就是说每个组件都有自己的私有数据空间，它们各自维护自己的数据，不会干扰其他组件的正常运行。</p><h3 id="17-对keep-alive的理解，它是如何实现的，具体缓存的是什么？"><a href="#17-对keep-alive的理解，它是如何实现的，具体缓存的是什么？" class="headerlink" title="17. 对keep-alive的理解，它是如何实现的，具体缓存的是什么？"></a>17. 对keep-alive的理解，它是如何实现的，具体缓存的是什么？</h3><p>如果需要在组件切换的时候，保存一些组件的状态防止多次渲染，就可以使用 keep-alive 组件包裹需要保存的组件。</p><p><strong>（1）keep-alive</strong></p><p>keep-alive有以下三个属性：</p><ul><li>include 字符串或正则表达式，只有名称匹配的组件会被匹配；</li><li>exclude 字符串或正则表达式，任何名称匹配的组件都不会被缓存；</li><li>max 数字，最多可以缓存多少组件实例。</li></ul><p>注意：keep-alive 包裹动态组件时，会缓存不活动的组件实例。</p><p><strong>主要流程</strong></p><ol><li>判断组件 name ，不在 include 或者在 exclude 中，直接返回 vnode，说明该组件不被缓存。</li><li>获取组件实例 key ，如果有获取实例的 key，否则重新生成。</li><li>key生成规则，cid +”∶∶”+ tag ，仅靠cid是不够的，因为相同的构造函数可以注册为不同的本地组件。</li><li>如果缓存对象内存在，则直接从缓存对象中获取组件实例给 vnode ，不存在则添加到缓存对象中。 5.最大缓存数量，当缓存组件数量超过 max 值时，清除 keys 数组内第一个组件。</li></ol><p><strong>（2）keep-alive 的实现</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">patternTypes</span>: <span class="title class_">Array</span>&lt;<span class="title class_">Function</span>&gt; = [<span class="title class_">String</span>, <span class="title class_">RegExp</span>, <span class="title class_">Array</span>] <span class="comment">// 接收：字符串，正则，数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;keep-alive&#x27;</span>,</span><br><span class="line">  <span class="attr">abstract</span>: <span class="literal">true</span>, <span class="comment">// 抽象组件，是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在父组件链中。</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">include</span>: patternTypes, <span class="comment">// 匹配的组件，缓存</span></span><br><span class="line">    <span class="attr">exclude</span>: patternTypes, <span class="comment">// 不去匹配的组件，不缓存</span></span><br><span class="line">    <span class="attr">max</span>: [<span class="title class_">String</span>, <span class="title class_">Number</span>], <span class="comment">// 缓存组件的最大实例数量, 由于缓存的是组件实例（vnode），数量过多的时候，会占用过多的内存，可以用max指定上限</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="title function_">created</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 用于初始化缓存虚拟DOM数组和vnode的key</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">cache</span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">keys</span> = []</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="title function_">destroyed</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 销毁缓存cache的组件实例</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> <span class="variable language_">this</span>.<span class="property">cache</span>) &#123;</span><br><span class="line">      <span class="title function_">pruneCacheEntry</span>(<span class="variable language_">this</span>.<span class="property">cache</span>, key, <span class="variable language_">this</span>.<span class="property">keys</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// prune 削减精简[v.]</span></span><br><span class="line">    <span class="comment">// 去监控include和exclude的改变，根据最新的include和exclude的内容，来实时削减缓存的组件的内容</span></span><br><span class="line">    <span class="variable language_">this</span>.$watch(<span class="string">&#x27;include&#x27;</span>, <span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">pruneCache</span>(<span class="variable language_">this</span>, <span class="function">(<span class="params">name</span>) =&gt;</span> <span class="title function_">matches</span>(val, name))</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="variable language_">this</span>.$watch(<span class="string">&#x27;exclude&#x27;</span>, <span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">pruneCache</span>(<span class="variable language_">this</span>, <span class="function">(<span class="params">name</span>) =&gt;</span> !<span class="title function_">matches</span>(val, name))</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>render函数：</strong></p><ol><li>会在 keep-alive 组件内部去写自己的内容，所以可以去获取默认 slot 的内容，然后根据这个去获取组件</li><li>keep-alive 只对第一个组件有效，所以获取第一个子组件。</li><li>和 keep-alive 搭配使用的一般有：动态组件 和router-view</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">render () &#123;</span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">getFirstComponentChild</span> (<span class="attr">children</span>: ?<span class="title class_">Array</span>&lt;<span class="title class_">VNode</span>&gt;): ?<span class="title class_">VNode</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(children)) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; children.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> c = children[i]</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isDef</span>(c) &amp;&amp; (<span class="title function_">isDef</span>(c.<span class="property">componentOptions</span>) || <span class="title function_">isAsyncPlaceholder</span>(c))) &#123;</span><br><span class="line">      <span class="keyword">return</span> c</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> slot = <span class="variable language_">this</span>.<span class="property">$slots</span>.<span class="property">default</span> <span class="comment">// 获取默认插槽</span></span><br><span class="line">  <span class="keyword">const</span> <span class="attr">vnode</span>: <span class="title class_">VNode</span> = <span class="title function_">getFirstComponentChild</span>(slot)<span class="comment">// 获取第一个子组件</span></span><br><span class="line">  <span class="keyword">const</span> <span class="attr">componentOptions</span>: ?<span class="title class_">VNodeComponentOptions</span> = vnode &amp;&amp; vnode.<span class="property">componentOptions</span> <span class="comment">// 组件参数</span></span><br><span class="line">  <span class="keyword">if</span> (componentOptions) &#123; <span class="comment">// 是否有组件参数</span></span><br><span class="line">    <span class="comment">// check pattern</span></span><br><span class="line">    <span class="keyword">const</span> <span class="attr">name</span>: ?string = <span class="title function_">getComponentName</span>(componentOptions) <span class="comment">// 获取组件名</span></span><br><span class="line">    <span class="keyword">const</span> &#123; include, exclude &#125; = <span class="variable language_">this</span></span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      <span class="comment">// not included</span></span><br><span class="line">      (include &amp;&amp; (!name || !<span class="title function_">matches</span>(include, name))) ||</span><br><span class="line">      <span class="comment">// excluded</span></span><br><span class="line">      (exclude &amp;&amp; name &amp;&amp; <span class="title function_">matches</span>(exclude, name))</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="comment">// 如果不匹配当前组件的名字和include以及exclude</span></span><br><span class="line">      <span class="comment">// 那么直接返回组件的实例</span></span><br><span class="line">      <span class="keyword">return</span> vnode</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> &#123; cache, keys &#125; = <span class="variable language_">this</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取这个组件的key</span></span><br><span class="line">    <span class="keyword">const</span> <span class="attr">key</span>: ?string = vnode.<span class="property">key</span> == <span class="literal">null</span></span><br><span class="line">      <span class="comment">// same constructor may get registered as different local components</span></span><br><span class="line">      <span class="comment">// so cid alone is not enough (#3269)</span></span><br><span class="line">      ? componentOptions.<span class="property">Ctor</span>.<span class="property">cid</span> + (componentOptions.<span class="property">tag</span> ? <span class="string">`::<span class="subst">$&#123;componentOptions.tag&#125;</span>`</span> : <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">      : vnode.<span class="property">key</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cache[key]) &#123;</span><br><span class="line">      <span class="comment">// LRU缓存策略执行</span></span><br><span class="line">      vnode.<span class="property">componentInstance</span> = cache[key].<span class="property">componentInstance</span> <span class="comment">// 组件初次渲染的时候componentInstance为undefined</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// make current key freshest</span></span><br><span class="line">      <span class="title function_">remove</span>(keys, key)</span><br><span class="line">      keys.<span class="title function_">push</span>(key)</span><br><span class="line">      <span class="comment">// 根据LRU缓存策略执行，将key从原来的位置移除，然后将这个key值放到最后面</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 在缓存列表里面没有的话，则加入，同时判断当前加入之后，是否超过了max所设定的范围，如果是，则去除</span></span><br><span class="line">      <span class="comment">// 使用时间间隔最长的一个</span></span><br><span class="line">      cache[key] = vnode</span><br><span class="line">      keys.<span class="title function_">push</span>(key)</span><br><span class="line">      <span class="comment">// prune oldest entry</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">max</span> &amp;&amp; keys.<span class="property">length</span> &gt; <span class="built_in">parseInt</span>(<span class="variable language_">this</span>.<span class="property">max</span>)) &#123;</span><br><span class="line">        <span class="title function_">pruneCacheEntry</span>(cache, keys[<span class="number">0</span>], keys, <span class="variable language_">this</span>.<span class="property">_vnode</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将组件的keepAlive属性设置为true</span></span><br><span class="line">    vnode.<span class="property">data</span>.<span class="property">keepAlive</span> = <span class="literal">true</span> <span class="comment">// 作用：判断是否要执行组件的created、mounted生命周期函数</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> vnode || (slot &amp;&amp; slot[<span class="number">0</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>keep-alive 具体是通过 cache 数组缓存所有组件的 vnode 实例。当 cache 内原有组件被使用时会将该组件 key 从 keys 数组中删除，然后 push 到 keys数组最后，以便清除最不常用组件。</p><p><strong>实现步骤：</strong></p><ol><li>获取 keep-alive 下第一个子组件的实例对象，通过他去获取这个组件的组件名</li><li>通过当前组件名去匹配原来 include 和 exclude，判断当前组件是否需要缓存，不需要缓存，直接返回当前组件的实例vNode</li><li>需要缓存，判断他当前是否在缓存数组里面：</li></ol><ul><li>存在，则将他原来位置上的 key 给移除，同时将这个组件的 key 放到数组最后面（LRU）</li><li>不存在，将组件 key 放入数组，然后判断当前 key数组是否超过 max 所设置的范围，超过，那么削减未使用时间最长的一个组件的 key</li></ul><ol><li>最后将这个组件的 keepAlive 设置为 true</li></ol><p><strong>（3）keep-alive 本身的创建过程和 patch 过程</strong></p><p>缓存渲染的时候，会根据 vnode.componentInstance（首次渲染 vnode.componentInstance 为 undefined） 和 keepAlive 属性判断不会执行组件的 created、mounted 等钩子函数，而是对缓存的组件执行 patch 过程∶ 直接把缓存的 DOM 对象直接插入到目标元素中，完成了数据更新的情况下的渲染过程。</p><p><strong>首次渲染</strong></p><ul><li>组件的首次渲染∶判断组件的 abstract 属性，才往父组件里面挂载 DOM</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// core/instance/lifecycle</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">initLifecycle</span> (<span class="attr">vm</span>: <span class="title class_">Component</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> options = vm.<span class="property">$options</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// locate first non-abstract parent</span></span><br><span class="line">  <span class="keyword">let</span> parent = options.<span class="property">parent</span></span><br><span class="line">  <span class="keyword">if</span> (parent &amp;&amp; !options.<span class="property">abstract</span>) &#123; <span class="comment">// 判断组件的abstract属性，才往父组件里面挂载DOM</span></span><br><span class="line">    <span class="keyword">while</span> (parent.<span class="property">$options</span>.<span class="property">abstract</span> &amp;&amp; parent.<span class="property">$parent</span>) &#123;</span><br><span class="line">      parent = parent.<span class="property">$parent</span></span><br><span class="line">    &#125;</span><br><span class="line">    parent.<span class="property">$children</span>.<span class="title function_">push</span>(vm)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  vm.<span class="property">$parent</span> = parent</span><br><span class="line">  vm.<span class="property">$root</span> = parent ? parent.<span class="property">$root</span> : vm</span><br><span class="line"></span><br><span class="line">  vm.<span class="property">$children</span> = []</span><br><span class="line">  vm.<span class="property">$refs</span> = &#123;&#125;</span><br><span class="line"></span><br><span class="line">  vm.<span class="property">_watcher</span> = <span class="literal">null</span></span><br><span class="line">  vm.<span class="property">_inactive</span> = <span class="literal">null</span></span><br><span class="line">  vm.<span class="property">_directInactive</span> = <span class="literal">false</span></span><br><span class="line">  vm.<span class="property">_isMounted</span> = <span class="literal">false</span></span><br><span class="line">  vm.<span class="property">_isDestroyed</span> = <span class="literal">false</span></span><br><span class="line">  vm.<span class="property">_isBeingDestroyed</span> = <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>判断当前 keepAlive 和 componentInstance 是否存在来判断是否要执行组件 prepatch 还是执行创建 componentlnstance</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// core/vdom/create-component</span></span><br><span class="line">init (<span class="attr">vnode</span>: <span class="title class_">VNodeWithData</span>, <span class="attr">hydrating</span>: boolean): ?boolean &#123;</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      vnode.<span class="property">componentInstance</span> &amp;&amp;</span><br><span class="line">      !vnode.<span class="property">componentInstance</span>.<span class="property">_isDestroyed</span> &amp;&amp;</span><br><span class="line">      vnode.<span class="property">data</span>.<span class="property">keepAlive</span></span><br><span class="line">    ) &#123; <span class="comment">// componentInstance在初次是undefined!!!</span></span><br><span class="line">      <span class="comment">// kept-alive components, treat as a patch</span></span><br><span class="line">      <span class="keyword">const</span> <span class="attr">mountedNode</span>: any = vnode <span class="comment">// work around flow</span></span><br><span class="line">      componentVNodeHooks.<span class="title function_">prepatch</span>(mountedNode, mountedNode) <span class="comment">// prepatch函数执行的是组件更新的过程</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> child = vnode.<span class="property">componentInstance</span> = <span class="title function_">createComponentInstanceForVnode</span>(</span><br><span class="line">        vnode,</span><br><span class="line">        activeInstance</span><br><span class="line">      )</span><br><span class="line">      child.$mount(hydrating ? vnode.<span class="property">elm</span> : <span class="literal">undefined</span>, hydrating)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><p>prepatch 操作就不会在执行组件的 mounted 和 created 生命周期函数，而是直接将 DOM 插入</p><p><strong>（4）LRU （least recently used）缓存策略</strong></p><p>LRU 缓存策略∶ 从内存中找出最久未使用的数据并置换新的数据。 LRU（Least rencently used）算法根据数据的历史访问记录来进行淘汰数据，其核心思想是 **”如果数据最近被访问过，那么将来被访问的几率也更高”**。 最常见的实现是使用一个链表保存缓存数据，详细算法实现如下∶</p><ul><li>新数据插入到链表头部</li><li>每当缓存命中（即缓存数据被访问），则将数据移到链表头部</li><li>链表满的时候，将链表尾部的数据丢弃。</li></ul><h3 id="18-nextTick-原理及作用"><a href="#18-nextTick-原理及作用" class="headerlink" title="18. $nextTick 原理及作用"></a>18. $nextTick 原理及作用</h3><p>Vue 的 nextTick 其本质是对 JavaScript 执行原理 EventLoop 的一种应用。</p><p>nextTick 的核心是利用了如 Promise 、MutationObserver、setImmediate、setTimeout的原生 JavaScript 方法来模拟对应的微/宏任务的实现，本质是为了利用 JavaScript 的这些异步回调任务队列来实现 Vue 框架中自己的异步回调队列。</p><p>nextTick 不仅是 Vue 内部的异步队列的调用方法，同时也允许开发者在实际项目中使用这个方法来满足实际应用中对 DOM 更新数据时机的后续逻辑处理</p><p>nextTick 是典型的将底层 JavaScript 执行原理应用到具体案例中的示例，引入异步更新队列机制的原因∶</p><ul><li>如果是同步更新，则多次对一个或多个属性赋值，会频繁触发 UI/DOM 的渲染，可以减少一些无用渲染</li><li>同时由于 VirtualDOM 的引入，每一次状态发生变化后，状态变化的信号会发送给组件，组件内部使用 VirtualDOM 进行计算得出需要更新的具体的 DOM 节点，然后对 DOM 进行更新操作，每次更新状态后的渲染过程需要更多的计算，而这种无用功也将浪费更多的性能，所以异步渲染变得更加至关重要</li></ul><p>Vue采用了数据驱动视图的思想，但是在一些情况下，仍然需要操作DOM。有时候，可能遇到这样的情况，DOM1的数据发生了变化，而DOM2需要从DOM1中获取数据，那这时就会发现DOM2的视图并没有更新，这时就需要用到了<code>nextTick</code>了。</p><p>由于Vue的DOM操作是异步的，所以，在上面的情况中，就要将DOM2获取数据的操作写在<code>$nextTick</code>中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.$nextTick(<span class="function">() =&gt;</span> &#123;    <span class="comment">// 获取数据的操作...&#125;)</span></span><br></pre></td></tr></table></figure><p>所以，在以下情况下，会用到nextTick：</p><ul><li>在数据变化后执行的某个操作，而这个操作需要使用随数据变化而变化的DOM结构的时候，这个操作就需要方法在<code>nextTick()</code>的回调函数中。</li><li>在vue生命周期中，如果在created()钩子进行DOM操作，也一定要放在<code>nextTick()</code>的回调函数中。</li></ul><p>因为在created()钩子函数中，页面的DOM还未渲染，这时候也没办法操作DOM，所以，此时如果想要操作DOM，必须将操作的代码放在<code>nextTick()</code>的回调函数中。</p><h3 id="19-Vue-中给-data-中的对象属性添加一个新的属性时会发生什么？如何解决？"><a href="#19-Vue-中给-data-中的对象属性添加一个新的属性时会发生什么？如何解决？" class="headerlink" title="19. Vue 中给 data 中的对象属性添加一个新的属性时会发生什么？如何解决？"></a><strong>19. Vue 中给 data 中的对象属性添加一个新的属性时会发生什么？如何解决？</strong></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt; </span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">         <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;value in obj&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;value&quot;</span>&gt;</span> &#123;&#123;value&#125;&#125; <span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">ul</span>&gt;</span> </span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;addObjB&quot;</span>&gt;</span>添加 obj.b<span class="tag">&lt;/<span class="name">button</span>&gt;</span> </span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">export</span> <span class="keyword">default</span> &#123; </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">       data () &#123; </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          <span class="keyword">return</span> &#123; </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">              <span class="attr">obj</span>: &#123; </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                  <span class="attr">a</span>: <span class="string">&#x27;obj.a&#x27;</span> </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">              &#125; </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          &#125; </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">       &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">       <span class="attr">methods</span>: &#123; </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          addObjB () &#123; </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">              <span class="variable language_">this</span>.<span class="property">obj</span>.<span class="property">b</span> = <span class="string">&#x27;obj.b&#x27;</span> </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">              <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">obj</span>) </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          &#125; </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">   &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>点击 button 会发现，obj.b 已经成功添加，但是视图并未刷新。这是因为在Vue实例创建时，obj.b并未声明，因此就没有被Vue转换为响应式的属性，自然就不会触发视图的更新，这时就需要使用Vue的全局 api <strong>$set()：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">addObjB () (</span><br><span class="line">   <span class="variable language_">this</span>.$set(<span class="variable language_">this</span>.<span class="property">obj</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;obj.b&#x27;</span>)</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">obj</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$set()方法相当于手动的去把obj.b处理成一个响应式的属性，此时视图也会跟着改变了。</p><h3 id="20-Vue中封装的数组方法有哪些，其如何实现页面更新"><a href="#20-Vue中封装的数组方法有哪些，其如何实现页面更新" class="headerlink" title="20. Vue中封装的数组方法有哪些，其如何实现页面更新"></a>20. Vue中封装的数组方法有哪些，其如何实现页面更新</h3><p>在Vue中，对响应式处理利用的是Object.defineProperty对数据进行拦截，而这个方法并不能监听到数组内部变化，数组长度变化，数组的截取变化等，所以需要对这些操作进行hack，让Vue能监听到其中的变化。 <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6be20296a76f4e7085dfb510a3211d16~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image.png"> 那Vue是如何实现让这些数组方法实现元素的实时更新的呢，下面是Vue中对这些方法的封装：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 缓存数组原型</span></span><br><span class="line"><span class="keyword">const</span> arrayProto = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line"><span class="comment">// 实现 arrayMethods.__proto__ === Array.prototype</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> arrayMethods = <span class="title class_">Object</span>.<span class="title function_">create</span>(arrayProto);</span><br><span class="line"><span class="comment">// 需要进行功能拓展的方法</span></span><br><span class="line"><span class="keyword">const</span> methodsToPatch = [</span><br><span class="line">  <span class="string">&quot;push&quot;</span>,</span><br><span class="line">  <span class="string">&quot;pop&quot;</span>,</span><br><span class="line">  <span class="string">&quot;shift&quot;</span>,</span><br><span class="line">  <span class="string">&quot;unshift&quot;</span>,</span><br><span class="line">  <span class="string">&quot;splice&quot;</span>,</span><br><span class="line">  <span class="string">&quot;sort&quot;</span>,</span><br><span class="line">  <span class="string">&quot;reverse&quot;</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Intercept mutating methods and emit events</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">methodsToPatch.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">method</span>) &#123;</span><br><span class="line">  <span class="comment">// 缓存原生数组方法</span></span><br><span class="line">  <span class="keyword">const</span> original = arrayProto[method];</span><br><span class="line">  <span class="title function_">def</span>(arrayMethods, method, <span class="keyword">function</span> <span class="title function_">mutator</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="comment">// 执行并缓存原生数组功能</span></span><br><span class="line">    <span class="keyword">const</span> result = original.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">    <span class="comment">// 响应式处理</span></span><br><span class="line">    <span class="keyword">const</span> ob = <span class="variable language_">this</span>.<span class="property">__ob__</span>;</span><br><span class="line">    <span class="keyword">let</span> inserted;</span><br><span class="line">    <span class="keyword">switch</span> (method) &#123;</span><br><span class="line">    <span class="comment">// push、unshift会新增索引，所以要手动observer</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;push&quot;</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;unshift&quot;</span>:</span><br><span class="line">        inserted = args;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="comment">// splice方法，如果传入了第三个参数，也会有索引加入，也要手动observer。</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;splice&quot;</span>:</span><br><span class="line">        inserted = args.<span class="title function_">slice</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="keyword">if</span> (inserted) ob.<span class="title function_">observeArray</span>(inserted);<span class="comment">// 获取插入的值，并设置响应式监听</span></span><br><span class="line">    <span class="comment">// notify change</span></span><br><span class="line">    ob.<span class="property">dep</span>.<span class="title function_">notify</span>();<span class="comment">// 通知依赖更新</span></span><br><span class="line">    <span class="comment">// 返回原生数组方法的执行结果</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>简单来说就是，重写了数组中的那些原生方法，首先获取到这个数组的__ob__，也就是它的Observer对象，如果有新的值，就调用observeArray继续对新的值观察变化（也就是通过<code>target__proto__ == arrayMethods</code>来改变了数组实例的型），然后手动调用notify，通知渲染watcher，执行update。</p><h3 id="21-Vue-单页应用与多页应用的区别"><a href="#21-Vue-单页应用与多页应用的区别" class="headerlink" title="21. Vue 单页应用与多页应用的区别"></a>21. Vue 单页应用与多页应用的区别</h3><p><strong>概念：</strong></p><ul><li>SPA单页面应用（SinglePage Web Application），指只有一个主页面的应用，一开始只需要加载一次js、css等相关资源。所有内容都包含在主页面，对每一个功能模块组件化。单页应用跳转，就是切换相关组件，仅仅刷新局部资源。</li><li>MPA多页面应用 （MultiPage Application），指有多个独立页面的应用，每个页面必须重复加载js、css等相关资源。多页应用跳转，需要整页资源刷新。</li></ul><p><strong>区别：</strong> <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/76b3d747986e45e096abaf64faf5e332~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="775316ebb4c727f7c8771cc2c06e06dd.jpg"></p><h3 id="22-Vue-template-到-render-的过程"><a href="#22-Vue-template-到-render-的过程" class="headerlink" title="22. Vue template 到 render 的过程"></a>22. Vue template 到 render 的过程</h3><p>vue的模版编译过程主要如下：<strong>template -&gt; ast -&gt; render函数</strong></p><p>vue 在模版编译版本的码中会执行 compileToFunctions 将template转化为render函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将模板编译为render函数const &#123; render, staticRenderFns &#125; = compileToFunctions(template,options//省略&#125;, this)</span></span><br></pre></td></tr></table></figure><p>CompileToFunctions中的主要逻辑如下∶ <strong>（1）调用parse方法将template转化为ast（抽象语法树）</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">constast = <span class="title function_">parse</span>(template.<span class="title function_">trim</span>(), options)</span><br></pre></td></tr></table></figure><ul><li><strong>parse的目标</strong>：把tamplate转换为AST树，它是一种用 JavaScript对象的形式来描述整个模板。</li><li><strong>解析过程</strong>：利用正则表达式顺序解析模板，当解析到开始标签、闭合标签、文本的时候都会分别执行对应的 回调函数，来达到构造AST树的目的。</li></ul><p>AST元素节点总共三种类型：type为1表示普通元素、2为表达式、3为纯文本</p><p><strong>（2）对静态节点做优化</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">optimize</span>(ast,options)</span><br></pre></td></tr></table></figure><p>这个过程主要分析出哪些是静态节点，给其打一个标记，为后续更新渲染可以直接跳过静态节点做优化</p><p>深度遍历AST，查看每个子树的节点元素是否为静态节点或者静态节点根。如果为静态节点，他们生成的DOM永远不会改变，这对运行时模板更新起到了极大的优化作用。</p><p><strong>（3）生成代码</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> code = <span class="title function_">generate</span>(ast, options)</span><br></pre></td></tr></table></figure><p>generate将ast抽象语法树编译成 render字符串并将静态部分放到 staticRenderFns 中，最后通过 <code>new Function(`` render``)</code> 生成render函数。</p><h3 id="23-Vue-data-中某一个属性的值发生改变后，视图会立即同步执行重新渲染吗？"><a href="#23-Vue-data-中某一个属性的值发生改变后，视图会立即同步执行重新渲染吗？" class="headerlink" title="23. Vue data 中某一个属性的值发生改变后，视图会立即同步执行重新渲染吗？"></a>23. Vue data 中某一个属性的值发生改变后，视图会立即同步执行重新渲染吗？</h3><p>不会立即同步执行重新渲染。Vue 实现响应式并不是数据发生变化之后 DOM 立即变化，而是按一定的策略进行 DOM 的更新。Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化， Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。</p><p>如果同一个watcher被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。然后，在下一个的事件循环tick中，Vue 刷新队列并执行实际（已去重的）工作。</p><h3 id="24-简述-mixin、extends-的覆盖逻辑"><a href="#24-简述-mixin、extends-的覆盖逻辑" class="headerlink" title="24. 简述 mixin、extends 的覆盖逻辑"></a>24. 简述 mixin、extends 的覆盖逻辑</h3><p><strong>（1）mixin 和 extends</strong> mixin 和 extends均是用于合并、拓展组件的，两者均通过 mergeOptions 方法实现合并。</p><ul><li>mixins 接收一个混入对象的数组，其中混入对象可以像正常的实例对象一样包含实例选项，这些选项会被合并到最终的选项中。Mixin 钩子按照传入顺序依次调用，并在调用组件自身的钩子之前被调用。</li><li>extends 主要是为了便于扩展单文件组件，接收一个对象或构造函数。</li></ul><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230610170706107.png" alt="image-20230610170706107"></p><p> <strong>（2）mergeOptions 的执行过程</strong></p><ul><li>规范化选项（normalizeProps、normalizelnject、normalizeDirectives)</li><li>对未合并的选项，进行判断</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!child.<span class="property">_base</span>) &#123;    <span class="keyword">if</span>(child.<span class="property">extends</span>) &#123;        parent = <span class="title function_">mergeOptions</span>(parent, child.<span class="property">extends</span>, vm)    &#125;    <span class="keyword">if</span>(child.<span class="property">mixins</span>) &#123;        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>, l = child.<span class="property">mixins</span>.<span class="property">length</span>; i &lt; l; i++)&#123;            parent = <span class="title function_">mergeOptions</span>(parent, child.<span class="property">mixins</span>[i], vm)        &#125;    &#125;&#125;</span><br></pre></td></tr></table></figure><ul><li>合并处理。根据一个通用 Vue 实例所包含的选项进行分类逐一判断合并，如 props、data、 methods、watch、computed、生命周期等，将合并结果存储在新定义的 options 对象里。</li><li>返回合并结果 options。</li></ul><h3 id="25-描述下Vue自定义指令"><a href="#25-描述下Vue自定义指令" class="headerlink" title="25. 描述下Vue自定义指令"></a>25. 描述下Vue自定义指令</h3><p>在 Vue2.0 中，代码复用和抽象的主要形式是组件。然而，有的情况下，你仍然需要对普通 DOM 元素进行底层操作，这时候就会用到自定义指令。 一般需要对DOM元素进行底层操作时使用，尽量只用来操作 DOM展示，不修改内部的值。当使用自定义指令直接修改 value 值时绑定v-model的值也不会同步更新；如必须修改可以在自定义指令中使用keydown事件，在vue组件中使用 change事件，回调中修改vue数据;</p><p><strong>（1）自定义指令基本内容</strong></p><ul><li><p>全局定义：<code>Vue.directive(&quot;focus&quot;,&#123;&#125;)</code></p></li><li><p>局部定义：<code>directives:&#123;focus:&#123;&#125;&#125;</code></p></li><li><p>钩子函数：指令定义对象提供钩子函数</p><p>o bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。</p><p>o inSerted：被绑定元素插入父节点时调用（仅保证父节点存在，但不一定已被插入文档中）。</p><p>o update：所在组件的VNode更新时调用，但是可能发生在其子VNode更新之前调用。指令的值可能发生了改变，也可能没有。但是可以通过比较更新前后的值来忽略不必要的模板更新。</p><p>o ComponentUpdate：指令所在组件的 VNode及其子VNode全部更新后调用。</p><p>o unbind：只调用一次，指令与元素解绑时调用。</p></li><li><p>钩子函数参数 o el：绑定元素</p><p>o bing： 指令核心对象，描述指令全部信息属性</p><p>o name</p><p>o value</p><p>o oldValue</p><p>o expression</p><p>o arg</p><p>o modifers</p><p>o vnode  虚拟节点</p><p>o oldVnode：上一个虚拟节点（更新钩子函数中才有用）</p></li></ul><p><strong>（2）使用场景</strong></p><ul><li>普通DOM元素进行底层操作的时候，可以使用自定义指令</li><li>自定义指令是用来操作DOM的。尽管Vue推崇数据驱动视图的理念，但并非所有情况都适合数据驱动。自定义指令就是一种有效的补充和扩展，不仅可用于定义任何的DOM操作，并且是可复用的。</li></ul><p><strong>（3）使用案例</strong></p><p>初级应用：</p><ul><li>鼠标聚焦</li><li>下拉菜单</li><li>相对时间转换</li><li>滚动动画</li></ul><p>高级应用：</p><ul><li>自定义指令实现图片懒加载</li><li>自定义指令集成第三方插件</li></ul><h3 id="26-子组件可以直接改变父组件的数据吗？"><a href="#26-子组件可以直接改变父组件的数据吗？" class="headerlink" title="26. 子组件可以直接改变父组件的数据吗？"></a>26. 子组件可以直接改变父组件的数据吗？</h3><p>子组件不可以直接改变父组件的数据。这样做主要是为了维护父子组件的单向数据流。每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。如果这样做了，Vue 会在浏览器的控制台中发出警告。</p><p>Vue提倡单向数据流，即父级 props 的更新会流向子组件，但是反过来则不行。这是为了防止意外的改变父组件状态，使得应用的数据流变得难以理解，导致数据流混乱。如果破坏了单向数据流，当应用复杂时，debug 的成本会非常高。</p><p><strong>只能通过 *<em><code>$emit</code>*</em> 派发一个自定义事件，父组件接收到后，由父组件修改。</strong></p><h3 id="27-Vue是如何收集依赖的？"><a href="#27-Vue是如何收集依赖的？" class="headerlink" title="27. Vue是如何收集依赖的？"></a>27. Vue是如何收集依赖的？</h3><p>在初始化 Vue 的每个组件时，会对组件的 data 进行初始化，就会将由普通对象变成响应式对象，在这个过程中便会进行依赖收集的相关逻辑，如下所示∶</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">defieneReactive</span> (obj, key, val)&#123;</span><br><span class="line">  <span class="keyword">const</span> dep = <span class="keyword">new</span> <span class="title class_">Dep</span>();</span><br><span class="line">  ...</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, key, &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="attr">get</span>: <span class="keyword">function</span> <span class="title function_">reactiveGetter</span> () &#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="title class_">Dep</span>.<span class="property">target</span>)&#123;</span><br><span class="line">        dep.<span class="title function_">depend</span>();</span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> val</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上只保留了关键代码，主要就是 <code>const dep = new Dep()</code>实例化一个 Dep 的实例，然后在 get 函数中通过 <code>dep.depend()</code> 进行依赖收集。 <strong>（1）Dep</strong> Dep是整个依赖收集的核心，其关键代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dep</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> target;</span><br><span class="line">  subs;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span> () &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subs</span> = [];</span><br><span class="line">  &#125;</span><br><span class="line">  addSub (sub) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subs</span>.<span class="title function_">push</span>(sub)</span><br><span class="line">  &#125;</span><br><span class="line">  removeSub (sub) &#123;</span><br><span class="line">    <span class="title function_">remove</span>(<span class="variable language_">this</span>.<span class="property">sub</span>, sub)</span><br><span class="line">  &#125;</span><br><span class="line">  depend () &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="title class_">Dep</span>.<span class="property">target</span>)&#123;</span><br><span class="line">      <span class="title class_">Dep</span>.<span class="property">target</span>.<span class="title function_">addDep</span>(<span class="variable language_">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  notify () &#123;</span><br><span class="line">    <span class="keyword">const</span> subs = <span class="variable language_">this</span>.<span class="property">subds</span>.<span class="title function_">slice</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; subs.<span class="property">length</span>; i++)&#123;</span><br><span class="line">      subs[i].<span class="title function_">update</span>()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Dep 是一个 class ，其中有一个关 键的静态属性 static，它指向了一个全局唯一 Watcher，保证了同一时间全局只有一个 watcher 被计算，另一个属性 subs 则是一个 Watcher 的数组，所以 Dep 实际上就是对 Watcher 的管理，再看看 Watcher 的相关代码∶</p><p><strong>（2）Watcher</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Watcher</span> &#123;</span><br><span class="line">  getter;</span><br><span class="line">  ...</span><br><span class="line">  <span class="title function_">constructor</span> (vm, expression)&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">getter</span> = expression;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">get</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  get () &#123;</span><br><span class="line">    <span class="title function_">pushTarget</span>(<span class="variable language_">this</span>);</span><br><span class="line">    value = <span class="variable language_">this</span>.<span class="property">getter</span>.<span class="title function_">call</span>(vm, vm)</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">  &#125;</span><br><span class="line">  addDep (dep)&#123;</span><br><span class="line">        ...</span><br><span class="line">    dep.<span class="title function_">addSub</span>(<span class="variable language_">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">pushTarget</span> (_target) &#123;</span><br><span class="line">  <span class="title class_">Dep</span>.<span class="property">target</span> = _target</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Watcher 是一个 class，它定义了一些方法，其中和依赖收集相关的主要有 get、addDep 等。</p><p><strong>（3）过程</strong></p><p>在实例化 Vue 时，依赖收集的相关过程如下∶ 初 始 化 状 态 initState ， 这 中 间 便 会 通 过 defineReactive 将数据变成响应式对象，其中的 getter 部分便是用来依赖收集的。 初始化最终会走 mount 过程，其中会实例化 Watcher ，进入 Watcher 中，便会执行 this.get() 方法，</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">updateComponent = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  vm.<span class="title function_">_update</span>(vm.<span class="title function_">_render</span>())</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Watcher</span>(vm, updateComponent)</span><br></pre></td></tr></table></figure><p>get 方法中的 pushTarget 实际上就是把 Dep.target 赋值为当前的 watcher。</p><p>this.getter.call（vm，vm），这里的 getter 会执行 vm._render() 方法，在这个过程中便会触发数据对象的 getter。那么每个对象值的 getter 都持有一个 dep，在触发 getter 的时候会调用 dep.depend() 方法，也就会执行 Dep.target.addDep(this)。刚才 Dep.target 已经被赋值为 watcher，于是便会执行 addDep 方法，然后走到 dep.addSub() 方法，便将当前的 watcher 订阅到这个数据持有的 dep 的 subs 中，这个目的是为后续数据变化时候能通知到哪些 subs 做准备。所以在 vm._render() 过程中，会触发所有数据的 getter，这样便已经完成了一个依赖收集的过程。</p><h3 id="28-对-React-和-Vue-的理解，它们的异同"><a href="#28-对-React-和-Vue-的理解，它们的异同" class="headerlink" title="28. 对 React 和 Vue 的理解，它们的异同"></a>28. 对 React 和 Vue 的理解，它们的异同</h3><p><strong>相似之处：</strong></p><ul><li>都将注意力集中保持在核心库，而将其他功能如路由和全局状态管理交给相关的库；</li><li>都有自己的构建工具，能让你得到一个根据最佳实践设置的项目模板；</li><li>都使用了Virtual DOM（虚拟DOM）提高重绘性能；</li><li>都有props的概念，允许组件间的数据传递；</li><li>都鼓励组件化应用，将应用分拆成一个个功能明确的模块，提高复用性。</li></ul><p><strong>不同之处 ：</strong></p><p><strong>1）数据流</strong></p><p>Vue默认支持数据双向绑定，而React一直提倡单向数据流</p><p><strong>2）虚拟DOM</strong></p><p>Vue2.x开始引入”Virtual DOM”，消除了和React在这方面的差异，但是在具体的细节还是有各自的特点。</p><ul><li>Vue宣称可以更快地计算出Virtual DOM的差异，这是由于它在渲染过程中，会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树。</li><li>对于React而言，每当应用的状态被改变时，全部子组件都会重新渲染。当然，这可以通过 PureComponent/shouldComponentUpdate这个生命周期方法来进行控制，但Vue将此视为默认的优化。</li></ul><p><strong>3）组件化</strong></p><p>React与Vue最大的不同是模板的编写。</p><ul><li>Vue鼓励写近似常规HTML的模板。写起来很接近标准 HTML元素，只是多了一些属性。</li><li>React推荐你所有的模板通用JavaScript的语法扩展——JSX书写。</li></ul><p>具体来讲：React中render函数是支持闭包特性的，所以import的组件在render中可以直接调用。但是在Vue中，由于模板中使用的数据都必须挂在 this 上进行一次中转，所以 import 一个组件完了之后，还需要在 components 中再声明下。 <strong>4）监听数据变化的实现原理不同</strong></p><ul><li>Vue 通过 getter/setter 以及一些函数的劫持，能精确知道数据变化，不需要特别的优化就能达到很好的性能</li><li>React 默认是通过比较引用的方式进行的，如果不优化（PureComponent/shouldComponentUpdate）可能导致大量不必要的vDOM的重新渲染。这是因为 Vue 使用的是可变数据，而React更强调数据的不可变。</li></ul><p><strong>5）高阶组件</strong></p><p>react可以通过高阶组件（HOC）来扩展，而Vue需要通过mixins来扩展。</p><p>高阶组件就是高阶函数，而React的组件本身就是纯粹的函数，所以高阶函数对React来说易如反掌。相反Vue.js使用HTML模板创建视图组件，这时模板无法有效的编译，因此Vue不能采用HOC来实现。</p><p><strong>6）构建工具</strong></p><p>两者都有自己的构建工具：</p><ul><li>React ==&gt; Create React APP</li><li>Vue ==&gt; vue-cli</li></ul><p><strong>7）跨平台</strong></p><ul><li>React ==&gt; React Native</li><li>Vue ==&gt; Weex</li></ul><h3 id="29-Vue的优点"><a href="#29-Vue的优点" class="headerlink" title="29. Vue的优点"></a>29. Vue的优点</h3><ul><li>轻量级框架：只关注视图层，是一个构建数据的视图集合，大小只有几十 <code>kb</code> ；</li><li>简单易学：国人开发，中文文档，不存在语言障碍 ，易于理解和学习；</li><li>双向数据绑定：保留了 <code>angular</code> 的特点，在数据操作方面更为简单；</li><li>组件化：保留了 <code>react</code> 的优点，实现了 <code>html</code> 的封装和重用，在构建单页面应用方面有着独特的优势；</li><li>视图，数据，结构分离：使数据的更改更为简单，不需要进行逻辑代码的修改，只需要操作数据就能完成相关操作；</li><li>虚拟DOM：<code>dom</code> 操作是非常耗费性能的，不再使用原生的 <code>dom</code> 操作节点，极大解放 <code>dom</code> 操作，但具体操作的还是 <code>dom</code> 不过是换了另一种方式；</li><li>运行速度更快：相比较于 <code>react</code> 而言，同样是操作虚拟 <code>dom</code>，就性能而言， <code>vue</code> 存在很大的优势。</li></ul><h3 id="30-assets和static的区别"><a href="#30-assets和static的区别" class="headerlink" title="30. assets和static的区别"></a>30. assets和static的区别</h3><p><strong>相同点：</strong> <code>assets</code> 和 <code>static</code> 两个都是存放静态资源文件。项目中所需要的资源文件图片，字体图标，样式文件等都可以放在这两个文件下，这是相同点</p><p><strong>不相同点：</strong><code>assets</code> 中存放的静态资源文件在项目打包时，也就是运行 <code>npm run build</code> 时会将 <code>assets</code> 中放置的静态资源文件进行打包上传，所谓打包简单点可以理解为压缩体积，代码格式化。而压缩后的静态资源文件最终也都会放置在 <code>static</code> 文件中跟着 <code>index.html</code> 一同上传至服务器。<code>static</code> 中放置的静态资源文件就不会要走打包压缩格式化等流程，而是直接进入打包好的目录，直接上传至服务器。因为避免了压缩直接进行上传，在打包时会提高一定的效率，但是 <code>static</code> 中的资源文件由于没有进行压缩等操作，所以文件的体积也就相对于 <code>assets</code> 中打包后的文件提交较大点。在服务器中就会占据更大的空间。</p><p><strong>建议：</strong> 将项目中 <code>template</code>需要的样式文件js文件等都可以放置在 <code>assets</code> 中，走打包这一流程。减少体积。而项目中引入的第三方的资源文件如<code>iconfoont.css</code> 等文件可以放置在 <code>static</code> 中，因为这些引入的第三方文件已经经过处理，不再需要处理，直接上传。</p><h3 id="31-delete和Vue-delete删除数组的区别"><a href="#31-delete和Vue-delete删除数组的区别" class="headerlink" title="31. delete和Vue.delete删除数组的区别"></a>31. delete和Vue.delete删除数组的区别</h3><ul><li><code>delete</code> 只是被删除的元素变成了 <code>empty/undefined</code> 其他的元素的键值还是不变。</li><li><code>Vue.delete</code> 直接删除了数组 改变了数组的键值。</li></ul><h3 id="32-vue如何监听对象或者数组某个属性的变化"><a href="#32-vue如何监听对象或者数组某个属性的变化" class="headerlink" title="32. vue如何监听对象或者数组某个属性的变化"></a>32. vue如何监听对象或者数组某个属性的变化</h3><p>当在项目中直接设置数组的某一项的值，或者直接设置对象的某个属性值，这个时候，你会发现页面并没有更新。这是因为Object.defineProperty()限制，监听不到变化。</p><p>解决方式：</p><ul><li>this.$set(你要改变的数组/对象，你要改变的位置/key，你要改成什么value)</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.$set(<span class="variable language_">this</span>.<span class="property">arr</span>, <span class="number">0</span>, <span class="string">&quot;OBKoro1&quot;</span>); <span class="comment">// 改变数组this.$set(this.obj, &quot;c&quot;, &quot;OBKoro1&quot;); // 改变对象</span></span><br></pre></td></tr></table></figure><ul><li>调用以下几个数组的方法</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">splice</span>()、 <span class="title function_">push</span>()、<span class="title function_">pop</span>()、<span class="title function_">shift</span>()、<span class="title function_">unshift</span>()、<span class="title function_">sort</span>()、<span class="title function_">reverse</span>()</span><br></pre></td></tr></table></figure><p>vue源码里缓存了array的原型链，然后重写了这几个方法，触发这几个方法的时候会observer数据，意思是使用这些方法不用再进行额外的操作，视图自动进行更新。 推荐使用splice方法会比较好自定义,因为splice可以在数组的任何位置进行删除/添加操作</p><p>vm.<code>$set</code> 的实现原理是：</p><ul><li>如果目标是数组，直接使用数组的 splice 方法触发相应式；</li><li>如果目标是对象，会先判读属性是否存在、对象是否是响应式，最终如果要对属性进行响应式处理，则是通过调用 defineReactive 方法进行响应式处理（ defineReactive 方法就是 Vue 在初始化对象时，给对象属性采用 Object.defineProperty 动态添加 getter 和 setter 的功能所调用的方法）</li></ul><h3 id="33-什么是-mixin-？"><a href="#33-什么是-mixin-？" class="headerlink" title="33. 什么是 mixin ？"></a>33. 什么是 mixin ？</h3><ul><li>Mixin 使我们能够为 Vue 组件编写可插拔和可重用的功能。</li><li>如果希望在多个组件之间重用一组组件选项，例如生命周期 hook、 方法等，则可以将其编写为 mixin，并在组件中简单的引用它。</li><li>然后将 mixin 的内容合并到组件中。如果你要在 mixin 中定义生命周期 hook，那么它在执行时将优化于组件自已的 hook。</li></ul><h3 id="34-Vue模版编译原理"><a href="#34-Vue模版编译原理" class="headerlink" title="34. Vue模版编译原理"></a>34. Vue模版编译原理</h3><p>vue中的模板template无法被浏览器解析并渲染，因为这不属于浏览器的标准，不是正确的HTML语法，所有需要将template转化成一个JavaScript函数，这样浏览器就可以执行这一个函数并渲染出对应的HTML元素，就可以让视图跑起来了，这一个转化的过程，就成为模板编译。模板编译又分三个阶段，解析parse，优化optimize，生成generate，最终生成可执行函数render。</p><ul><li><strong>解析阶段</strong>：使用大量的正则表达式对template字符串进行解析，将标签、指令、属性等转化为抽象语法树AST。</li><li><strong>优化阶段</strong>：遍历AST，找到其中的一些静态节点并进行标记，方便在页面重渲染的时候进行diff比较时，直接跳过这一些静态节点，优化runtime的性能。</li><li><strong>生成阶段</strong>：将最终的AST转化为render函数字符串。</li></ul><h3 id="35-对SSR的理解"><a href="#35-对SSR的理解" class="headerlink" title="35. 对SSR的理解"></a>35. 对SSR的理解</h3><p>SSR也就是服务端渲染，也就是将Vue在客户端把标签渲染成HTML的工作放在服务端完成，然后再把html直接返回给客户端</p><p>SSR的优势：</p><ul><li>更好的SEO</li><li>首屏加载速度更快</li></ul><p>SSR的缺点：</p><ul><li>开发条件会受到限制，服务器端渲染只支持beforeCreate和created两个钩子；</li><li>当需要一些外部扩展库时需要特殊处理，服务端渲染应用程序也需要处于Node.js的运行环境；</li><li>更多的服务端负载。</li></ul><h3 id="36-Vue的性能优化有哪些"><a href="#36-Vue的性能优化有哪些" class="headerlink" title="36. Vue的性能优化有哪些"></a>36. Vue的性能优化有哪些</h3><p><strong>（1）编码阶段</strong></p><ul><li>尽量减少data中的数据，data中的数据都会增加getter和setter，会收集对应的watcher</li><li>v-if和v-for不能连用</li><li>如果需要使用v-for给每项元素绑定事件时使用事件代理</li><li>SPA 页面采用keep-alive缓存组件</li><li>在更多的情况下，使用v-if替代v-show</li><li>key保证唯一</li><li>使用路由懒加载、异步组件</li><li>防抖、节流</li><li>第三方模块按需导入</li><li>长列表滚动到可视区域动态加载</li><li>图片懒加载</li></ul><p><strong>（2）SEO优化</strong></p><ul><li>预渲染</li><li>服务端渲染SSR</li></ul><p><strong>（3）打包优化</strong></p><ul><li>压缩代码</li><li>Tree Shaking/Scope Hoisting</li><li>使用cdn加载第三方模块</li><li>多线程打包happypack</li><li>splitChunks抽离公共文件</li><li>sourceMap优化</li></ul><p><strong>（4）用户体验</strong></p><ul><li>骨架屏</li><li>PWA</li><li>还可以使用缓存(客户端缓存、服务端缓存)优化、服务端开启gzip压缩等。</li></ul><h3 id="37-对-SPA-单页面的理解，它的优缺点分别是什么？"><a href="#37-对-SPA-单页面的理解，它的优缺点分别是什么？" class="headerlink" title="37. 对 SPA 单页面的理解，它的优缺点分别是什么？"></a>37. 对 SPA 单页面的理解，它的优缺点分别是什么？</h3><p>SPA（ single-page application ）仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。</p><p><strong>优点：</strong></p><ul><li>用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；</li><li>基于上面一点，SPA 相对对服务器压力小；</li><li>前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；</li></ul><p><strong>缺点：</strong></p><ul><li>初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载；</li><li>前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；</li><li>SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。</li></ul><h3 id="38-template和jsx的有什么分别？"><a href="#38-template和jsx的有什么分别？" class="headerlink" title="38. template和jsx的有什么分别？"></a>38. template和jsx的有什么分别？</h3><p>对于 runtime 来说，只需要保证组件存在 render 函数即可，而有了预编译之后，只需要保证构建过程中生成 render 函数就可以。在 webpack 中，使用<code>vue-loader</code>编译.vue文件，内部依赖的<code>vue-template-compiler</code>模块，在 webpack 构建过程中，将template预编译成 render 函数。与 react 类似，在添加了jsx的语法糖解析器<code>babel-plugin-transform-vue-jsx</code>之后，就可以直接手写render函数。</p><p>所以，template和jsx的都是render的一种表现形式，不同的是：JSX相对于template而言，具有更高的灵活性，在复杂的组件中，更具有优势，而 template 虽然显得有些呆滞。但是 template 在代码结构上更符合视图与逻辑分离的习惯，更简单、更直观、更好维护。</p><h3 id="39-vue初始化页面闪动问题"><a href="#39-vue初始化页面闪动问题" class="headerlink" title="39. vue初始化页面闪动问题"></a>39. vue初始化页面闪动问题</h3><p>使用vue开发时，在vue初始化之前，由于div是不归vue管的，所以我们写的代码在还没有解析的情况下会容易出现花屏现象，看到类似于的字样，虽然一般情况下这个时间很短暂，但是还是有必要让解决这个问题的。</p><p>首先：在css里加上以下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[v-cloak] &#123;    <span class="attr">display</span>: none;&#125;</span><br></pre></td></tr></table></figure><p>如果没有彻底解决问题，则在根元素加上<code>style=&quot;display: none;&quot; :style=&quot;&#123;display: &#39;block&#39;&#125;&quot;</code></p><h3 id="40-extend-有什么作用"><a href="#40-extend-有什么作用" class="headerlink" title="40. extend 有什么作用"></a>40. extend 有什么作用</h3><p>这个 API 很少用到，作用是扩展组件生成一个构造器，通常会与 <code>$mount</code> 一起使用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建组件构造器let Component = Vue.extend(&#123;  template: &#x27;&lt;div&gt;test&lt;/div&gt;&#x27;&#125;)// 挂载到 #app 上new Component().$mount(&#x27;#app&#x27;)// 除了上面的方式，还可以用来扩展已有的组件let SuperComponent = Vue.extend(Component)new SuperComponent(&#123;    created() &#123;        console.log(1)    &#125;&#125;)new SuperComponent().$mount(&#x27;#app&#x27;)</span></span><br></pre></td></tr></table></figure><h3 id="42-MVVM的优缺点"><a href="#42-MVVM的优缺点" class="headerlink" title="42. MVVM的优缺点?"></a>42. <strong>MVVM</strong>的优缺点?</h3><p>优点:</p><ul><li>分离视图（View）和模型（Model），降低代码耦合，提⾼视图或者逻辑的重⽤性: ⽐如视图（View）可以独⽴于Model变化和修改，⼀个ViewModel可以绑定不同的”View”上，当View变化的时候Model不可以不变，当Model变化的时候View也可以不变。你可以把⼀些视图逻辑放在⼀个ViewModel⾥⾯，让很多view重⽤这段视图逻辑</li><li>提⾼可测试性: ViewModel的存在可以帮助开发者更好地编写测试代码</li><li>⾃动更新dom: 利⽤双向绑定,数据更新后视图⾃动更新,让开发者从繁琐的⼿动dom中解放</li></ul><p>缺点:</p><ul><li>Bug很难被调试: 因为使⽤双向绑定的模式，当你看到界⾯异常了，有可能是你View的代码有Bug，也可能是Model的代码有问题。数据绑定使得⼀个位置的Bug被快速传递到别的位置，要定位原始出问题的地⽅就变得不那么容易了。另外，数据绑定的声明是指令式地写在View的模版当中的，这些内容是没办法去打断点debug的</li><li>⼀个⼤的模块中model也会很⼤，虽然使⽤⽅便了也很容易保证了数据的⼀致性，当时⻓期持有，不释放内存就造成了花费更多的内存</li><li>对于⼤型的图形应⽤程序，视图状态较多，ViewModel的构建和维护的成本都会⽐较⾼。</li></ul><h2 id="二、生命周期"><a href="#二、生命周期" class="headerlink" title="二、生命周期"></a>二、生命周期</h2><h3 id="1-说一下Vue的生命周期"><a href="#1-说一下Vue的生命周期" class="headerlink" title="1. 说一下Vue的生命周期"></a>1. 说一下Vue的生命周期</h3><p>Vue 实例有⼀个完整的⽣命周期，也就是从开始创建、初始化数据、编译模版、挂载Dom -&gt; 渲染、更新 -&gt; 渲染、卸载 等⼀系列过程，称这是Vue的⽣命周期。</p><ol><li><strong>beforeCreate（创建前）</strong>：数据观测和初始化事件还未开始，此时 data 的响应式追踪、event/watcher 都还没有被设置，也就是说不能访问到data、computed、watch、methods上的方法和数据。</li><li><strong>created（创建后）</strong> ：实例创建完成，实例上配置的 options 包括 data、computed、watch、methods 等都配置完成，但是此时渲染得节点还未挂载到 DOM，所以不能访问到 <code>$el</code> 属性。</li><li><strong>beforeMount（挂载前）</strong>：在挂载开始之前被调用，相关的render函数首次被调用。实例已完成以下的配置：编译模板，把data里面的数据和模板生成html。此时还没有挂载html到页面上。</li><li><strong>mounted（挂载后）</strong>：在el被新创建的 vm.$el 替换，并挂载到实例上去之后调用。实例已完成以下的配置：用上面编译好的html内容替换el属性指向的DOM对象。完成模板中的html渲染到html 页面中。此过程中进行ajax交互。</li><li><strong>beforeUpdate（更新前）</strong>：响应式数据更新时调用，此时虽然响应式数据更新了，但是对应的真实 DOM 还没有被渲染。</li><li><strong>updated（更新后）</strong> ：在由于数据更改导致的虚拟DOM重新渲染和打补丁之后调用。此时 DOM 已经根据响应式数据的变化更新了。调用时，组件 DOM已经更新，所以可以执行依赖于DOM的操作。然而在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。</li><li><strong>beforeDestroy（销毁前）</strong>：实例销毁之前调用。这一步，实例仍然完全可用，<code>this</code> 仍能获取到实例。</li><li><strong>destroyed（销毁后）</strong>：实例销毁后调用，调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务端渲染期间不被调用。</li></ol><p>另外还有 <code>keep-alive</code> 独有的生命周期，分别为 <code>activated</code> 和 <code>deactivated</code> 。用 <code>keep-alive</code> 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 <code>deactivated</code> 钩子函数，命中缓存渲染后会执行 <code>activated</code> 钩子函数。</p><h3 id="2-Vue-子组件和父组件执行顺序"><a href="#2-Vue-子组件和父组件执行顺序" class="headerlink" title="2. Vue 子组件和父组件执行顺序"></a>2. Vue 子组件和父组件执行顺序</h3><p><strong>加载渲染过程：</strong></p><ol><li>父组件 beforeCreate</li><li>父组件 created</li><li>父组件 beforeMount</li><li>子组件 beforeCreate</li><li>子组件 created</li><li>子组件 beforeMount</li><li>子组件 mounted</li><li>父组件 mounted</li></ol><p><strong>更新过程：</strong></p><ol><li>父组件 beforeUpdate</li><li>子组件 beforeUpdate</li><li>子组件 updated</li><li>父组件 updated</li></ol><p><strong>销毁过程：</strong></p><ol><li>父组件 beforeDestroy</li><li>子组件 beforeDestroy</li><li>子组件 destroyed</li><li>父组件 destoryed</li></ol><h3 id="3-created和mounted的区别"><a href="#3-created和mounted的区别" class="headerlink" title="3. created和mounted的区别"></a>3. created和mounted的区别</h3><ul><li>created:在模板渲染成html前调用，即通常初始化某些属性值，然后再渲染成视图。</li><li>mounted:在模板渲染成html后调用，通常是初始化页面完成后，再对html的dom节点进行一些需要的操作。</li></ul><h3 id="4-一般在哪个生命周期请求异步数据"><a href="#4-一般在哪个生命周期请求异步数据" class="headerlink" title="4. 一般在哪个生命周期请求异步数据"></a>4. 一般在哪个生命周期请求异步数据</h3><p>我们可以在钩子函数 created、beforeMount、mounted 中进行调用，因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。 </p><p>推荐在 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点：</p><ul><li>能更快获取到服务端数据，减少页面加载时间，用户体验更好；</li><li>SSR不支持 beforeMount 、mounted 钩子函数，放在 created 中有助于一致性。</li></ul><h3 id="5-keep-alive-中的生命周期哪些"><a href="#5-keep-alive-中的生命周期哪些" class="headerlink" title="5. keep-alive 中的生命周期哪些"></a>5. keep-alive 中的生命周期哪些</h3><p>keep-alive是 Vue 提供的一个内置组件，用来对组件进行缓存——在组件切换过程中将状态保留在内存中，防止重复渲染DOM。</p><p>如果为一个组件包裹了 keep-alive，那么它会多出两个生命周期：deactivated、activated。同时，beforeDestroy 和 destroyed 就不会再被触发了，因为组件不会被真正销毁。</p><p>当组件被换掉时，会被缓存到内存中、触发 deactivated 生命周期；当组件被切回来时，再去缓存里找这个组件、触发 activated钩子函数。</p><h2 id="三、组件通信"><a href="#三、组件通信" class="headerlink" title="三、组件通信"></a>三、组件通信</h2><p>组件通信的方式如下：</p><h3 id="（1）-props-emit"><a href="#（1）-props-emit" class="headerlink" title="（1） props  /  $emit"></a>（1） props  /  $emit</h3><p>父组件通过<code>props</code>向子组件传递数据，子组件通过<code>$emit</code>和父组件通信</p><h5 id="1-父组件向子组件传值"><a href="#1-父组件向子组件传值" class="headerlink" title="1. 父组件向子组件传值"></a>1. 父组件向子组件传值</h5><ul><li><code>props</code>只能是父组件向子组件进行传值，<code>props</code>使得父子组件之间形成了一个单向下行绑定。子组件的数据会随着父组件不断更新。</li><li><code>props</code> 可以显示定义一个或一个以上的数据，对于接收的数据，可以是各种数据类型，同样也可以传递一个函数。</li><li><code>props</code>属性名规则：若在<code>props</code>中使用驼峰形式，模板中需要使用短横线的形式</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父组件</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;father&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">son</span> <span class="attr">:msg</span>=<span class="string">&quot;msgData&quot;</span> <span class="attr">:fn</span>=<span class="string">&quot;myFunction&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">son</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> son <span class="keyword">from</span> <span class="string">&quot;./son.vue&quot;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">name</span>: father,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">msgData</span>: <span class="string">&quot;父组件数据&quot;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">methods</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="title function_">myFunction</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;vue&quot;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">components</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        son</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="comment">// 子组件</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;son&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;fn&quot;</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">name</span>: <span class="string">&quot;son&quot;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">props</span>: [<span class="string">&quot;msg&quot;</span>, <span class="string">&quot;fn&quot;</span>]</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h5 id="2-子组件向父组件传值"><a href="#2-子组件向父组件传值" class="headerlink" title="2. 子组件向父组件传值"></a>2. 子组件向父组件传值</h5><ul><li><code>$emit</code>绑定一个自定义事件，当这个事件被执行的时就会将参数传递给父组件，而父组件通过<code>v-on</code>监听并接收参数。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父组件</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;section&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">com-article</span> <span class="attr">:articles</span>=<span class="string">&quot;articleList&quot;</span> @<span class="attr">onEmitIndex</span>=<span class="string">&quot;onEmitIndex&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">com-article</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;currentIndex&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> comArticle <span class="keyword">from</span> <span class="string">&#x27;./test/article.vue&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">name</span>: <span class="string">&#x27;comArticle&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">components</span>: &#123; comArticle &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">currentIndex</span>: -<span class="number">1</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">articleList</span>: [<span class="string">&#x27;红楼梦&#x27;</span>, <span class="string">&#x27;西游记&#x27;</span>, <span class="string">&#x27;三国演义&#x27;</span>]</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">methods</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">onEmitIndex</span>(<span class="params">idx</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">this</span>.<span class="property">currentIndex</span> = idx</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="comment">//子组件</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">&quot;(item, index) in articles&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;index&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;emitIndex(index)&quot;</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">props</span>: [<span class="string">&#x27;articles&#x27;</span>],</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">methods</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">emitIndex</span>(<span class="params">index</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">this</span>.$emit(<span class="string">&#x27;onEmitIndex&#x27;</span>, index) <span class="comment">// 触发父组件的方法，并传递参数index</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="（2）eventBus事件总线（-emit-on）"><a href="#（2）eventBus事件总线（-emit-on）" class="headerlink" title="（2）eventBus事件总线（$emit / $on）"></a>（2）eventBus事件总线（<code>$emit / $on</code>）</h3><p><code>eventBus</code>事件总线适用于<strong>父子组件</strong>、<strong>非父子组件</strong>等之间的通信，使用步骤如下： <strong>（1）创建事件中心管理组件之间的通信</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// event-bus.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">EventBus</span> = <span class="keyword">new</span> <span class="title class_">Vue</span>()</span><br></pre></td></tr></table></figure><p><strong>（2）发送事件</strong> 假设有两个兄弟组件<code>firstCom</code>和<code>secondCom</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">first-com</span>&gt;</span><span class="tag">&lt;/<span class="name">first-com</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">second-com</span>&gt;</span><span class="tag">&lt;/<span class="name">second-com</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> firstCom <span class="keyword">from</span> <span class="string">&#x27;./firstCom.vue&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> secondCom <span class="keyword">from</span> <span class="string">&#x27;./secondCom.vue&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">components</span>: &#123; firstCom, secondCom &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>在<code>firstCom</code>组件中发送事件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;add&quot;</span>&gt;</span>加法<span class="tag">&lt;/<span class="name">button</span>&gt;</span>    </span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> &#123;<span class="title class_">EventBus</span>&#125; <span class="keyword">from</span> <span class="string">&#x27;./event-bus.js&#x27;</span> <span class="comment">// 引入事件中心</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">data</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">return</span>&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">num</span>:<span class="number">0</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">methods</span>:&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">add</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="title class_">EventBus</span>.$emit(<span class="string">&#x27;addition&#x27;</span>, &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">num</span>:<span class="variable language_">this</span>.<span class="property">num</span>++</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p><strong>（3）接收事件</strong> 在<code>secondCom</code>组件中发送事件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>求和: &#123;&#123;count&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> &#123; <span class="title class_">EventBus</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./event-bus.js&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">count</span>: <span class="number">0</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title class_">EventBus</span>.$on(<span class="string">&#x27;addition&#x27;</span>, <span class="function"><span class="params">param</span> =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">this</span>.<span class="property">count</span> = <span class="variable language_">this</span>.<span class="property">count</span> + param.<span class="property">num</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>在上述代码中，这就相当于将<code>num</code>值存贮在了事件总线中，在其他组件中可以直接访问。事件总线就相当于一个桥梁，不用组件通过它来通信。</p><p>虽然看起来比较简单，但是这种方法也有不变之处，如果项目过大，使用这种方式进行通信，后期维护起来会很困难。</p><h3 id="（3）依赖注入（provide-inject）"><a href="#（3）依赖注入（provide-inject）" class="headerlink" title="（3）依赖注入（provide / inject）"></a>（3）依赖注入（provide / inject）</h3><p>这种方式就是Vue中的<strong>依赖注入</strong>，该方法用于<strong>父子组件之间的通信</strong>。当然这里所说的父子不一定是真正的父子，也可以是祖孙组件，在层数很深的情况下，可以使用这种方法来进行传值。就不用一层一层的传递了。</p><p><code>provide / inject</code>是Vue提供的两个钩子，和<code>data</code>、<code>methods</code>是同级的。并且<code>provide</code>的书写形式和<code>data</code>一样。</p><ul><li><code>provide</code> 钩子用来发送数据或方法</li><li><code>inject</code>钩子用来接收数据或方法</li></ul><p>在父组件中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">provide</span>(<span class="params"></span>) &#123; </span><br><span class="line">    <span class="keyword">return</span> &#123;     </span><br><span class="line">        <span class="attr">num</span>: <span class="variable language_">this</span>.<span class="property">num</span>  </span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在子组件中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">inject</span>: [<span class="string">&#x27;num&#x27;</span>]</span><br></pre></td></tr></table></figure><p>还可以这样写，这样写就可以访问父组件中的所有属性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">provide</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">app</span>: <span class="variable language_">this</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">num</span>: <span class="number">1</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attr">inject</span>: [<span class="string">&#x27;app&#x27;</span>]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">app</span>.<span class="property">num</span>)</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 依赖注入所提供的属性是<strong>非响应式</strong>的。</p><h3 id="（3）ref-refs"><a href="#（3）ref-refs" class="headerlink" title="（3）ref / $refs"></a>（3）ref / $refs</h3><p>这种方式也是实现<strong>父子组件</strong>之间的通信。</p><p><code>ref</code>： 这个属性用在子组件上，它的引用就指向了子组件的实例。可以通过实例来访问组件的数据和方法。</p><p>在子组件中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;JavaScript&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    sayHello () &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在父组件中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">child</span> <span class="attr">ref</span>=<span class="string">&quot;child&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component-a</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">import</span> child <span class="keyword">from</span> <span class="string">&#x27;./child.vue&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">components</span>: &#123; child &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    mounted () &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">child</span>.<span class="property">name</span>);  <span class="comment">// JavaScript</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">child</span>.<span class="title function_">sayHello</span>();  <span class="comment">// hello</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="（4）-parent-children"><a href="#（4）-parent-children" class="headerlink" title="（4）$parent / $children"></a>（4）<code>$parent / $children</code></h3><ul><li>使用<code>$parent</code>可以让组件访问父组件的实例（访问的是上一级父组件的属性和方法）</li><li>使用<code>$children</code>可以让组件访问子组件的实例，但是，<code>$children</code>并不能保证顺序，并且访问的数据也不是响应式的。</li></ul><p>在子组件中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>获取父组件的值为:  &#123;&#123;parentVal&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">message</span>: <span class="string">&#x27;Vue&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">computed</span>:&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">parentVal</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">$parent</span>.<span class="property">msg</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>在父组件中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父组件中</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;hello_world&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">child</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;change&quot;</span>&gt;</span>点击改变子组件值<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> child <span class="keyword">from</span> <span class="string">&#x27;./child.vue&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">components</span>: &#123; child &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">msg</span>: <span class="string">&#x27;Welcome&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">methods</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">change</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="comment">// 获取到子组件</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">this</span>.<span class="property">$children</span>[<span class="number">0</span>].<span class="property">message</span> = <span class="string">&#x27;JavaScript&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>在上面的代码中，子组件获取到了父组件的<code>parentVal</code>值，父组件改变了子组件中<code>message</code>的值。 <strong>需要注意：</strong></p><ul><li>通过<code>$parent</code>访问到的是上一级父组件的实例，可以使用<code>$root</code>来访问根组件的实例</li><li>在组件中使用<code>$children</code>拿到的是所有的子组件的实例，它是一个数组，并且是无序的</li><li>在根组件<code>#app</code>上拿<code>$parent</code>得到的是<code>new Vue()</code>的实例，在这实例上再拿<code>$parent</code>得到的是<code>undefined</code>，而在最底层的子组件拿<code>$children</code>是个空数组</li><li><code>$children</code> 的值是<strong>数组</strong>，而<code>$parent</code>是个<strong>对象</strong></li></ul><h3 id="（5）-attrs-listeners"><a href="#（5）-attrs-listeners" class="headerlink" title="（5）$attrs / $listeners"></a>（5）<code>$attrs / $listeners</code></h3><p>考虑一种场景，如果A是B组件的父组件，B是C组件的父组件。如果想要组件A给组件C传递数据，这种隔代的数据，该使用哪种方式呢？</p><p>如果是用<code>props/$emit</code>来一级一级的传递，确实可以完成，但是比较复杂；如果使用事件总线，在多人开发或者项目较大的时候，维护起来很麻烦；如果使用Vuex，的确也可以，但是如果仅仅是传递数据，那可能就有点浪费了。</p><p>针对上述情况，Vue引入了<code>$attrs / $listeners</code>，实现组件之间的跨代通信。</p><p>先来看一下<code>inheritAttrs</code>，它的默认值true，继承所有的父组件属性除<code>props</code>之外的所有属性；<code>inheritAttrs：false</code> 只继承class属性 。</p><ul><li><code>$attrs</code>：继承所有的父组件属性（除了prop传递的属性、class 和 style ），一般用在子组件的子元素上</li><li><code>$listeners</code>：该属性是一个对象，里面包含了作用在这个组件上的所有监听器，可以配合 <code>v-on=&quot;$listeners&quot;</code> 将所有的事件监听器指向这个组件的某个特定的子元素。（相当于子组件继承父组件的事件）</li></ul><p>A组件（<code>APP.vue</code>）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        //此处监听了两个事件，可以在B组件或者C组件中直接触发 </span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">child1</span> <span class="attr">:p-child1</span>=<span class="string">&quot;child1&quot;</span> <span class="attr">:p-child2</span>=<span class="string">&quot;child2&quot;</span> @<span class="attr">test1</span>=<span class="string">&quot;onTest1&quot;</span> @<span class="attr">test2</span>=<span class="string">&quot;onTest2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">child1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> <span class="title class_">Child1</span> <span class="keyword">from</span> <span class="string">&#x27;./Child1.vue&#x27;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">components</span>: &#123; <span class="title class_">Child1</span> &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">methods</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="title function_">onTest1</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;test1 running&#x27;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="title function_">onTest2</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;test2 running&#x27;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>B组件（<code>Child1.vue</code>）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child-1&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>props: &#123;&#123;pChild1&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>$attrs: &#123;&#123;$attrs&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">child2</span> <span class="attr">v-bind</span>=<span class="string">&quot;$attrs&quot;</span> <span class="attr">v-on</span>=<span class="string">&quot;$listeners&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">child2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> <span class="title class_">Child2</span> <span class="keyword">from</span> <span class="string">&#x27;./Child2.vue&#x27;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">props</span>: [<span class="string">&#x27;pChild1&#x27;</span>],</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">components</span>: &#123; <span class="title class_">Child2</span> &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">inheritAttrs</span>: <span class="literal">false</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">this</span>.$emit(<span class="string">&#x27;test1&#x27;</span>); <span class="comment">// 触发APP.vue中的test1方法</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>C 组件 (<code>Child2.vue</code>)：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child-2&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>props: &#123;&#123;pChild2&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>$attrs: &#123;&#123;$attrs&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">props</span>: [<span class="string">&#x27;pChild2&#x27;</span>],</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">inheritAttrs</span>: <span class="literal">false</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">this</span>.$emit(<span class="string">&#x27;test2&#x27;</span>);<span class="comment">// 触发APP.vue中的test2方法</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>在上述代码中：</p><ul><li>C组件中能直接触发test的原因在于 B组件调用C组件时 使用 v-on 绑定了<code>$listeners</code> 属性</li><li>在B组件中通过v-bind 绑定<code>$attrs</code>属性，C组件可以直接获取到A组件中传递下来的props（除了B组件中props声明的）</li></ul><h3 id="（6）总结"><a href="#（6）总结" class="headerlink" title="（6）总结"></a>（6）总结</h3><p><strong>（1）父子组件间通信</strong></p><ul><li>子组件通过 props 属性来接受父组件的数据，然后父组件在子组件上注册监听事件，子组件通过 emit 触发事件来向父组件发送数据。</li><li>通过 ref 属性给子组件设置一个名字。父组件通过 <code>$refs</code> 组件名来获得子组件，子组件通过 <code>$parent</code> 获得父组件，这样也可以实现通信。</li><li>使用 provide/inject，在父组件中通过 provide提供变量，在子组件中通过 inject 来将变量注入到组件中。不论子组件有多深，只要调用了 inject 那么就可以注入 provide中的数据。</li></ul><p><strong>（2）兄弟组件间通信</strong></p><ul><li>使用 eventBus 的方法，它的本质是通过创建一个空的 Vue 实例来作为消息传递的对象，通信的组件引入这个实例，通信的组件通过在这个实例上监听和触发事件，来实现消息的传递。</li><li>通过 <code>$parent/$refs</code> 来获取到兄弟组件，也可以进行通信。</li></ul><p><strong>（3）任意组件之间</strong></p><ul><li>使用 eventBus ，其实就是创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件。</li></ul><p>如果业务逻辑复杂，很多组件之间需要同时处理一些公共的数据，这个时候采用上面这一些方法可能不利于项目的维护。这个时候可以使用 vuex ，vuex 的思想就是将这一些公共的数据抽离出来，将它作为一个全局的变量来管理，然后其他组件就可以对这个公共数据进行读写操作，这样达到了解耦的目的。</p><h2 id="四、路由"><a href="#四、路由" class="headerlink" title="四、路由"></a>四、路由</h2><h3 id="1-Vue-Router-的懒加载如何实现"><a href="#1-Vue-Router-的懒加载如何实现" class="headerlink" title="1. Vue-Router 的懒加载如何实现"></a>1. Vue-Router 的懒加载如何实现</h3><p>非懒加载：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">List</span> <span class="keyword">from</span> <span class="string">&#x27;@/components/list.vue&#x27;</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;/list&#x27;</span>, <span class="attr">component</span>: <span class="title class_">List</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>（1）方案一(常用)：使用箭头函数+import动态加载</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">List</span> = (<span class="params"></span>) =&gt; <span class="title function_">import</span>(<span class="string">&#x27;@/components/list.vue&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;/list&#x27;</span>, <span class="attr">component</span>: <span class="title class_">List</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>（2）方案二：使用箭头函数+require动态加载</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">Router</span>(&#123;</span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="attr">path</span>: <span class="string">&#x27;/list&#x27;</span>,</span><br><span class="line">     <span class="attr">component</span>: <span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">require</span>([<span class="string">&#x27;@/components/list&#x27;</span>], resolve)</span><br><span class="line">   &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>（3）方案三：使用webpack的require.ensure技术，也可以实现按需加载。 这种情况下，多个路由指定相同的chunkName，会合并打包成一个js文件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// r就是resolve</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">List</span> = r =&gt; <span class="built_in">require</span>.<span class="title function_">ensure</span>([], <span class="function">() =&gt;</span> <span class="title function_">r</span>(<span class="built_in">require</span>(<span class="string">&#x27;@/components/list&#x27;</span>)), <span class="string">&#x27;list&#x27;</span>);</span><br><span class="line"><span class="comment">// 路由也是正常的写法  这种是官方推荐的写的 按模块划分懒加载 </span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">Router</span>(&#123;</span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/list&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="title class_">List</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;list&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line"> ]</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure><h3 id="2-路由的hash和history模式的区别"><a href="#2-路由的hash和history模式的区别" class="headerlink" title="2. 路由的hash和history模式的区别"></a>2. 路由的hash和history模式的区别</h3><p>Vue-Router有两种模式：<strong>hash模式</strong>和<strong>history模式</strong>。默认的路由模式是hash模式。</p><h4 id="1-hash模式"><a href="#1-hash模式" class="headerlink" title="1. hash模式"></a>1. hash模式</h4><p><strong>简介：</strong> hash模式是开发中默认的模式，它的URL带着一个#，例如：<a href="https://link.juejin.cn/?target=http://www.abc.com/%23/vue">www.abc.com/#/vue</a>，它的hash值就是<code>#/vue</code>。</p><p><strong>特点</strong>：hash值会出现在URL里面，但是不会出现在HTTP请求中，对后端完全没有影响。所以改变hash值，不会重新加载页面。这种模式的浏览器支持度很好，低版本的IE浏览器也支持这种模式。hash路由被称为是前端路由，已经成为SPA（单页面应用）的标配。</p><p><strong>原理：</strong> hash模式的主要原理就是<strong>onhashchange()事件</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">onhashchange</span> = <span class="keyword">function</span>(<span class="params">event</span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">oldURL</span>, event.<span class="property">newURL</span>);</span><br><span class="line"><span class="keyword">let</span> hash = location.<span class="property">hash</span>.<span class="title function_">slice</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用onhashchange()事件的好处就是，在页面的hash值发生变化时，无需向后端发起请求，window就可以监听事件的改变，并按规则加载相应的代码。除此之外，hash值变化对应的URL都会被浏览器记录下来，这样浏览器就能实现页面的前进和后退。虽然是没有请求后端服务器，但是页面的hash值和对应的URL关联起来了。</p><h4 id="2-history模式"><a href="#2-history模式" class="headerlink" title="2. history模式"></a>2. history模式</h4><p><strong>简介：</strong> history模式的URL中没有#，它使用的是传统的路由分发模式，即用户在输入一个URL时，服务器会接收这个请求，并解析这个URL，然后做出相应的逻辑处理。 <strong>特点：</strong> 当使用history模式时，URL就像这样：<a href="https://link.juejin.cn/?target=http://abc.com/user/id">abc.com/user/id</a>。相比hash模式更加好看。但是，history模式需要后台配置支持。如果后台没有正确配置，访问时会返回404。 <strong>API：</strong> history api可以分为两大部分，切换历史状态和修改历史状态：</p><ul><li><strong>修改历史状态</strong>：包括了 HTML5 History Interface 中新增的 <code>pushState()</code> 和 <code>replaceState()</code> 方法，这两个方法应用于浏览器的历史记录栈，提供了对历史记录进行修改的功能。只是当他们进行修改时，虽然修改了url，但浏览器不会立即向后端发送请求。如果要做到改变url但又不刷新页面的效果，就需要前端用上这两个API。</li><li><strong>切换历史状态：</strong> 包括<code>forward()</code>、<code>back()</code>、<code>go()</code>三个方法，对应浏览器的前进，后退，跳转操作。</li></ul><p>虽然history模式丢弃了丑陋的#。但是，它也有自己的缺点，就是在刷新页面的时候，如果没有相应的路由或资源，就会刷出404来。</p><p>如果想要切换到history模式，就要进行以下配置（后端也要进行配置）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&#x27;history&#x27;</span>,</span><br><span class="line">  <span class="attr">routes</span>: [...]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="3-两种模式对比"><a href="#3-两种模式对比" class="headerlink" title="3. 两种模式对比"></a>3. 两种模式对比</h4><p>调用 history.pushState() 相比于直接修改 hash，存在以下优势:</p><ul><li>pushState() 设置的新 URL 可以是与当前 URL 同源的任意 URL；而 hash 只可修改 # 后面的部分，因此只能设置与当前 URL 同文档的 URL；</li><li>pushState() 设置的新 URL 可以与当前 URL 一模一样，这样也会把记录添加到栈中；而 hash 设置的新值必须与原来不一样才会触发动作将记录添加到栈中；</li><li>pushState() 通过 stateObject 参数可以添加任意类型的数据到记录中；而 hash 只可添加短字符串；</li><li>pushState() 可额外设置 title 属性供后续使用。</li><li>hash模式下，仅hash符号之前的url会被包含在请求中，后端如果没有做到对路由的全覆盖，也不会返回404错误；history模式下，前端的url必须和实际向后端发起请求的url一致，如果没有对用的路由处理，将返回404错误。</li></ul><p>hash模式和history模式都有各自的优势和缺陷，还是要根据实际情况选择性的使用。</p><h3 id="3-如何获取页面的hash变化"><a href="#3-如何获取页面的hash变化" class="headerlink" title="3. 如何获取页面的hash变化"></a>3. 如何获取页面的hash变化</h3><p><strong>（1）监听$route的变化</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 监听,当路由发生变化的时候执行</span></span><br><span class="line"><span class="attr">watch</span>: &#123;</span><br><span class="line">  <span class="attr">$route</span>: &#123;</span><br><span class="line">    <span class="attr">handler</span>: <span class="keyword">function</span>(<span class="params">val, oldVal</span>)&#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(val);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 深度观察监听</span></span><br><span class="line">    <span class="attr">deep</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p><strong>（2）window.location.hash读取#值</strong> window.location.hash 的值可读可写，读取来判断状态是否改变，写入时可以在不重载网页的前提下，添加一条历史访问记录。</p><h3 id="4-route-和-router-的区别"><a href="#4-route-和-router-的区别" class="headerlink" title="4. $route 和$router 的区别"></a>4. <code>$route 和$router</code> 的区别</h3><ul><li>$route 是“路由信息对象”，包括 path，params，hash，query，fullPath，matched，name 等路由信息参数</li><li>$router 是“路由实例”对象包括了路由的跳转方法，钩子函数等。</li></ul><h3 id="5-如何定义动态路由？如何获取传过来的动态参数？"><a href="#5-如何定义动态路由？如何获取传过来的动态参数？" class="headerlink" title="5. 如何定义动态路由？如何获取传过来的动态参数？"></a>5. 如何定义动态路由？如何获取传过来的动态参数？</h3><p><strong>（1）param方式</strong></p><ul><li>配置路由格式：<code>/router/:id</code></li><li>传递的方式：在path后面跟上对应的值</li><li>传递后形成的路径：<code>/router/123</code></li></ul><p>1）路由定义</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在APP.vue中</span></span><br><span class="line">&lt;router-link :to=<span class="string">&quot;&#x27;/user/&#x27;+userId&quot;</span> replace&gt;用户&lt;/router-link&gt;    </span><br><span class="line"></span><br><span class="line"><span class="comment">//在index.js</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="attr">path</span>: <span class="string">&#x27;/user/:userid&#x27;</span>,</span><br><span class="line">   <span class="attr">component</span>: <span class="title class_">User</span>,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>2）路由跳转</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法1：</span></span><br><span class="line">&lt;router-link :to=<span class="string">&quot;&#123; name: &#x27;users&#x27;, params: &#123; uname: wade &#125;&#125;&quot;</span>&gt;按钮&lt;/router-link</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法2：</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(&#123;<span class="attr">name</span>:<span class="string">&#x27;users&#x27;</span>,<span class="attr">params</span>:&#123;<span class="attr">uname</span>:wade&#125;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法3：</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(<span class="string">&#x27;/user/&#x27;</span> + wade)</span><br></pre></td></tr></table></figure><p>3）参数获取 通过 <code>$route.params.userid</code> 获取传递的值</p><p><strong>（2）query方式</strong></p><ul><li>配置路由格式：<code>/router</code>，也就是普通配置</li><li>传递的方式：对象中使用query的key作为传递方式</li><li>传递后形成的路径：<code>/route?id=123</code></li></ul><p>1）路由定义</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式1：直接在router-link 标签上以对象的形式</span></span><br><span class="line">&lt;router-link :to=<span class="string">&quot;&#123;path:&#x27;/profile&#x27;,query:&#123;name:&#x27;why&#x27;,age:28,height:188&#125;&#125;&quot;</span>&gt;档案&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式2：写成按钮以点击事件形式</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&#x27;profileClick&#x27;</span>&gt;</span>我的<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>    </span><br><span class="line"></span><br><span class="line"><span class="title function_">profileClick</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&quot;/profile&quot;</span>,</span><br><span class="line">    <span class="attr">query</span>: &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&quot;kobi&quot;</span>,</span><br><span class="line">        <span class="attr">age</span>: <span class="string">&quot;28&quot;</span>,</span><br><span class="line">        <span class="attr">height</span>: <span class="number">198</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2）跳转方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法1：</span></span><br><span class="line">&lt;router-link :to=<span class="string">&quot;&#123; name: &#x27;users&#x27;, query: &#123; uname: james &#125;&#125;&quot;</span>&gt;按钮&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法2：</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;users&#x27;</span>, <span class="attr">query</span>:&#123; <span class="attr">uname</span>:james &#125;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法3：</span></span><br><span class="line">&lt;router-link :to=<span class="string">&quot;&#123; path: &#x27;/user&#x27;, query: &#123; uname:james &#125;&#125;&quot;</span>&gt;按钮&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法4：</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(&#123; <span class="attr">path</span>: <span class="string">&#x27;/user&#x27;</span>, <span class="attr">query</span>:&#123; <span class="attr">uname</span>:james &#125;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法5：</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(<span class="string">&#x27;/user?uname=&#x27;</span> + jsmes)</span><br></pre></td></tr></table></figure><p>3）获取参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通过$route.<span class="property">query</span> 获取传递的值</span><br></pre></td></tr></table></figure><h3 id="6-Vue-router-路由钩子在生命周期的体现"><a href="#6-Vue-router-路由钩子在生命周期的体现" class="headerlink" title="6. Vue-router 路由钩子在生命周期的体现"></a>6. Vue-router 路由钩子在生命周期的体现</h3><p>一、Vue-Router导航守卫</p><p>有的时候，需要通过路由来进行一些操作，比如最常见的登录权限验证，当用户满足条件时，才让其进入导航，否则就取消跳转，并跳到登录页面让其登录。 为此有很多种方法可以植入路由的导航过程：全局的，单个路由独享的，或者组件级的</p><ol><li>全局路由钩子</li></ol><p>vue-router全局有三个路由钩子;</p><ul><li>router.beforeEach 全局前置守卫 进入路由之前</li><li>router.beforeResolve 全局解析守卫（2.5.0+）在 beforeRouteEnter 调用之后调用</li><li>router.afterEach 全局后置钩子 进入路由之后</li></ul><p>具体使用∶</p><ul><li>beforeEach（判断是否登录了，没登录就跳转到登录页）</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">router.<span class="title function_">beforeEach</span>(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;  </span><br><span class="line">    <span class="keyword">let</span> ifInfo = <span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$common</span>.<span class="title function_">getSession</span>(<span class="string">&#x27;userData&#x27;</span>);  <span class="comment">// 判断是否登录的存储信息</span></span><br><span class="line">    <span class="keyword">if</span> (!ifInfo) &#123; </span><br><span class="line">        <span class="comment">// sessionStorage里没有储存user信息    </span></span><br><span class="line">        <span class="keyword">if</span> (to.<span class="property">path</span> == <span class="string">&#x27;/&#x27;</span>) &#123; </span><br><span class="line">            <span class="comment">//如果是登录页面路径，就直接next()      </span></span><br><span class="line">            <span class="title function_">next</span>();    </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">            <span class="comment">//不然就跳转到登录      </span></span><br><span class="line">            <span class="title class_">Message</span>.<span class="title function_">warning</span>(<span class="string">&quot;请重新登录！&quot;</span>);     </span><br><span class="line">            <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span> = <span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$loginUrl</span>;    </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;    </span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">next</span>();  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>afterEach （跳转之后滚动条回到顶部）</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">router.<span class="title function_">afterEach</span>(<span class="function">(<span class="params">to, <span class="keyword">from</span></span>) =&gt;</span> &#123;  </span><br><span class="line">    <span class="comment">// 跳转之后滚动条回到顶部  </span></span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">scrollTo</span>(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol><li>单个路由独享钩子</li></ol><p><strong>beforeEnter</strong> 如果不想全局配置守卫的话，可以为某些路由单独配置守卫，有三个参数∶ to、from、next</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> [    </span><br><span class="line">    &#123;        </span><br><span class="line">        <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>,        </span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;login&#x27;</span>,        </span><br><span class="line">        <span class="attr">component</span>: login,        </span><br><span class="line">        <span class="attr">beforeEnter</span>: <span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;          </span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;即将进入登录页面&#x27;</span>)          </span><br><span class="line">            <span class="title function_">next</span>()        </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><ol><li>组件内钩子</li></ol><p>beforeRouteUpdate、beforeRouteEnter、beforeRouteLeave</p><p>这三个钩子都有三个参数∶to、from、next</p><ul><li>beforeRouteEnter∶ 进入组件前触发</li><li>beforeRouteUpdate∶ 当前地址改变并且改组件被复用时触发，举例来说，带有动态参数的路径foo/∶id，在 /foo/1 和 /foo/2 之间跳转的时候，由于会渲染同样的foa组件，这个钩子在这种情况下就会被调用</li><li>beforeRouteLeave∶ 离开组件被调用</li></ul><p>注意点，beforeRouteEnter组件内还访问不到this，因为该守卫执行前组件实例还没有被创建，需要传一个回调给 next来访问，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">beforeRouteEnter</span>(<span class="params">to, <span class="keyword">from</span>, next</span>) &#123;      </span><br><span class="line">    <span class="title function_">next</span>(<span class="function"><span class="params">target</span> =&gt;</span> &#123;        </span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">from</span>.<span class="property">path</span> == <span class="string">&#x27;/classProcess&#x27;</span>) &#123;          </span><br><span class="line">            target.<span class="property">isFromProcess</span> = <span class="literal">true</span>        </span><br><span class="line">        &#125;      </span><br><span class="line">    &#125;)    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二、Vue路由钩子在生命周期函数的体现</p><ol><li>完整的路由导航解析流程（不包括其他生命周期）</li></ol><ul><li>触发进入其他路由。</li><li>调用要离开路由的组件守卫beforeRouteLeave</li><li>调用局前置守卫∶ beforeEach</li><li>在重用的组件里调用 beforeRouteUpdate</li><li>调用路由独享守卫 beforeEnter。</li><li>解析异步路由组件。</li><li>在将要进入的路由组件中调用 beforeRouteEnter</li><li>调用全局解析守卫 beforeResolve</li><li>导航被确认。</li><li>调用全局后置钩子的 afterEach 钩子。</li><li>触发DOM更新（mounted）。</li><li>执行beforeRouteEnter 守卫中传给 next 的回调函数</li></ul><ol><li>触发钩子的完整顺序</li></ol><p>路由导航、keep-alive、和组件生命周期钩子结合起来的，触发顺序，假设是从a组件离开，第一次进入b组件∶</p><ul><li>beforeRouteLeave：路由组件的组件离开路由前钩子，可取消路由离开。</li><li>beforeEach：路由全局前置守卫，可用于登录验证、全局路由loading等。</li><li>beforeEnter：路由独享守卫</li><li>beforeRouteEnter：路由组件的组件进入路由前钩子。</li><li>beforeResolve：路由全局解析守卫</li><li>afterEach：路由全局后置钩子</li><li>beforeCreate：组件生命周期，不能访问tAis。</li><li>created;组件生命周期，可以访问tAis，不能访问dom。</li><li>beforeMount：组件生命周期</li><li>deactivated：离开缓存组件a，或者触发a的beforeDestroy和destroyed组件销毁钩子。</li><li>mounted：访问/操作dom。</li><li>activated：进入缓存组件，进入a的嵌套子组件（如果有的话）。</li><li>执行beforeRouteEnter回调函数next。</li></ul><ol><li>导航行为被触发到导航完成的整个过程</li></ol><ul><li>导航行为被触发，此时导航未被确认。</li><li>在失活的组件里调用离开守卫 beforeRouteLeave。</li><li>调用全局的 beforeEach守卫。</li><li>在重用的组件里调用 beforeRouteUpdate 守卫(2.2+)。</li><li>在路由配置里调用 beforeEnteY。</li><li>解析异步路由组件（如果有）。</li><li>在被激活的组件里调用 beforeRouteEnter。</li><li>调用全局的 beforeResolve 守卫（2.5+），标示解析阶段完成。</li><li>导航被确认。</li><li>调用全局的 afterEach 钩子。</li><li>非重用组件，开始组件实例的生命周期：beforeCreate&amp;created、beforeMount&amp;mounted</li><li>触发 DOM 更新。</li><li>用创建好的实例调用 beforeRouteEnter守卫中传给 next 的回调函数。</li><li>导航完成</li></ul><h3 id="7-Vue-router跳转和location-href有什么区别"><a href="#7-Vue-router跳转和location-href有什么区别" class="headerlink" title="7. Vue-router跳转和location.href有什么区别"></a>7. Vue-router跳转和location.href有什么区别</h3><ul><li>使用 <code>location.href= /url </code>来跳转，简单方便，但是刷新了页面；</li><li>使用 <code>history.pushState( /url )</code> ，无刷新页面，静态跳转；</li><li>引进 router ，然后使用 <code>router.push( /url )</code> 来跳转，使用了 <code>diff</code> 算法，实现了按需加载，减少了 dom 的消耗。其实使用 router 跳转和使用 <code>history.pushState()</code> 没什么差别的，因为vue-router就是用了 <code>history.pushState()</code> ，尤其是在history模式下。</li></ul><h3 id="8-params和query的区别"><a href="#8-params和query的区别" class="headerlink" title="8. params和query的区别"></a>8. params和query的区别</h3><p><strong>用法</strong>：query要用path来引入，params要用name来引入，接收参数都是类似的，分别是 <code>this.$route.query.name</code> 和 <code>this.$route.params.name</code> 。</p><p><strong>url地址显示</strong>：query更加类似于ajax中get传参，params则类似于post，说的再简单一点，前者在浏览器地址栏中显示参数，后者则不显示</p><p><strong>注意</strong>：query刷新不会丢失query里面的数据 params刷新会丢失 params里面的数据。</p><h3 id="9-Vue-router-导航守卫有哪些"><a href="#9-Vue-router-导航守卫有哪些" class="headerlink" title="9. Vue-router 导航守卫有哪些"></a>9. Vue-router 导航守卫有哪些</h3><ul><li>全局前置/钩子：beforeEach、beforeResolve、afterEach</li><li>路由独享的守卫：beforeEnter</li><li>组件内的守卫：beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave</li></ul><h3 id="10-对前端路由的理解"><a href="#10-对前端路由的理解" class="headerlink" title="10. 对前端路由的理解"></a>10. 对前端路由的理解</h3><p>在前端技术早期，一个 url 对应一个页面，如果要从 A 页面切换到 B 页面，那么必然伴随着页面的刷新。这个体验并不好，不过在最初也是无奈之举——用户只有在刷新页面的情况下，才可以重新去请求数据。</p><p>后来，改变发生了——Ajax 出现了，它允许人们在不刷新页面的情况下发起请求；与之共生的，还有“不刷新页面即可更新页面内容”这种需求。在这样的背景下，出现了 <strong>SPA（单页面应用</strong>）。</p><p>SPA极大地提升了用户体验，它允许页面在不刷新的情况下更新页面内容，使内容的切换更加流畅。但是在 SPA 诞生之初，人们并没有考虑到“定位”这个问题——在内容切换前后，页面的 URL 都是一样的，这就带来了两个问题：</p><ul><li>SPA 其实并不知道当前的页面“进展到了哪一步”。可能在一个站点下经过了反复的“前进”才终于唤出了某一块内容，但是此时只要刷新一下页面，一切就会被清零，必须重复之前的操作、才可以重新对内容进行定位——SPA 并不会“记住”你的操作。</li><li>由于有且仅有一个 URL 给页面做映射，这对 SEO 也不够友好，搜索引擎无法收集全面的信息</li></ul><p>为了解决这个问题，前端路由出现了。</p><p>前端路由可以帮助我们在仅有一个页面的情况下，“记住”用户当前走到了哪一步——为 SPA 中的各个视图匹配一个唯一标识。这意味着用户前进、后退触发的新内容，都会映射到不同的 URL 上去。此时即便他刷新页面，因为当前的 URL 可以标识出他所处的位置，因此内容也不会丢失。</p><p>那么如何实现这个目的呢？首先要解决两个问题：</p><ul><li>当用户刷新页面时，浏览器会默认根据当前 URL 对资源进行重新定位（发送请求）。这个动作对 SPA 是不必要的，因为我们的 SPA 作为单页面，无论如何也只会有一个资源与之对应。此时若走正常的请求-刷新流程，反而会使用户的前进后退操作无法被记录。</li><li>单页面应用对服务端来说，就是一个URL、一套资源，那么如何做到用“不同的URL”来映射不同的视图内容呢？</li></ul><p>从这两个问题来看，服务端已经完全救不了这个场景了。所以要靠咱们前端自力更生，不然怎么叫“前端路由”呢？作为前端，可以提供这样的解决思路：</p><ul><li>拦截用户的刷新操作，避免服务端盲目响应、返回不符合预期的资源内容。把刷新这个动作完全放到前端逻辑里消化掉。</li><li>感知 URL 的变化。这里不是说要改造 URL、凭空制造出 N 个 URL 来。而是说 URL 还是那个 URL，只不过我们可以给它做一些微小的处理——这些处理并不会影响 URL 本身的性质，不会影响服务器对它的识别，只有我们前端感知的到。一旦我们感知到了，我们就根据这些变化、用 JS 去给它生成不同的内容。</li></ul><h2 id="五、Vuex"><a href="#五、Vuex" class="headerlink" title="五、Vuex"></a>五、Vuex</h2><h3 id="1-Vuex-的原理"><a href="#1-Vuex-的原理" class="headerlink" title="1. Vuex 的原理"></a>1. Vuex 的原理</h3><p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。</p><ul><li>Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</li><li>改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样可以方便地跟踪每一个状态的变化。</li></ul><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230610180254411.png" alt="image-20230610180254411"></p><p>Vuex为Vue Components建立起了一个完整的生态圈，包括开发中的API调用一环。 <strong>（1)核心流程中的主要功能：</strong></p><ul><li>Vue Components 是 vue 组件，组件会触发（dispatch）一些事件或动作，也就是图中的 Actions;</li><li>在组件中发出的动作，肯定是想获取或者改变数据的，但是在 vuex 中，数据是集中管理的，不能直接去更改数据，所以会把这个动作提交（Commit）到 Mutations 中;</li><li>然后 Mutations 就去改变（Mutate）State 中的数据;</li><li>当 State 中的数据被改变之后，就会重新渲染（Render）到 Vue Components 中去，组件展示更新后的数据，完成一个流程。</li></ul><p><strong>（2）各模块在核心流程中的主要功能：</strong></p><ul><li><code>Vue Components</code>∶ Vue组件。HTML页面上，负责接收用户操作等交互行为，执行dispatch方法触发对应action进行回应。</li><li><code>dispatch</code>∶操作行为触发方法，是唯一能执行action的方法。</li><li><code>actions</code>∶ 操作行为处理模块。负责处理Vue Components接收到的所有交互行为。包含同步/异步操作，支持多个同名方法，按照注册的顺序依次触发。向后台API请求的操作就在这个模块中进行，包括触发其他action以及提交mutation的操作。该模块提供了Promise的封装，以支持action的链式触发。</li><li><code>commit</code>∶状态改变提交操作方法。对mutation进行提交，是唯一能执行mutation的方法。</li><li><code>mutations</code>∶状态改变操作方法。是Vuex修改state的唯一推荐方法，其他修改方式在严格模式下将会报错。该方法只能进行同步操作，且方法名只能全局唯一。操作之中会有一些hook暴露出来，以进行state的监控等。</li><li><code>state</code>∶ 页面状态管理容器对象。集中存储Vuecomponents中data对象的零散数据，全局唯一，以进行统一的状态管理。页面显示所需的数据从该对象中进行读取，利用Vue的细粒度数据响应机制来进行高效的状态更新。</li><li><code>getters</code>∶ state对象读取方法。图中没有单独列出该模块，应该被包含在了render中，Vue Components通过该方法读取全局state对象。</li></ul><h3 id="2-Vuex中action和mutation的区别"><a href="#2-Vuex中action和mutation的区别" class="headerlink" title="2. Vuex中action和mutation的区别"></a>2. Vuex中action和mutation的区别</h3><p>mutation中的操作是一系列的同步函数，用于修改state中的变量的的状态。当使用vuex时需要通过commit来提交需要操作的内容。mutation 非常类似于事件：每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。这个回调函数就是实际进行状态更改的地方，并且它会接受 state 作为第一个参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123;</span><br><span class="line">    increment (state) &#123;</span><br><span class="line">      state.<span class="property">count</span>++      <span class="comment">// 变更状态</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>当触发一个类型为 increment 的 mutation 时，需要调用此函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">store.<span class="title function_">commit</span>(<span class="string">&#x27;increment&#x27;</span>)</span><br></pre></td></tr></table></figure><p>而Action类似于mutation，不同点在于：</p><ul><li>Action 可以包含任意异步操作。</li><li>Action 提交的是 mutation，而不是直接变更状态。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123;</span><br><span class="line">    increment (state) &#123;</span><br><span class="line">      state.<span class="property">count</span>++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123;</span><br><span class="line">    increment (context) &#123;</span><br><span class="line">      context.<span class="title function_">commit</span>(<span class="string">&#x27;increment&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此你可以调用 context.commit 提交一个 mutation，或者通过 context.state 和 context.getters 来获取 state 和 getters。 所以，两者的不同点如下：</p><ul><li>Mutation专注于修改State，理论上是修改State的唯一途径；Action业务代码、异步请求。</li><li>Mutation：必须同步执行；Action：可以异步，但不能直接操作State。</li><li>在视图更新时，先触发actions，actions再触发mutation</li><li>mutation的参数是state，它包含store中的数据；store的参数是context，它是 state 的父级，包含 state、getters</li></ul><h3 id="3-Vuex-和-localStorage-的区别"><a href="#3-Vuex-和-localStorage-的区别" class="headerlink" title="3. Vuex 和 localStorage 的区别"></a>3. Vuex 和 localStorage 的区别</h3><p><strong>（1）最重要的区别</strong></p><ul><li>vuex存储在内存中</li><li>localstorage 则以文件的方式存储在本地，只能存储字符串类型的数据，存储对象需要 JSON的stringify和parse方法进行处理。 读取内存比读取硬盘速度要快</li></ul><p><strong>（2）应用场景</strong></p><ul><li>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。vuex用于组件之间的传值。</li><li>localstorage是本地存储，是将数据存储到浏览器的方法，一般是在跨页面传递数据时使用 。</li><li>Vuex能做到数据的响应式，localstorage不能</li></ul><p><strong>（3）永久性</strong></p><p>刷新页面时vuex存储的值会丢失，localstorage不会。</p><p><strong>注意：</strong> 对于不变的数据确实可以用localstorage可以代替vuex，但是当两个组件共用一个数据源（对象或数组）时，如果其中一个组件改变了该数据源，希望另一个组件响应该变化时，localstorage无法做到，原因就是区别1。</p><h3 id="4-Redux-和-Vuex-有什么区别，它们的共同思想"><a href="#4-Redux-和-Vuex-有什么区别，它们的共同思想" class="headerlink" title="4. Redux 和 Vuex 有什么区别，它们的共同思想"></a>4. Redux 和 Vuex 有什么区别，它们的共同思想</h3><p><strong>（1）Redux 和 Vuex区别</strong></p><ul><li>Vuex改进了Redux中的Action和Reducer函数，以mutations变化函数取代Reducer，无需switch，只需在对应的mutation函数里改变state值即可</li><li>Vuex由于Vue自动重新渲染的特性，无需订阅重新渲染函数，只要生成新的State即可</li><li>Vuex数据流的顺序是∶View调用store.commit提交对应的请求到Store中对应的mutation函数-&gt;store改变（vue检测到数据变化自动渲染）</li></ul><p>通俗点理解就是，vuex 弱化 dispatch，通过commit进行 store状态的一次更变;取消了action概念，不必传入特定的 action形式进行指定变更;弱化reducer，基于commit参数直接对数据进行转变，使得框架更加简易;</p><p><strong>（2）共同思想</strong></p><ul><li>单—的数据源</li><li>变化可以预测</li></ul><p>本质上：redux与vuex都是对mvvm思想的服务，将数据从视图中抽离的一种方案; 形式上：vuex借鉴了redux，将store作为全局的数据中心，进行mode管理;</p><h3 id="5-为什么要用-Vuex-或者-Redux"><a href="#5-为什么要用-Vuex-或者-Redux" class="headerlink" title="5. 为什么要用 Vuex 或者 Redux"></a>5. 为什么要用 Vuex 或者 Redux</h3><p>由于传参的方法对于多层嵌套的组件将会非常繁琐，并且对于兄弟组件间的状态传递无能为力。我们经常会采用父子组件直接引用或者通过事件来变更和同步状态的多份拷贝。以上的这些模式非常脆弱，通常会导致代码无法维护。</p><p>所以需要把组件的共享状态抽取出来，以一个全局单例模式管理。在这种模式下，组件树构成了一个巨大的”视图”，不管在树的哪个位置，任何组件都能获取状态或者触发行为。</p><p>另外，通过定义和隔离状态管理中的各种概念并强制遵守一定的规则，代码将会变得更结构化且易维护。</p><h3 id="6-Vuex有哪几种属性？"><a href="#6-Vuex有哪几种属性？" class="headerlink" title="6. Vuex有哪几种属性？"></a>6. Vuex有哪几种属性？</h3><p>有五种，分别是 State、 Getter、Mutation 、Action、 Module</p><ul><li>state =&gt; 基本数据(数据源存放地)</li><li>getters =&gt; 从基本数据派生出来的数据</li><li>mutations =&gt; 提交更改数据的方法，同步</li><li>actions =&gt; 像一个装饰器，包裹mutations，使之可以异步。</li><li>modules =&gt; 模块化Vuex</li></ul><h3 id="7-Vuex和单纯的全局对象有什么区别？"><a href="#7-Vuex和单纯的全局对象有什么区别？" class="headerlink" title="7. Vuex和单纯的全局对象有什么区别？"></a>7. Vuex和单纯的全局对象有什么区别？</h3><ul><li>Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</li><li>不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样可以方便地跟踪每一个状态的变化，从而能够实现一些工具帮助更好地了解我们的应用。</li></ul><h3 id="8-为什么-Vuex-的-mutation-中不能做异步操作？"><a href="#8-为什么-Vuex-的-mutation-中不能做异步操作？" class="headerlink" title="8. 为什么 Vuex 的 mutation 中不能做异步操作？"></a>8. 为什么 Vuex 的 mutation 中不能做异步操作？</h3><ul><li>Vuex中所有的状态更新的唯一途径都是mutation，异步操作通过 Action 来提交 mutation实现，这样可以方便地跟踪每一个状态的变化，从而能够实现一些工具帮助更好地了解我们的应用。</li><li>每个mutation执行完成后都会对应到一个新的状态变更，这样devtools就可以打个快照存下来，然后就可以实现 time-travel 了。如果mutation支持异步操作，就没有办法知道状态是何时更新的，无法很好的进行状态的追踪，给调试带来困难。</li></ul><h3 id="9-Vuex的严格模式是什么-有什么作用，如何开启？"><a href="#9-Vuex的严格模式是什么-有什么作用，如何开启？" class="headerlink" title="9. Vuex的严格模式是什么,有什么作用，如何开启？"></a>9. Vuex的严格模式是什么,有什么作用，如何开启？</h3><p>在严格模式下，无论何时发生了状态变更且不是由mutation函数引起的，将会抛出错误。这能保证所有的状态变更都能被调试工具跟踪到。</p><p>在Vuex.Store 构造器选项中开启,如下</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">store</span> = <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title function_ invoke__">Store</span>(&#123;</span><br><span class="line">    <span class="attr">strict</span>:<span class="literal">true</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="10-如何在组件中批量使用Vuex的getter属性"><a href="#10-如何在组件中批量使用Vuex的getter属性" class="headerlink" title="10. 如何在组件中批量使用Vuex的getter属性"></a>10. 如何在组件中批量使用Vuex的getter属性</h3><p>使用mapGetters辅助函数, 利用对象展开运算符将getter混入computed 对象中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;mapGetters&#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>&#123;</span><br><span class="line">    <span class="attr">computed</span>:&#123;</span><br><span class="line">        ...<span class="title function_">mapGetters</span>([<span class="string">&#x27;total&#x27;</span>,<span class="string">&#x27;discountTotal&#x27;</span>])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-如何在组件中重复使用Vuex的mutation"><a href="#11-如何在组件中重复使用Vuex的mutation" class="headerlink" title="11. 如何在组件中重复使用Vuex的mutation"></a>11. 如何在组件中重复使用Vuex的mutation</h3><p>使用mapMutations辅助函数,在组件中这么使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapMutations &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="attr">methods</span>:&#123;</span><br><span class="line">    ...<span class="title function_">mapMutations</span>(&#123;</span><br><span class="line">        <span class="attr">setNumber</span>:<span class="string">&#x27;SET_NUMBER&#x27;</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后调用<code>this.setNumber(10)</code>相当调用<code>this.$store.commit(&#39;SET_NUMBER&#39;,10)</code></p><h2 id="六、Vue-3-0"><a href="#六、Vue-3-0" class="headerlink" title="六、Vue 3.0"></a>六、Vue 3.0</h2><h3 id="1-Vue3-0有什么更新"><a href="#1-Vue3-0有什么更新" class="headerlink" title="1. Vue3.0有什么更新"></a>1. Vue3.0有什么更新</h3><p><strong>（1）监测机制的改变</strong></p><ul><li>3.0 将带来基于代理 Proxy的 observer 实现，提供全语言覆盖的反应性跟踪。</li><li>消除了 Vue 2 当中基于 Object.defineProperty 的实现所存在的很多限制：</li></ul><p><strong>（2）只能监测属性，不能监测对象</strong></p><ul><li>检测属性的添加和删除；</li><li>检测数组索引和长度的变更；</li><li>支持 Map、Set、WeakMap 和 WeakSet。</li></ul><p><strong>（3）模板</strong></p><ul><li>作用域插槽，2.x 的机制导致作用域插槽变了，父组件会重新渲染，而 3.0 把作用域插槽改成了函数的方式，这样只会影响子组件的重新渲染，提升了渲染的性能。</li><li>同时，对于 render 函数的方面，vue3.0 也会进行一系列更改来方便习惯直接使用 api 来生成 vdom 。</li></ul><p><strong>（4）对象式的组件声明方式</strong></p><ul><li>vue2.x 中的组件是通过声明的方式传入一系列 option，和 TypeScript 的结合需要通过一些装饰器的方式来做，虽然能实现功能，但是比较麻烦。</li><li>3.0 修改了组件的声明方式，改成了类式的写法，这样使得和 TypeScript 的结合变得很容易</li></ul><p><strong>（5）其它方面的更改</strong></p><ul><li>支持自定义渲染器，从而使得 weex 可以通过自定义渲染器的方式来扩展，而不是直接 fork 源码来改的方式。</li><li>支持 Fragment（多个根节点）和 Protal（在 dom 其他部分渲染组建内容）组件，针对一些特殊的场景做了处理。</li><li>基于 tree shaking 优化，提供了更多的内置功能。</li></ul><h3 id="2-defineProperty和proxy的区别"><a href="#2-defineProperty和proxy的区别" class="headerlink" title="2. defineProperty和proxy的区别"></a>2. defineProperty和proxy的区别</h3><p>Vue 在实例初始化时遍历 data 中的所有属性，并使用 Object.defineProperty 把这些属性全部转为 getter/setter。这样当追踪数据发生变化时，setter 会被自动调用。</p><p>Object.defineProperty 是 ES5 中一个无法 shim 的特性，这也就是 Vue 不支持 IE8 以及更低版本浏览器的原因。</p><p>但是这样做有以下问题：</p><ol><li>添加或删除对象的属性时，Vue 检测不到。因为添加或删除的对象没有在初始化进行响应式处理，只能通过<code>$set</code> 来调用<code>Object.defineProperty()</code>处理。</li><li>无法监控到数组下标和长度的变化。</li></ol><p>Vue3 使用 Proxy 来监控数据的变化。Proxy 是 ES6 中提供的功能，其作用为：用于定义基本操作的自定义行为（如属性查找，赋值，枚举，函数调用等）。相对于<code>Object.defineProperty()</code>，其有以下特点：</p><ol><li>Proxy 直接代理整个对象而非对象属性，这样只需做一层代理就可以监听同级结构下的所有属性变化，包括新增属性和删除属性。</li><li>Proxy 可以监听数组的变化。</li></ol><h3 id="3-Vue3-0-为什么要用-proxy？"><a href="#3-Vue3-0-为什么要用-proxy？" class="headerlink" title="3. Vue3.0 为什么要用 proxy？"></a>3. Vue3.0 为什么要用 proxy？</h3><p>在 Vue2 中， 0bject.defineProperty 会改变原始数据，而 Proxy 是创建对象的虚拟表示，并提供 set 、get 和 deleteProperty 等处理器，这些处理器可在访问或修改原始对象上的属性时进行拦截，有以下特点∶</p><ul><li>不需用使用 <code>Vue.$set</code> 或 <code>Vue.$delete</code> 触发响应式。</li><li>全方位的数组变化检测，消除了Vue2 无效的边界情况。</li><li>支持 Map，Set，WeakMap 和 WeakSet。</li></ul><p>Proxy 实现的响应式原理与 Vue2的实现原理相同，实现方式大同小异∶</p><ul><li>get 收集依赖</li><li>Set、delete 等触发依赖</li><li>对于集合类型，就是对集合对象的方法做一层包装：原方法执行后执行依赖相关的收集或触发逻辑。</li></ul><h3 id="4-Vue-3-0-中的-Vue-Composition-API？"><a href="#4-Vue-3-0-中的-Vue-Composition-API？" class="headerlink" title="4.  Vue 3.0 中的 Vue Composition API？"></a>4.  Vue 3.0 中的 Vue Composition API？</h3><p>在 Vue2 中，代码是 Options API 风格的，也就是通过填充 (option) data、methods、computed 等属性来完成一个 Vue 组件。这种风格使得 Vue 相对于 React极为容易上手，同时也造成了几个问题：</p><ol><li>由于 Options API 不够灵活的开发方式，使得Vue开发缺乏优雅的方法来在组件间共用代码。</li><li>Vue 组件过于依赖<code>this</code>上下文，Vue 背后的一些小技巧使得 Vue 组件的开发看起来与 JavaScript 的开发原则相悖，比如在<code>methods</code> 中的<code>this</code>竟然指向组件实例来不指向<code>methods</code>所在的对象。这也使得 TypeScript 在Vue2 中很不好用。</li></ol><p>于是在 Vue3 中，舍弃了 Options API，转而投向 Composition API。Composition API本质上是将 Options API 背后的机制暴露给用户直接使用，这样用户就拥有了更多的灵活性，也使得 Vue3 更适合于 TypeScript 结合。</p><p>如下，是一个使用了 Vue Composition API 的 Vue3 组件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;increment&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    Count: &#123;&#123; count &#125;&#125;</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"> </span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="comment">// Composition API 将组件属性暴露为函数，因此第一步是导入所需的函数</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> &#123; ref, computed, onMounted &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"> </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="comment">// 使用 ref 函数声明了称为 count 的响应属性，对应于Vue2中的data函数</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">0</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"> </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="comment">// Vue2中需要在methods option中声明的函数，现在直接声明</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">function</span> <span class="title function_">increment</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      count.<span class="property">value</span>++</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"> <span class="comment">// 对应于Vue2中的mounted声明周期</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">onMounted</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;component mounted!&#x27;</span>))</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"> </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      count,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      increment</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>显而易见，Vue Composition API 使得 Vue3 的开发风格更接近于原生 JavaScript，带给开发者更多地灵活性</p><h3 id="5-Composition-API与React-Hook很像，区别是什么"><a href="#5-Composition-API与React-Hook很像，区别是什么" class="headerlink" title="5. Composition API与React Hook很像，区别是什么"></a>5. Composition API与React Hook很像，区别是什么</h3><p>从React Hook的实现角度看，React Hook是根据useState调用的顺序来确定下一次重渲染时的state是来源于哪个useState，所以出现了以下限制</p><ul><li>不能在循环、条件、嵌套函数中调用Hook</li><li>必须确保总是在你的React函数的顶层调用Hook</li><li>useEffect、useMemo等函数必须手动确定依赖关系</li></ul><p>而Composition API是基于Vue的响应式系统实现的，与React Hook的相比</p><ul><li>声明在setup函数内，一次组件实例化只调用一次setup，而React Hook每次重渲染都需要调用Hook，使得React的GC比Vue更有压力，性能也相对于Vue来说也较慢</li><li>Compositon API的调用不需要顾虑调用顺序，也可以在循环、条件、嵌套函数中使用</li><li>响应式系统自动实现了依赖收集，进而组件的部分的性能优化由Vue内部自己完成，而React Hook需要手动传入依赖，而且必须必须保证依赖的顺序，让useEffect、useMemo等函数正确的捕获依赖变量，否则会由于依赖不正确使得组件性能下降。</li></ul><p>虽然Compositon API看起来比React Hook好用，但是其设计思想也是借鉴React Hook的。</p><h2 id="七、虚拟DOM"><a href="#七、虚拟DOM" class="headerlink" title="七、虚拟DOM"></a>七、虚拟DOM</h2><h3 id="1-对虚拟DOM的理解？"><a href="#1-对虚拟DOM的理解？" class="headerlink" title="1. 对虚拟DOM的理解？"></a>1. 对虚拟DOM的理解？</h3><p>从本质上来说，Virtual Dom是一个JavaScript对象，通过对象的方式来表示DOM结构。将页面的状态抽象为JS对象的形式，配合不同的渲染工具，使跨平台渲染成为可能。通过事务处理机制，将多次DOM修改的结果一次性的更新到页面上，从而有效的减少页面渲染的次数，减少修改DOM的重绘重排次数，提高渲染性能。</p><p>虚拟DOM是对DOM的抽象，这个对象是更加轻量级的对 DOM的描述。它设计的最初目的，就是更好的跨平台，比如Node.js就没有DOM，如果想实现SSR，那么一个方式就是借助虚拟DOM，因为虚拟DOM本身是js对象。 在代码渲染到页面之前，vue会把代码转换成一个对象（虚拟 DOM）。以对象的形式来描述真实DOM结构，最终渲染到页面。在每次数据发生变化前，虚拟DOM都会缓存一份，变化之时，现在的虚拟DOM会与缓存的虚拟DOM进行比较。在vue内部封装了diff算法，通过这个算法来进行比较，渲染时修改改变的变化，原先没有发生改变的通过原先的数据进行渲染。</p><p>另外现代前端框架的一个基本要求就是无须手动操作DOM，一方面是因为手动操作DOM无法保证程序性能，多人协作的项目中如果review不严格，可能会有开发者写出性能较低的代码，另一方面更重要的是省略手动DOM操作可以大大提高开发效率。</p><h3 id="2-虚拟DOM的解析过程"><a href="#2-虚拟DOM的解析过程" class="headerlink" title="2. 虚拟DOM的解析过程"></a>2. 虚拟DOM的解析过程</h3><p>虚拟DOM的解析过程：</p><ul><li>首先对将要插入到文档中的 DOM 树结构进行分析，使用 js 对象将其表示出来，比如一个元素对象，包含 TagName、props 和 Children 这些属性。然后将这个 js 对象树给保存下来，最后再将 DOM 片段插入到文档中。</li><li>当页面的状态发生改变，需要对页面的 DOM 的结构进行调整的时候，首先根据变更的状态，重新构建起一棵对象树，然后将这棵新的对象树和旧的对象树进行比较，记录下两棵树的的差异。</li><li>最后将记录的有差异的地方应用到真正的 DOM 树中去，这样视图就更新了。</li></ul><h3 id="3-为什么要用虚拟DOM"><a href="#3-为什么要用虚拟DOM" class="headerlink" title="3. 为什么要用虚拟DOM"></a>3. 为什么要用虚拟DOM</h3><p><strong>（1）保证性能下限，在不进行手动优化的情况下，提供过得去的性能</strong> 看一下页面渲染的流程：<strong>解析HTML -&gt; 生成DOM -&gt; 生成 CSSOM -&gt; Layout -&gt; Paint -&gt; Compiler</strong> 下面对比一下修改DOM时真实DOM操作和Virtual DOM的过程，来看一下它们重排重绘的性能消耗∶</p><ul><li>真实DOM∶ 生成HTML字符串＋重建所有的DOM元素</li><li>虚拟DOM∶ 生成vNode+ DOMDiff＋必要的dom更新</li></ul><p>Virtual DOM的更新DOM的准备工作耗费更多的时间，也就是JS层面，相比于更多的DOM操作它的消费是极其便宜的。尤雨溪在社区论坛中说道∶ 框架给你的保证是，你不需要手动优化的情况下，依然可以给你提供过得去的性能。 <strong>（2）跨平台</strong> Virtual DOM本质上是JavaScript的对象，它可以很方便的跨平台操作，比如服务端渲染、uniapp等。</p><h3 id="4-虚拟DOM真的比真实DOM性能好吗"><a href="#4-虚拟DOM真的比真实DOM性能好吗" class="headerlink" title="4. 虚拟DOM真的比真实DOM性能好吗"></a>4. 虚拟DOM真的比真实DOM性能好吗</h3><ul><li>首次渲染大量DOM时，由于多了一层虚拟DOM的计算，会比innerHTML插入慢。</li><li>正如它能保证性能下限，在真实DOM操作的时候进行针对性的优化时，还是更快的。</li></ul><h3 id="5-DIFF算法的原理"><a href="#5-DIFF算法的原理" class="headerlink" title="5. DIFF算法的原理"></a>5. DIFF算法的原理</h3><p>在新老虚拟DOM对比时：</p><ul><li>首先，对比节点本身，判断是否为同一节点，如果不为相同节点，则删除该节点重新创建节点进行替换</li><li>如果为相同节点，进行patchVnode，判断如何对该节点的子节点进行处理，先判断一方有子节点一方没有子节点的情况(如果新的children没有子节点，将旧的子节点移除)</li><li>比较如果都有子节点，则进行updateChildren，判断如何对这些新老节点的子节点进行操作（diff核心）。</li><li>匹配时，找到相同的子节点，递归比较子节点</li></ul><p>在diff中，只对同层的子节点进行比较，放弃跨级的节点比较，使得时间复杂从O(n3)降低值O(n)，也就是说，只有当新旧children都为多个子节点时才需要用核心的Diff算法进行同层级比较。</p><h3 id="6-Vue中key的作用"><a href="#6-Vue中key的作用" class="headerlink" title="6. Vue中key的作用"></a>6. Vue中key的作用</h3><p>vue 中 key 值的作用可以分为两种情况来考虑：</p><ul><li>第一种情况是 v-if 中使用 key。由于 Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。因此当使用 v-if 来实现元素切换的时候，如果切换前后含有相同类型的元素，那么这个元素就会被复用。如果是相同的 input 元素，那么切换前后用户的输入不会被清除掉，这样是不符合需求的。因此可以通过使用 key 来唯一的标识一个元素，这个情况下，使用 key 的元素不会被复用。这个时候 key 的作用是用来标识一个独立的元素。</li><li>第二种情况是 v-for 中使用 key。用 v-for 更新已渲染过的元素列表时，它默认使用“就地复用”的策略。如果数据项的顺序发生了改变，Vue 不会移动 DOM 元素来匹配数据项的顺序，而是简单复用此处的每个元素。因此通过为每个列表项提供一个 key 值，来以便 Vue 跟踪元素的身份，从而高效的实现复用。这个时候 key 的作用是为了高效的更新渲染虚拟 DOM。</li></ul><p>key 是为 Vue 中 vnode 的唯一标记，通过这个 key，diff 操作可以更准确、更快速</p><ul><li>更准确：因为带 key 就不是就地复用了，在 sameNode 函数a.key === b.key对比中可以避免就地复用的情况。所以会更加准确。</li><li>更快速：利用 key 的唯一性生成 map 对象来获取对应节点，比遍历方式更快</li></ul><h3 id="7-为什么不建议用index作为key"><a href="#7-为什么不建议用index作为key" class="headerlink" title="7. 为什么不建议用index作为key?"></a>7. 为什么不建议用index作为key?</h3><p>使用index 作为 key和没写基本上没区别，因为不管数组的顺序怎么颠倒，index 都是 0, 1, 2…这样排列，导致 Vue 会复用错误的旧子节点，做很多额外的工作。</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vela运行时</title>
      <link href="/posts/d9795f88.html"/>
      <url>/posts/d9795f88.html</url>
      
        <content type="html"><![CDATA[<p>vela运行时</p><span id="more"></span><ol><li>响应式数据实现和原理</li><li>vdom和组件</li><li>计算属性</li><li>watch实现</li></ol>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c </tag>
            
            <tag> js </tag>
            
            <tag> 运行时 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>quickjs调试工具</title>
      <link href="/posts/d9795d10.html"/>
      <url>/posts/d9795d10.html</url>
      
        <content type="html"><![CDATA[<p>vela系统quickjs对接devtools</p><span id="more"></span><h2 id="vela快应用调试功能概览"><a href="#vela快应用调试功能概览" class="headerlink" title="vela快应用调试功能概览"></a>vela快应用调试功能概览</h2><p><img src="https://raw.githubusercontent.com/why862555625/images/main/image-20230525102147522.png" alt="image-20230525102147522"></p><h1 id="vela-debug调试功能"><a href="#vela-debug调试功能" class="headerlink" title="vela debug调试功能"></a>vela debug调试功能</h1><p>debug调试功能图</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/image-20230525111407415.png" alt="image-20230525111407415"></p><p>vela debug调试功能实现大致分为4个步骤：</p><ol><li><strong>连接时将所有的源码发送给devtools。</strong></li><li><strong>在devtools 的source功能中打断点、将请求发送给下层cdp.</strong></li><li><strong>cdp计算断点具体在字节码中的位置、并记录。</strong></li><li><strong>在引擎执行字节码时判断有无命中断点。</strong></li></ol><p>下面具体说明这四个步骤：</p><h2 id="1-连接时将所有的源码发送给devtools"><a href="#1-连接时将所有的源码发送给devtools" class="headerlink" title="1. 连接时将所有的源码发送给devtools"></a>1. 连接时将所有的源码发送给devtools</h2><p>在调用loadApplication时会将app的路径保存在APP类中，也就是app的rpk的最外层路径。在监听到devtool连接时，会将rpk包中的所js文件发送给devtools，devtools会将这些js文件拼接成上图中的source文件。</p><h2 id="2-在devtools-的source功能中打断点、将请求发送给下层cdp"><a href="#2-在devtools-的source功能中打断点、将请求发送给下层cdp" class="headerlink" title="2. 在devtools 的source功能中打断点、将请求发送给下层cdp"></a>2. 在devtools 的source功能中打断点、将请求发送给下层cdp</h2><p>当打开source文件上打断点、devtools会将断点的文件名、行号发送到下层cdp.</p><h2 id="3-cdp计算断点具体在字节码中的位置、并记录。"><a href="#3-cdp计算断点具体在字节码中的位置、并记录。" class="headerlink" title="3. cdp计算断点具体在字节码中的位置、并记录。"></a>3. cdp计算断点具体在字节码中的位置、并记录。</h2><ul><li><p>断点功能的输入实际上是文件名和断点行信息，第一步我们需要利用这个信息，找到模块，进而首先找到目标函数。</p><ul><li>quickjs在真实加载module的时候都会调用JS_EvalInternal。我们可以在这个函数里面监听并记录已经加载完的模块。</li></ul></li><li><p>每个函数对象上都记录了自身的起始行，通过pc2line table可以计算得到结束行，进而和传入的行号进行范围匹配计算。</p><ul><li>函数和字节码的映射规则：<ul><li>如果一行源码对应的字节码较短，就将前4位存源码的行数，后四位存字节码对应的行数</li><li>如果一个源码对应的字节码较长，就先存入一个0值（解析pc2line_buf的时候遇到0值会自动将下一个当做128  int来解析），后面补一个128的int，这个int的高位用来存源码行数、低位存字节码的行数。</li></ul></li></ul></li></ul><p><strong>计算结束行函数：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PC2LINE_BASE     (-1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PC2LINE_RANGE    5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PC2LINE_OP_FIRST 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PC2LINE_DIFF_PC_MAX ((255 - PC2LINE_OP_FIRST) / PC2LINE_RANGE)</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">caculate_function_last_line</span><span class="params">(JSFunctionBytecode* b)</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> op;</span><br><span class="line">    <span class="type">int</span> ret, v;</span><br><span class="line">    FunctionBytecodeDebugInfo* debug = <span class="built_in">js_debugger_get_bytecode_debug_info</span>(b);</span><br><span class="line">    <span class="type">int</span> line_num = debug-&gt;line_num, new_line_num;</span><br><span class="line">    <span class="type">uint8_t</span> *p = debug-&gt;pc2line_buf;</span><br><span class="line">    <span class="type">uint8_t</span> *p_end = p + debug-&gt;pc2line_len;</span><br><span class="line">    <span class="type">int</span> succ = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// scan line by line</span></span><br><span class="line">    <span class="keyword">while</span> (p &lt; p_end) &#123;</span><br><span class="line">        op = *p++;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">uint32_t</span> val;</span><br><span class="line">            ret = <span class="built_in">get_leb128</span>(&amp;val, p, p_end);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                succ = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// pc += val;</span></span><br><span class="line">            p += ret;</span><br><span class="line">            ret = <span class="built_in">get_sleb128</span>(&amp;v, p, p_end);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                succ = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p += ret;</span><br><span class="line">            new_line_num = line_num + v;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            op -= PC2LINE_OP_FIRST;</span><br><span class="line">            new_line_num = line_num + (op % PC2LINE_RANGE) + PC2LINE_BASE;</span><br><span class="line">        &#125;</span><br><span class="line">        line_num = new_line_num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> succ ? line_num : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">STATIC <span class="type">int</span> <span class="title">get_leb128</span><span class="params">(<span class="type">uint32_t</span> *pval, <span class="type">const</span> <span class="type">uint8_t</span> *buf,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="type">const</span> <span class="type">uint8_t</span> *buf_end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">uint8_t</span> *ptr = buf;</span><br><span class="line">    <span class="type">uint32_t</span> v, a, i;</span><br><span class="line">    v = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">unlikely</span>(ptr &gt;= buf_end))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        a = *ptr++;</span><br><span class="line">        v |= (a &amp; <span class="number">0x7f</span>) &lt;&lt; (i * <span class="number">7</span>);</span><br><span class="line">        <span class="keyword">if</span> (!(a &amp; <span class="number">0x80</span>)) &#123;</span><br><span class="line">            *pval = v;</span><br><span class="line">            <span class="keyword">return</span> ptr - buf;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *pval = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">STATIC <span class="type">int</span> <span class="title">get_sleb128</span><span class="params">(<span class="type">int32_t</span> *pval, <span class="type">const</span> <span class="type">uint8_t</span> *buf,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="type">const</span> <span class="type">uint8_t</span> *buf_end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="type">uint32_t</span> val;</span><br><span class="line">    ret = <span class="built_in">get_leb128</span>(&amp;val, buf, buf_end);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        *pval = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *pval = (val &gt;&gt; <span class="number">1</span>) ^ -(val &amp; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>源码表和字节码表对应规则：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">compute_pc2line_info</span><span class="params">(JSFunctionDef *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(s-&gt;js_mode &amp; JS_MODE_STRIP) &amp;&amp; s-&gt;line_number_slots) &#123;</span><br><span class="line">        <span class="type">int</span> last_line_num = s-&gt;line_num;</span><br><span class="line">        <span class="type">uint32_t</span> last_pc = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">js_dbuf_init</span>(s-&gt;ctx, &amp;s-&gt;pc2line);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; s-&gt;line_number_count; i++) &#123;</span><br><span class="line">            <span class="type">uint32_t</span> pc = s-&gt;line_number_slots[i].pc;</span><br><span class="line">            <span class="type">int</span> line_num = s-&gt;line_number_slots[i].line_num;</span><br><span class="line">            <span class="type">int</span> diff_pc, diff_line;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (line_num &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            diff_pc = pc - last_pc;</span><br><span class="line">            diff_line = line_num - last_line_num;</span><br><span class="line">            <span class="keyword">if</span> (diff_line == <span class="number">0</span> || diff_pc &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (diff_line &gt;= PC2LINE_BASE &amp;&amp;</span><br><span class="line">                diff_line &lt; PC2LINE_BASE + PC2LINE_RANGE &amp;&amp;</span><br><span class="line">                diff_pc &lt;= PC2LINE_DIFF_PC_MAX) &#123;</span><br><span class="line">                <span class="built_in">dbuf_putc</span>(&amp;s-&gt;pc2line, (diff_line - PC2LINE_BASE) +</span><br><span class="line">                          diff_pc * PC2LINE_RANGE + PC2LINE_OP_FIRST);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/* longer encoding */</span></span><br><span class="line">                <span class="built_in">dbuf_putc</span>(&amp;s-&gt;pc2line, <span class="number">0</span>);</span><br><span class="line">                <span class="built_in">dbuf_put_leb128</span>(&amp;s-&gt;pc2line, diff_pc);</span><br><span class="line">                <span class="built_in">dbuf_put_sleb128</span>(&amp;s-&gt;pc2line, diff_line);</span><br><span class="line">            &#125;</span><br><span class="line">            last_pc = pc;</span><br><span class="line">            last_line_num = line_num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>需要注意匹配到的函数可能只是外层函数，具体的断点偏移计算时要考虑递归子函数。</p><ul><li>基于pc2line table计算断点在函数字节码中的偏移位置，计算时如果目出现计算出来的行号比目标行号大的情况 <code>end_line_num&gt;cur_line_num&gt;targe_num</code>，说明断点落在了子函数中，需要递归，直到最终找到或全部失败。</li></ul><p><img src="https://raw.githubusercontent.com/why862555625/images/main/image-20230525125207891.png" alt="image-20230525125207891"></p></li><li><p>断点断到、将pause消息和目前上下文的变量信息和调用栈发送给devtools。</p><ul><li>runtime上面保留了当前栈的信息JSStackFrame，JSStackFrame上面保存了栈上的变量、参数、函数信息；并且JSStackFrame可以通过prev_frame向上查找栈信息。这样遍历下来就可以完整的得到栈上的变量和调用栈。</li></ul></li></ul><p><strong>JSRuntime和JSStackFrame的数据结构</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">JSRuntime</span> &#123;</span><br><span class="line">    JSMallocFunctions mf;</span><br><span class="line">    JSMallocState malloc_state;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *rt_info;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> atom_hash_size; <span class="comment">/* power of two */</span></span><br><span class="line">    <span class="type">int</span> atom_count;</span><br><span class="line">    <span class="type">int</span> atom_size;</span><br><span class="line">    <span class="type">int</span> atom_count_resize; <span class="comment">/* resize hash table at this count */</span></span><br><span class="line">    <span class="type">uint32_t</span> *atom_hash;</span><br><span class="line">    JSAtomStruct **atom_array;</span><br><span class="line">    <span class="type">int</span> atom_free_index; <span class="comment">/* 0 = none */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> class_count;    <span class="comment">/* size of class_array */</span></span><br><span class="line">    JSClass *class_array;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">list_head</span> context_list; <span class="comment">/* list of JSContext.link */</span></span><br><span class="line">    <span class="comment">/* list of JSGCObjectHeader.link. List of allocated GC objects (used</span></span><br><span class="line"><span class="comment">       by the garbage collector) */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">list_head</span> gc_obj_list;</span><br><span class="line">    <span class="comment">/* list of JSGCObjectHeader.link. Used during JS_FreeValueRT() */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">list_head</span> gc_zero_ref_count_list;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">list_head</span> tmp_obj_list; <span class="comment">/* used during GC */</span></span><br><span class="line">    JSGCPhaseEnum gc_phase : <span class="number">8</span>;</span><br><span class="line">    <span class="type">size_t</span> malloc_gc_threshold;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DUMP_LEAKS</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">list_head</span> string_list; <span class="comment">/* list of JSString.link */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">/* stack limitation */</span></span><br><span class="line">    <span class="type">uintptr_t</span> stack_size; <span class="comment">/* in bytes, 0 if no limit */</span></span><br><span class="line">    <span class="type">uintptr_t</span> stack_top;</span><br><span class="line">    <span class="type">uintptr_t</span> stack_limit; <span class="comment">/* lower stack limit */</span></span><br><span class="line"></span><br><span class="line">    JSValue current_exception;</span><br><span class="line">    <span class="comment">/* true if inside an out of memory error, to avoid recursing */</span></span><br><span class="line">    BOOL in_out_of_memory : <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">JSStackFrame</span> *current_stack_frame;  <span class="comment">// current stack info</span></span><br><span class="line"></span><br><span class="line">    JSInterruptHandler *interrupt_handler;</span><br><span class="line">    <span class="type">void</span> *interrupt_opaque;</span><br><span class="line"></span><br><span class="line">    JSHostPromiseRejectionTracker *host_promise_rejection_tracker;</span><br><span class="line">    <span class="type">void</span> *host_promise_rejection_tracker_opaque;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">list_head</span> job_list; <span class="comment">/* list of JSJobEntry.link */</span></span><br><span class="line"></span><br><span class="line">    JSModuleNormalizeFunc *module_normalize_func;</span><br><span class="line">    JSModuleLoaderFunc *module_loader_func;</span><br><span class="line">    <span class="type">void</span> *module_loader_opaque;</span><br><span class="line"></span><br><span class="line">    BOOL can_block : <span class="number">8</span>; <span class="comment">/* TRUE if Atomics.wait can block */</span></span><br><span class="line">    <span class="comment">/* used to allocate, free and clone SharedArrayBuffers */</span></span><br><span class="line">    JSSharedArrayBufferFunctions sab_funcs;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Shape hash table */</span></span><br><span class="line">    <span class="type">int</span> shape_hash_bits;</span><br><span class="line">    <span class="type">int</span> shape_hash_size;</span><br><span class="line">    <span class="type">int</span> shape_hash_count; <span class="comment">/* number of hashed shapes */</span></span><br><span class="line">    JSShape **shape_hash;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_BIGNUM</span></span><br><span class="line">    <span class="type">bf_context_t</span> bf_ctx;</span><br><span class="line">    JSNumericOperations bigint_ops;</span><br><span class="line">    JSNumericOperations bigfloat_ops;</span><br><span class="line">    JSNumericOperations bigdecimal_ops;</span><br><span class="line">    <span class="type">uint32_t</span> operator_count;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">void</span> *user_opaque;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_INTERPRETERS_QUICKJS_DEBUG</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">JSDebuggerInfo</span> debugger_info;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">DumpMemoryInfo</span> dump_memory_info;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    JSOutOfMemoryTracker* oom_tracker;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MEMORY_LEAK_TRACK</span></span><br><span class="line">    <span class="type">int</span> isStartMemoryDump;</span><br><span class="line">    vector* newObjVector;</span><br><span class="line">    JSContext* currentCtx;</span><br><span class="line">    <span class="type">char</span>* pageStatus;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">JSStackFrame</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">JSStackFrame</span> *prev_frame; <span class="comment">/* NULL if first stack frame */</span></span><br><span class="line">    JSValue cur_func; <span class="comment">/* current function, JS_UNDEFINED if the frame is detached */</span></span><br><span class="line">    JSValue *arg_buf; <span class="comment">/* arguments */</span></span><br><span class="line">    JSValue *var_buf; <span class="comment">/* variables */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">list_head</span> var_ref_list; <span class="comment">/* list of JSVarRef.link */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">uint8_t</span> *cur_pc; <span class="comment">/* only used in bytecode functions : PC of the</span></span><br><span class="line"><span class="comment">                        instruction after the call */</span></span><br><span class="line">    <span class="type">int</span> arg_count;</span><br><span class="line">    <span class="type">int</span> js_mode; <span class="comment">/* 0 or JS_MODE_MATH for C functions */</span></span><br><span class="line">    <span class="comment">/* only used in generators. Current stack pointer value. NULL if</span></span><br><span class="line"><span class="comment">       the function is running. */</span></span><br><span class="line">    JSValue *cur_sp;</span><br><span class="line">&#125; JSStackFrame;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>函数数据结构：</strong></p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/image-20230525144252998.png"></p><p><strong>查找目标函数流程：</strong></p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/image-20230525124949165.png"></p><h2 id="4-在引擎执行字节码时判断有无命中断点。"><a href="#4-在引擎执行字节码时判断有无命中断点。" class="headerlink" title="4. 在引擎执行字节码时判断有无命中断点。"></a>4. 在引擎执行字节码时判断有无命中断点。</h2><p>命中断点有两个设计思路：</p><p><strong>第一种：</strong></p><p>直接修改字节码、插入debugger指令和nop\需要额外注意在命中后和取消时将字节码恢复、否则会出现问题。</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/image-20230525161322186.png" alt="image-20230525161322186"></p><p><strong>第二种：</strong></p><p>分配一块和字节码相同长度的数组、在相同的便宜位置写入1、作为断点标志、方便命中检查。</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/image-20230525161507336.png" alt="image-20230525161507336"></p><p>断点命中的核心思路实在引擎解释执行字节码的时候插入堆断点命中的检查、命中断电后停止执行（不在继续解释下一条指令）。</p><p>这里选择重定义字节码的case定义、如果开启了调试功能、则每次解释执行字节码都会插入对js_debugger_check函数执行、他负责检查每一步执行是否命中断点。检查方法很简单、检查当前pc是否落在了断点的范围内（依赖设置断点）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_INTERPRETERS_QUICKJS_DEBUG</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASE(op)        case op: js_debugger_check(ctx, pc); stub_ ## op</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASE(op)        case op: stub_ ## op</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><strong>执行字节码：</strong></p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/image-20230525170447952.png" alt="image-20230525170447952"></p><p>js_debugger_check 中暂停的主要逻辑是一个<code>while(ture)</code>循环，然后每次执行libuv_run_once()推一次主循环的句柄，用来判断服务端是否放开断点。</p><h1 id="memory-功能"><a href="#memory-功能" class="headerlink" title="memory 功能"></a>memory 功能</h1><p>memory功能大概可以概述为三个部分：</p><ol><li>接受devtools  memory dump的请求之后，开始遍历引擎的堆内存链表（v8是使用图结构来表示的堆内存、quickjs是使用链表表示的）。</li><li>将quickjs中的链表内存转化为图结构内存。（devtools snapshot需要图结构）</li><li>将图结构转化为snapshot发送给devtools、devtools进行解析并显示。</li></ol><h2 id="1-理解引擎的堆内存结构"><a href="#1-理解引擎的堆内存结构" class="headerlink" title="1. 理解引擎的堆内存结构"></a>1. 理解引擎的堆内存结构</h2><p>quickjs的runtime中的gc_obj_list保存了引擎中的所有堆对象的JSGCObjectHeader.遍历gc_obj_list就可以得到所有的堆对象信息</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">JSGCObjectHeader</span> &#123;</span><br><span class="line">    <span class="type">int</span> ref_count; <span class="comment">/* must come first, 32-bit */</span></span><br><span class="line">    JSGCObjectTypeEnum gc_obj_type : <span class="number">4</span>;</span><br><span class="line">    <span class="type">uint8_t</span> mark : <span class="number">4</span>; <span class="comment">/* used by the GC */</span></span><br><span class="line">    <span class="type">uint8_t</span> dummy1; <span class="comment">/* not used by the GC */</span></span><br><span class="line">    <span class="type">uint16_t</span> dummy2; <span class="comment">/* not used by the GC */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">list_head</span> link;</span><br><span class="line">    <span class="type">int64_t</span> id;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/why862555625/images/main/image-20230525171354456.png" alt="image-20230525171354456"></p><h2 id="2-理解snapshot文件格式"><a href="#2-理解snapshot文件格式" class="headerlink" title="2. 理解snapshot文件格式"></a>2. 理解snapshot文件格式</h2><ul><li>V8 HeapSnapshot文件整体采用JSON格式存储。</li><li>存储时采用Meta + 内容的方式，Meta里描述了各个字段的含义，各个节点的数量等。</li><li>内存dump信息按照点集和边集的形式存储。点集存储节点信息，边集存储对象之间的链接关系。</li><li>字符串是单独存储的，节点中使用时采用下标引用的方式以节约内存。</li></ul><p><img src="https://raw.githubusercontent.com/why862555625/images/main/image-20230525172031289.png" alt="image-20230525172031289"></p><h2 id="3-堆对象处理：从链表到图"><a href="#3-堆对象处理：从链表到图" class="headerlink" title="3.堆对象处理：从链表到图"></a>3.堆对象处理：从链表到图</h2><p>Quickjs中GC对象是通过链表保存的，但HeapSnapshot中是按照图结构保存的，所以需要有一个从链表构建对象图的过程，我生成了一个代理结构，额外记录了对象间的链接关系。</p><p>如果不这样做，就需要修改quickjs的GC list结构，这样改动会很大。</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/image-20230525172159734.png" alt="image-20230525172159734"></p><h2 id="4-Proxy图的构建算法"><a href="#4-Proxy图的构建算法" class="headerlink" title="4. Proxy图的构建算法"></a>4. Proxy图的构建算法</h2><p><img src="https://raw.githubusercontent.com/why862555625/images/main/image-20230525172302551.png" alt="image-20230525172302551"></p>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML复习</title>
      <link href="/posts/d9795d88.html"/>
      <url>/posts/d9795d88.html</url>
      
        <content type="html"><![CDATA[<p>HTML复习 </p><span id="more"></span><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230608143228021.png" alt="image-20230608143228021"></p><h3 id="1-src和href的区别"><a href="#1-src和href的区别" class="headerlink" title="1. src和href的区别"></a>1. src和href的区别</h3><p>src和href都是<strong>用来引用外部的资源</strong>，它们的区别如下：</p><ul><li><strong>src：</strong> 表示对资源的引用，它指向的内容会嵌入到当前标签所在的位置。src会将其指向的资源下载并应⽤到⽂档内，如请求js脚本。当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执⾏完毕，所以⼀般js脚本会放在页面底部。</li><li><strong>href：</strong> 表示超文本引用，它指向一些网络资源，建立和当前元素或本文档的链接关系。当浏览器识别到它他指向的⽂件时，就会并⾏下载资源，不会停⽌对当前⽂档的处理。 常用在a、link等标签上。</li></ul><h3 id="2-对HTML语义化的理解"><a href="#2-对HTML语义化的理解" class="headerlink" title="2. 对HTML语义化的理解"></a>2. 对HTML语义化的理解</h3><p><strong>语义化是指根据内容的结构化（内容语义化），选择合适的标签（代码语义化）</strong>。通俗来讲就是用正确的标签做正确的事情。</p><p>语义化的优点如下：</p><ul><li>对机器友好，带有语义的文字表现力丰富，更适合搜索引擎的爬虫爬取有效信息，有利于SEO。除此之外，语义类还支持读屏软件，根据文章可以自动生成目录；</li><li>对开发者友好，使用语义类标签增强了可读性，结构更加清晰，开发者能清晰的看出网页的结构，便于团队的开发与维护。</li></ul><p>常见的语义化标签：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span><span class="tag">&lt;/<span class="name">header</span>&gt;</span>  头部</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">nav</span>&gt;</span><span class="tag">&lt;/<span class="name">nav</span>&gt;</span>  导航栏</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span>&gt;</span><span class="tag">&lt;/<span class="name">section</span>&gt;</span>  区块（有语义化的div）</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">main</span>&gt;</span><span class="tag">&lt;/<span class="name">main</span>&gt;</span>  主要区域</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span><span class="tag">&lt;/<span class="name">article</span>&gt;</span>  主要内容</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">aside</span>&gt;</span><span class="tag">&lt;/<span class="name">aside</span>&gt;</span>  侧边栏</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span><span class="tag">&lt;/<span class="name">footer</span>&gt;</span>  底部</span><br></pre></td></tr></table></figure><h3 id="3-DOCTYPE-⽂档类型-的作⽤"><a href="#3-DOCTYPE-⽂档类型-的作⽤" class="headerlink" title="3. DOCTYPE(⽂档类型) 的作⽤"></a>3. DOCTYPE(⽂档类型) 的作⽤</h3><p>DOCTYPE是HTML5中一种标准通用标记语言的文档类型声明，它的目的是<strong>告诉浏览器（解析器）应该以什么样（html或xhtml）的文档类型定义来解析文档</strong>，不同的渲染模式会影响浏览器对 CSS 代码甚⾄ JavaScript 脚本的解析。它必须声明在HTML⽂档的第⼀⾏。</p><p>浏览器渲染页面的两种模式（可通过document.compatMode获取，比如，语雀官网的文档类型是<strong>CSS1Compat</strong>）：</p><ul><li><strong>CSS1Compat：标准模式（Strick mode）</strong>，默认模式，浏览器使用W3C的标准解析渲染页面。在标准模式中，浏览器以其支持的最高标准呈现页面。</li><li>**BackCompat：怪异模式(混杂模式)(Quick mode)**，浏览器使用自己的怪异模式解析渲染页面。在怪异模式中，页面以一种比较宽松的向后兼容的方式显示。</li></ul><h3 id="4-script标签中defer和async的区别"><a href="#4-script标签中defer和async的区别" class="headerlink" title="4. script标签中defer和async的区别"></a>4. script标签中defer和async的区别</h3><p>如果没有defer或async属性，浏览器会立即加载并执行相应的脚本。它不会等待后续加载的文档元素，读取到就会开始加载和执行，这样就阻塞了后续文档的加载。</p><p>下图可以直观的看出三者之间的区别: <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b0a8a139519f46dfa2d1992c58eb5397~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image.png"> 其中蓝色代表js脚本网络加载时间，红色代表js脚本执行时间，绿色代表html解析。</p><p><strong>defer 和 async属性都是去异步加载外部的JS脚本文件，它们都不会阻塞页面的解析</strong>，其区别如下：</p><ul><li><strong>执行顺序：</strong> 多个带async属性的标签，不能保证加载的顺序；多个带defer属性的标签，按照加载顺序执行；</li><li>**脚本是否并行执行：**async属性，表示**后续文档的加载和执行与js脚本的加载和执行是并行进行的**，即异步执行；defer属性，加载后续文档的过程和js脚本的加载(此时仅加载不执行)是并行进行的(异步)，js脚本需要等到文档所有元素解析完成之后才执行，DOMContentLoaded事件触发执行之前。</li></ul><h3 id="5-常⽤的meta标签有哪些"><a href="#5-常⽤的meta标签有哪些" class="headerlink" title="5. 常⽤的meta标签有哪些"></a>5. 常⽤的meta标签有哪些</h3><p><code>meta</code> 标签由 <code>name</code> 和 <code>content</code> 属性定义，<strong>用来描述网页文档的属性</strong>，比如网页的作者，网页描述，关键词等，除了HTTP标准固定了一些<code>name</code>作为大家使用的共识，开发者还可以自定义name。</p><p>常用的meta标签： （1）<code>charset</code>，用来描述HTML文档的编码类型：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> &gt;</span></span><br></pre></td></tr></table></figure><p>（2） <code>keywords</code>，页面关键词：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;keywords&quot;</span> <span class="attr">content</span>=<span class="string">&quot;关键词&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>（3）<code>description</code>，页面描述：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;description&quot;</span> <span class="attr">content</span>=<span class="string">&quot;页面描述内容&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>（4）<code>refresh</code>，页面重定向和刷新：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;refresh&quot;</span> <span class="attr">content</span>=<span class="string">&quot;0;url=&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>（5）<code>viewport</code>，适配移动端，可以控制视口的大小和比例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1, maximum-scale=1&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中，<code>content</code> 参数有以下几种：</p><ul><li><code>width viewport</code> ：宽度(数值/device-width)</li><li><code>height viewport</code> ：高度(数值/device-height)</li><li><code>initial-scale</code> ：初始缩放比例</li><li><code>maximum-scale</code> ：最大缩放比例</li><li><code>minimum-scale</code> ：最小缩放比例</li><li><code>user-scalable</code> ：是否允许用户缩放(yes/no）</li></ul><p>（6）搜索引擎索引方式：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;robots&quot;</span> <span class="attr">content</span>=<span class="string">&quot;index,follow&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>其中，<code>content</code> 参数有以下几种：</p><ul><li><code>all</code>：文件将被检索，且页面上的链接可以被查询；</li><li><code>none</code>：文件将不被检索，且页面上的链接不可以被查询；</li><li><code>index</code>：文件将被检索；</li><li><code>follow</code>：页面上的链接可以被查询；</li><li><code>noindex</code>：文件将不被检索；</li><li><code>nofollow</code>：页面上的链接不可以被查询。</li></ul><h3 id="6-HTML5有哪些更新"><a href="#6-HTML5有哪些更新" class="headerlink" title="6. HTML5有哪些更新"></a>6. HTML5有哪些更新</h3><h4 id="1-语义化标签"><a href="#1-语义化标签" class="headerlink" title="1. 语义化标签"></a>1. 语义化标签</h4><ul><li>header：定义文档的页眉（头部）；</li><li>nav：定义导航链接的部分；</li><li>footer：定义文档或节的页脚（底部）；</li><li>article：定义文章内容；</li><li>section：定义文档中的节（section、区段）；</li><li>aside：定义其所处内容之外的内容（侧边）；</li></ul><h4 id="2-媒体标签"><a href="#2-媒体标签" class="headerlink" title="2. 媒体标签"></a>2. 媒体标签</h4><p>（1） audio：音频</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">src</span>=<span class="string">&#x27;&#x27;</span> <span class="attr">controls</span> <span class="attr">autoplay</span> <span class="attr">loop</span>=<span class="string">&#x27;true&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br></pre></td></tr></table></figure><p>属性：</p><ul><li>controls 控制面板</li><li>autoplay 自动播放</li><li>loop=‘true’ 循环播放</li></ul><p>（2）video视频</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">src</span>=<span class="string">&#x27;&#x27;</span> <span class="attr">poster</span>=<span class="string">&#x27;imgs/aa.jpg&#x27;</span> <span class="attr">controls</span>&gt;</span><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure><p>属性：</p><ul><li>poster：指定视频还没有完全下载完毕，或者用户还没有点击播放前显示的封面。默认显示当前视频文件的第一针画面，当然通过poster也可以自己指定。</li><li>controls 控制面板</li><li>width</li><li>height</li></ul><p>（3）source标签 因为浏览器对视频格式支持程度不一样，为了能够兼容不同的浏览器，可以通过source来指定视频源。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&#x27;aa.flv&#x27;</span> <span class="attr">type</span>=<span class="string">&#x27;video/flv&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&#x27;aa.mp4&#x27;</span> <span class="attr">type</span>=<span class="string">&#x27;video/mp4&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="3-表单"><a href="#3-表单" class="headerlink" title="3. 表单"></a>3. 表单</h4><p><strong>表单类型：</strong></p><ul><li>email ：能够验证当前输入的邮箱地址是否合法</li><li>url ： 验证URL</li><li>number ： 只能输入数字，其他输入不了，而且自带上下增大减小箭头，max属性可以设置为最大值，min可以设置为最小值，value为默认值。</li><li>search ： 输入框后面会给提供一个小叉，可以删除输入的内容，更加人性化。</li><li>range ： 可以提供给一个范围，其中可以设置max和min以及value，其中value属性可以设置为默认值</li><li>color ： 提供了一个颜色拾取器</li><li>time ： 时分秒</li><li>data ： 日期选择年月日</li><li>datatime ： 时间和日期(目前只有Safari支持)</li><li>datatime-local ：日期时间控件</li><li>week ：周控件</li><li>month：月控件</li></ul><p><strong>表单属性：</strong></p><ul><li>placeholder ：提示信息</li><li>autofocus ：自动获取焦点</li><li>autocomplete=“on” 或者 autocomplete=“off” 使用这个属性需要有两个前提：<ul><li>表单必须提交过</li><li>必须有name属性。</li></ul></li><li>required：要求输入框不能为空，必须有值才能够提交。</li><li>pattern=” “ 里面写入想要的正则模式，例如手机号patte=”^(+86)?\d{10}$”</li><li>multiple：可以选择多个文件或者多个邮箱</li><li>form=” form表单的ID”</li></ul><p><strong>表单事件：</strong></p><ul><li>oninput 每当input里的输入框内容发生变化都会触发此事件。</li><li>oninvalid 当验证不通过时触发此事件。</li></ul><h4 id="4-进度条、度量器"><a href="#4-进度条、度量器" class="headerlink" title="4. 进度条、度量器"></a>4. 进度条、度量器</h4><ul><li>progress标签：用来表示任务的进度（IE、Safari不支持），max用来表示任务的进度，value表示已完成多少</li><li>meter属性：用来显示剩余容量或剩余库存（IE、Safari不支持）<ul><li>high/low：规定被视作高/低的范围</li><li>max/min：规定最大/小值</li><li>value：规定当前度量值</li></ul></li></ul><p>设置规则：min &lt; low &lt; high &lt; max</p><h4 id="5-DOM查询操作"><a href="#5-DOM查询操作" class="headerlink" title="5.DOM查询操作"></a>5.DOM查询操作</h4><ul><li>document.querySelector()</li><li>document.querySelectorAll()</li></ul><p>它们选择的对象可以是标签，可以是类(需要加点)，可以是ID(需要加#)</p><h4 id="6-Web存储"><a href="#6-Web存储" class="headerlink" title="6. Web存储"></a>6. Web存储</h4><p>HTML5 提供了两种在客户端存储数据的新方法：</p><ul><li>localStorage - 没有时间限制的数据存储</li><li>sessionStorage - 针对一个 session 的数据存储</li></ul><h4 id="7-其他"><a href="#7-其他" class="headerlink" title="7. 其他"></a>7. 其他</h4><ul><li>拖放：拖放是一种常见的特性，即抓取对象以后拖到另一个位置。设置元素可拖放：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">draggable</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><ul><li>画布（canvas ）： canvas 元素使用 JavaScript 在网页上绘制图像。画布是一个矩形区域，可以控制其每一像素。canvas 拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">&quot;myCanvas&quot;</span> <span class="attr">width</span>=<span class="string">&quot;200&quot;</span> <span class="attr">height</span>=<span class="string">&quot;100&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>SVG：SVG 指可伸缩矢量图形，用于定义用于网络的基于矢量的图形，使用 XML 格式定义图形，图像在放大或改变尺寸的情况下其图形质量不会有损失，它是万维网联盟的标准</li><li>地理定位：Geolocation（地理定位）用于定位用户的位置。‘</li></ul><p><strong>总结：</strong> （1）新增语义化标签：nav、header、footer、aside、section、article （2）音频、视频标签：audio、video （3）数据存储：localStorage、sessionStorage （4）canvas（画布）、Geolocation（地理定位）、websocket（通信协议） （5）input标签新增属性：placeholder、autocomplete、autofocus、required （6）history API：go、forward、back、pushstate</p><p><strong>移除的元素有：</strong></p><ul><li>纯表现的元素：basefont，big，center，font, s，strike，tt，u;</li><li>对可用性产生负面影响的元素：frame，frameset，noframes；</li></ul><h3 id="7-img的srcset属性的作⽤？"><a href="#7-img的srcset属性的作⽤？" class="headerlink" title="7. img的srcset属性的作⽤？"></a>7. img的srcset属性的作⽤？</h3><p>响应式页面中经常用到根据屏幕密度设置不同的图片。这时就用到了 img 标签的srcset属性。srcset属性用于设置不同屏幕密度下，img 会自动加载不同的图片。用法如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;image-128.png&quot;</span> <span class="attr">srcset</span>=<span class="string">&quot;image-256.png 2x&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>使用上面的代码，就能实现在屏幕密度为1x的情况下加载image-128.png, 屏幕密度为2x时加载image-256.png。</p><p>按照上面的实现，不同的屏幕密度都要设置图片地址，目前的屏幕密度有1x,2x,3x,4x四种，如果每一个图片都设置4张图片，加载就会很慢。所以就有了新的srcset标准。代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;image-128.png&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">srcset</span>=<span class="string">&quot;image-128.png 128w, image-256.png 256w, image-512.png 512w&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">sizes</span>=<span class="string">&quot;(max-width: 360px) 340px, 128px&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>其中srcset指定图片的地址和对应的图片质量。sizes用来设置图片的尺寸零界点。对于 srcset 中的 w 单位，可以理解成图片质量。如果可视区域小于这个质量的值，就可以使用。浏览器会自动选择一个最小的可用图片。</p><p>sizes语法如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sizes=&quot;[media query] [length], [media query] [length] ... &quot;</span><br></pre></td></tr></table></figure><p>sizes就是指默认显示128px, 如果视区宽度大于360px, 则显示340px。</p><h3 id="8-行内元素有哪些？块级元素有哪些？-空-void-元素有那些？"><a href="#8-行内元素有哪些？块级元素有哪些？-空-void-元素有那些？" class="headerlink" title="8.  行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？"></a>8.  行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？</h3><ul><li>行内元素有：<code>a b span img input select strong</code>；</li><li>块级元素有：<code>div ul ol li dl dt dd h1 h2 h3 h4 h5 h6 p</code>；</li></ul><p>空元素，即没有内容的HTML元素。空元素是在开始标签中关闭的，也就是空元素没有闭合标签：</p><ul><li>常见的有：<code>&lt;br&gt;</code>、<code>&lt;hr&gt;</code>、<code>&lt;img&gt;</code>、<code>&lt;input&gt;</code>、<code>&lt;link&gt;</code>、<code>&lt;meta&gt;</code>；</li><li>鲜见的有：<code>&lt;area&gt;</code>、<code>&lt;base&gt;</code>、<code>&lt;col&gt;</code>、<code>&lt;colgroup&gt;</code>、<code>&lt;command&gt;</code>、<code>&lt;embed&gt;</code>、<code>&lt;keygen&gt;</code>、<code>&lt;param&gt;</code>、<code>&lt;source&gt;</code>、<code>&lt;track&gt;</code>、<code>&lt;wbr&gt;</code>。</li></ul><h3 id="9-说一下-web-worker"><a href="#9-说一下-web-worker" class="headerlink" title="9. 说一下 web worker"></a>9. 说一下 web worker</h3><p>在 HTML 页面中，如果在执行脚本时，页面的状态是不可相应的，直到脚本执行完成后，页面才变成可相应。web worker 是运行在后台的 js，独立于其他脚本，不会影响页面的性能。 并且通过 postMessage 将结果回传到主线程。这样在进行复杂操作的时候，就不会阻塞主线程了。</p><p>如何创建 web worker：</p><ol><li>检测浏览器对于 web worker 的支持性</li><li>创建 web worker 文件（js，回传函数等）</li><li>创建 web worker 对象</li></ol><h3 id="10-HTML5的离线储存怎么使用，它的工作原理是什么"><a href="#10-HTML5的离线储存怎么使用，它的工作原理是什么" class="headerlink" title="10. HTML5的离线储存怎么使用，它的工作原理是什么"></a>10. HTML5的离线储存怎么使用，它的工作原理是什么</h3><p>离线存储指的是：在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件。</p><p><strong>原理：</strong>HTML5的离线存储是基于一个新建的 <code>.appcache</code> 文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示</p><p><strong>使用方法：</strong> （1）创建一个和 html 同名的 manifest 文件，然后在页面头部加入 manifest 属性：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">manifest</span>=<span class="string">&quot;index.manifest&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（2）在 <code>cache.manifest</code> 文件中编写需要离线存储的资源：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CACHE MANIFEST</span><br><span class="line">    #v0.11</span><br><span class="line">    CACHE:</span><br><span class="line">    js/app.js</span><br><span class="line">    css/style.css</span><br><span class="line">    NETWORK:</span><br><span class="line">    resourse/logo.png</span><br><span class="line">    FALLBACK:</span><br><span class="line">    / /offline.html</span><br></pre></td></tr></table></figure><ul><li><strong>CACHE</strong>: 表示需要离线存储的资源列表，由于包含 manifest 文件的页面将被自动离线存储，所以不需要把页面自身也列出来。</li><li><strong>NETWORK</strong>: 表示在它下面列出来的资源只有在在线的情况下才能访问，他们不会被离线存储，所以在离线情况下无法使用这些资源。不过，如果在 CACHE 和 NETWORK 中有一个相同的资源，那么这个资源还是会被离线存储，也就是说 CACHE 的优先级更高。</li><li><strong>FALLBACK</strong>: 表示如果访问第一个资源失败，那么就使用第二个资源来替换他，比如上面这个文件表示的就是如果访问根目录下任何一个资源失败了，那么就去访问 offline.html 。</li></ul><p>（3）在离线状态时，操作 <code>window.applicationCache</code> 进行离线缓存的操作。</p><p><strong>如何更新缓存：</strong></p><p>（1）更新 manifest 文件</p><p>（2）通过 javascript 操作</p><p>（3）清除浏览器缓存</p><p><strong>注意事项：</strong></p><p>（1）浏览器对缓存数据的容量限制可能不太一样（某些浏览器设置的限制是每个站点 5MB）。</p><p>（2）如果 manifest 文件，或者内部列举的某一个文件不能正常下载，整个更新过程都将失败，浏览器继续全部使用老的缓存。</p><p>（3）引用 manifest 的 html 必须与 manifest 文件同源，在同一个域下。</p><p>（4）FALLBACK 中的资源必须和 manifest 文件同源。</p><p>（5）当一个资源被缓存后，该浏览器直接请求这个绝对路径也会访问缓存中的资源。</p><p>（6）站点中的其他页面即使没有设置 manifest 属性，请求的资源如果在缓存中也从缓存中访问。</p><p>（7）当 manifest 文件发生改变时，资源请求本身也会触发更新。</p><h3 id="11-浏览器是如何对-HTML5-的离线储存资源进行管理和加载？"><a href="#11-浏览器是如何对-HTML5-的离线储存资源进行管理和加载？" class="headerlink" title="11. 浏览器是如何对 HTML5 的离线储存资源进行管理和加载？"></a>11. 浏览器是如何对 HTML5 的离线储存资源进行管理和加载？</h3><ul><li><strong>在线的情况下</strong>，浏览器发现 html 头部有 manifest 属性，它会请求 manifest 文件，如果是第一次访问页面 ，那么浏览器就会根据 manifest 文件的内容下载相应的资源并且进行离线存储。如果已经访问过页面并且资源已经进行离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的 manifest 文件与旧的 manifest 文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，就会重新下载文件中的资源并进行离线存储。</li><li><strong>离线的情况下</strong>，浏览器会直接使用离线存储的资源。</li></ul><h3 id="12-title与h1的区别、b与strong的区别、i与em的区别？"><a href="#12-title与h1的区别、b与strong的区别、i与em的区别？" class="headerlink" title="12. title与h1的区别、b与strong的区别、i与em的区别？"></a>12. title与h1的区别、b与strong的区别、i与em的区别？</h3><ul><li>strong标签有语义，是起到加重语气的效果，而b标签是没有的，b标签只是一个简单加粗标签。b标签之间的字符都设为粗体，strong标签加强字符的语气都是通过粗体来实现的，而搜索引擎更侧重strong标签。</li><li>title属性没有明确意义只表示是个标题，H1则表示层次明确的标题，对页面信息的抓取有很大的影响</li><li><strong>i内容展示为斜体，em表示强调的文本</strong></li></ul><h3 id="13-iframe-有那些优点和缺点？"><a href="#13-iframe-有那些优点和缺点？" class="headerlink" title="13. iframe 有那些优点和缺点？"></a>13. <strong>iframe 有那些优点和缺点？</strong></h3><p>iframe 元素会创建包含另外一个文档的内联框架（即行内框架）。</p><p><strong>优点：</strong></p><ul><li>用来加载速度较慢的内容（如广告）</li><li>可以使脚本可以并行下载</li><li>可以实现跨子域通信</li></ul><p><strong>缺点：</strong></p><ul><li>iframe 会阻塞主页面的 onload 事件</li><li>无法被一些搜索引擎索识别</li><li>会产生很多页面，不容易管理</li></ul><h3 id="14-label-的作用是什么？如何使用？"><a href="#14-label-的作用是什么？如何使用？" class="headerlink" title="14. label 的作用是什么？如何使用？"></a>14. label 的作用是什么？如何使用？</h3><p>label标签来定义表单控件的关系：当用户选择label标签时，浏览器会自动将焦点转到和label标签相关的表单控件上。</p><ul><li>使用方法1：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;mobile&quot;</span>&gt;</span>Number:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;mobile&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><ul><li>使用方法2：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span>&gt;</span>Date:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="15-Canvas和SVG的区别"><a href="#15-Canvas和SVG的区别" class="headerlink" title="15. Canvas和SVG的区别"></a>15. Canvas和SVG的区别</h3><p><strong>（1）SVG：</strong> SVG可缩放矢量图形（Scalable Vector Graphics）是基于可扩展标记语言XML描述的2D图形的语言，SVG基于XML就意味着SVG DOM中的每个元素都是可用的，可以为某个元素附加Javascript事件处理器。在 SVG 中，每个被绘制的图形均被视为对象。如果 SVG 对象的属性发生变化，那么浏览器能够自动重现图形。</p><p>其特点如下：</p><ul><li>不依赖分辨率</li><li>支持事件处理器</li><li>最适合带有大型渲染区域的应用程序（比如谷歌地图）</li><li>复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快）</li><li>不适合游戏应用</li></ul><p><strong>（2）Canvas：</strong> Canvas是画布，通过Javascript来绘制2D图形，是逐像素进行渲染的。其位置发生改变，就会重新进行绘制。</p><p>其特点如下：</p><ul><li>依赖分辨率</li><li>不支持事件处理器</li><li>弱的文本渲染能力</li><li>能够以 .png 或 .jpg 格式保存结果图像</li><li>最适合图像密集型的游戏，其中的许多对象会被频繁重绘</li></ul><p>注：矢量图，也称为面向对象的图像或绘图图像，在数学上定义为一系列由线连接的点。矢量文件中的图形元素称为对象。每个对象都是一个自成一体的实体，它具有颜色、形状、轮廓、大小和屏幕位置等属性。</p><h3 id="16-head-标签有什么作用，其中什么标签必不可少？"><a href="#16-head-标签有什么作用，其中什么标签必不可少？" class="headerlink" title="16. head 标签有什么作用，其中什么标签必不可少？"></a>16. head 标签有什么作用，其中什么标签必不可少？</h3><p> 标签用于定义文档的头部，它是所有头部元素的容器。 中的元素可以引用脚本、指示浏览器在哪里找到样式表、提供元信息等。</p><p>文档的头部描述了文档的各种属性和信息，包括文档的标题、在 Web 中的位置以及和其他文档的关系等。绝大多数文档头部包含的数据都不会真正作为内容显示给读者。</p><p>下面这些标签可用在 head 部分：<code>&lt;base&gt;, &lt;link&gt;, &lt;meta&gt;, &lt;script&gt;, &lt;style&gt;, &lt;title&gt;</code>。</p><p>其中 <code>&lt;title&gt;</code> 定义文档的标题，它是 head 部分中唯一必需的元素。</p><h3 id="17-文档声明（Doctype）和-lt-Doctype-html-gt-有何作用-严格模式与混杂模式如何区分？它们有何意义"><a href="#17-文档声明（Doctype）和-lt-Doctype-html-gt-有何作用-严格模式与混杂模式如何区分？它们有何意义" class="headerlink" title="17. 文档声明（Doctype）和&lt;!Doctype html&gt;有何作用? 严格模式与混杂模式如何区分？它们有何意义?"></a>17. 文档声明（Doctype）和<code>&lt;!Doctype html&gt;</code>有何作用? 严格模式与混杂模式如何区分？它们有何意义?</h3><p><strong>文档声明的作用：</strong> 文档声明是为了告诉浏览器，当前<code>HTML</code>文档使用什么版本的<code>HTML</code>来写的，这样浏览器才能按照声明的版本来正确的解析。</p><p><strong>的作用：</strong><code>&lt;!doctype html&gt;</code> 的作用就是让浏览器进入标准模式，使用最新的 <code>HTML5</code> 标准来解析渲染页面；如果不写，浏览器就会进入混杂模式，我们需要避免此类情况发生。</p><p><strong>严格模式与混杂模式的区分：</strong></p><ul><li><strong>严格模式</strong>： 又称为标准模式，指浏览器按照<code>W3C</code>标准解析代码；</li><li><strong>混杂模式</strong>： 又称怪异模式、兼容模式，是指浏览器用自己的方式解析代码。混杂模式通常模拟老式浏览器的行为，以防止老站点无法工作；</li></ul><p><strong>区分</strong>：网页中的<code>DTD</code>，直接影响到使用的是严格模式还是浏览模式，可以说<code>DTD</code>的使用与这两种方式的区别息息相关。</p><ul><li>如果文档包含严格的<code>DOCTYPE</code> ，那么它一般以严格模式呈现（<strong>严格 DTD ——严格模式</strong>）；</li><li>包含过渡 <code>DTD</code> 和 <code>URI</code> 的 <code>DOCTYPE</code> ，也以严格模式呈现，但有过渡 <code>DTD</code> 而没有 <code>URI</code> （统一资源标识符，就是声明最后的地址）会导致页面以混杂模式呈现（<strong>有 URI 的过渡 DTD ——严格模式；没有 URI 的过渡 DTD ——混杂模式</strong>）；</li><li><code>DOCTYPE</code> 不存在或形式不正确会导致文档以混杂模式呈现（<strong>DTD不存在或者格式不正确——混杂模式</strong>）；</li><li><code>HTML5</code> 没有 <code>DTD</code> ，因此也就没有严格模式与混杂模式的区别，<code>HTML5</code> 有相对宽松的 法，实现时，已经尽可能大的实现了向后兼容(<strong>HTML5 没有严格和混杂之分</strong>)。</li></ul><p>总之，<strong>严格模式让各个浏览器统一执行一套规范兼容模式保证了旧网站的正常运行。</strong></p><h3 id="18-浏览器乱码的原因是什么？如何解决？"><a href="#18-浏览器乱码的原因是什么？如何解决？" class="headerlink" title="18. 浏览器乱码的原因是什么？如何解决？"></a>18. 浏览器乱码的原因是什么？如何解决？</h3><p><strong>产生乱码的原因：</strong></p><ul><li>网页源代码是<code>gbk</code>的编码，而内容中的中文字是<code>utf-8</code>编码的，这样浏览器打开即会出现<code>html</code>乱码，反之也会出现乱码；</li><li><code>html</code>网页编码是<code>gbk</code>，而程序从数据库中调出呈现是<code>utf-8</code>编码的内容也会造成编码乱码；</li><li>浏览器不能自动检测网页编码，造成网页乱码。</li></ul><p><strong>解决办法：</strong></p><ul><li>使用软件编辑HTML网页内容；</li><li>如果网页设置编码是<code>gbk</code>，而数据库储存数据编码格式是<code>UTF-8</code>，此时需要程序查询数据库数据显示数据前进程序转码；</li><li>如果浏览器浏览时候出现网页乱码，在浏览器中找到转换编码的菜单进行转换。</li></ul><h3 id="19-渐进增强和优雅降级之间的区别"><a href="#19-渐进增强和优雅降级之间的区别" class="headerlink" title="19. 渐进增强和优雅降级之间的区别"></a>19. 渐进增强和优雅降级之间的区别</h3><p><strong>（1）渐进增强（progressive enhancement）</strong>：主要是针对低版本的浏览器进行页面重构，保证基本的功能情况下，再针对高级浏览器进行效果、交互等方面的改进和追加功能，以达到更好的用户体验。 <strong>（2）优雅降级 graceful degradation</strong>： 一开始就构建完整的功能，然后再针对低版本的浏览器进行兼容。</p><p><strong>两者区别：</strong></p><ul><li>优雅降级是从复杂的现状开始的，并试图减少用户体验的供给；而渐进增强是从一个非常基础的，能够起作用的版本开始的，并在此基础上不断扩充，以适应未来环境的需要；</li><li>降级（功能衰竭）意味着往回看，而渐进增强则意味着往前看，同时保证其根基处于安全地带。</li></ul><p>“优雅降级”观点认为应该针对那些最高级、最完善的浏览器来设计网站。而将那些被认为“过时”或有功能缺失的浏览器下的测试工作安排在开发周期的最后阶段，并把测试对象限定为主流浏览器（如 IE、Mozilla 等）的前一个版本。 在这种设计范例下，旧版的浏览器被认为仅能提供“简陋却无妨 (poor, but passable)” 的浏览体验。可以做一些小的调整来适应某个特定的浏览器。但由于它们并非我们所关注的焦点，因此除了修复较大的错误之外，其它的差异将被直接忽略。</p><p>“渐进增强”观点则认为应关注于内容本身。内容是建立网站的诱因，有的网站展示它，有的则收集它，有的寻求，有的操作，还有的网站甚至会包含以上的种种，但相同点是它们全都涉及到内容。这使得“渐进增强”成为一种更为合理的设计范例。这也是它立即被 Yahoo 所采纳并用以构建其“分级式浏览器支持 (Graded Browser Support)”策略的原因所在。</p><h3 id="20-说一下-HTML5-drag-API"><a href="#20-说一下-HTML5-drag-API" class="headerlink" title="20. 说一下 HTML5 drag API"></a>20. 说一下 HTML5 drag API</h3><ul><li>dragstart：事件主体是被拖放元素，在开始拖放被拖放元素时触发。</li><li>darg：事件主体是被拖放元素，在正在拖放被拖放元素时触发。</li><li>dragenter：事件主体是目标元素，在被拖放元素进入某元素时触发。</li><li>dragover：事件主体是目标元素，在被拖放在某元素内移动时触发。</li><li>dragleave：事件主体是目标元素，在被拖放元素移出目标元素是触发。</li><li>drop：事件主体是目标元素，在目标元素完全接受被拖放元素时触发。</li><li>dragend：事件主体是被拖放元素，在整个拖放操作结束时触发。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS复习</title>
      <link href="/posts/d9795d86.html"/>
      <url>/posts/d9795d86.html</url>
      
        <content type="html"><![CDATA[<p>JS复习记录</p><span id="more"></span><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230610112558784.png" alt="image-20230610112558784"></p><h2 id="一、数据类型"><a href="#一、数据类型" class="headerlink" title="一、数据类型"></a>一、数据类型</h2><h3 id="1-JavaScript有哪些数据类型，它们的区别？"><a href="#1-JavaScript有哪些数据类型，它们的区别？" class="headerlink" title="1. JavaScript有哪些数据类型，它们的区别？"></a>1. JavaScript有哪些数据类型，它们的区别？</h3><p>JavaScript共有八种数据类型，分别是 Undefined、Null、Boolean、Number、String、Object、Symbol、BigInt。</p><p>其中 Symbol 和 BigInt 是ES6 中新增的数据类型：</p><ul><li>Symbol 代表创建后独一无二且不可变的数据类型，它主要是为了解决可能出现的全局变量冲突的问题。</li><li>BigInt 是一种数字类型的数据，它可以表示任意精度格式的整数，使用 BigInt 可以安全地存储和操作大整数，即使这个数已经超出了 Number 能够表示的安全整数范围。</li></ul><p>这些数据可以分为原始数据类型和引用数据类型：</p><ul><li>栈：原始数据类型（Undefined、Null、Boolean、Number、String）</li><li>堆：引用数据类型（对象、数组和函数）</li></ul><p>两种类型的区别在于<strong>存储位置的不同：</strong></p><ul><li>原始数据类型直接存储在栈（stack）中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；</li><li>引用数据类型存储在堆（heap）中的对象，占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。</li></ul><p>堆和栈的概念存在于数据结构和操作系统内存中，在数据结构中：</p><ul><li>在数据结构中，栈中数据的存取方式为先进后出。</li><li>堆是一个优先队列，是按优先级来进行排序的，优先级可以按照大小来规定。</li></ul><p>在操作系统中，内存被分为栈区和堆区：</p><ul><li>栈区内存由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。</li><li>堆区内存一般由开发着分配释放，若开发者不释放，程序结束时可能由垃圾回收机制回收。</li></ul><h3 id="2-数据类型检测的方式有哪些"><a href="#2-数据类型检测的方式有哪些" class="headerlink" title="2. 数据类型检测的方式有哪些"></a>2. 数据类型检测的方式有哪些</h3><p><strong>（1）typeof</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="number">2</span>);               <span class="comment">// number</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="literal">true</span>);            <span class="comment">// boolean</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="string">&#x27;str&#x27;</span>);           <span class="comment">// string</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> []);              <span class="comment">// object    </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;);    <span class="comment">// function</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> &#123;&#125;);              <span class="comment">// object</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="literal">undefined</span>);       <span class="comment">// undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="literal">null</span>);            <span class="comment">// object</span></span><br></pre></td></tr></table></figure><p>其中数组、对象、null都会被判断为object，其他判断都正确。</p><p><strong>（2）instanceof</strong></p><p><code>instanceof</code>可以正确判断对象的类型，<strong>其内部运行机制是判断在其原型链中能否找到该类型的原型</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span> <span class="keyword">instanceof</span> <span class="title class_">Number</span>);                    <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">true</span> <span class="keyword">instanceof</span> <span class="title class_">Boolean</span>);                <span class="comment">// false </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;str&#x27;</span> <span class="keyword">instanceof</span> <span class="title class_">String</span>);                <span class="comment">// false </span></span><br><span class="line"> </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([] <span class="keyword">instanceof</span> <span class="title class_">Array</span>);                    <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125; <span class="keyword">instanceof</span> <span class="title class_">Function</span>);       <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(&#123;&#125; <span class="keyword">instanceof</span> <span class="title class_">Object</span>);                   <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>可以看到，<code>instanceof</code><strong>只能正确判断引用数据类型</strong>，而不能判断基本数据类型。<code>instanceof</code> 运算符可以用来测试一个对象在其原型链中是否存在一个构造函数的 <code>prototype</code> 属性。</p><p><strong>（3） constructor</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((<span class="number">2</span>).<span class="property">constructor</span> === <span class="title class_">Number</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((<span class="literal">true</span>).<span class="property">constructor</span> === <span class="title class_">Boolean</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((<span class="string">&#x27;str&#x27;</span>).<span class="property">constructor</span> === <span class="title class_">String</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(([]).<span class="property">constructor</span> === <span class="title class_">Array</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((<span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;).<span class="property">constructor</span> === <span class="title class_">Function</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((&#123;&#125;).<span class="property">constructor</span> === <span class="title class_">Object</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><code>constructor</code>有两个作用，一是判断数据的类型，二是对象实例通过 <code>constrcutor</code> 对象访问它的构造函数。需要注意，如果创建一个对象来改变它的原型，<code>constructor</code>就不能用来判断数据类型了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Fn</span>(<span class="params"></span>)&#123;&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="title class_">Fn</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Array</span>();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> <span class="title class_">Fn</span>();</span><br><span class="line"> </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f.<span class="property">constructor</span>===<span class="title class_">Fn</span>);    <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f.<span class="property">constructor</span>===<span class="title class_">Array</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><strong>（4）Object.prototype.toString.call()</strong></p><p><code>Object.prototype.toString.call()</code> 使用 Object 对象的原型方法 toString 来判断数据类型：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>;</span><br><span class="line"> </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">call</span>(<span class="number">2</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">call</span>(<span class="literal">true</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">call</span>(<span class="string">&#x27;str&#x27;</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">call</span>([]));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">call</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">call</span>(&#123;&#125;));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">call</span>(<span class="literal">undefined</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">call</span>(<span class="literal">null</span>));</span><br></pre></td></tr></table></figure><p>同样是检测对象obj调用toString方法，obj.toString()的结果和Object.prototype.toString.call(obj)的结果不一样，这是为什么？</p><p>这是因为toString是Object的原型方法，而Array、function等<strong>类型作为Object的实例，都重写了toString方法</strong>。不同的对象类型调用toString方法时，根据原型链的知识，调用的是对应的重写之后的toString方法（function类型返回内容为函数体的字符串，Array类型返回元素组成的字符串…），而不会去调用Object上原型toString方法（返回对象的具体类型），所以采用obj.toString()不能得到其对象类型，只能将obj转换为字符串类型；因此，在想要得到对象的具体类型时，应该调用Object原型上的toString方法。</p><h3 id="3-判断数组的方式有哪些"><a href="#3-判断数组的方式有哪些" class="headerlink" title="3. 判断数组的方式有哪些"></a>3. 判断数组的方式有哪些</h3><ul><li>通过Object.prototype.toString.call()做判断</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(obj).<span class="title function_">slice</span>(<span class="number">8</span>,-<span class="number">1</span>) === <span class="string">&#x27;Array&#x27;</span>;</span><br></pre></td></tr></table></figure><ul><li>通过原型链做判断</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj.<span class="property">__proto__</span> === <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>;</span><br></pre></td></tr></table></figure><ul><li>通过ES6的Array.isArray()做判断</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="title function_">isArrray</span>(obj);</span><br></pre></td></tr></table></figure><ul><li>通过instanceof做判断</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj <span class="keyword">instanceof</span> <span class="title class_">Array</span></span><br></pre></td></tr></table></figure><ul><li>通过Array.prototype.isPrototypeOf</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">isPrototypeOf</span>(obj)</span><br></pre></td></tr></table></figure><h3 id="4-null和undefined区别"><a href="#4-null和undefined区别" class="headerlink" title="4. null和undefined区别"></a>4. null和undefined区别</h3><p>首先 Undefined 和 Null 都是基本数据类型，这两个基本数据类型分别都只有一个值，就是 undefined 和 null。</p><p>undefined 代表的含义是<strong>未定义</strong>，null 代表的含义是<strong>空对象</strong>。一般变量声明了但还没有定义的时候会返回 undefined，null主要用于赋值给一些可能会返回对象的变量，作为初始化。</p><p>undefined 在 JavaScript 中不是一个保留字，这意味着可以使用 undefined 来作为一个变量名，但是这样的做法是非常危险的，它会影响对 undefined 值的判断。我们可以通过一些方法获得安全的 undefined 值，比如说 void 0。</p><p>当对这两种类型使用 typeof 进行判断时，Null 类型化会返回 “object”，这是一个历史遗留的问题。当使用双等号对两种类型的值进行比较时会返回 true，使用三个等号时会返回 false。</p><h3 id="5-typeof-null-的结果是什么，为什么？"><a href="#5-typeof-null-的结果是什么，为什么？" class="headerlink" title="5. typeof null 的结果是什么，为什么？"></a>5. typeof null 的结果是什么，为什么？</h3><p>typeof null 的结果是Object。</p><p>在 JavaScript 第一个版本中，所有值都存储在 32 位的单元中，每个单元包含一个小的 <strong>类型标签(1-3 bits)</strong> 以及当前要存储值的真实数据。类型标签存储在每个单元的低位中，共有五种数据类型：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">000</span>: object   - 当前存储的数据指向一个对象。</span><br><span class="line">  <span class="number">1</span>: int      - 当前存储的数据是一个 <span class="number">31</span> 位的有符号整数。</span><br><span class="line"><span class="number">010</span>: double   - 当前存储的数据指向一个双精度的浮点数。</span><br><span class="line"><span class="number">100</span>: string   - 当前存储的数据指向一个字符串。</span><br><span class="line"><span class="number">110</span>: boolean  - 当前存储的数据是布尔值。</span><br></pre></td></tr></table></figure><p>如果最低位是 1，则类型标签标志位的长度只有一位；如果最低位是 0，则类型标签标志位的长度占三位，为存储其他四种数据类型提供了额外两个 bit 的长度。</p><p>有两种特殊数据类型：</p><ul><li>undefined的值是 (-2)30(一个超出整数范围的数字)；</li><li>null 的值是机器码 NULL 指针(null 指针的值全是 0)</li></ul><p>那也就是说null的类型标签也是000，和Object的类型标签一样，所以会被判定为Object。</p><h3 id="6-intanceof-操作符的实现原理及实现"><a href="#6-intanceof-操作符的实现原理及实现" class="headerlink" title="6. intanceof 操作符的实现原理及实现"></a>6. intanceof 操作符的实现原理及实现</h3><p>instanceof 运算符用于判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myInstanceof</span>(<span class="params">left, right</span>) &#123;</span><br><span class="line">  <span class="comment">// 获取对象的原型</span></span><br><span class="line">  <span class="keyword">let</span> proto = <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(left)</span><br><span class="line">  <span class="comment">// 获取构造函数的 prototype 对象</span></span><br><span class="line">  <span class="keyword">let</span> prototype = right.<span class="property"><span class="keyword">prototype</span></span>; </span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 判断构造函数的 prototype 对象是否在对象的原型链上</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!proto) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (proto === prototype) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 如果没有找到，就继续从其原型上找，Object.getPrototypeOf方法用来获取指定对象的原型</span></span><br><span class="line">    proto = <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(proto);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-为什么0-1-0-2-0-3，如何让其相等"><a href="#7-为什么0-1-0-2-0-3，如何让其相等" class="headerlink" title="7. 为什么0.1+0.2 ! == 0.3，如何让其相等"></a>7. 为什么0.1+0.2 ! == 0.3，如何让其相等</h3><p>在开发过程中遇到类似这样的问题：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> n1 = <span class="number">0.1</span>, n2 = <span class="number">0.2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(n1 + n2)  <span class="comment">// 0.30000000000000004</span></span><br></pre></td></tr></table></figure><p>这里得到的不是想要的结果，要想等于0.3，就要把它进行转化：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(n1 + n2).<span class="title function_">toFixed</span>(<span class="number">2</span>) <span class="comment">// 注意，toFixed为四舍五入</span></span><br></pre></td></tr></table></figure><p><code>toFixed(num)</code> 方法可把 Number 四舍五入为指定小数位数的数字。那为什么会出现这样的结果呢？</p><p>计算机是通过二进制的方式存储数据的，所以计算机计算0.1+0.2的时候，实际上是计算的两个数的二进制的和。0.1的二进制是<code>0.0001100110011001100...</code>（1100循环），0.2的二进制是：<code>0.00110011001100...</code>（1100循环），这两个数的二进制都是无限循环的数。那JavaScript是如何处理无限循环的二进制小数呢？</p><p>一般我们认为数字包括整数和小数，但是在 JavaScript 中只有一种数字类型：Number，它的实现遵循IEEE 754标准，使用64位固定长度来表示，也就是标准的double双精度浮点数。在二进制科学表示法中，双精度浮点数的小数部分最多只能保留52位，再加上前面的1，其实就是保留53位有效数字，剩余的需要舍去，遵从“0舍1入”的原则。</p><p>根据这个原则，0.1和0.2的二进制数相加，再转化为十进制数就是：<code>0.30000000000000004</code>。</p><p>下面看一下<strong>双精度数是如何保存</strong>的： <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0cb225cf71d748a8b2d6a5615e402711~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img"></p><ul><li>第一部分（蓝色）：用来存储符号位（sign），用来区分正负数，0表示正数，占用1位</li><li>第二部分（绿色）：用来存储指数（exponent），占用11位</li><li>第三部分（红色）：用来存储小数（fraction），占用52位</li></ul><p>对于0.1，它的二进制为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.00011001100110011001100110011001100110011001100110011001</span> <span class="number">10011.</span>..</span><br></pre></td></tr></table></figure><p>转为科学计数法（科学计数法的结果就是浮点数）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.1001100110011001100110011001100110011001100110011001</span>*<span class="number">2</span>^-<span class="number">4</span></span><br></pre></td></tr></table></figure><p>可以看出0.1的符号位为0，指数位为-4，小数位为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1001100110011001100110011001100110011001100110011001</span></span><br></pre></td></tr></table></figure><p>那么问题又来了，<strong>指数位是负数，该如何保存</strong>呢？</p><p>IEEE标准规定了一个偏移量，对于指数部分，每次都加这个偏移量进行保存，这样即使指数是负数，那么加上这个偏移量也就是正数了。由于JavaScript的数字是双精度数，这里就以双精度数为例，它的指数部分为11位，能表示的范围就是0~2047，IEEE固定<strong>双精度数的偏移量为1023</strong>。</p><ul><li>当指数位不全是0也不全是1时(规格化的数值)，IEEE规定，阶码计算公式为 e-Bias。 此时e最小值是1，则1-1023= -1022，e最大值是2046，则2046-1023=1023，可以看到，这种情况下取值范围是<code>-1022~1013</code>。</li><li>当指数位全部是0的时候(非规格化的数值)，IEEE规定，阶码的计算公式为1-Bias，即1-1023= -1022。</li><li>当指数位全部是1的时候(特殊值)，IEEE规定这个浮点数可用来表示3个特殊值，分别是正无穷，负无穷，NaN。 具体的，小数位不为0的时候表示NaN；小数位为0时，当符号位s=0时表示正无穷，s=1时候表示负无穷。</li></ul><p>对于上面的0.1的指数位为-4，-4+1023 = 1019 转化为二进制就是：<code>1111111011</code>.</p><p>所以，0.1表示为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">1111111011</span> <span class="number">1001100110011001100110011001100110011001100110011001</span></span><br></pre></td></tr></table></figure><p>说了这么多，是时候该最开始的问题了，如何实现0.1+0.2=0.3呢？</p><p>对于这个问题，一个直接的解决方法就是设置一个误差范围，通常称为“机器精度”。对JavaScript来说，这个值通常为2-52，在ES6中，提供了<code>Number.EPSILON</code>属性，而它的值就是2-52，只要判断<code>0.1+0.2-0.3</code>是否小于<code>Number.EPSILON</code>，如果小于，就可以判断为0.1+0.2 ===0.3</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">numberepsilon</span>(<span class="params">arg1,arg2</span>)&#123;                   </span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">abs</span>(arg1 - arg2) &lt; <span class="title class_">Number</span>.<span class="property">EPSILON</span>;        </span><br><span class="line">&#125;        </span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">numberepsilon</span>(<span class="number">0.1</span> + <span class="number">0.2</span>, <span class="number">0.3</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="8-如何获取安全的-undefined-值？"><a href="#8-如何获取安全的-undefined-值？" class="headerlink" title="8. 如何获取安全的 undefined 值？"></a>8. 如何获取安全的 undefined 值？</h3><p>因为 undefined 是一个标识符，所以可以被当作变量来使用和赋值，但是这样会影响 undefined 的正常判断。表达式 void ___ 没有返回值，因此返回结果是 undefined。void 并不改变表达式的结果，只是让表达式不返回值。因此可以用 void 0 来获得 undefined。</p><h3 id="9-typeof-NaN-的结果是什么？"><a href="#9-typeof-NaN-的结果是什么？" class="headerlink" title="9. typeof NaN 的结果是什么？"></a>9. typeof NaN 的结果是什么？</h3><p>NaN 指“不是一个数字”（not a number），NaN 是一个“警戒值”（sentinel value，有特殊用途的常规值），用于指出数字类型中的错误情况，即“执行数学运算没有成功，这是失败后返回的结果”。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="title class_">NaN</span>; <span class="comment">// &quot;number&quot;</span></span><br></pre></td></tr></table></figure><p>NaN 是一个特殊值，它和自身不相等，是唯一一个非自反（自反，reflexive，即 x === x 不成立）的值。而 NaN !== NaN 为 true。</p><h3 id="10-isNaN-和-Number-isNaN-函数的区别？"><a href="#10-isNaN-和-Number-isNaN-函数的区别？" class="headerlink" title="10. isNaN 和 Number.isNaN 函数的区别？"></a>10. isNaN 和 Number.isNaN 函数的区别？</h3><ul><li>函数 isNaN 接收参数后，会尝试将这个参数转换为数值，任何不能被转换为数值的的值都会返回 true，因此非数字值传入也会返回 true ，会影响 NaN 的判断。</li><li>函数 Number.isNaN 会首先判断传入参数是否为数字，如果是数字再继续判断是否为 NaN ，不会进行数据类型的转换，这种方法对于 NaN 的判断更为准确。</li></ul><h3 id="12-其他值到字符串的转换规则？"><a href="#12-其他值到字符串的转换规则？" class="headerlink" title="12. 其他值到字符串的转换规则？"></a>12. 其他值到字符串的转换规则？</h3><ul><li>Null 和 Undefined 类型 ，null 转换为 “null”，undefined 转换为 “undefined”，</li><li>Boolean 类型，true 转换为 “true”，false 转换为 “false”。</li><li>Number 类型的值直接转换，不过那些极小和极大的数字会使用指数形式。</li><li>Symbol 类型的值直接转换，但是只允许显式强制类型转换，使用隐式强制类型转换会产生错误。</li><li>对普通对象来说，除非自行定义 toString() 方法，否则会调用 toString()（Object.prototype.toString()）来返回内部属性 [[Class]] 的值，如”[object Object]”。如果对象有自己的 toString() 方法，字符串化时就会调用该方法并使用其返回值。</li></ul><h3 id="13-其他值到数字值的转换规则？"><a href="#13-其他值到数字值的转换规则？" class="headerlink" title="13. 其他值到数字值的转换规则？"></a>13. 其他值到数字值的转换规则？</h3><ul><li>Undefined 类型的值转换为 NaN。</li><li>Null 类型的值转换为 0。</li><li>Boolean 类型的值，true 转换为 1，false 转换为 0。</li><li>String 类型的值转换如同使用 Number() 函数进行转换，如果包含非数字值则转换为 NaN，空字符串为 0。</li><li>Symbol 类型的值不能转换为数字，会报错。</li><li>对象（包括数组）会首先被转换为相应的基本类型值，如果返回的是非数字的基本类型值，则再遵循以上规则将其强制转换为数字。</li></ul><p>为了将值转换为相应的基本类型值，抽象操作 ToPrimitive 会首先（通过内部操作 DefaultValue）检查该值是否有valueOf()方法。如果有并且返回基本类型值，就使用该值进行强制类型转换。如果没有就使用 toString() 的返回值（如果存在）来进行强制类型转换。</p><p>如果 valueOf() 和 toString() 均不返回基本类型值，会产生 TypeError 错误。</p><h3 id="14-其他值到布尔类型的值的转换规则？"><a href="#14-其他值到布尔类型的值的转换规则？" class="headerlink" title="14. 其他值到布尔类型的值的转换规则？"></a>14. 其他值到布尔类型的值的转换规则？</h3><p>以下这些是假值： • undefined • null • false • +0、-0 和 NaN • “”</p><p>假值的布尔强制类型转换结果为 false。从逻辑上说，假值列表以外的都应该是真值。</p><h3 id="15-和-amp-amp-操作符的返回值？"><a href="#15-和-amp-amp-操作符的返回值？" class="headerlink" title="15. || 和 &amp;&amp; 操作符的返回值？"></a>15. || 和 &amp;&amp; 操作符的返回值？</h3><p>|| 和 &amp;&amp; 首先会对第一个操作数执行条件判断，如果其不是布尔值就先强制转换为布尔类型，然后再执行条件判断。</p><ul><li>对于 || 来说，如果条件判断结果为 true 就返回第一个操作数的值，如果为 false 就返回第二个操作数的值。</li><li>&amp;&amp; 则相反，如果条件判断结果为 true 就返回第二个操作数的值，如果为 false 就返回第一个操作数的值。</li></ul><p>|| 和 &amp;&amp; 返回它们其中一个操作数的值，而非条件判断的结果</p><h3 id="16-Object-is-与比较操作符-“-”、“-”-的区别？"><a href="#16-Object-is-与比较操作符-“-”、“-”-的区别？" class="headerlink" title="16. Object.is() 与比较操作符 “===”、“==” 的区别？"></a>16. Object.is() 与比较操作符 “===”、“==” 的区别？</h3><ul><li>使用双等号（==）进行相等判断时，如果两边的类型不一致，则会进行强制类型转化后再进行比较。</li><li>使用三等号（===）进行相等判断时，如果两边的类型不一致时，不会做强制类型准换，直接返回 false。</li><li>使用 Object.is 来进行相等判断时，一般情况下和三等号的判断相同，它处理了一些特殊的情况，比如 -0 和 +0 不再相等，两个 NaN 是相等的。</li></ul><h3 id="17-什么是-JavaScript-中的包装类型？"><a href="#17-什么是-JavaScript-中的包装类型？" class="headerlink" title="17. 什么是 JavaScript 中的包装类型？"></a>17. 什么是 JavaScript 中的包装类型？</h3><p>在 JavaScript 中，基本类型是没有属性和方法的，但是为了便于操作基本类型的值，在调用基本类型的属性或方法时 JavaScript 会在后台隐式地将基本类型的值转换为对象，如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">a.<span class="property">length</span>; <span class="comment">// 3</span></span><br><span class="line">a.<span class="title function_">toUpperCase</span>(); <span class="comment">// &quot;ABC&quot;</span></span><br></pre></td></tr></table></figure><p>在访问<code>&#39;abc&#39;.length</code>时，JavaScript 将<code>&#39;abc&#39;</code>在后台转换成<code>String(&#39;abc&#39;)</code>，然后再访问其<code>length</code>属性。</p><p>JavaScript也可以使用<code>Object</code>函数显式地将基本类型转换为包装类型：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;abc&#x27;</span></span><br><span class="line"><span class="title class_">Object</span>(a) <span class="comment">// String &#123;&quot;abc&quot;&#125;</span></span><br></pre></td></tr></table></figure><p>也可以使用<code>valueOf</code>方法将包装类型倒转成基本类型：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;abc&#x27;</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="title class_">Object</span>(a)</span><br><span class="line"><span class="keyword">var</span> c = b.<span class="title function_">valueOf</span>() <span class="comment">// &#x27;abc&#x27;</span></span><br></pre></td></tr></table></figure><p>看看如下代码会打印出什么：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="title class_">Boolean</span>( <span class="literal">false</span> );</span><br><span class="line"><span class="keyword">if</span> (!a) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&quot;Oops&quot;</span> ); <span class="comment">// never runs</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案是什么都不会打印，因为虽然包裹的基本类型是<code>false</code>，但是<code>false</code>被包裹成包装类型后就成了对象，所以其非值为<code>false</code>，所以循环体中的内容不会运行。</p><h3 id="18-JavaScript-中如何进行隐式类型转换？"><a href="#18-JavaScript-中如何进行隐式类型转换？" class="headerlink" title="18. JavaScript 中如何进行隐式类型转换？"></a>18. JavaScript 中如何进行隐式类型转换？</h3><p>首先要介绍<code>ToPrimitive</code>方法，这是 JavaScript 中每个值隐含的自带的方法，用来将值 （无论是基本类型值还是对象）转换为基本类型值。如果值为基本类型，则直接返回值本身；如果值为对象，其看起来大概是这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@obj</span> 需要转换的对象</span></span><br><span class="line"><span class="comment">* <span class="doctag">@type</span> 期望的结果类型</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="title class_">ToPrimitive</span>(obj,type)</span><br></pre></td></tr></table></figure><p><code>type</code>的值为<code>number</code>或者<code>string</code>。</p><p><strong>（1）当</strong><code>type</code><strong>为</strong><code>number</code><strong>时规则如下：</strong></p><ul><li>调用<code>obj</code>的<code>valueOf</code>方法，如果为原始值，则返回，否则下一步；</li><li>调用<code>obj</code>的<code>toString</code>方法，后续同上；</li><li>抛出<code>TypeError</code> 异常。</li></ul><p><strong>（2）当</strong><code>type</code><strong>为</strong><code>string</code><strong>时规则如下：</strong></p><ul><li>调用<code>obj</code>的<code>toString</code>方法，如果为原始值，则返回，否则下一步；</li><li>调用<code>obj</code>的<code>valueOf</code>方法，后续同上；</li><li>抛出<code>TypeError</code> 异常。</li></ul><p>可以看出两者的主要区别在于调用<code>toString</code>和<code>valueOf</code>的先后顺序。默认情况下：</p><ul><li>如果对象为 Date 对象，则<code>type</code>默认为<code>string</code>；</li><li>其他情况下，<code>type</code>默认为<code>number</code>。</li></ul><p>总结上面的规则，对于 Date 以外的对象，转换为基本类型的大概规则可以概括为一个函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title function_">objToNumber</span> = value =&gt; <span class="title class_">Number</span>(value.<span class="title function_">valueOf</span>().<span class="title function_">toString</span>())</span><br><span class="line"><span class="title function_">objToNumber</span>([]) === <span class="number">0</span></span><br><span class="line"><span class="title function_">objToNumber</span>(&#123;&#125;) === <span class="title class_">NaN</span></span><br></pre></td></tr></table></figure><p>而 JavaScript 中的隐式类型转换主要发生在<code>+、-、*、/</code>以及<code>==、&gt;、&lt;</code>这些运算符之间。而这些运算符只能操作基本类型值，所以在进行这些运算前的第一步就是将两边的值用<code>ToPrimitive</code>转换成基本类型，再进行操作。</p><p>以下是基本类型的值在不同操作符的情况下隐式转换的规则 （对于对象，其会被<code>ToPrimitive</code>转换成基本类型，所以最终还是要应用基本类型转换规则）：</p><ol><li><code>+</code><strong>操作符</strong> <code>+</code>操作符的两边有至少一个<code>string</code>类型变量时，两边的变量都会被隐式转换为字符串；其他情况下两边的变量都会被转换为数字。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> + <span class="string">&#x27;23&#x27;</span> <span class="comment">// &#x27;123&#x27;</span></span><br><span class="line"> <span class="number">1</span> + <span class="literal">false</span> <span class="comment">// 1 </span></span><br><span class="line"> <span class="number">1</span> + <span class="title class_">Symbol</span>() <span class="comment">// Uncaught TypeError: Cannot convert a Symbol value to a number</span></span><br><span class="line"> <span class="string">&#x27;1&#x27;</span> + <span class="literal">false</span> <span class="comment">// &#x27;1false&#x27;</span></span><br><span class="line"> <span class="literal">false</span> + <span class="literal">true</span> <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><ol><li><code>-</code>、<code>*</code>、<code>\</code><strong>操作符</strong></li></ol><p><code>NaN</code>也是一个数字</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> * <span class="string">&#x27;23&#x27;</span> <span class="comment">// 23</span></span><br><span class="line"> <span class="number">1</span> * <span class="literal">false</span> <span class="comment">// 0</span></span><br><span class="line"> <span class="number">1</span> / <span class="string">&#x27;aa&#x27;</span> <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure><ol><li><strong>对于</strong><code>==</code><strong>操作符</strong></li></ol><p>操作符两边的值都尽量转成<code>number</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span> == <span class="literal">true</span> <span class="comment">// false, 3 转为number为3，true转为number为1</span></span><br><span class="line"><span class="string">&#x27;0&#x27;</span> == <span class="literal">false</span> <span class="comment">//true, &#x27;0&#x27;转为number为0，false转为number为0</span></span><br><span class="line"><span class="string">&#x27;0&#x27;</span> == <span class="number">0</span> <span class="comment">// &#x27;0&#x27;转为number为0</span></span><br></pre></td></tr></table></figure><ol><li><strong>对于</strong><code>&lt;</code><strong>和</strong><code>&gt;</code><strong>比较符</strong></li></ol><p>如果两边都是字符串，则比较字母表顺序：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;ca&#x27;</span> &lt; <span class="string">&#x27;bd&#x27;</span> <span class="comment">// false</span></span><br><span class="line"><span class="string">&#x27;a&#x27;</span> &lt; <span class="string">&#x27;b&#x27;</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>其他情况下，转换为数字再比较：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;12&#x27;</span> &lt; <span class="number">13</span> <span class="comment">// true</span></span><br><span class="line"><span class="literal">false</span> &gt; -<span class="number">1</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>以上说的是基本类型的隐式转换，而对象会被<code>ToPrimitive</code>转换为基本类型再进行转换：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;&#125;</span><br><span class="line">a &gt; <span class="number">2</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>其对比过程如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a.<span class="title function_">valueOf</span>() <span class="comment">// &#123;&#125;, 上面提到过，ToPrimitive默认type为number，所以先valueOf，结果还是个对象，下一步</span></span><br><span class="line">a.<span class="title function_">toString</span>() <span class="comment">// &quot;[object Object]&quot;，现在是一个字符串了</span></span><br><span class="line"><span class="title class_">Number</span>(a.<span class="title function_">toString</span>()) <span class="comment">// NaN，根据上面 &lt; 和 &gt; 操作符的规则，要转换成数字</span></span><br><span class="line"><span class="title class_">NaN</span> &gt; <span class="number">2</span> <span class="comment">//false，得出比较结果</span></span><br></pre></td></tr></table></figure><p>又比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;<span class="attr">name</span>:<span class="string">&#x27;Jack&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">var</span> b = &#123;<span class="attr">age</span>: <span class="number">18</span>&#125;</span><br><span class="line">a + b <span class="comment">// &quot;[object Object][object Object]&quot;</span></span><br></pre></td></tr></table></figure><p>运算过程如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a.<span class="title function_">valueOf</span>() <span class="comment">// &#123;&#125;，上面提到过，ToPrimitive默认type为number，所以先valueOf，结果还是个对象，下一步</span></span><br><span class="line">a.<span class="title function_">toString</span>() <span class="comment">// &quot;[object Object]&quot;</span></span><br><span class="line">b.<span class="title function_">valueOf</span>() <span class="comment">// 同理</span></span><br><span class="line">b.<span class="title function_">toString</span>() <span class="comment">// &quot;[object Object]&quot;</span></span><br><span class="line">a + b <span class="comment">// &quot;[object Object][object Object]&quot;</span></span><br></pre></td></tr></table></figure><h3 id="19-操作符什么时候用于字符串的拼接？"><a href="#19-操作符什么时候用于字符串的拼接？" class="headerlink" title="19. + 操作符什么时候用于字符串的拼接？"></a>19. <code>+</code> 操作符什么时候用于字符串的拼接？</h3><p>根据 ES5 规范，如果某个操作数是字符串或者能够通过以下步骤转换为字符串的话，+ 将进行拼接操作。如果其中一个操作数是对象（包括数组），则首先对其调用 ToPrimitive 抽象操作，该抽象操作再调用 [[DefaultValue]]，以数字作为上下文。如果不能转换为字符串，则会将其转换为数字类型来进行计算。</p><p>简单来说就是，如果 + 的其中一个操作数是字符串（或者通过以上步骤最终得到字符串），则执行字符串拼接，否则执行数字加法。</p><p>那么对于除了加法的运算符来说，只要其中一方是数字，那么另一方就会被转为数字。</p><h3 id="20-为什么会有BigInt的提案？"><a href="#20-为什么会有BigInt的提案？" class="headerlink" title="20. 为什么会有BigInt的提案？"></a>20. 为什么会有<strong>BigInt</strong>的提案？</h3><p>JavaScript中Number.MAX_SAFE_INTEGER表示最⼤安全数字，计算结果是9007199254740991，即在这个数范围内不会出现精度丢失（⼩数除外）。但是⼀旦超过这个范围，js就会出现计算不准确的情况，这在⼤数计算的时候不得不依靠⼀些第三⽅库进⾏解决，因此官⽅提出了BigInt来解决此问题。</p><h3 id="21-object-assign和扩展运算法是深拷贝还是浅拷贝，两者区别"><a href="#21-object-assign和扩展运算法是深拷贝还是浅拷贝，两者区别" class="headerlink" title="21. object.assign和扩展运算法是深拷贝还是浅拷贝，两者区别"></a>21. object.assign和扩展运算法是深拷贝还是浅拷贝，两者区别</h3><p>扩展运算符：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> outObj = &#123;</span><br><span class="line">  <span class="attr">inObj</span>: &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> newObj = &#123;...outObj&#125;</span><br><span class="line">newObj.<span class="property">inObj</span>.<span class="property">a</span> = <span class="number">2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(outObj) <span class="comment">// &#123;inObj: &#123;a: 2, b: 2&#125;&#125;</span></span><br></pre></td></tr></table></figure><p>Object.assign():</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> outObj = &#123;</span><br><span class="line">  <span class="attr">inObj</span>: &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> newObj = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, outObj)</span><br><span class="line">newObj.<span class="property">inObj</span>.<span class="property">a</span> = <span class="number">2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(outObj) <span class="comment">// &#123;inObj: &#123;a: 2, b: 2&#125;&#125;</span></span><br></pre></td></tr></table></figure><p>可以看到，两者都是浅拷贝。</p><ul><li>Object.assign()方法接收的第一个参数作为目标对象，后面的所有参数作为源对象。然后把所有的源对象合并到目标对象中。它会修改了一个对象，因此会触发 ES6 setter。</li><li>扩展操作符（…）使用它时，数组或对象中的每一个值都会被拷贝到一个新的数组或对象中。它不复制继承的属性或类的属性，但是它会复制ES6的 symbols 属性。</li></ul><h2 id="二、ES6"><a href="#二、ES6" class="headerlink" title="二、ES6"></a>二、ES6</h2><h3 id="1-let、const、var的区别"><a href="#1-let、const、var的区别" class="headerlink" title="1. let、const、var的区别"></a>1. let、const、var的区别</h3><p><strong>（1）块级作用域：</strong> 块作用域由 <code>&#123; &#125;</code>包括，let和const具有块级作用域，var不存在块级作用域。块级作用域解决了ES5中的两个问题：</p><ul><li>内层变量可能覆盖外层变量</li><li>用来计数的循环变量泄露为全局变量</li></ul><p><strong>（2）变量提升：</strong> var存在变量提升，let和const不存在变量提升，即在变量只能在声明之后使用，否在会报错。</p><p><strong>（3）给全局添加属性：</strong> 浏览器的全局对象是window，Node的全局对象是global。var声明的变量为全局变量，并且会将该变量添加为全局对象的属性，但是let和const不会。</p><p><strong>（4）重复声明：</strong> var声明变量时，可以重复声明变量，后声明的同名变量会覆盖之前声明的遍历。const和let不允许重复声明变量。</p><p><strong>（5）暂时性死区：</strong> 在使用let、const命令声明变量之前，该变量都是不可用的。这在语法上，称为<strong>暂时性死区</strong>。使用var声明的变量不存在暂时性死区。</p><p><strong>（6）初始值设置：</strong> 在变量声明时，var 和 let 可以不用设置初始值。而const声明变量必须设置初始值。</p><p><strong>（7）指针指向：</strong> let和const都是ES6新增的用于创建变量的语法。 let创建的变量是可以更改指针指向（可以重新赋值）。但const声明的变量是不允许改变指针的指向。</p><table><thead><tr><th><strong>区别</strong></th><th><strong>var</strong></th><th><strong>let</strong></th><th><strong>const</strong></th></tr></thead><tbody><tr><td>是否有块级作用域</td><td>×</td><td>✔️</td><td>✔️</td></tr><tr><td>是否存在变量提升</td><td>✔️</td><td>×</td><td>×</td></tr><tr><td>是否添加全局属性</td><td>✔️</td><td>×</td><td>×</td></tr><tr><td>能否重复声明变量</td><td>✔️</td><td>×</td><td>×</td></tr><tr><td>是否存在暂时性死区</td><td>×</td><td>✔️</td><td>✔️</td></tr><tr><td>是否必须设置初始值</td><td>×</td><td>×</td><td>✔️</td></tr><tr><td>能否改变指针指向</td><td>✔️</td><td>✔️</td><td>×</td></tr></tbody></table><h3 id="2-const对象的属性可以修改吗"><a href="#2-const对象的属性可以修改吗" class="headerlink" title="2. const对象的属性可以修改吗"></a>2. const对象的属性可以修改吗</h3><p>const保证的并不是变量的值不能改动，而是变量指向的那个内存地址不能改动。对于基本类型的数据（数值、字符串、布尔值），其值就保存在变量指向的那个内存地址，因此等同于常量。</p><p>但对于引用类型的数据（主要是对象和数组）来说，变量指向数据的内存地址，保存的只是一个指针，const只能保证这个指针是固定不变的，至于它指向的数据结构是不是可变的，就完全不能控制了。</p><h3 id="3-如果new一个箭头函数的会怎么样"><a href="#3-如果new一个箭头函数的会怎么样" class="headerlink" title="3. 如果new一个箭头函数的会怎么样"></a>3. 如果new一个箭头函数的会怎么样</h3><p>箭头函数是ES6中的提出来的，它没有prototype，也没有自己的this指向，更不可以使用arguments参数，所以不能New一个箭头函数。</p><p>new操作符的实现步骤如下：</p><ol><li>创建一个对象</li><li>将构造函数的作用域赋给新对象（也就是将对象的__proto__属性指向构造函数的prototype属性）</li><li>指向构造函数中的代码，构造函数中的this指向该对象（也就是为这个对象添加属性和方法）</li><li>返回新的对象</li></ol><p>所以，上面的第二、三步，箭头函数都是没有办法执行的。</p><h3 id="4-箭头函数与普通函数的区别"><a href="#4-箭头函数与普通函数的区别" class="headerlink" title="4. 箭头函数与普通函数的区别"></a>4. 箭头函数与普通函数的区别</h3><p><strong>（1）箭头函数比普通函数更加简洁</strong></p><ul><li>如果没有参数，就直接写一个空括号即可</li><li>如果只有一个参数，可以省去参数的括号</li><li>如果有多个参数，用逗号分割</li><li>如果函数体的返回值只有一句，可以省略大括号</li><li>如果函数体不需要返回值，且只有一句话，可以给这个语句前面加一个void关键字。最常见的就是调用一个函数：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">fn</span> = (<span class="params"></span>) =&gt; <span class="keyword">void</span> <span class="title function_">doesNotReturn</span>();</span><br></pre></td></tr></table></figure><p><strong>（2）箭头函数没有自己的this</strong></p><p>箭头函数不会创建自己的this， 所以它没有自己的this，它只会在自己作用域的上一层继承this。所以箭头函数中this的指向在它在定义时已经确定了，之后不会改变。</p><p><strong>（3）箭头函数继承来的this指向永远不会改变</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> id = <span class="string">&#x27;GLOBAL&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="string">&#x27;OBJ&#x27;</span>,</span><br><span class="line">  <span class="attr">a</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">id</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">b</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">id</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.<span class="title function_">a</span>();    <span class="comment">// &#x27;OBJ&#x27;</span></span><br><span class="line">obj.<span class="title function_">b</span>();    <span class="comment">// &#x27;GLOBAL&#x27;</span></span><br><span class="line"><span class="keyword">new</span> obj.<span class="title function_">a</span>()  <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">new</span> obj.<span class="title function_">b</span>()  <span class="comment">// Uncaught TypeError: obj.b is not a constructor</span></span><br></pre></td></tr></table></figure><p>对象obj的方法b是使用箭头函数定义的，这个函数中的this就永远指向它定义时所处的全局执行环境中的this，即便这个函数是作为对象obj的方法调用，this依旧指向Window对象。需要注意，定义对象的大括号<code>&#123;&#125;</code>是无法形成一个单独的执行环境的，它依旧是处于全局执行环境中。</p><p><strong>（4）call()、apply()、bind()等方法不能改变箭头函数中this的指向</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> id = <span class="string">&#x27;Global&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="title function_">fun1</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">id</span>)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">fun1</span>();                     <span class="comment">// &#x27;Global&#x27;</span></span><br><span class="line">fun1.<span class="title function_">call</span>(&#123;<span class="attr">id</span>: <span class="string">&#x27;Obj&#x27;</span>&#125;);     <span class="comment">// &#x27;Global&#x27;</span></span><br><span class="line">fun1.<span class="title function_">apply</span>(&#123;<span class="attr">id</span>: <span class="string">&#x27;Obj&#x27;</span>&#125;);    <span class="comment">// &#x27;Global&#x27;</span></span><br><span class="line">fun1.<span class="title function_">bind</span>(&#123;<span class="attr">id</span>: <span class="string">&#x27;Obj&#x27;</span>&#125;)();   <span class="comment">// &#x27;Global&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>（5）箭头函数不能作为构造函数使用</strong></p><p>构造函数在new的步骤在上面已经说过了，实际上第二步就是将函数中的this指向该对象。 但是由于箭头函数时没有自己的this的，且this指向外层的执行环境，且不能改变指向，所以不能当做构造函数使用。</p><p><strong>（6）箭头函数没有自己的arguments</strong></p><p>箭头函数没有自己的arguments对象。在箭头函数中访问arguments实际上获得的是它外层函数的arguments值。</p><p><strong>（7）箭头函数没有prototype</strong></p><p><strong>（8）箭头函数不能用作Generator函数，不能使用yeild关键字</strong></p><h3 id="5-箭头函数的this指向哪⾥？"><a href="#5-箭头函数的this指向哪⾥？" class="headerlink" title="5. 箭头函数的this指向哪⾥？"></a>5. 箭头函数的<strong>this</strong>指向哪⾥？</h3><p>箭头函数不同于传统JavaScript中的函数，箭头函数并没有属于⾃⼰的this，它所谓的this是捕获其所在上下⽂的 this 值，作为⾃⼰的 this 值，并且由于没有属于⾃⼰的this，所以是不会被new调⽤的，这个所谓的this也不会被改变。</p><p>可以⽤Babel理解⼀下箭头函数:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES6 </span></span><br><span class="line"><span class="keyword">const</span> obj = &#123; </span><br><span class="line">  <span class="title function_">getArrow</span>(<span class="params"></span>) &#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123; </span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span> === obj); </span><br><span class="line">    &#125;; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转化后：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5，由 Babel 转译</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123; </span><br><span class="line">   <span class="attr">getArrow</span>: <span class="keyword">function</span> <span class="title function_">getArrow</span>(<span class="params"></span>) &#123; </span><br><span class="line">     <span class="keyword">var</span> _this = <span class="variable language_">this</span>; </span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123; </span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(_this === obj); </span><br><span class="line">     &#125;; </span><br><span class="line">   &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="6-扩展运算符的作用及使用场景"><a href="#6-扩展运算符的作用及使用场景" class="headerlink" title="6. 扩展运算符的作用及使用场景"></a>6. 扩展运算符的作用及使用场景</h3><p><strong>（1）对象扩展运算符</strong></p><p>对象的扩展运算符(…)用于取出参数对象中的所有可遍历属性，拷贝到当前对象之中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bar = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> baz = &#123; ...bar &#125;; <span class="comment">// &#123; a: 1, b: 2 &#125;</span></span><br></pre></td></tr></table></figure><p>上述方法实际上等价于:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bar = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> baz = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, bar); <span class="comment">// &#123; a: 1, b: 2 &#125;</span></span><br></pre></td></tr></table></figure><p><code>Object.assign</code>方法用于对象的合并，将源对象<code>（source）</code>的所有可枚举属性，复制到目标对象<code>（target）</code>。<code>Object.assign</code>方法的第一个参数是目标对象，后面的参数都是源对象。(<strong>如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性</strong>)。</p><p>同样，如果用户自定义的属性，放在扩展运算符后面，则扩展运算符内部的同名属性会被覆盖掉。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bar = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> baz = &#123;...bar, ...&#123;<span class="attr">a</span>:<span class="number">2</span>, <span class="attr">b</span>: <span class="number">4</span>&#125;&#125;;  <span class="comment">// &#123;a: 2, b: 4&#125;</span></span><br></pre></td></tr></table></figure><p>利用上述特性就可以很方便的修改对象的部分属性。在<code>redux</code>中的<code>reducer</code>函数规定必须是<strong>一个纯函数</strong>，<code>reducer</code>中的<code>state</code>对象要求不能直接修改，可以通过扩展运算符把修改路径的对象都复制一遍，然后产生一个新的对象返回。</p><p>需要注意：<strong>扩展运算符对对象实例的拷贝属于浅拷贝</strong>。</p><p><strong>（2）数组扩展运算符</strong></p><p>数组的扩展运算符可以将一个数组转为用逗号分隔的参数序列，且每次只能展开一层数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(...[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="comment">// 1 2 3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(...[<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="number">5</span>])</span><br><span class="line"><span class="comment">// 1 [2, 3, 4] 5</span></span><br></pre></td></tr></table></figure><p>下面是数组的扩展运算符的应用：</p><ul><li><strong>将数组转换为参数序列</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="title function_">add</span>(...numbers) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><ul><li><strong>复制数组</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">const</span> arr2 = [...arr1];</span><br></pre></td></tr></table></figure><p>要记住：<strong>扩展运算符(…)用于取出参数对象中的所有可遍历属性，拷贝到当前对象之中</strong>，这里参数对象是个数组，数组里面的所有对象都是基础数据类型，将所有基础数据类型重新拷贝到新的数组中。</p><ul><li><strong>合并数组</strong></li></ul><p>如果想在数组内合并数组，可以这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>];<span class="keyword">const</span> arr2 = [<span class="string">&#x27;one&#x27;</span>, ...arr1, <span class="string">&#x27;four&#x27;</span>, <span class="string">&#x27;five&#x27;</span>];<span class="comment">// [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;]</span></span><br></pre></td></tr></table></figure><ul><li><strong>扩展运算符与解构赋值结合起来，用于生成数组</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [first, ...rest] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];first <span class="comment">// 1rest  // [2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure><p>需要注意：<strong>如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [...rest, last] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];         <span class="comment">// 报错const [first, ...rest, last] = [1, 2, 3, 4, 5];  // 报错</span></span><br></pre></td></tr></table></figure><ul><li><strong>将字符串转为真正的数组</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[...<span class="string">&#x27;hello&#x27;</span>]    <span class="comment">// [ &quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot; ]</span></span><br></pre></td></tr></table></figure><ul><li><strong>任何 Iterator 接口的对象，都可以用扩展运算符转为真正的数组</strong></li></ul><p>比较常见的应用是可以将某些数据结构转为数组：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arguments对象</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> args = [...<span class="variable language_">arguments</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用于替换<code>es5</code>中的<code>Array.prototype.slice.call(arguments)</code>写法。</p><ul><li><strong>使用</strong><code>Math</code><strong>函数获取数组中特定的值</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">9</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">1</span>];</span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">min</span>(...numbers); <span class="comment">// 1</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">max</span>(...numbers); <span class="comment">// 9</span></span><br></pre></td></tr></table></figure><h3 id="8-对对象与数组的解构的理解"><a href="#8-对对象与数组的解构的理解" class="headerlink" title="8. 对对象与数组的解构的理解"></a>8. 对对象与数组的解构的理解</h3><p>解构是 ES6 提供的一种新的提取数据的模式，这种模式能够从对象或数组里有针对性地拿到想要的数值。 <strong>1）数组的解构</strong> 在解构数组时，以元素的位置为匹配条件来提取想要的数据的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><p>最终，a、b、c分别被赋予了数组第0、1、2个索引位的值：</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230610112704625.png" alt="image-20230610112704625"></p><p>数组里的0、1、2索引位的元素值，精准地被映射到了左侧的第0、1、2个变量里去，这就是数组解构的工作模式。还可以通过给左侧变量数组设置空占位的方式，实现对数组中某几个元素的精准提取：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [a,,c] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure><p>通过把中间位留空，可以顺利地把数组第一位和最后一位的值赋给 a、c 两个变量： </p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230610112753402.png" alt="image-20230610112753402"></p><p><strong>2）对象的解构</strong> 对象解构比数组结构稍微复杂一些，也更显强大。在解构对象时，是以属性的名称为匹配条件，来提取想要的数据的。现在定义一个对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> stu = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Bob&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">24</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假如想要解构它的两个自有属性，可以这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; name, age &#125; = stu</span><br></pre></td></tr></table></figure><p>这样就得到了 name 和 age 两个和 stu 平级的变量：</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230610112810838.png" alt="image-20230610112810838"></p><p>注意，对象解构严格以属性名作为定位依据，所以就算调换了 name 和 age 的位置，结果也是一样的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; age, name &#125; = stu</span><br></pre></td></tr></table></figure><h3 id="9-如何提取高度嵌套的对象里的指定属性？"><a href="#9-如何提取高度嵌套的对象里的指定属性？" class="headerlink" title="9. 如何提取高度嵌套的对象里的指定属性？"></a>9. <strong>如何提取高度嵌套的对象里的指定属性？</strong></h3><p>有时会遇到一些嵌套程度非常深的对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> school = &#123;</span><br><span class="line">   <span class="attr">classes</span>: &#123;</span><br><span class="line">      <span class="attr">stu</span>: &#123;</span><br><span class="line">         <span class="attr">name</span>: <span class="string">&#x27;Bob&#x27;</span>,</span><br><span class="line">         <span class="attr">age</span>: <span class="number">24</span>,</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>像此处的 name 这个变量，嵌套了四层，此时如果仍然尝试老方法来提取它：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; name &#125; = school</span><br></pre></td></tr></table></figure><p>显然是不奏效的，因为 school 这个对象本身是没有 name 这个属性的，name 位于 school 对象的“儿子的儿子”对象里面。要想把 name 提取出来，一种比较笨的方法是逐层解构：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; classes &#125; = school</span><br><span class="line"><span class="keyword">const</span> &#123; stu &#125; = classes</span><br><span class="line"><span class="keyword">const</span> &#123; name &#125; = stu</span><br><span class="line">name <span class="comment">// &#x27;Bob&#x27;</span></span><br></pre></td></tr></table></figure><p>但是还有一种更标准的做法，可以用一行代码来解决这个问题：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; <span class="attr">classes</span>: &#123; <span class="attr">stu</span>: &#123; name &#125; &#125;&#125; = school</span><br><span class="line">       </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name)  <span class="comment">// &#x27;Bob&#x27;</span></span><br></pre></td></tr></table></figure><p>可以在解构出来的变量名右侧，通过冒号+{目标属性名}这种形式，进一步解构它，一直解构到拿到目标数据为止。</p><h3 id="10-对-rest-参数的理解"><a href="#10-对-rest-参数的理解" class="headerlink" title="10. 对 rest 参数的理解"></a>10. 对 rest 参数的理解</h3><p>扩展运算符被用在函数形参上时，<strong>它还可以把一个分离的参数序列整合成一个数组</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mutiple</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> val <span class="keyword">of</span> args) &#123;</span><br><span class="line">    result *= val;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">mutiple</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>) <span class="comment">// 24</span></span><br></pre></td></tr></table></figure><p>这里，传入 mutiple 的是四个分离的参数，但是如果在 mutiple 函数里尝试输出 args 的值，会发现它是一个数组：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mutiple</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(args)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">mutiple</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>) <span class="comment">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure><p>这就是 … rest运算符的又一层威力了，它可以把函数的多个入参收敛进一个数组里。这一点<strong>经常用于获取函数的多余参数，或者像上面这样处理函数参数个数不确定的情况。</strong></p><h3 id="11-ES6中模板语法与字符串处理"><a href="#11-ES6中模板语法与字符串处理" class="headerlink" title="11. ES6中模板语法与字符串处理"></a>11. ES6中模板语法与字符串处理</h3><p>ES6 提出了“模板语法”的概念。在 ES6 以前，拼接字符串是很麻烦的事情：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;css&#x27;</span>   </span><br><span class="line"><span class="keyword">var</span> career = <span class="string">&#x27;coder&#x27;</span> </span><br><span class="line"><span class="keyword">var</span> hobby = [<span class="string">&#x27;coding&#x27;</span>, <span class="string">&#x27;writing&#x27;</span>]</span><br><span class="line"><span class="keyword">var</span> finalString = <span class="string">&#x27;my name is &#x27;</span> + name + <span class="string">&#x27;, I work as a &#x27;</span> + career + <span class="string">&#x27;, I love &#x27;</span> + hobby[<span class="number">0</span>] + <span class="string">&#x27; and &#x27;</span> + hobby[<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>仅仅几个变量，写了这么多加号，还要时刻小心里面的空格和标点符号有没有跟错地方。但是有了模板字符串，拼接难度直线下降：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;css&#x27;</span>   </span><br><span class="line"><span class="keyword">var</span> career = <span class="string">&#x27;coder&#x27;</span> </span><br><span class="line"><span class="keyword">var</span> hobby = [<span class="string">&#x27;coding&#x27;</span>, <span class="string">&#x27;writing&#x27;</span>]</span><br><span class="line"><span class="keyword">var</span> finalString = <span class="string">`my name is <span class="subst">$&#123;name&#125;</span>, I work as a <span class="subst">$&#123;career&#125;</span> I love <span class="subst">$&#123;hobby[<span class="number">0</span>]&#125;</span> and <span class="subst">$&#123;hobby[<span class="number">1</span>]&#125;</span>`</span></span><br></pre></td></tr></table></figure><p>字符串不仅更容易拼了，也更易读了，代码整体的质量都变高了。这就是模板字符串的第一个优势——允许用${}的方式嵌入变量。但这还不是问题的关键，模板字符串的关键优势有两个：</p><ul><li>在模板字符串中，空格、缩进、换行都会被保留</li><li>模板字符串完全支持“运算”式的表达式，可以在${}里完成一些计算</li></ul><p>基于第一点，可以在模板字符串里无障碍地直接写 html 代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> list = <span class="string">`</span></span><br><span class="line"><span class="string">&lt;ul&gt;</span></span><br><span class="line"><span class="string">&lt;li&gt;列表项1&lt;/li&gt;</span></span><br><span class="line"><span class="string">&lt;li&gt;列表项2&lt;/li&gt;</span></span><br><span class="line"><span class="string">&lt;/ul&gt;</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message); <span class="comment">// 正确输出，不存在报错</span></span><br></pre></td></tr></table></figure><p>基于第二点，可以把一些简单的计算和调用丢进 ${} 来做：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> finalString = <span class="string">`<span class="subst">$&#123;a&#125;</span> + <span class="subst">$&#123;b&#125;</span> = <span class="subst">$&#123;a+b&#125;</span>`</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(finalString)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">add</span>(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 输出 &#x27;1 + 2 = 3&#x27;</span></span><br></pre></td></tr></table></figure><p>除了模板语法外， ES6中还新增了一系列的字符串方法用于提升开发效率：</p><p>（1）<strong>存在性判定</strong>：在过去，当判断一个字符/字符串是否在某字符串中时，只能用 indexOf &gt; -1 来做。现在 ES6 提供了三个方法：includes、startsWith、endsWith，它们都会返回一个布尔值来告诉你是否存在。</p><ul><li><strong>includes</strong>：判断字符串与子串的包含关系：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> son = <span class="string">&#x27;haha&#x27;</span> </span><br><span class="line"><span class="keyword">const</span> father = <span class="string">&#x27;xixi haha hehe&#x27;</span></span><br><span class="line">father.<span class="title function_">includes</span>(son) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><ul><li><strong>startsWith</strong>：判断字符串是否以某个/某串字符开头：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> father = <span class="string">&#x27;xixi haha hehe&#x27;</span></span><br><span class="line">father.<span class="title function_">startsWith</span>(<span class="string">&#x27;haha&#x27;</span>) <span class="comment">// false</span></span><br><span class="line">father.<span class="title function_">startsWith</span>(<span class="string">&#x27;xixi&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><ul><li><strong>endsWith</strong>：判断字符串是否以某个/某串字符结尾：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> father = <span class="string">&#x27;xixi haha hehe&#x27;</span></span><br><span class="line">  father.<span class="title function_">endsWith</span>(<span class="string">&#x27;hehe&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>（2）<strong>自动重复</strong>：可以使用 repeat 方法来使同一个字符串输出多次（被连续复制多次）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sourceCode = <span class="string">&#x27;repeat for 3 times;&#x27;</span></span><br><span class="line"><span class="keyword">const</span> repeated = sourceCode.<span class="title function_">repeat</span>(<span class="number">3</span>) </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(repeated) <span class="comment">// repeat for 3 times;repeat for 3 times;repeat for 3 times;</span></span><br></pre></td></tr></table></figure><h2 id="三、JavaScript基础"><a href="#三、JavaScript基础" class="headerlink" title="三、JavaScript基础"></a>三、JavaScript基础</h2><h3 id="1-new操作符的实现原理"><a href="#1-new操作符的实现原理" class="headerlink" title="1. new操作符的实现原理"></a>1. new操作符的实现原理</h3><p><strong>new操作符的执行过程：</strong></p><p>（1）首先创建了一个新的空对象</p><p>（2）设置原型，将对象的原型设置为函数的 prototype 对象。</p><p>（3）让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）</p><p>（4）判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。</p><p>具体实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">objectFactory</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> newObject = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> constructor = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">shift</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>);</span><br><span class="line">  <span class="keyword">let</span> result = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 判断参数是否是一个函数</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> constructor !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;type error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 新建一个空对象，对象的原型为构造函数的 prototype 对象</span></span><br><span class="line">  newObject = <span class="title class_">Object</span>.<span class="title function_">create</span>(constructor.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line">  <span class="comment">// 将 this 指向新建对象，并执行函数</span></span><br><span class="line">  result = constructor.<span class="title function_">apply</span>(newObject, <span class="variable language_">arguments</span>);</span><br><span class="line">  <span class="comment">// 判断返回对象</span></span><br><span class="line">  <span class="keyword">let</span> flag = result &amp;&amp; (<span class="keyword">typeof</span> result === <span class="string">&quot;object&quot;</span> || <span class="keyword">typeof</span> result === <span class="string">&quot;function&quot;</span>);</span><br><span class="line">  <span class="comment">// 判断返回结果</span></span><br><span class="line">  <span class="keyword">return</span> flag ? result : newObject;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用方法</span></span><br><span class="line"><span class="title function_">objectFactory</span>(构造函数, 初始化参数);</span><br></pre></td></tr></table></figure><h3 id="2-map和Object的区别"><a href="#2-map和Object的区别" class="headerlink" title="2. map和Object的区别"></a>2. map和Object的区别</h3><table><thead><tr><th></th><th>Map</th><th>Object</th></tr></thead><tbody><tr><td>意外的键</td><td>Map默认情况不包含任何键，只包含显式插入的键。</td><td>Object 有一个原型, 原型链上的键名有可能和自己在对象上的设置的键名产生冲突。</td></tr><tr><td>键的类型</td><td>Map的键可以是任意值，包括函数、对象或任意基本类型。</td><td>Object 的键必须是 String 或是Symbol。</td></tr><tr><td>键的顺序</td><td>Map 中的 key 是有序的。因此，当迭代的时候， Map 对象以插入的顺序返回键值。</td><td>Object 的键是无序的</td></tr><tr><td>Size</td><td>Map 的键值对个数可以轻易地通过size 属性获取</td><td>Object 的键值对个数只能手动计算</td></tr><tr><td>迭代</td><td>Map 是 iterable 的，所以可以直接被迭代。</td><td>迭代Object需要以某种方式获取它的键然后才能迭代。</td></tr><tr><td>性能</td><td>在频繁增删键值对的场景下表现更好。</td><td>在频繁添加和删除键值对的场景下未作出优化。</td></tr></tbody></table><h3 id="3-map和weakMap的区别"><a href="#3-map和weakMap的区别" class="headerlink" title="3. map和weakMap的区别"></a>3. map和weakMap的区别</h3><p><strong>（1）Map</strong> map本质上就是键值对的集合，但是普通的Object中的键值对中的键只能是字符串。而ES6提供的Map数据结构类似于对象，但是它的键不限制范围，可以是任意类型，是一种更加完善的Hash结构。如果Map的键是一个原始数据类型，只要两个键严格相同，就视为是同一个键。</p><p>实际上Map是一个数组，它的每一个数据也都是一个数组，其形式如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = [</span><br><span class="line">     [<span class="string">&quot;name&quot;</span>,<span class="string">&quot;张三&quot;</span>],</span><br><span class="line">     [<span class="string">&quot;age&quot;</span>,<span class="number">18</span>],</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>Map数据结构有以下操作方法：</p><ul><li><strong>size</strong>： <code>map.size</code> 返回Map结构的成员总数。</li><li>**set(key,value)**：设置键名key对应的键值value，然后返回整个Map结构，如果key已经有值，则键值会被更新，否则就新生成该键。（因为返回的是当前Map对象，所以可以链式调用）</li><li>**get(key)**：该方法读取key对应的键值，如果找不到key，返回undefined。</li><li>**has(key)**：该方法返回一个布尔值，表示某个键是否在当前Map对象中。</li><li>**delete(key)**：该方法删除某个键，返回true，如果删除失败，返回false。</li><li>**clear()**：map.clear()清除所有成员，没有返回值。</li></ul><p>Map结构原生提供是三个遍历器生成函数和一个遍历方法</p><ul><li>keys()：返回键名的遍历器。</li><li>values()：返回键值的遍历器。</li><li>entries()：返回所有成员的遍历器。</li><li>forEach()：遍历Map的所有成员。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>([</span><br><span class="line">     [<span class="string">&quot;foo&quot;</span>,<span class="number">1</span>],</span><br><span class="line">     [<span class="string">&quot;bar&quot;</span>,<span class="number">2</span>],</span><br><span class="line">])</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">of</span> map.<span class="title function_">keys</span>())&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(key);  <span class="comment">// foo bar</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> value <span class="keyword">of</span> map.<span class="title function_">values</span>())&#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(value); <span class="comment">// 1 2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> items <span class="keyword">of</span> map.<span class="title function_">entries</span>())&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(items);  <span class="comment">// [&quot;foo&quot;,1]  [&quot;bar&quot;,2]</span></span><br><span class="line">&#125;</span><br><span class="line">map.<span class="title function_">forEach</span>( <span class="function">(<span class="params">value,key,map</span>) =&gt;</span> &#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(key,value); <span class="comment">// foo 1    bar 2</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>（2）WeakMap</strong> WeakMap 对象也是一组键值对的集合，其中的键是弱引用的。<strong>其键必须是对象</strong>，原始数据类型不能作为key值，而值可以是任意的。</p><p>该对象也有以下几种方法：</p><ul><li>**set(key,value)**：设置键名key对应的键值value，然后返回整个Map结构，如果key已经有值，则键值会被更新，否则就新生成该键。（因为返回的是当前Map对象，所以可以链式调用）</li><li>**get(key)**：该方法读取key对应的键值，如果找不到key，返回undefined。</li><li>**has(key)**：该方法返回一个布尔值，表示某个键是否在当前Map对象中。</li><li>**delete(key)**：该方法删除某个键，返回true，如果删除失败，返回false。</li></ul><p>其clear()方法已经被弃用，所以可以通过创建一个空的WeakMap并替换原对象来实现清除。</p><p>WeakMap的设计目的在于，有时想在某个对象上面存放一些数据，但是这会形成对于这个对象的引用。一旦不再需要这两个对象，就必须手动删除这个引用，否则垃圾回收机制就不会释放对象占用的内存。</p><p>而WeakMap的<strong>键名所引用的对象都是弱引用</strong>，即垃圾回收机制不将该引用考虑在内。因此，只要所引用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存。也就是说，一旦不再需要，WeakMap 里面的<strong>键名对象和所对应的键值对会自动消失，不用手动删除引用</strong>。</p><p><strong>总结：</strong></p><ul><li>Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。</li><li>WeakMap 结构与 Map 结构类似，也是用于生成键值对的集合。但是 WeakMap 只接受对象作为键名（ null 除外），不接受其他类型的值作为键名。而且 WeakMap 的键名所指向的对象，不计入垃圾回收机制。</li></ul><h3 id="4-JavaScript有哪些内置对象"><a href="#4-JavaScript有哪些内置对象" class="headerlink" title="4. JavaScript有哪些内置对象"></a>4. JavaScript有哪些内置对象</h3><p>全局的对象（ global objects ）或称标准内置对象，不要和 “全局对象（global object）” 混淆。这里说的全局的对象是说在 全局作用域里的对象。全局作用域中的其他对象可以由用户的脚本创建或由宿主程序提供。</p><p><strong>标准内置对象的分类：</strong></p><p>（1）值属性，这些全局属性返回一个简单值，这些值没有自己的属性和方法。例如 Infinity、NaN、undefined、null 字面量</p><p>（2）函数属性，全局函数可以直接调用，不需要在调用时指定所属对象，执行结束后会将结果直接返回给调用者。例如 eval()、parseFloat()、parseInt() 等</p><p>（3）基本对象，基本对象是定义或使用其他对象的基础。基本对象包括一般对象、函数对象和错误对象。例如 Object、Function、Boolean、Symbol、Error 等</p><p>（4）数字和日期对象，用来表示数字、日期和执行数学计算的对象。例如 Number、Math、Date</p><p>（5）字符串，用来表示和操作字符串的对象。例如 String、RegExp</p><p>（6）可索引的集合对象，这些对象表示按照索引值来排序的数据集合，包括数组和类型数组，以及类数组结构的对象。例如 Array</p><p>（7）使用键的集合对象，这些集合对象在存储数据时会使用到键，支持按照插入顺序来迭代元素。 例如 Map、Set、WeakMap、WeakSet</p><p>（8）矢量集合，SIMD 矢量集合中的数据会被组织为一个数据序列。 例如 SIMD 等</p><p>（9）结构化数据，这些对象用来表示和操作结构化的缓冲区数据，或使用 JSON 编码的数据。例如 JSON 等</p><p>（10）控制抽象对象 例如 Promise、Generator 等</p><p>（11）反射。例如 Reflect、Proxy</p><p>（12）国际化，为了支持多语言处理而加入 ECMAScript 的对象。例如 Intl、Intl.Collator 等</p><p>（13）WebAssembly</p><p>（14）其他。例如 arguments</p><p><strong>总结：</strong> js 中的内置对象主要指的是在程序执行前存在全局作用域里的由 js 定义的一些全局值属性、函数和用来实例化其他对象的构造函数对象。一般经常用到的如全局变量值 NaN、undefined，全局函数如 parseInt()、parseFloat() 用来实例化对象的构造函数如 Date、Object 等，还有提供数学计算的单体内置对象如 Math 对象。</p><h3 id="5-常用的正则表达式有哪些？"><a href="#5-常用的正则表达式有哪些？" class="headerlink" title="5. 常用的正则表达式有哪些？"></a>5. 常用的正则表达式有哪些？</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// （1）匹配 16 进制颜色值</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/#([0-9a-fA-F]&#123;6&#125;|[0-9a-fA-F]&#123;3&#125;)/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// （2）匹配日期，如 yyyy-mm-dd 格式</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/^[0-9]&#123;4&#125;-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// （3）匹配 qq 号</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/^[1-9][0-9]&#123;4,10&#125;$/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// （4）手机号码正则</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/^1[34578]\d&#123;9&#125;$/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// （5）用户名正则</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/^[a-zA-Z\$][a-zA-Z0-9_\$]&#123;4,16&#125;$/</span>;</span><br></pre></td></tr></table></figure><h3 id="6-对JSON的理解"><a href="#6-对JSON的理解" class="headerlink" title="6. 对JSON的理解"></a>6. 对JSON的理解</h3><p>JSON 是一种基于文本的轻量级的数据交换格式。它可以被任何的编程语言读取和作为数据格式来传递。</p><p>在项目开发中，使用 JSON 作为前后端数据交换的方式。在前端通过将一个符合 JSON 格式的数据结构序列化为 JSON 字符串，然后将它传递到后端，后端通过 JSON 格式的字符串解析后生成对应的数据结构，以此来实现前后端数据的一个传递。</p><p>因为 JSON 的语法是基于 js 的，因此很容易将 JSON 和 js 中的对象弄混，但是应该注意的是 JSON 和 js 中的对象不是一回事，JSON 中对象格式更加严格，比如说在 JSON 中属性值不能为函数，不能出现 NaN 这样的属性值等，因此大多数的 js 对象是不符合 JSON 对象的格式的。</p><p>在 js 中提供了两个函数来实现 js 数据结构和 JSON 格式的转换处理，</p><ul><li>JSON.stringify 函数，通过传入一个符合 JSON 格式的数据结构，将其转换为一个 JSON 字符串。如果传入的数据结构不符合 JSON 格式，那么在序列化的时候会对这些值进行对应的特殊处理，使其符合规范。在前端向后端发送数据时，可以调用这个函数将数据对象转化为 JSON 格式的字符串。</li><li>JSON.parse() 函数，这个函数用来将 JSON 格式的字符串转换为一个 js 数据结构，如果传入的字符串不是标准的 JSON 格式的字符串的话，将会抛出错误。当从后端接收到 JSON 格式的字符串时，可以通过这个方法来将其解析为一个 js 数据结构，以此来进行数据的访问。</li></ul><h3 id="7-JavaScript脚本延迟加载的方式有哪些？"><a href="#7-JavaScript脚本延迟加载的方式有哪些？" class="headerlink" title="7. JavaScript脚本延迟加载的方式有哪些？"></a>7. JavaScript脚本延迟加载的方式有哪些？</h3><p>延迟加载就是等页面加载完成之后再加载 JavaScript 文件。 js 延迟加载有助于提高页面加载速度。</p><p>一般有以下几种方式：</p><ul><li><strong>defer 属性：</strong> 给 js 脚本添加 defer 属性，这个属性会让脚本的加载与文档的解析同步解析，然后在文档解析完成后再执行这个脚本文件，这样的话就能使页面的渲染不被阻塞。多个设置了 defer 属性的脚本按规范来说最后是顺序执行的，但是在一些浏览器中可能不是这样。</li><li><strong>async 属性：</strong> 给 js 脚本添加 async 属性，这个属性会使脚本异步加载，不会阻塞页面的解析过程，但是当脚本加载完成后立即执行 js 脚本，这个时候如果文档没有解析完成的话同样会阻塞。多个 async 属性的脚本的执行顺序是不可预测的，一般不会按照代码的顺序依次执行。</li><li><strong>动态创建 DOM 方式：</strong> 动态创建 DOM 标签的方式，可以对文档的加载事件进行监听，当文档加载完成后再动态的创建 script 标签来引入 js 脚本。</li><li><strong>使用 setTimeout 延迟方法：</strong> 设置一个定时器来延迟加载js脚本文件</li><li><strong>让 JS 最后加载：</strong> 将 js 脚本放在文档的底部，来使 js 脚本尽可能的在最后来加载执行。</li></ul><h3 id="8-JavaScript-类数组对象的定义？"><a href="#8-JavaScript-类数组对象的定义？" class="headerlink" title="8. JavaScript 类数组对象的定义？"></a>8. JavaScript 类数组对象的定义？</h3><p>一个拥有 length 属性和若干索引属性的对象就可以被称为类数组对象，类数组对象和数组类似，但是不能调用数组的方法。常见的类数组对象有 arguments 和 DOM 方法的返回结果，还有一个函数也可以被看作是类数组对象，因为它含有 length 属性值，代表可接收的参数个数。</p><p>常见的类数组转换为数组的方法有这样几种：</p><p>（1）通过 call 调用数组的 slice 方法来实现转换</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(arrayLike);</span><br></pre></td></tr></table></figure><p>（2）通过 call 调用数组的 splice 方法来实现转换</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">splice</span>.<span class="title function_">call</span>(arrayLike, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>（3）通过 apply 调用数组的 concat 方法来实现转换</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">concat</span>.<span class="title function_">apply</span>([], arrayLike);</span><br></pre></td></tr></table></figure><p>（4）通过 Array.from 方法来实现转换</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="title function_">from</span>(arrayLike);</span><br></pre></td></tr></table></figure><h3 id="9-数组有哪些原生方法？"><a href="#9-数组有哪些原生方法？" class="headerlink" title="9. 数组有哪些原生方法？"></a>9. 数组有哪些原生方法？</h3><ul><li>数组和字符串的转换方法：toString()、toLocalString()、join() 其中 join() 方法可以指定转换为字符串时的分隔符。</li><li>数组尾部操作的方法 pop() 和 push()，push 方法可以传入多个参数。</li><li>数组首部操作的方法 shift() 和 unshift() 重排序的方法 reverse() 和 sort()，sort() 方法可以传入一个函数来进行比较，传入前后两个值，如果返回值为正数，则交换两个参数的位置。</li><li>数组连接的方法 concat() ，返回的是拼接好的数组，不影响原数组。</li><li>数组截取办法 slice()，用于截取数组中的一部分返回，不影响原数组。</li><li>数组插入方法 splice()，影响原数组查找特定项的索引的方法，indexOf() 和 lastIndexOf() 迭代方法 every()、some()、filter()、map() 和 forEach() 方法</li><li>数组归并方法 reduce() 和 reduceRight() 方法</li></ul><h3 id="10-Unicode、UTF-8、UTF-16、UTF-32的区别？"><a href="#10-Unicode、UTF-8、UTF-16、UTF-32的区别？" class="headerlink" title="10. Unicode、UTF-8、UTF-16、UTF-32的区别？"></a>10. <strong>Unicode、UTF-8、UTF-16、UTF-32的区别？</strong></h3><h4 id="（1）Unicode"><a href="#（1）Unicode" class="headerlink" title="（1）Unicode"></a>（1）Unicode</h4><p>在说<code>Unicode</code>之前需要先了解一下<code>ASCII</code>码：ASCII 码（<code>American Standard Code for Information Interchange</code>）称为美国标准信息交换码。</p><ul><li>它是基于拉丁字母的一套电脑编码系统。</li><li>它定义了一个用于代表常见字符的字典。</li><li>它包含了”A-Z”(包含大小写)，数据”0-9” 以及一些常见的符号。</li><li>它是专门为英语而设计的，有128个编码，对其他语言无能为力</li></ul><p><code>ASCII</code>码可以表示的编码有限，要想表示其他语言的编码，还是要使用<code>Unicode</code>来表示，可以说<code>Unicode</code>是<code>ASCII</code> 的超集。</p><p><code>Unicode</code>全称 <code>Unicode Translation Format</code>，又叫做统一码、万国码、单一码。<code>Unicode</code> 是为了解决传统的字符编码方案的局限而产生的，它为每种语言中的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求。</p><p><code>Unicode</code>的实现方式（也就是编码方式）有很多种，常见的是<strong>UTF-8</strong>、<strong>UTF-16</strong>、<strong>UTF-32</strong>和<strong>USC-2</strong>。</p><h4 id="（2）UTF-8"><a href="#（2）UTF-8" class="headerlink" title="（2）UTF-8"></a>（2）UTF-8</h4><p><code>UTF-8</code>是使用最广泛的<code>Unicode</code>编码方式，它是一种可变长的编码方式，可以是1—4个字节不等，它可以完全兼容<code>ASCII</code>码的128个字符。</p><p><strong>注意：</strong> <code>UTF-8</code> 是一种编码方式，<code>Unicode</code>是一个字符集合。</p><p><code>UTF-8</code>的编码规则：</p><ul><li>对于<strong>单字节</strong>的符号，字节的第一位为0，后面的7位为这个字符的<code>Unicode</code>编码，因此对于英文字母，它的<code>Unicode</code>编码和<code>ACSII</code>编码一样。</li><li>对于<strong>n字节</strong>的符号，第一个字节的前n位都是1，第n+1位设为0，后面字节的前两位一律设为10，剩下的没有提及的二进制位，全部为这个符号的<code>Unicode</code>码 。</li></ul><p>来看一下具体的<code>Unicode</code>编号范围与对应的<code>UTF-8</code>二进制格式 ：</p><table><thead><tr><th>编码范围（编号对应的十进制数）</th><th>二进制格式</th></tr></thead><tbody><tr><td>0x00—0x7F （0-127）</td><td>0xxxxxxx</td></tr><tr><td>0x80—0x7FF （128-2047）</td><td>110xxxxx 10xxxxxx</td></tr><tr><td>0x800—0xFFFF  （2048-65535）</td><td>1110xxxx 10xxxxxx 10xxxxxx</td></tr><tr><td>0x10000—0x10FFFF  （65536以上）</td><td>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</td></tr></tbody></table><p>那该如何通过具体的<code>Unicode</code>编码，进行具体的<code>UTF-8</code>编码呢？<strong>步骤如下：</strong></p><ul><li>找到该<code>Unicode</code>编码的所在的编号范围，进而找到与之对应的二进制格式</li><li>将<code>Unicode</code>编码转换为二进制数（去掉最高位的0）</li><li>将二进制数从右往左一次填入二进制格式的<code>X</code>中，如果有<code>X</code>未填，就设为0</li></ul><p>来看一个实际的例子： “<strong>马</strong>” 字的<code>Unicode</code>编码是：<code>0x9A6C</code>，整数编号是<code>39532</code> （1）首选确定了该字符在第三个范围内，它的格式是 <code>1110xxxx 10xxxxxx 10xxxxxx</code> （2）39532对应的二进制数为<code>1001 1010 0110 1100</code> （3）将二进制数填入X中，结果是：<code>11101001 10101001 10101100</code></p><h4 id="（3）UTF-16"><a href="#（3）UTF-16" class="headerlink" title="（3）UTF-16"></a>（3）UTF-16</h4><p><strong>1. 平面的概念</strong></p><p>在了解<code>UTF-16</code>之前，先看一下<strong>平面</strong>的概念： <code>Unicode</code>编码中有很多很多的字符，它并不是一次性定义的，而是分区进行定义的，每个区存放<strong>65536</strong>（216）个字符，这称为一个<strong>平面</strong>，目前总共有17 个平面。</p><p>最前面的一个平面称为<strong>基本平面</strong>，它的码点从<strong>0 — 216-1</strong>，写成16进制就是<code>U+0000 — U+FFFF</code>，那剩下的16个平面就是<strong>辅助平面</strong>，码点范围是 <code>U+10000—U+10FFFF</code>。</p><p><strong>2. UTF-16 概念：</strong></p><p><code>UTF-16</code>也是<code>Unicode</code>编码集的一种编码形式，把<code>Unicode</code>字符集的抽象码位映射为16位长的整数（即码元）的序列，用于数据存储或传递。<code>Unicode</code>字符的码位需要1个或者2个16位长的码元来表示，因此<code>UTF-16</code>也是用变长字节表示的。</p><p><strong>3. UTF-16 编码规则：</strong></p><ul><li>编号在 <code>U+0000—U+FFFF</code> 的字符（常用字符集），直接用两个字节表示。</li><li>编号在 <code>U+10000—U+10FFFF</code> 之间的字符，需要用四个字节表示。</li></ul><p><strong>4. 编码识别</strong></p><p>那么问题来了，当遇到两个字节时，怎么知道是把它当做一个字符还是和后面的两个字节一起当做一个字符呢？</p><p><code>UTF-16</code> 编码肯定也考虑到了这个问题，在基本平面内，从 <code>U+D800 — U+DFFF</code> 是一个空段，也就是说这个区间的码点不对应任何的字符，因此这些空段就可以用来映射辅助平面的字符。</p><p>辅助平面共有 <strong>220</strong> 个字符位，因此表示这些字符至少需要 20 个二进制位。<code>UTF-16</code> 将这 20 个二进制位分成两半，前 10 位映射在 <code>U+D800 — U+DBFF</code>，称为<strong>高位</strong>（H），后 10 位映射在 <code>U+DC00 — U+DFFF</code>，称为<strong>低位</strong>（L）。这就相当于，将一个辅助平面的字符拆成了两个基本平面的字符来表示。</p><p>因此，当遇到两个字节时，发现它的码点在 <code>U+D800 —U+DBFF</code>之间，就可以知道，它后面的两个字节的码点应该在 <code>U+DC00 — U+DFFF</code> 之间，这四个字节必须放在一起进行解读。</p><p><strong>5. 举例说明</strong></p><p>以 “<strong>𡠀</strong>“ 字为例，它的 <code>Unicode</code> 码点为 <code>0x21800</code>，该码点超出了基本平面的范围，因此需要用四个字节来表示，步骤如下：</p><ul><li>首先计算超出部分的结果：<code>0x21800 - 0x10000</code></li><li>将上面的计算结果转为20位的二进制数，不足20位就在前面补0，结果为：<code>0001000110 0000000000</code></li><li>将得到的两个10位二进制数分别对应到两个区间中</li><li><code>U+D800</code> 对应的二进制数为 <code>1101100000000000</code>， 将<code>0001000110</code>填充在它的后10 个二进制位，得到 <code>1101100001000110</code>，转成 16 进制数为 <code>0xD846</code>。同理，低位为 <code>0xDC00</code>，所以这个字的<code>UTF-16</code> 编码为 <code>0xD846 0xDC00</code></li></ul><h4 id="（4）-UTF-32"><a href="#（4）-UTF-32" class="headerlink" title="（4） UTF-32"></a>（4） UTF-32</h4><p><code>UTF-32</code> 就是字符所对应编号的整数二进制形式，每个字符占四个字节，这个是直接进行转换的。该编码方式占用的储存空间较多，所以使用较少。</p><p>比如“<strong>马</strong>” 字的Unicode编号是：<code>U+9A6C</code>，整数编号是<code>39532</code>，直接转化为二进制：<code>1001 1010 0110 1100</code>，这就是它的UTF-32编码。</p><h4 id="（5）总结"><a href="#（5）总结" class="headerlink" title="（5）总结"></a>（5）总结</h4><p><strong>Unicode、UTF-8、UTF-16、UTF-32有什么区别？</strong></p><ul><li><code>Unicode</code> 是编码字符集（字符集），而<code>UTF-8</code>、<code>UTF-16</code>、<code>UTF-32</code>是字符集编码（编码规则）；</li><li><code>UTF-16</code> 使用变长码元序列的编码方式，相较于定长码元序列的<code>UTF-32</code>算法更复杂，甚至比同样是变长码元序列的<code>UTF-8</code>也更为复杂，因为其引入了独特的<strong>代理对</strong>这样的代理机制；</li><li><code>UTF-8</code>需要判断每个字节中的开头标志信息，所以如果某个字节在传送过程中出错了，就会导致后面的字节也会解析出错；而<code>UTF-16</code>不会判断开头标志，即使错也只会错一个字符，所以容错能力教强；</li><li>如果字符内容全部英文或英文与其他文字混合，但英文占绝大部分，那么用<code>UTF-8</code>就比<code>UTF-16</code>节省了很多空间；而如果字符内容全部是中文这样类似的字符或者混合字符中中文占绝大多数，那么<code>UTF-16</code>就占优势了，可以节省很多空间；</li></ul><h3 id="11-常见的位运算符有哪些？其计算规则是什么？"><a href="#11-常见的位运算符有哪些？其计算规则是什么？" class="headerlink" title="11. 常见的位运算符有哪些？其计算规则是什么？"></a>11. 常见的位运算符有哪些？其计算规则是什么？</h3><p>现代计算机中数据都是以二进制的形式存储的，即0、1两种状态，计算机对二进制数据进行的运算加减乘除等都是叫位运算，即将符号位共同参与运算的运算。</p><p>常见的位运算有以下几种：</p><table><thead><tr><th>运算符</th><th>描述</th><th>运算规则</th><th></th></tr></thead><tbody><tr><td><code>&amp;</code></td><td>与</td><td>两个位都为1时，结果才为1</td><td></td></tr><tr><td>`</td><td>`</td><td>或</td><td>两个位都为0时，结果才为0</td></tr><tr><td><code>^</code></td><td>异或</td><td>两个位相同为0，相异为1</td><td></td></tr><tr><td><code>~</code></td><td>取反</td><td>0变1，1变0</td><td></td></tr><tr><td><code>&lt;&lt;</code></td><td>左移</td><td>各二进制位全部左移若干位，高位丢弃，低位补0</td><td></td></tr><tr><td><code>&gt;&gt;</code></td><td>右移</td><td>各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃</td><td></td></tr></tbody></table><h4 id="1-按位与运算符（-amp-）"><a href="#1-按位与运算符（-amp-）" class="headerlink" title="1. 按位与运算符（&amp;）"></a>1. 按位与运算符（&amp;）</h4><p><strong>定义：</strong> 参加运算的两个数据<strong>按二进制位</strong>进行“与”运算。 <strong>运算规则：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> &amp; <span class="number">0</span> = <span class="number">0</span>  </span><br><span class="line"><span class="number">0</span> &amp; <span class="number">1</span> = <span class="number">0</span>  </span><br><span class="line"><span class="number">1</span> &amp; <span class="number">0</span> = <span class="number">0</span>  </span><br><span class="line"><span class="number">1</span> &amp; <span class="number">1</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>总结：两位同时为1，结果才为1，否则结果为0。 例如：3&amp;5 即：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000</span> <span class="number">0011</span> </span><br><span class="line">   <span class="number">0000</span> <span class="number">0101</span> </span><br><span class="line"> = <span class="number">0000</span> <span class="number">0001</span></span><br></pre></td></tr></table></figure><p>因此 3&amp;5 的值为1。 注意：负数按补码形式参加按位与运算。</p><p><strong>用途：</strong></p><p><strong>（1）判断奇偶</strong></p><p>只要根据最未位是0还是1来决定，为0就是偶数，为1就是奇数。因此可以用<code>if ((i &amp; 1) == 0)</code>代替<code>if (i % 2 == 0)</code>来判断a是不是偶数。</p><p><strong>（2）清零</strong></p><p>如果想将一个单元清零，即使其全部二进制位为0，只要与一个各位都为零的数值相与，结果为零。</p><h4 id="2-按位或运算符（-）"><a href="#2-按位或运算符（-）" class="headerlink" title="2. 按位或运算符（|）"></a>2. 按位或运算符（|）</h4><p><strong>定义：</strong> 参加运算的两个对象按二进制位进行“或”运算。</p><p><strong>运算规则：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> | <span class="number">0</span> = <span class="number">0</span></span><br><span class="line"><span class="number">0</span> | <span class="number">1</span> = <span class="number">1</span>  </span><br><span class="line"><span class="number">1</span> | <span class="number">0</span> = <span class="number">1</span>  </span><br><span class="line"><span class="number">1</span> | <span class="number">1</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>总结：参加运算的两个对象只要有一个为1，其值为1。 例如：3|5即：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000</span> <span class="number">0011</span></span><br><span class="line">  <span class="number">0000</span> <span class="number">0101</span> </span><br><span class="line">= <span class="number">0000</span> <span class="number">0111</span></span><br></pre></td></tr></table></figure><p>因此，3|5的值为7。 注意：负数按补码形式参加按位或运算。</p><h4 id="3-异或运算符（-）"><a href="#3-异或运算符（-）" class="headerlink" title="3. 异或运算符（^）"></a>3. 异或运算符（^）</h4><p><strong>定义：</strong> 参加运算的两个数据按二进制位进行“异或”运算。</p><p><strong>运算规则：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> ^ <span class="number">0</span> = <span class="number">0</span>  </span><br><span class="line"><span class="number">0</span> ^ <span class="number">1</span> = <span class="number">1</span>  </span><br><span class="line"><span class="number">1</span> ^ <span class="number">0</span> = <span class="number">1</span>  </span><br><span class="line"><span class="number">1</span> ^ <span class="number">1</span> = <span class="number">0</span></span><br></pre></td></tr></table></figure><p>总结：参加运算的两个对象，如果两个相应位相同为0，相异为1。 例如：3|5即：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000</span> <span class="number">0011</span></span><br><span class="line">  <span class="number">0000</span> <span class="number">0101</span> </span><br><span class="line">= <span class="number">0000</span> <span class="number">0110</span></span><br></pre></td></tr></table></figure><p>因此，3^5的值为6。 异或运算的性质:</p><ul><li>交换律：<code>(a^b)^c == a^(b^c)</code></li><li>结合律：<code>(a + b)^c == a^b + b^c</code></li><li>对于任何数x，都有 <code>x^x=0，x^0=x</code></li><li>自反性: <code>a^b^b=a^0=a</code>;</li></ul><h4 id="4-取反运算符"><a href="#4-取反运算符" class="headerlink" title="4. 取反运算符 (~)"></a>4. 取反运算符 (~)</h4><p><strong>定义：</strong> 参加运算的一个数据按二进制进行“取反”运算。</p><p><strong>运算规则：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~ <span class="number">1</span> = <span class="number">0</span>~ <span class="number">0</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>总结：对一个二进制数按位取反，即将0变1，1变0。 例如：~6 即：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000</span> <span class="number">0110</span>= <span class="number">1111</span> <span class="number">1001</span></span><br></pre></td></tr></table></figure><p>在计算机中，正数用原码表示，负数使用补码存储，首先看最高位，最高位1表示负数，0表示正数。此计算机二进制码为负数，最高位为符号位。 当发现按位取反为负数时，就<strong>直接取其补码</strong>，变为十进制：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000</span> <span class="number">0110</span>   = <span class="number">1111</span> <span class="number">1001</span>反码：<span class="number">1000</span> <span class="number">0110</span>补码：<span class="number">1000</span> <span class="number">0111</span></span><br></pre></td></tr></table></figure><p>因此，~6的值为-7。</p><h4 id="5-左移运算符（-lt-lt-）"><a href="#5-左移运算符（-lt-lt-）" class="headerlink" title="5. 左移运算符（&lt;&lt;）"></a>5. 左移运算符（&lt;&lt;）</h4><p><strong>定义：</strong> 将一个运算对象的各二进制位全部左移若干位，左边的二进制位丢弃，右边补0。 设 a=1010 1110，a = a&lt;&lt; 2 将a的二进制位左移2位、右补0，即得a=1011 1000。 若左移时舍弃的高位不包含1，则每左移一位，相当于该数乘以2。</p><h4 id="6-右移运算符（-gt-gt-）"><a href="#6-右移运算符（-gt-gt-）" class="headerlink" title="6. 右移运算符（&gt;&gt;）"></a>6. 右移运算符（&gt;&gt;）</h4><p><strong>定义：</strong> 将一个数的各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃。 例如：a=a&gt;&gt;2 将a的二进制位右移2位，左补0 或者 左补1得看被移数是正还是负。 操作数每右移一位，相当于该数除以2。</p><h4 id="7-原码、补码、反码"><a href="#7-原码、补码、反码" class="headerlink" title="7. 原码、补码、反码"></a>7. 原码、补码、反码</h4><p>上面提到了补码、反码等知识，这里就补充一下。 计算机中的<strong>有符号数</strong>有三种表示方法，即原码、反码和补码。三种表示方法均有符号位和数值位两部分，符号位都是用0表示“正”，用1表示“负”，而数值位，三种表示方法各不相同。</p><p><strong>（1）原码</strong></p><p>原码就是一个数的二进制数。例如：10的原码为0000 1010</p><p><strong>（2）反码</strong></p><ul><li>正数的反码与原码相同，如：10 反码为 0000 1010</li><li>负数的反码为除符号位，按位取反，即0变1，1变0。</li></ul><p>例如：-10</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">原码：<span class="number">1000</span> <span class="number">1010</span></span><br><span class="line">反码：<span class="number">1111</span> <span class="number">0101</span></span><br></pre></td></tr></table></figure><p><strong>（3）补码</strong></p><ul><li>正数的补码与原码相同，如：10 补码为 0000 1010</li><li>负数的补码是原码除符号位外的所有位取反即0变1，1变0，然后加1，也就是反码加1。</li></ul><p>例如：-10</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">原码：<span class="number">1000</span> <span class="number">1010</span></span><br><span class="line">反码：<span class="number">1111</span> <span class="number">0101</span></span><br><span class="line">补码：<span class="number">1111</span> <span class="number">0110</span></span><br></pre></td></tr></table></figure><h3 id="12-为什么函数的-arguments-参数是类数组而不是数组？如何遍历类数组"><a href="#12-为什么函数的-arguments-参数是类数组而不是数组？如何遍历类数组" class="headerlink" title="12. 为什么函数的 arguments 参数是类数组而不是数组？如何遍历类数组?"></a>12. 为什么函数的 arguments 参数是类数组而不是数组？如何遍历类数组?</h3><p><code>arguments</code>是一个对象，它的属性是从 0 开始依次递增的数字，还有<code>callee</code>和<code>length</code>等属性，与数组相似；但是它却没有数组常见的方法属性，如<code>forEach</code>, <code>reduce</code>等，所以叫它们类数组。</p><p>要遍历类数组，有三个方法：</p><p>（1）将数组的方法应用到类数组上，这时候就可以使用<code>call</code>和<code>apply</code>方法，如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>)&#123; </span><br><span class="line">  <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">forEach</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>, <span class="function"><span class="params">a</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(a))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）使用Array.from方法将类数组转化成数组：‌</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>)&#123; </span><br><span class="line">  <span class="keyword">const</span> arrArgs = <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="variable language_">arguments</span>) </span><br><span class="line">  arrArgs.<span class="title function_">forEach</span>(<span class="function"><span class="params">a</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(a))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）使用展开运算符将类数组转化成数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>)&#123; </span><br><span class="line">    <span class="keyword">const</span> arrArgs = [...<span class="variable language_">arguments</span>] </span><br><span class="line">    arrArgs.<span class="title function_">forEach</span>(<span class="function"><span class="params">a</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(a)) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13-什么是-DOM-和-BOM？"><a href="#13-什么是-DOM-和-BOM？" class="headerlink" title="13. 什么是 DOM 和 BOM？"></a>13. 什么是 DOM 和 BOM？</h3><ul><li>DOM 指的是文档对象模型，它指的是把文档当做一个对象，这个对象主要定义了处理网页内容的方法和接口。</li><li>BOM 指的是浏览器对象模型，它指的是把浏览器当做一个对象来对待，这个对象主要定义了与浏览器进行交互的法和接口。BOM的核心是 window，而 window 对象具有双重角色，它既是通过 js 访问浏览器窗口的一个接口，又是一个 Global（全局）对象。这意味着在网页中定义的任何对象，变量和函数，都作为全局对象的一个属性或者方法存在。window 对象含有 location 对象、navigator 对象、screen 对象等子对象，并且 DOM 的最根本的对象 document 对象也是 BOM 的 window 对象的子对象。</li></ul><h3 id="14-对类数组对象的理解，如何转化为数组"><a href="#14-对类数组对象的理解，如何转化为数组" class="headerlink" title="14. 对类数组对象的理解，如何转化为数组"></a>14. 对类数组对象的理解，如何转化为数组</h3><p>一个拥有 length 属性和若干索引属性的对象就可以被称为类数组对象，类数组对象和数组类似，但是不能调用数组的方法。常见的类数组对象有 arguments 和 DOM 方法的返回结果，函数参数也可以被看作是类数组对象，因为它含有 length属性值，代表可接收的参数个数。</p><p>常见的类数组转换为数组的方法有这样几种：</p><ul><li>通过 call 调用数组的 slice 方法来实现转换</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(arrayLike);</span><br></pre></td></tr></table></figure><ul><li>通过 call 调用数组的 splice 方法来实现转换</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">splice</span>.<span class="title function_">call</span>(arrayLike, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><ul><li>通过 apply 调用数组的 concat 方法来实现转换</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">concat</span>.<span class="title function_">apply</span>([], arrayLike);</span><br></pre></td></tr></table></figure><ul><li>通过 Array.from 方法来实现转换</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="title function_">from</span>(arrayLike);</span><br></pre></td></tr></table></figure><h3 id="15-escape、encodeURI、encodeURIComponent-的区别"><a href="#15-escape、encodeURI、encodeURIComponent-的区别" class="headerlink" title="15. escape、encodeURI、encodeURIComponent 的区别"></a>15. escape、encodeURI、encodeURIComponent 的区别</h3><ul><li>encodeURI 是对整个 URI 进行转义，将 URI 中的非法字符转换为合法字符，所以对于一些在 URI 中有特殊意义的字符不会进行转义。</li><li>encodeURIComponent 是对 URI 的组成部分进行转义，所以一些特殊字符也会得到转义。</li><li>escape 和 encodeURI 的作用相同，不过它们对于 unicode 编码为 0xff 之外字符的时候会有区别，escape 是直接在字符的 unicode 编码前加上 %u，而 encodeURI 首先会将字符转换为 UTF-8 的格式，再在每个字节前加上 %。</li></ul><h3 id="16-对AJAX的理解，实现一个AJAX请求"><a href="#16-对AJAX的理解，实现一个AJAX请求" class="headerlink" title="16. 对AJAX的理解，实现一个AJAX请求"></a>16. 对AJAX的理解，实现一个AJAX请求</h3><p>AJAX是 Asynchronous JavaScript and XML 的缩写，指的是通过 JavaScript 的 异步通信，从服务器获取 XML 文档从中提取数据，再更新当前网页的对应部分，而不用刷新整个网页。</p><p>创建AJAX请求的步骤：</p><ul><li><strong>创建一个 XMLHttpRequest 对象。</strong></li><li>在这个对象上<strong>使用 open 方法创建一个 HTTP 请求</strong>，open 方法所需要的参数是请求的方法、请求的地址、是否异步和用户的认证信息。</li><li>在发起请求前，可以为这个对象<strong>添加一些信息和监听函数</strong>。比如说可以通过 setRequestHeader 方法来为请求添加头信息。还可以为这个对象添加一个状态监听函数。一个 XMLHttpRequest 对象一共有 5 个状态，当它的状态变化时会触发onreadystatechange 事件，可以通过设置监听函数，来处理请求成功后的结果。当对象的 readyState 变为 4 的时候，代表服务器返回的数据接收完成，这个时候可以通过判断请求的状态，如果状态是 2xx 或者 304 的话则代表返回正常。这个时候就可以通过 response 中的数据来对页面进行更新了。</li><li>当对象的属性和监听函数设置完成后，最后调<strong>用 sent 方法来向服务器发起请求</strong>，可以传入参数作为发送的数据体。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">SERVER_URL</span> = <span class="string">&quot;/server&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line"><span class="comment">// 创建 Http 请求</span></span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&quot;GET&quot;</span>, url, <span class="literal">true</span>);</span><br><span class="line"><span class="comment">// 设置状态监听函数</span></span><br><span class="line">xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">readyState</span> !== <span class="number">4</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// 当请求成功时</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="title function_">handle</span>(<span class="variable language_">this</span>.<span class="property">response</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="variable language_">this</span>.<span class="property">statusText</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 设置请求失败时的监听函数</span></span><br><span class="line">xhr.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="variable language_">this</span>.<span class="property">statusText</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 设置请求头信息</span></span><br><span class="line">xhr.<span class="property">responseType</span> = <span class="string">&quot;json&quot;</span>;</span><br><span class="line">xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&quot;Accept&quot;</span>, <span class="string">&quot;application/json&quot;</span>);</span><br><span class="line"><span class="comment">// 发送 Http 请求</span></span><br><span class="line">xhr.<span class="title function_">send</span>(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure><p>使用Promise封装AJAX：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// promise 封装实现：</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getJSON</span>(<span class="params">url</span>) &#123;</span><br><span class="line">  <span class="comment">// 创建一个 promise 对象</span></span><br><span class="line">  <span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">    <span class="comment">// 新建一个 http 请求</span></span><br><span class="line">    xhr.<span class="title function_">open</span>(<span class="string">&quot;GET&quot;</span>, url, <span class="literal">true</span>);</span><br><span class="line">    <span class="comment">// 设置状态的监听函数</span></span><br><span class="line">    xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">readyState</span> !== <span class="number">4</span>) <span class="keyword">return</span>;</span><br><span class="line">      <span class="comment">// 当请求成功或失败时，改变 promise 的状态</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="variable language_">this</span>.<span class="property">response</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="variable language_">this</span>.<span class="property">statusText</span>));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 设置错误监听函数</span></span><br><span class="line">    xhr.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="variable language_">this</span>.<span class="property">statusText</span>));</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 设置响应的数据类型</span></span><br><span class="line">    xhr.<span class="property">responseType</span> = <span class="string">&quot;json&quot;</span>;</span><br><span class="line">    <span class="comment">// 设置请求头信息</span></span><br><span class="line">    xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&quot;Accept&quot;</span>, <span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">    <span class="comment">// 发送 http 请求</span></span><br><span class="line">    xhr.<span class="title function_">send</span>(<span class="literal">null</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="17-JavaScript为什么要进行变量提升，它导致了什么问题？"><a href="#17-JavaScript为什么要进行变量提升，它导致了什么问题？" class="headerlink" title="17. JavaScript为什么要进行变量提升，它导致了什么问题？"></a>17. JavaScript为什么要进行变量提升，它导致了什么问题？</h3><p>变量提升的表现是，无论在函数中何处位置声明的变量，好像都被提升到了函数的首部，可以在变量声明前访问到而不会报错。</p><p>造成变量声明提升的<strong>本质原因</strong>是 js 引擎在代码执行前有一个解析的过程，创建了执行上下文，初始化了一些代码执行时需要用到的对象。当访问一个变量时，会到当前执行上下文中的作用域链中去查找，而作用域链的首端指向的是当前执行上下文的变量对象，这个变量对象是执行上下文的一个属性，它包含了函数的形参、所有的函数和变量声明，这个对象的是在代码解析的时候创建的。</p><p>首先要知道，JS在拿到一个变量或者一个函数的时候，会有两步操作，即解析和执行。</p><ul><li><p>在解析阶段</p><p>，JS会检查语法，并对函数进行预编译。解析的时候会先创建一个全局执行上下文环境，先把代码中即将执行的变量、函数声明都拿出来，变量先赋值为undefined，函数先声明好可使用。在一个函数执行之前，也会创建一个函数执行上下文环境，跟全局执行上下文类似，不过函数执行上下文会多出this、arguments和函数的参数。</p><ul><li>全局上下文：变量定义，函数声明</li><li>函数上下文：变量定义，函数声明，this，arguments</li></ul></li><li><p><strong>在执行阶段</strong>，就是按照代码的顺序依次执行。</p></li></ul><p>那为什么会进行变量提升呢？主要有以下两个原因：</p><ul><li>提高性能</li><li>容错性更好</li></ul><p><strong>（1）提高性能</strong> 在JS代码执行之前，会进行语法检查和预编译，并且这一操作只进行一次。这么做就是为了提高性能，如果没有这一步，那么每次执行代码前都必须重新解析一遍该变量（函数），而这是没有必要的，因为变量（函数）的代码并不会改变，解析一遍就够了。</p><p>在解析的过程中，还会为函数生成预编译代码。在预编译时，会统计声明了哪些变量、创建了哪些函数，并对函数的代码进行压缩，去除注释、不必要的空白等。这样做的好处就是每次执行函数时都可以直接为该函数分配栈空间（不需要再解析一遍去获取代码中声明了哪些变量，创建了哪些函数），并且因为代码压缩的原因，代码执行也更快了。</p><p><strong>（2）容错性更好</strong></p><p>变量提升可以在一定程度上提高JS的容错性，看下面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span>;<span class="keyword">var</span> a;<span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br></pre></td></tr></table></figure><p>如果没有变量提升，这两行代码就会报错，但是因为有了变量提升，这段代码就可以正常执行。</p><p>虽然，在可以开发过程中，可以完全避免这样写，但是有时代码很复杂的时候。可能因为疏忽而先使用后定义了，这样也不会影响正常使用。由于变量提升的存在，而会正常运行。</p><p><strong>总结：</strong></p><ul><li>解析和预编译过程中的声明提升可以提高性能，让函数可以在执行时预先为变量分配栈空间</li><li>声明提升还可以提高JS代码的容错性，使一些不规范的代码也可以正常执行</li></ul><p>变量提升虽然有一些优点，但是他也会造成一定的问题，在ES6中提出了let、const来定义变量，它们就没有变量提升的机制。下面看一下变量提升可能会导致的问题：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(tmp);</span><br><span class="line"><span class="keyword">if</span>(<span class="literal">false</span>)&#123;</span><br><span class="line"><span class="keyword">var</span> tmp = <span class="string">&#x27;hello world&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fn</span>();  <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>在这个函数中，原本是要打印出外层的tmp变量，但是因为变量提升的问题，内层定义的tmp被提到函数内部的最顶部，相当于覆盖了外层的tmp，所以打印结果为undefined。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp = <span class="string">&#x27;hello world&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; tmp.<span class="property">length</span>; i++) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(tmp[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 11</span></span><br></pre></td></tr></table></figure><p>由于遍历时定义的i会变量提升成为一个全局变量，在函数结束之后不会被销毁，所以打印出来11。</p><h3 id="18-什么是尾调用，使用尾调用有什么好处？"><a href="#18-什么是尾调用，使用尾调用有什么好处？" class="headerlink" title="18. 什么是尾调用，使用尾调用有什么好处？"></a>18. 什么是尾调用，使用尾调用有什么好处？</h3><p>尾调用指的是函数的最后一步调用另一个函数。代码执行是基于执行栈的，所以当在一个函数里调用另一个函数时，会保留当前的执行上下文，然后再新建另外一个执行上下文加入栈中。使用尾调用的话，因为已经是函数的最后一步，所以这时可以不必再保留当前的执行上下文，从而节省了内存，这就是尾调用优化。但是 ES6 的尾调用优化只在严格模式下开启，正常模式是无效的。</p><h3 id="19-ES6模块与CommonJS模块有什么异同？"><a href="#19-ES6模块与CommonJS模块有什么异同？" class="headerlink" title="19.  ES6模块与CommonJS模块有什么异同？"></a>19.  <strong>ES6</strong>模块与<strong>CommonJS</strong>模块有什么异同？</h3><p>ES6 Module和CommonJS模块的区别：</p><ul><li>CommonJS是对模块的浅拷⻉，ES6 Module是对模块的引⽤，即ES6 Module只存只读，不能改变其值，也就是指针指向不能变，类似const；</li><li>import的接⼝是read-only（只读状态），不能修改其变量值。 即不能修改其变量的指针指向，但可以改变变量内部指针指向，可以对commonJS对重新赋值（改变指针指向），但是对ES6 Module赋值会编译报错。</li></ul><p>ES6 Module和CommonJS模块的共同点：</p><ul><li>CommonJS和ES6 Module都可以对引⼊的对象进⾏赋值，即对对象内部属性的值进⾏改变。</li></ul><h3 id="20-常见的DOM操作有哪些"><a href="#20-常见的DOM操作有哪些" class="headerlink" title="20. 常见的DOM操作有哪些"></a>20. 常见的DOM操作有哪些</h3><h4 id="1）DOM-节点的获取"><a href="#1）DOM-节点的获取" class="headerlink" title="1）DOM 节点的获取"></a>1）DOM 节点的获取</h4><p>DOM 节点的获取的API及使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">getElementById <span class="comment">// 按照 id 查询</span></span><br><span class="line">getElementsByTagName <span class="comment">// 按照标签名查询</span></span><br><span class="line">getElementsByClassName <span class="comment">// 按照类名查询</span></span><br><span class="line">querySelectorAll <span class="comment">// 按照 css 选择器查询</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 按照 id 查询</span></span><br><span class="line"><span class="keyword">var</span> imooc = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;imooc&#x27;</span>) <span class="comment">// 查询到 id 为 imooc 的元素</span></span><br><span class="line"><span class="comment">// 按照标签名查询</span></span><br><span class="line"><span class="keyword">var</span> pList = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;p&#x27;</span>)  <span class="comment">// 查询到标签为 p 的集合</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(divList.<span class="property">length</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(divList[<span class="number">0</span>])</span><br><span class="line"><span class="comment">// 按照类名查询</span></span><br><span class="line"><span class="keyword">var</span> moocList = <span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&#x27;mooc&#x27;</span>) <span class="comment">// 查询到类名为 mooc 的集合</span></span><br><span class="line"><span class="comment">// 按照 css 选择器查询</span></span><br><span class="line"><span class="keyword">var</span> pList = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;.mooc&#x27;</span>) <span class="comment">// 查询到类名为 mooc 的集合</span></span><br></pre></td></tr></table></figure><h4 id="2）DOM-节点的创建"><a href="#2）DOM-节点的创建" class="headerlink" title="2）DOM 节点的创建"></a>2）DOM 节点的创建</h4><p><strong>创建一个新节点，并把它添加到指定节点的后面。</strong> 已知的 HTML 结构如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>DEMO<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;container&quot;</span>&gt;</span> </span><br><span class="line">      <span class="tag">&lt;<span class="name">h1</span> <span class="attr">id</span>=<span class="string">&quot;title&quot;</span>&gt;</span>我是标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span>   </span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>要求添加一个有内容的 span 节点到 id 为 title 的节点后面，做法就是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先获取父节点</span></span><br><span class="line"><span class="keyword">var</span> container = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;container&#x27;</span>)</span><br><span class="line"><span class="comment">// 创建新节点</span></span><br><span class="line"><span class="keyword">var</span> targetSpan = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;span&#x27;</span>)</span><br><span class="line"><span class="comment">// 设置 span 节点的内容</span></span><br><span class="line">targetSpan.<span class="property">innerHTML</span> = <span class="string">&#x27;hello world&#x27;</span></span><br><span class="line"><span class="comment">// 把新创建的元素塞进父节点里去</span></span><br><span class="line">container.<span class="title function_">appendChild</span>(targetSpan)</span><br></pre></td></tr></table></figure><h4 id="3）DOM-节点的删除"><a href="#3）DOM-节点的删除" class="headerlink" title="3）DOM 节点的删除"></a>3）DOM 节点的删除</h4><p><strong>删除指定的 DOM 节点，</strong> 已知的 HTML 结构如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>DEMO<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;container&quot;</span>&gt;</span> </span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span> <span class="attr">id</span>=<span class="string">&quot;title&quot;</span>&gt;</span>我是标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span>   </span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>需要删除 id 为 title 的元素，做法是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取目标元素的父元素</span></span><br><span class="line"><span class="keyword">var</span> container = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;container&#x27;</span>)</span><br><span class="line"><span class="comment">// 获取目标元素</span></span><br><span class="line"><span class="keyword">var</span> targetNode = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;title&#x27;</span>)</span><br><span class="line"><span class="comment">// 删除目标元素</span></span><br><span class="line">container.<span class="title function_">removeChild</span>(targetNode)</span><br></pre></td></tr></table></figure><p>或者通过子节点数组来完成删除：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取目标元素的父元素var container = document.getElementById(&#x27;container&#x27;)// 获取目标元素var targetNode = container.childNodes[1]// 删除目标元素container.removeChild(targetNode)</span></span><br></pre></td></tr></table></figure><h4 id="4）修改-DOM-元素"><a href="#4）修改-DOM-元素" class="headerlink" title="4）修改 DOM 元素"></a>4）修改 DOM 元素</h4><p>修改 DOM 元素这个动作可以分很多维度，比如说移动 DOM 元素的位置，修改 DOM 元素的属性等。</p><p><strong>将指定的两个 DOM 元素交换位置，</strong> 已知的 HTML 结构如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>DEMO<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;container&quot;</span>&gt;</span> </span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span> <span class="attr">id</span>=<span class="string">&quot;title&quot;</span>&gt;</span>我是标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;content&quot;</span>&gt;</span>我是内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span>   </span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>现在需要调换 title 和 content 的位置，可以考虑 insertBefore 或者 appendChild：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取父元素</span></span><br><span class="line"><span class="keyword">var</span> container = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;container&#x27;</span>)   </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 获取两个需要被交换的元素</span></span><br><span class="line"><span class="keyword">var</span> title = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;title&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> content = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;content&#x27;</span>)</span><br><span class="line"><span class="comment">// 交换两个元素，把 content 置于 title 前面</span></span><br><span class="line">container.<span class="title function_">insertBefore</span>(content, title)</span><br></pre></td></tr></table></figure><h3 id="21-use-strict是什么意思-使用它区别是什么？"><a href="#21-use-strict是什么意思-使用它区别是什么？" class="headerlink" title="21. use strict是什么意思 ? 使用它区别是什么？"></a>21. use strict是什么意思 ? 使用它区别是什么？</h3><p>use strict 是一种 ECMAscript5 添加的（严格模式）运行模式，这种模式使得 Javascript 在更严格的条件下运行。设立严格模式的目的如下：</p><ul><li>消除 Javascript 语法的不合理、不严谨之处，减少怪异行为;</li><li>消除代码运行的不安全之处，保证代码运行的安全；</li><li>提高编译器效率，增加运行速度；</li><li>为未来新版本的 Javascript 做好铺垫。</li></ul><p>区别：</p><ul><li>禁止使用 with 语句。</li><li>禁止 this 关键字指向全局对象。</li><li>对象不能有重名的属性。</li></ul><h3 id="22-如何判断一个对象是否属于某个类？"><a href="#22-如何判断一个对象是否属于某个类？" class="headerlink" title="22. 如何判断一个对象是否属于某个类？"></a>22. 如何判断一个对象是否属于某个类？</h3><ul><li>第一种方式，使用 instanceof 运算符来判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。</li><li>第二种方式，通过对象的 constructor 属性来判断，对象的 constructor 属性指向该对象的构造函数，但是这种方式不是很安全，因为 constructor 属性可以被改写。</li><li>第三种方式，如果需要判断的是某个内置的引用类型的话，可以使用 Object.prototype.toString() 方法来打印对象的[[Class]] 属性来进行判断。</li></ul><h3 id="23-强类型语言和弱类型语言的区别"><a href="#23-强类型语言和弱类型语言的区别" class="headerlink" title="23. 强类型语言和弱类型语言的区别"></a>23. 强类型语言和弱类型语言的区别</h3><ul><li><strong>强类型语言</strong>：强类型语言也称为强类型定义语言，是一种总是强制类型定义的语言，要求变量的使用要严格符合定义，所有变量都必须先定义后使用。Java和C++等语言都是强制类型定义的，也就是说，一旦一个变量被指定了某个数据类型，如果不经过强制转换，那么它就永远是这个数据类型了。例如你有一个整数，如果不显式地进行转换，你不能将其视为一个字符串。</li><li><strong>弱类型语言</strong>：弱类型语言也称为弱类型定义语言，与强类型定义相反。JavaScript语言就属于弱类型语言。简单理解就是一种变量类型可以被忽略的语言。比如JavaScript是弱类型定义的，在JavaScript中就可以将字符串’12’和整数3进行连接得到字符串’123’，在相加的时候会进行强制类型转换。</li></ul><p>两者对比：强类型语言在速度上可能略逊色于弱类型语言，但是强类型语言带来的严谨性可以有效地帮助避免许多错误。</p><h3 id="24-解释性语言和编译型语言的区别"><a href="#24-解释性语言和编译型语言的区别" class="headerlink" title="24. 解释性语言和编译型语言的区别"></a>24. 解释性语言和编译型语言的区别</h3><p>（1）解释型语言 使用专门的解释器对源程序逐行解释成特定平台的机器码并立即执行。是代码在执行时才被解释器一行行动态翻译和执行，而不是在执行之前就完成翻译。解释型语言不需要事先编译，其直接将源代码解释成机器码并立即执行，所以只要某一平台提供了相应的解释器即可运行该程序。其特点总结如下</p><ul><li>解释型语言每次运行都需要将源代码解释称机器码并执行，效率较低；</li><li>只要平台提供相应的解释器，就可以运行源代码，所以可以方便源程序移植；</li><li>JavaScript、Python等属于解释型语言。</li></ul><p>（2）编译型语言 使用专门的编译器，针对特定的平台，将高级语言源代码一次性的编译成可被该平台硬件执行的机器码，并包装成该平台所能识别的可执行性程序的格式。在编译型语言写的程序执行之前，需要一个专门的编译过程，把源代码编译成机器语言的文件，如exe格式的文件，以后要再运行时，直接使用编译结果即可，如直接运行exe文件。因为只需编译一次，以后运行时不需要编译，所以编译型语言执行效率高。其特点总结如下：</p><ul><li>一次性的编译成平台相关的机器语言文件，运行时脱离开发环境，运行效率高；</li><li>与特定平台相关，一般无法移植到其他平台；</li><li>C、C++等属于编译型语言。</li></ul><p><strong>两者主要区别在于：</strong> 前者源程序编译后即可在该平台运行，后者是在运行期间才编译。所以前者运行速度快，后者跨平台性好。</p><h3 id="25-for…in和for…of的区别"><a href="#25-for…in和for…of的区别" class="headerlink" title="25. for…in和for…of的区别"></a>25. for…in和for…of的区别</h3><p>for…of 是ES6新增的遍历方式，允许遍历一个含有iterator接口的数据结构（数组、对象等）并且返回各项的值，和ES3中的for…in的区别如下</p><ul><li>for…of 遍历获取的是对象的键值，for…in 获取的是对象的键名；</li><li>for… in 会遍历对象的整个原型链，性能非常差不推荐使用，而 for … of 只遍历当前对象不会遍历原型链；</li><li>对于数组的遍历，for…in 会返回数组中所有可枚举的属性(包括原型链上可枚举的属性)，for…of 只返回数组的下标对应的属性值；</li></ul><p><strong>总结：</strong> for…in 循环主要是为了遍历对象而生，不适用于遍历数组；for…of 循环可以用来遍历数组、类数组对象，字符串、Set、Map 以及 Generator 对象。</p><h3 id="26-如何使用for…of遍历对象"><a href="#26-如何使用for…of遍历对象" class="headerlink" title="26. 如何使用for…of遍历对象"></a>26. 如何使用for…of遍历对象</h3><p>for…of是作为ES6新增的遍历方式，允许遍历一个含有iterator接口的数据结构（数组、对象等）并且返回各项的值，普通的对象用for..of遍历是会报错的。</p><p>如果需要遍历的对象是类数组对象，用Array.from转成数组即可。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="number">0</span>:<span class="string">&#x27;one&#x27;</span>,</span><br><span class="line">    <span class="number">1</span>:<span class="string">&#x27;two&#x27;</span>,</span><br><span class="line">    <span class="attr">length</span>: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line">obj = <span class="title class_">Array</span>.<span class="title function_">from</span>(obj);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> k <span class="keyword">of</span> obj)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(k)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不是类数组对象，就给对象添加一个[Symbol.iterator]属性，并指向一个迭代器即可。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法一：</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>:<span class="number">1</span>,</span><br><span class="line">    <span class="attr">b</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="attr">c</span>:<span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj[<span class="title class_">Symbol</span>.<span class="property">iterator</span>] = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">var</span> keys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(<span class="variable language_">this</span>);</span><br><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line"><span class="title function_">next</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(count&lt;keys.<span class="property">length</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> &#123;<span class="attr">value</span>: obj[keys[count++]],<span class="attr">done</span>:<span class="literal">false</span>&#125;;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> &#123;<span class="attr">value</span>:<span class="literal">undefined</span>,<span class="attr">done</span>:<span class="literal">true</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> k <span class="keyword">of</span> obj)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>:<span class="number">1</span>,</span><br><span class="line">    <span class="attr">b</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="attr">c</span>:<span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line">obj[<span class="title class_">Symbol</span>.<span class="property">iterator</span>] = <span class="keyword">function</span>*()&#123;</span><br><span class="line">    <span class="keyword">var</span> keys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> k <span class="keyword">of</span> keys)&#123;</span><br><span class="line">        <span class="keyword">yield</span> [k,obj[k]]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> [k,v] <span class="keyword">of</span> obj)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(k,v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="27-ajax、axios、fetch的区别"><a href="#27-ajax、axios、fetch的区别" class="headerlink" title="27. ajax、axios、fetch的区别"></a>27. ajax、axios、fetch的区别</h3><p><strong>（1）AJAX</strong> Ajax 即“AsynchronousJavascriptAndXML”（异步 JavaScript 和 XML），是指一种创建交互式网页应用的网页开发技术。它是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面。其缺点如下：</p><ul><li>本身是针对MVC编程，不符合前端MVVM的浪潮</li><li>基于原生XHR开发，XHR本身的架构不清晰</li><li>不符合关注分离（Separation of Concerns）的原则</li><li>配置和调用方式非常混乱，而且基于事件的异步模型不友好。</li></ul><p><strong>（2）Fetch</strong> fetch号称是AJAX的替代品，是在ES6出现的，使用了ES6中的promise对象。Fetch是基于promise设计的。Fetch的代码结构比起ajax简单多。<strong>fetch不是ajax的进一步封装，而是原生js，没有使用XMLHttpRequest对象</strong>。</p><p>fetch的优点：</p><ul><li>语法简洁，更加语义化</li><li>基于标准 Promise 实现，支持 async/await</li><li>更加底层，提供的API丰富（request, response）</li><li>脱离了XHR，是ES规范里新的实现方式</li></ul><p>fetch的缺点：</p><ul><li>fetch只对网络请求报错，对400，500都当做成功的请求，服务器返回 400，500 错误码时并不会 reject，只有网络错误这些导致请求不能完成时，fetch 才会被 reject。</li><li>fetch默认不会带cookie，需要添加配置项： fetch(url, {credentials: ‘include’})</li><li>fetch不支持abort，不支持超时控制，使用setTimeout及Promise.reject的实现的超时控制并不能阻止请求过程继续在后台运行，造成了流量的浪费</li><li>fetch没有办法原生监测请求的进度，而XHR可以</li></ul><p><strong>（3）Axios</strong> Axios 是一种基于Promise封装的HTTP客户端，其特点如下：</p><ul><li>浏览器端发起XMLHttpRequests请求</li><li>node端发起http请求</li><li>支持Promise API</li><li>监听请求和返回</li><li>对请求和返回进行转化</li><li>取消请求</li><li>自动转换json数据</li><li>客户端支持抵御XSRF攻击</li></ul><h3 id="28-数组的遍历方法有哪些"><a href="#28-数组的遍历方法有哪些" class="headerlink" title="28. 数组的遍历方法有哪些"></a>28. 数组的遍历方法有哪些</h3><table><thead><tr><th><strong>方法</strong></th><th><strong>是否改变原数组</strong></th><th><strong>特点</strong></th></tr></thead><tbody><tr><td>forEach()</td><td>否</td><td>数组方法，不改变原数组，没有返回值</td></tr><tr><td>map()</td><td>否</td><td>数组方法，不改变原数组，有返回值，可链式调用</td></tr><tr><td>filter()</td><td>否</td><td>数组方法，过滤数组，返回包含符合条件的元素的数组，可链式调用</td></tr><tr><td>for…of</td><td>否</td><td>for…of遍历具有Iterator迭代器的对象的属性，返回的是数组的元素、对象的属性值，不能遍历普通的obj对象，将异步循环变成同步循环</td></tr><tr><td>every() 和 some()</td><td>否</td><td>数组方法，some()只要有一个是true，便返回true；而every()只要有一个是false，便返回false.</td></tr><tr><td>find() 和 findIndex()</td><td>否</td><td>数组方法，find()返回的是第一个符合条件的值；findIndex()返回的是第一个返回条件的值的索引值</td></tr><tr><td>reduce() 和 reduceRight()</td><td>否</td><td>数组方法，reduce()对数组正序操作；reduceRight()对数组逆序操作</td></tr></tbody></table><p>遍历方法的详细解释：<a href="https://link.juejin.cn/?target=https://cuggz.blog.csdn.net/article/details/107649549">《细数JavaScript中那些遍历和循环》</a></p><h3 id="29-forEach和map方法有什么区别"><a href="#29-forEach和map方法有什么区别" class="headerlink" title="29. forEach和map方法有什么区别"></a>29. forEach和map方法有什么区别</h3><p>这方法都是用来遍历数组的，两者区别如下：</p><ul><li>forEach()方法会针对每一个元素执行提供的函数，对数据的操作会改变原数组，该方法没有返回值；</li><li>map()方法不会改变原数组的值，返回一个新数组，新数组中的值为原数组调用函数处理之后的值；</li></ul><h2 id="四、原型与原型链"><a href="#四、原型与原型链" class="headerlink" title="四、原型与原型链"></a>四、原型与原型链</h2><h3 id="1-对原型、原型链的理解"><a href="#1-对原型、原型链的理解" class="headerlink" title="1. 对原型、原型链的理解"></a>1. 对原型、原型链的理解</h3><p>在JavaScript中是使用构造函数来新建一个对象的，每一个构造函数的内部都有一个 prototype 属性，它的属性值是一个对象，这个对象包含了可以由该构造函数的所有实例共享的属性和方法。当使用构造函数新建一个对象后，在这个对象的内部将包含一个指针，这个指针指向构造函数的 prototype 属性对应的值，在 ES5 中这个指针被称为对象的原型。一般来说不应该能够获取到这个值的，但是现在浏览器中都实现了 <strong>proto</strong> 属性来访问这个属性，但是最好不要使用这个属性，因为它不是规范中规定的。ES5 中新增了一个 Object.getPrototypeOf() 方法，可以通过这个方法来获取对象的原型。</p><p>当访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又会有自己的原型，于是就这样一直找下去，也就是原型链的概念。原型链的尽头一般来说都是 Object.prototype 所以这就是新建的对象为什么能够使用 toString() 等方法的原因。</p><p><strong>特点：</strong> JavaScript 对象是通过引用来传递的，创建的每个新对象实体中并没有一份属于自己的原型副本。当修改原型时，与之相关的对象也会继承这一改变。</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230610112915792.png" alt="image-20230610112915792"></p><h3 id="2-原型修改、重写"><a href="#2-原型修改、重写" class="headerlink" title="2. 原型修改、重写"></a>2. 原型修改、重写</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 修改原型</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">__proto__</span> === <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">__proto__</span> === p.<span class="property">constructor</span>.<span class="property"><span class="keyword">prototype</span></span>) <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 重写原型</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">    <span class="attr">getName</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">__proto__</span> === <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>)        <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">__proto__</span> === p.<span class="property">constructor</span>.<span class="property"><span class="keyword">prototype</span></span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>可以看到修改原型的时候p的构造函数不是指向Person了，因为直接给Person的原型对象直接用对象赋值时，它的构造函数指向的了根构造函数Object，所以这时候<code>p.constructor === Object</code> ，而不是<code>p.constructor === Person</code>。要想成立，就要用constructor指回来：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">    <span class="attr">getName</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">p.<span class="property">constructor</span> = <span class="title class_">Person</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">__proto__</span> === <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>)        <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">__proto__</span> === p.<span class="property">constructor</span>.<span class="property"><span class="keyword">prototype</span></span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="3-原型链指向"><a href="#3-原型链指向" class="headerlink" title="3. 原型链指向"></a>3. 原型链指向</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">p.<span class="property">__proto__</span>  <span class="comment">// Person.prototype</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span>  <span class="comment">// Object.prototype</span></span><br><span class="line">p.<span class="property">__proto__</span>.<span class="property">__proto__</span> <span class="comment">//Object.prototype</span></span><br><span class="line">p.<span class="property">__proto__</span>.<span class="property">constructor</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span> <span class="comment">// Object.prototype</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span> <span class="comment">// Object.prototype</span></span><br><span class="line">p1.<span class="property">__proto__</span>.<span class="property">constructor</span> <span class="comment">// Person</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span>  <span class="comment">// Person</span></span><br></pre></td></tr></table></figure><h3 id="4-原型链的终点是什么？如何打印出原型链的终点？"><a href="#4-原型链的终点是什么？如何打印出原型链的终点？" class="headerlink" title="4. 原型链的终点是什么？如何打印出原型链的终点？"></a>4. 原型链的终点是什么？如何打印出原型链的终点？</h3><p>由于<code>Object</code>是构造函数，原型链终点是<code>Object.prototype.__proto__</code>，而<code>Object.prototype.__proto__=== null // true</code>，所以，原型链的终点是<code>null</code>。原型链上的所有原型都是对象，所有的对象最终都是由<code>Object</code>构造的，而<code>Object.prototype</code>的下一级是<code>Object.prototype.__proto__</code>。</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230610112941072.png" alt="image-20230610112941072"></p><h3 id="5-如何获得对象非原型链上的属性？"><a href="#5-如何获得对象非原型链上的属性？" class="headerlink" title="5. 如何获得对象非原型链上的属性？"></a>5. 如何获得对象非原型链上的属性？</h3><p>使用后<code>hasOwnProperty()</code>方法来判断属性是否属于原型链的属性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">iterate</span>(<span class="params">obj</span>)&#123;</span><br><span class="line">   <span class="keyword">var</span> res=[];</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> obj)&#123;</span><br><span class="line">        <span class="keyword">if</span>(obj.<span class="title function_">hasOwnProperty</span>(key))</span><br><span class="line">           res.<span class="title function_">push</span>(key+<span class="string">&#x27;: &#x27;</span>+obj[key]);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> res;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="五、执行上下文-作用域链-闭包"><a href="#五、执行上下文-作用域链-闭包" class="headerlink" title="五、执行上下文/作用域链/闭包"></a>五、执行上下文/作用域链/闭包</h2><h3 id="1-对闭包的理解"><a href="#1-对闭包的理解" class="headerlink" title="1. 对闭包的理解"></a>1. 对闭包的理解</h3><p><strong>闭包是指有权访问另一个函数作用域中变量的函数</strong>，创建闭包的最常见的方式就是在一个函数内创建另一个函数，创建的函数可以访问到当前函数的局部变量。</p><p>闭包有两个常用的用途；</p><ul><li>闭包的第一个用途是使我们在函数外部能够访问到函数内部的变量。通过使用闭包，可以通过在外部调用闭包函数，从而在外部访问到函数内部的变量，可以使用这种方法来创建私有变量。</li><li>闭包的另一个用途是使已经运行结束的函数上下文中的变量对象继续留在内存中，因为闭包函数保留了这个变量对象的引用，所以这个变量对象不会被回收。</li></ul><p>比如，函数 A 内部有一个函数 B，函数 B 可以访问到函数 A 中的变量，那么函数 B 就是闭包。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">A</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line">  <span class="variable language_">window</span>.<span class="property">B</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">A</span>()</span><br><span class="line"><span class="title function_">B</span>() <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>在 JS 中，闭包存在的意义就是让我们可以间接访问函数内部的变量。经典面试题：循环中使用闭包解决 var 定义函数的问题</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">timer</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line">  &#125;, i * <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先因为 <code>setTimeout</code> 是个异步函数，所以会先把循环全部执行完毕，这时候 <code>i</code> 就是 6 了，所以会输出一堆 6。解决办法有三种：</p><ul><li>第一种是使用闭包的方式</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;  ;(<span class="keyword">function</span>(<span class="params">j</span>) &#123;    <span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">timer</span>(<span class="params"></span>) &#123;      <span class="variable language_">console</span>.<span class="title function_">log</span>(j)    &#125;, j * <span class="number">1000</span>)  &#125;)(i)&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，首先使用了立即执行函数将 <code>i</code> 传入函数内部，这个时候值就被固定在了参数 <code>j</code> 上面不会改变，当下次执行 <code>timer</code> 这个闭包的时候，就可以使用外部函数的变量 <code>j</code>，从而达到目的。</p><ul><li>第二种就是使用 <code>setTimeout</code> 的第三个参数，这个参数会被当成 <code>timer</code> 函数的参数传入。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">timer</span>(<span class="params">j</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(j)</span><br><span class="line">    &#125;,</span><br><span class="line">    i * <span class="number">1000</span>,</span><br><span class="line">    i</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第三种就是使用 <code>let</code> 定义 <code>i</code> 了来解决问题了，这个也是最为推荐的方式</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">timer</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line">  &#125;, i * <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-对作用域、作用域链的理解"><a href="#2-对作用域、作用域链的理解" class="headerlink" title="2. 对作用域、作用域链的理解"></a>2. 对作用域、作用域链的理解</h3><h5 id="1）全局作用域和函数作用域"><a href="#1）全局作用域和函数作用域" class="headerlink" title="1）全局作用域和函数作用域"></a>1）全局作用域和函数作用域</h5><p>（1）全局作用域</p><ul><li>最外层函数和最外层函数外面定义的变量拥有全局作用域</li><li>所有未定义直接赋值的变量自动声明为全局作用域</li><li>所有window对象的属性拥有全局作用域</li><li>全局作用域有很大的弊端，过多的全局作用域变量会污染全局命名空间，容易引起命名冲突。</li></ul><p>（2）函数作用域</p><ul><li>函数作用域声明在函数内部的变零，一般只有固定的代码片段可以访问到</li><li>作用域是分层的，内层作用域可以访问外层作用域，反之不行</li></ul><h5 id="2）块级作用域"><a href="#2）块级作用域" class="headerlink" title="2）块级作用域"></a>2）块级作用域</h5><ul><li>使用ES6中新增的let和const指令可以声明块级作用域，块级作用域可以在函数中创建也可以在一个代码块中的创建（由<code>&#123; &#125;</code>包裹的代码片段）</li><li>let和const声明的变量不会有变量提升，也不可以重复声明</li><li>在循环中比较适合绑定块级作用域，这样就可以把声明的计数器变量限制在循环内部。</li></ul><p><strong>作用域链：</strong> 在当前作用域中查找所需变量，但是该作用域没有这个变量，那这个变量就是自由变量。如果在自己作用域找不到该变量就去父级作用域查找，依次向上级作用域查找，直到访问到window对象就被终止，这一层层的关系就是作用域链。</p><p>作用域链的作用是<strong>保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，可以访问到外层环境的变量和函数。</strong></p><p>作用域链的本质上是一个指向变量对象的指针列表。变量对象是一个包含了执行环境中所有变量和函数的对象。作用域链的前端始终都是当前执行上下文的变量对象。全局执行上下文的变量对象（也就是全局对象）始终是作用域链的最后一个对象。</p><p>当查找一个变量时，如果当前执行环境中没有找到，可以沿着作用域链向后查找。</p><h3 id="3-对执行上下文的理解"><a href="#3-对执行上下文的理解" class="headerlink" title="3. 对执行上下文的理解"></a>3. 对执行上下文的理解</h3><h5 id="1-执行上下文类型"><a href="#1-执行上下文类型" class="headerlink" title="1. 执行上下文类型"></a>1. 执行上下文类型</h5><p><strong>（1）全局执行上下文</strong></p><p>任何不在函数内部的都是全局执行上下文，它首先会创建一个全局的window对象，并且设置this的值等于这个全局对象，一个程序中只有一个全局执行上下文。</p><p><strong>（2）函数执行上下文</strong></p><p>当一个函数被调用时，就会为该函数创建一个新的执行上下文，函数的上下文可以有任意多个。</p><p><strong>（3）</strong><code>eval</code><strong>函数执行上下文</strong></p><p>执行在eval函数中的代码会有属于他自己的执行上下文，不过eval函数不常使用，不做介绍。</p><h5 id="2-执行上下文栈"><a href="#2-执行上下文栈" class="headerlink" title="2. 执行上下文栈"></a>2. 执行上下文栈</h5><ul><li>JavaScript引擎使用执行上下文栈来管理执行上下文</li><li>当JavaScript执行代码时，首先遇到全局代码，会创建一个全局执行上下文并且压入执行栈中，每当遇到一个函数调用，就会为该函数创建一个新的执行上下文并压入栈顶，引擎会执行位于执行上下文栈顶的函数，当函数执行完成之后，执行上下文从栈中弹出，继续执行下一个上下文。当所有的代码都执行完毕之后，从栈中弹出全局执行上下文。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">&#x27;Hello World!&#x27;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">first</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Inside first function&#x27;</span>);</span><br><span class="line">  <span class="title function_">second</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Again inside first function&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">second</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Inside second function&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">first</span>();</span><br><span class="line"><span class="comment">//执行顺序</span></span><br><span class="line"><span class="comment">//先执行second(),在执行first()</span></span><br></pre></td></tr></table></figure><h5 id="3-创建执行上下文"><a href="#3-创建执行上下文" class="headerlink" title="3. 创建执行上下文"></a>3. 创建执行上下文</h5><p>创建执行上下文有两个阶段：<strong>创建阶段</strong>和<strong>执行阶段</strong></p><p><strong>1）创建阶段</strong></p><p>（1）this绑定</p><ul><li>在全局执行上下文中，this指向全局对象（window对象）</li><li>在函数执行上下文中，this指向取决于函数如何调用。如果它被一个引用对象调用，那么 this 会被设置成那个对象，否则 this 的值被设置为全局对象或者 undefined</li></ul><p>（2）创建词法环境组件</p><ul><li>词法环境是一种有<strong>标识符——变量映射</strong>的数据结构，标识符是指变量/函数名，变量是对实际对象或原始数据的引用。</li><li>词法环境的内部有两个组件：<strong>加粗样式</strong>：环境记录器:用来储存变量个函数声明的实际位置<strong>外部环境的引用</strong>：可以访问父级作用域</li></ul><p>（3）创建变量环境组件</p><ul><li>变量环境也是一个词法环境，其环境记录器持有变量声明语句在执行上下文中创建的绑定关系。</li></ul><p><strong>2）执行阶段</strong> 此阶段会完成对变量的分配，最后执行完代码。</p><p><strong>简单来说执行上下文就是指：</strong></p><p>在执行一点JS代码之前，需要先解析代码。解析的时候会先创建一个全局执行上下文环境，先把代码中即将执行的变量、函数声明都拿出来，变量先赋值为undefined，函数先声明好可使用。这一步执行完了，才开始正式的执行程序。</p><p>在一个函数执行之前，也会创建一个函数执行上下文环境，跟全局执行上下文类似，不过函数执行上下文会多出this、arguments和函数的参数。</p><ul><li>全局上下文：变量定义，函数声明</li><li>函数上下文：变量定义，函数声明，<code>this</code>，<code>arguments</code></li></ul><h2 id="六、this-call-apply-bind"><a href="#六、this-call-apply-bind" class="headerlink" title="六、this/call/apply/bind"></a>六、this/call/apply/bind</h2><h3 id="1-对this对象的理解"><a href="#1-对this对象的理解" class="headerlink" title="1. 对this对象的理解"></a>1. 对this对象的理解</h3><p>this 是执行上下文中的一个属性，它指向最后一次调用这个方法的对象。在实际开发中，this 的指向可以通过四种调用模式来判断。</p><ul><li>第一种是<strong>函数调用模式</strong>，当一个函数不是一个对象的属性时，直接作为函数来调用时，this 指向全局对象。</li><li>第二种是<strong>方法调用模式</strong>，如果一个函数作为一个对象的方法来调用时，this 指向这个对象。</li><li>第三种是<strong>构造器调用模式</strong>，如果一个函数用 new 调用时，函数执行前会新创建一个对象，this 指向这个新创建的对象。</li><li>第四种是 <strong>apply 、 call 和 bind 调用模式</strong>，这三个方法都可以显示的指定调用函数的 this 指向。其中 apply 方法接收两个参数：一个是 this 绑定的对象，一个是参数数组。call 方法接收的参数，第一个是 this 绑定的对象，后面的其余参数是传入函数执行的参数。也就是说，在使用 call() 方法时，传递给函数的参数必须逐个列举出来。bind 方法通过传入一个对象，返回一个 this 绑定了传入对象的新函数。这个函数的 this 指向除了使用 new 时会被改变，其他情况下都不会改变。</li></ul><p>这四种方式，使用构造器调用模式的优先级最高，然后是 apply、call 和 bind 调用模式，然后是方法调用模式，然后是函数调用模式。</p><h3 id="2-call-和-apply-的区别？"><a href="#2-call-和-apply-的区别？" class="headerlink" title="2. call() 和 apply() 的区别？"></a>2. call() 和 apply() 的区别？</h3><p>它们的作用一模一样，区别仅在于传入参数的形式的不同。</p><ul><li>apply 接受两个参数，第一个参数指定了函数体内 this 对象的指向，第二个参数为一个带下标的集合，这个集合可以为数组，也可以为类数组，apply 方法把这个集合中的元素作为参数传递给被调用的函数。</li><li>call 传入的参数数量不固定，跟 apply 相同的是，第一个参数也是代表函数体内的 this 指向，从第二个参数开始往后，每个参数被依次传入函数。</li></ul><h3 id="3-实现call、apply-及-bind-函数"><a href="#3-实现call、apply-及-bind-函数" class="headerlink" title="3. 实现call、apply 及 bind 函数"></a>3. 实现call、apply 及 bind 函数</h3><p><strong>（1）call 函数的实现步骤：</strong></p><ul><li>判断调用对象是否为函数，即使是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li><li>判断传入上下文对象是否存在，如果不存在，则设置为 window 。</li><li>处理传入的参数，截取第一个参数后的所有参数。</li><li>将函数作为上下文对象的一个属性。</li><li>使用上下文对象来调用这个方法，并保存返回结果。</li><li>删除刚才新增的属性。</li><li>返回结果。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myCall</span> = <span class="keyword">function</span>(<span class="params">context</span>) &#123;</span><br><span class="line">  <span class="comment">// 判断调用对象</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">this</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;type error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 获取参数</span></span><br><span class="line">  <span class="keyword">let</span> args = [...<span class="variable language_">arguments</span>].<span class="title function_">slice</span>(<span class="number">1</span>),</span><br><span class="line">    result = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 判断 context 是否传入，如果未传入则设置为 window</span></span><br><span class="line">  context = context || <span class="variable language_">window</span>;</span><br><span class="line">  <span class="comment">// 将调用函数设为对象的方法</span></span><br><span class="line">  context.<span class="property">fn</span> = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="comment">// 调用函数</span></span><br><span class="line">  result = context.<span class="title function_">fn</span>(...args);</span><br><span class="line">  <span class="comment">// 将属性删除</span></span><br><span class="line">  <span class="keyword">delete</span> context.<span class="property">fn</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>（2）apply 函数的实现步骤：</strong></p><ul><li>判断调用对象是否为函数，即使是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li><li>判断传入上下文对象是否存在，如果不存在，则设置为 window 。</li><li>将函数作为上下文对象的一个属性。</li><li>判断参数值是否传入</li><li>使用上下文对象来调用这个方法，并保存返回结果。</li><li>删除刚才新增的属性</li><li>返回结果</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myApply</span> = <span class="keyword">function</span>(<span class="params">context</span>) &#123;</span><br><span class="line">  <span class="comment">// 判断调用对象是否为函数</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">this</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&quot;Error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 判断 context 是否存在，如果未传入则为 window</span></span><br><span class="line">  context = context || <span class="variable language_">window</span>;</span><br><span class="line">  <span class="comment">// 将函数设为对象的方法</span></span><br><span class="line">  context.<span class="property">fn</span> = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="comment">// 调用方法</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">arguments</span>[<span class="number">1</span>]) &#123;</span><br><span class="line">    result = context.<span class="title function_">fn</span>(...<span class="variable language_">arguments</span>[<span class="number">1</span>]);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    result = context.<span class="title function_">fn</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将属性删除</span></span><br><span class="line">  <span class="keyword">delete</span> context.<span class="property">fn</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>（3）bind 函数的实现步骤：</strong></p><ul><li>判断调用对象是否为函数，即使是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li><li>保存当前函数的引用，获取其余传入参数值。</li><li>创建一个函数返回</li><li>函数内部使用 apply 来绑定函数调用，需要判断函数作为构造函数的情况，这个时候需要传入当前函数的 this 给 apply 调用，其余情况都传入指定的上下文对象。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myBind</span> = <span class="keyword">function</span>(<span class="params">context</span>) &#123;</span><br><span class="line">  <span class="comment">// 判断调用对象是否为函数</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">this</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&quot;Error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 获取参数</span></span><br><span class="line">  <span class="keyword">var</span> args = [...<span class="variable language_">arguments</span>].<span class="title function_">slice</span>(<span class="number">1</span>),</span><br><span class="line">    fn = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">Fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 根据调用方式，传入不同绑定值</span></span><br><span class="line">    <span class="keyword">return</span> fn.<span class="title function_">apply</span>(</span><br><span class="line">      <span class="variable language_">this</span> <span class="keyword">instanceof</span> <span class="title class_">Fn</span> ? <span class="variable language_">this</span> : context,</span><br><span class="line">      args.<span class="title function_">concat</span>(...<span class="variable language_">arguments</span>)</span><br><span class="line">    );</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="七、异步编程"><a href="#七、异步编程" class="headerlink" title="七、异步编程"></a>七、异步编程</h2><h3 id="1-异步编程的实现方式？"><a href="#1-异步编程的实现方式？" class="headerlink" title="1. 异步编程的实现方式？"></a>1. 异步编程的实现方式？</h3><p>JavaScript中的异步机制可以分为以下几种：</p><ul><li><strong>回调函数</strong> 的方式，使用回调函数的方式有一个缺点是，多个回调函数嵌套的时候会造成回调函数地狱，上下两层的回调函数间的代码耦合度太高，不利于代码的可维护。</li><li><strong>Promise</strong> 的方式，使用 Promise 的方式可以将嵌套的回调函数作为链式调用。但是使用这种方法，有时会造成多个 then 的链式调用，可能会造成代码的语义不够明确。</li><li><strong>generator</strong> 的方式，它可以在函数的执行过程中，将函数的执行权转移出去，在函数外部还可以将执行权转移回来。当遇到异步函数执行的时候，将函数执行权转移出去，当异步函数执行完毕时再将执行权给转移回来。因此在 generator 内部对于异步操作的方式，可以以同步的顺序来书写。使用这种方式需要考虑的问题是何时将函数的控制权转移回来，因此需要有一个自动执行 generator 的机制，比如说 co 模块等方式来实现 generator 的自动执行。</li><li><strong>async 函数</strong> 的方式，async 函数是 generator 和 promise 实现的一个自动执行的语法糖，它内部自带执行器，当函数内部执行到一个 await 语句的时候，如果语句返回一个 promise 对象，那么函数将会等待 promise 对象的状态变为 resolve 后再继续向下执行。因此可以将异步逻辑，转化为同步的顺序来书写，并且这个函数可以自动执行。</li></ul><h3 id="2-setTimeout、Promise、Async-Await-的区别"><a href="#2-setTimeout、Promise、Async-Await-的区别" class="headerlink" title="2. setTimeout、Promise、Async/Await 的区别"></a>2. setTimeout、Promise、Async/Await 的区别</h3><h4 id="（1）setTimeout"><a href="#（1）setTimeout" class="headerlink" title="（1）setTimeout"></a>（1）setTimeout</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script start&#x27;</span>)<span class="comment">//1. 打印 script start</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;settimeout&#x27;</span>)<span class="comment">// 4. 打印 settimeout</span></span><br><span class="line">&#125;)<span class="comment">// 2. 调用 setTimeout 函数，并定义其完成后执行的回调函数</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script end&#x27;</span>)<span class="comment">//3. 打印 script start</span></span><br><span class="line"><span class="comment">// 输出顺序：script start-&gt;script end-&gt;settimeout</span></span><br></pre></td></tr></table></figure><h4 id="（2）Promise"><a href="#（2）Promise" class="headerlink" title="（2）Promise"></a>（2）Promise</h4><p>Promise本身是<strong>同步的立即执行函数</strong>， 当在executor中执行resolve或者reject的时候, 此时是异步操作， 会先执行then/catch等，当主栈完成后，才会去调用resolve/reject中存放的方法执行，打印p的时候，是打印的返回结果，一个Promise实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script start&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> promise1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise1&#x27;</span>)</span><br><span class="line">    <span class="title function_">resolve</span>()</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise1 end&#x27;</span>)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise2&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;settimeout&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script end&#x27;</span>)</span><br><span class="line"><span class="comment">// 输出顺序: script start-&gt;promise1-&gt;promise1 end-&gt;script end-&gt;promise2-&gt;settimeout</span></span><br></pre></td></tr></table></figure><p>当JS主线程执行到Promise对象时：</p><ul><li>promise1.then() 的回调就是一个 task</li><li>promise1 是 resolved或rejected: 那这个 task 就会放入当前事件循环回合的 microtask queue</li><li>promise1 是 pending: 这个 task 就会放入 事件循环的未来的某个(可能下一个)回合的 microtask queue 中</li><li>setTimeout 的回调也是个 task ，它会被放入 macrotask queue 即使是 0ms 的情况</li></ul><h4 id="（3）async-await"><a href="#（3）async-await" class="headerlink" title="（3）async/await"></a>（3）async/await</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async1</span>(<span class="params"></span>)&#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;async1 start&#x27;</span>);</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">async2</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;async1 end&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async2</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;async2&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script start&#x27;</span>);</span><br><span class="line"><span class="title function_">async1</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script end&#x27;</span>)</span><br><span class="line"><span class="comment">// 输出顺序：script start-&gt;async1 start-&gt;async2-&gt;script end-&gt;async1 end</span></span><br></pre></td></tr></table></figure><p>async 函数返回一个 Promise 对象，当函数执行的时候，一旦遇到 await 就会先返回，等到触发的异步操作完成，再执行函数体内后面的语句。可以理解为，是让出了线程，跳出了 async 函数体。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">func1</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">func1</span>())</span><br></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/40194bdc07024b78b6da8bb43d84a7d8~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img"> func1的运行结果其实就是一个Promise对象。因此也可以使用then来处理后续逻辑。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">func1</span>().<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res);  <span class="comment">// 30</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>await的含义为等待，也就是 async 函数需要等待await后的函数执行完成并且有了返回结果（Promise对象）之后，才能继续执行下面的代码。await通过返回一个Promise对象来实现同步的效果。</p><h3 id="3-对Promise的理解"><a href="#3-对Promise的理解" class="headerlink" title="3. 对Promise的理解"></a>3. 对Promise的理解</h3><p>Promise是异步编程的一种解决方案，它是一个对象，可以获取异步操作的消息，他的出现大大改善了异步编程的困境，避免了地狱回调，它比传统的解决方案回调函数和事件更合理和更强大。</p><p>所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。</p><p>（1）Promise的实例有<strong>三个状态</strong>:</p><ul><li>Pending（进行中）</li><li>Resolved（已完成）</li><li>Rejected（已拒绝）</li></ul><p>当把一件事情交给promise时，它的状态就是Pending，任务完成了状态就变成了Resolved、没有完成失败了就变成了Rejected。</p><p>（2）Promise的实例有<strong>两个过程</strong>：</p><ul><li>pending -&gt; fulfilled : Resolved（已完成）</li><li>pending -&gt; rejected：Rejected（已拒绝）</li></ul><p>注意：一旦从进行状态变成为其他状态就永远不能更改状态了。</p><p><strong>Promise的特点：</strong></p><ul><li>对象的状态不受外界影响。promise对象代表一个异步操作，有三种状态，<code>pending</code>（进行中）、<code>fulfilled</code>（已成功）、<code>rejected</code>（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态，这也是promise这个名字的由来——“<strong>承诺</strong>”；</li><li>一旦状态改变就不会再变，任何时候都可以得到这个结果。promise对象的状态改变，只有两种可能：从<code>pending</code>变为<code>fulfilled</code>，从<code>pending</code>变为<code>rejected</code>。这时就称为<code>resolved</code>（已定型）。如果改变已经发生了，你再对promise对象添加回调函数，也会立即得到这个结果。这与事件（event）完全不同，事件的特点是：如果你错过了它，再去监听是得不到结果的。</li></ul><p><strong>Promise的缺点：</strong></p><ul><li>无法取消Promise，一旦新建它就会立即执行，无法中途取消。</li><li>如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。</li><li>当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</li></ul><p><strong>总结：</strong> Promise 对象是异步编程的一种解决方案，最早由社区提出。Promise 是一个构造函数，接收一个函数作为参数，返回一个 Promise 实例。一个 Promise 实例有三种状态，分别是pending、resolved 和 rejected，分别代表了进行中、已成功和已失败。实例的状态只能由 pending 转变 resolved 或者rejected 状态，并且状态一经改变，就凝固了，无法再被改变了。</p><p>状态的改变是通过 resolve() 和 reject() 函数来实现的，可以在异步操作结束后调用这两个函数改变 Promise 实例的状态，它的原型上定义了一个 then 方法，使用这个 then 方法可以为两个状态的改变注册回调函数。这个回调函数属于微任务，会在本轮事件循环的末尾执行。</p><p><strong>注意：</strong> 在构造 <code>Promise</code> 的时候，构造函数内部的代码是立即执行的</p><h3 id="4-Promise的基本用法"><a href="#4-Promise的基本用法" class="headerlink" title="4. Promise的基本用法"></a>4. Promise的基本用法</h3><h4 id="（1）创建Promise对象"><a href="#（1）创建Promise对象" class="headerlink" title="（1）创建Promise对象"></a>（1）创建Promise对象</h4><p>Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。</p><p>Promise构造函数接受一个函数作为参数，该函数的两个参数分别是<code>resolve</code>和<code>reject</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="comment">// ... some code</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="comment">/* 异步操作成功 */</span>)&#123;</span><br><span class="line">    <span class="title function_">resolve</span>(value);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_">reject</span>(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>一般情况下都会使用</strong><code>new Promise()</code><strong>来创建promise对象，但是也可以使用</strong><code>promise.resolve</code><strong>和</strong><code>promise.reject</code><strong>这两个方法：</strong></p><ul><li><strong>Promise.resolve</strong></li></ul><p><code>Promise.resolve(value)</code>的返回值也是一个promise对象，可以对返回值进行.then调用，代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">11</span>).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">value</span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value); <span class="comment">// 打印出11</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>resolve(11)</code>代码中，会让promise对象进入确定(<code>resolve</code>状态)，并将参数<code>11</code>传递给后面的<code>then</code>所指定的<code>onFulfilled</code> 函数；</p><p>创建promise对象可以使用<code>new Promise</code>的形式创建对象，也可以使用<code>Promise.resolve(value)</code>的形式创建promise对象；</p><ul><li><strong>Promise.reject</strong></li></ul><p><code>Promise.reject</code> 也是<code>new Promise</code>的快捷形式，也创建一个promise对象。代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(“我错了，请原谅俺！！”));</span><br></pre></td></tr></table></figure><p>就是下面的代码new Promise的简单形式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve,reject</span>)&#123;</span><br><span class="line">   <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;我错了！&quot;</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>下面是使用resolve方法和reject方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">testPromise</span>(<span class="params">ready</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve,reject</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(ready) &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="title function_">reject</span>(<span class="string">&quot;No thanks&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 方法调用</span></span><br><span class="line"><span class="title function_">testPromise</span>(<span class="literal">true</span>).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">msg</span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(msg);</span><br><span class="line">&#125;,<span class="keyword">function</span>(<span class="params">error</span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面的代码的含义是给<code>testPromise</code>方法传递一个参数，返回一个promise对象，如果为<code>true</code>的话，那么调用promise对象中的<code>resolve()</code>方法，并且把其中的参数传递给后面的<code>then</code>第一个函数内，因此打印出 “<code>hello world</code>”, 如果为<code>false</code>的话，会调用promise对象中的<code>reject()</code>方法，则会进入<code>then</code>的第二个函数内，会打印<code>No thanks</code>；</p><h4 id="（2）Promise方法"><a href="#（2）Promise方法" class="headerlink" title="（2）Promise方法"></a>（2）Promise方法</h4><p>Promise有五个常用的方法：then()、catch()、all()、race()、finally。下面就来看一下这些方法。</p><ol><li><strong>then()</strong></li></ol><p>当Promise执行的内容符合成功条件时，调用<code>resolve</code>函数，失败就调用<code>reject</code>函数。Promise创建完了，那该如何调用呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">promise.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="comment">// success</span></span><br><span class="line">&#125;, <span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line">  <span class="comment">// failure</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>then</code>方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为<code>resolved</code>时调用，第二个回调函数是Promise对象的状态变为<code>rejected</code>时调用。其中第二个参数可以省略。 <code>then</code>方法返回的是一个新的Promise实例（不是原来那个Promise实例）。因此可以采用链式写法，即<code>then</code>方法后面再调用另一个then方法。</p><p>当要写有顺序的异步事件时，需要串行时，可以这样写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="title function_">ajax</span>(<span class="string">&#x27;first&#x27;</span>).<span class="title function_">success</span>(<span class="keyword">function</span>(<span class="params">res</span>)&#123;</span><br><span class="line">        <span class="title function_">resolve</span>(res);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">promise.<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resovle,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="title function_">ajax</span>(<span class="string">&#x27;second&#x27;</span>).<span class="title function_">success</span>(<span class="keyword">function</span>(<span class="params">res</span>)&#123;</span><br><span class="line">            <span class="title function_">resolve</span>(res)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resovle,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="title function_">ajax</span>(<span class="string">&#x27;second&#x27;</span>).<span class="title function_">success</span>(<span class="keyword">function</span>(<span class="params">res</span>)&#123;</span><br><span class="line">            <span class="title function_">resolve</span>(res)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>那当要写的事件没有顺序或者关系时，还如何写呢？可以使用<code>all</code> 方法来解决。</p><p><strong>2. catch()</strong></p><p>Promise对象除了有then方法，还有一个catch方法，该方法相当于<code>then</code>方法的第二个参数，指向<code>reject</code>的回调函数。不过<code>catch</code>方法还有一个作用，就是在执行<code>resolve</code>回调函数时，如果出现错误，抛出异常，不会停止运行，而是进入<code>catch</code>方法中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">p.<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;resolved&#x27;</span>,data);</span><br><span class="line">&#125;,<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;rejected&#x27;</span>,err);</span><br><span class="line">     &#125;</span><br><span class="line">); </span><br><span class="line">p.<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;resolved&#x27;</span>,data);</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;rejected&#x27;</span>,err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>3. all()</strong></p><p><code>all</code>方法可以完成并行任务， 它接收一个数组，数组的每一项都是一个<code>promise</code>对象。当数组中所有的<code>promise</code>的状态都达到<code>resolved</code>的时候，<code>all</code>方法的状态就会变成<code>resolved</code>，如果有一个状态变成了<code>rejected</code>，那么<code>all</code>方法的状态就会变成<code>rejected</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">javascript</span><br><span class="line"><span class="keyword">let</span> promise1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">       <span class="title function_">resolve</span>(<span class="number">1</span>);</span><br><span class="line">&#125;,<span class="number">2000</span>)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> promise2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">       <span class="title function_">resolve</span>(<span class="number">2</span>);</span><br><span class="line">&#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> promise3 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">       <span class="title function_">resolve</span>(<span class="number">3</span>);</span><br><span class="line">&#125;,<span class="number">3000</span>)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>([promise1,promise2,promise3]).<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">    <span class="comment">//结果为：[1,2,3] </span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>调用<code>all</code>方法时的结果成功的时候是回调函数的参数也是一个数组，这个数组按顺序保存着每一个promise对象<code>resolve</code>执行时的值。</p><p><strong>（4）race()</strong></p><p><code>race</code>方法和<code>all</code>一样，接受的参数是一个每项都是<code>promise</code>的数组，但是与<code>all</code>不同的是，当最先执行完的事件执行完之后，就直接返回该<code>promise</code>对象的值。如果第一个<code>promise</code>对象状态变成<code>resolved</code>，那自身的状态变成了<code>resolved</code>；反之第一个<code>promise</code>变成<code>rejected</code>，那自身状态就会变成<code>rejected</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">       <span class="title function_">reject</span>(<span class="number">1</span>);</span><br><span class="line">&#125;,<span class="number">2000</span>)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> promise2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">       <span class="title function_">resolve</span>(<span class="number">2</span>);</span><br><span class="line">&#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> promise3 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">       <span class="title function_">resolve</span>(<span class="number">3</span>);</span><br><span class="line">&#125;,<span class="number">3000</span>)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">race</span>([promise1,promise2,promise3]).<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line"><span class="comment">//结果：2</span></span><br><span class="line">&#125;,<span class="function"><span class="params">rej</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(rej)&#125;;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>那么<code>race</code>方法有什么实际作用呢？当要做一件事，超过多长时间就不做了，可以用这个方法来解决：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">race</span>([promise1,<span class="title function_">timeOutPromise</span>(<span class="number">5000</span>)]).<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span>&#123;&#125;)</span><br></pre></td></tr></table></figure><p><strong>5. finally()</strong></p><p><code>finally</code>方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">promise</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> &#123;···&#125;)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;···&#125;)</span><br><span class="line">.<span class="title function_">finally</span>(<span class="function">() =&gt;</span> &#123;···&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，不管<code>promise</code>最后的状态，在执行完<code>then</code>或<code>catch</code>指定的回调函数以后，都会执行<code>finally</code>方法指定的回调函数。</p><p>下面是一个例子，服务器使用 Promise 处理请求，然后使用<code>finally</code>方法关掉服务器。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server.<span class="title function_">listen</span>(port)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">finally</span>(server.<span class="property">stop</span>);</span><br></pre></td></tr></table></figure><p><code>finally</code>方法的回调函数不接受任何参数，这意味着没有办法知道，前面的 Promise 状态到底是<code>fulfilled</code>还是<code>rejected</code>。这表明，<code>finally</code>方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。<code>finally</code>本质上是<code>then</code>方法的特例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">promise</span><br><span class="line">.<span class="title function_">finally</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 语句</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">promise</span><br><span class="line">.<span class="title function_">then</span>(</span><br><span class="line">  <span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 语句</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 语句</span></span><br><span class="line">    <span class="keyword">throw</span> error;</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>上面代码中，如果不使用<code>finally</code>方法，同样的语句需要为成功和失败两种情况各写一次。有了<code>finally</code>方法，则只需要写一次。</p><h3 id="5-Promise解决了什么问题"><a href="#5-Promise解决了什么问题" class="headerlink" title="5. Promise解决了什么问题"></a>5. Promise解决了什么问题</h3><p>在工作中经常会碰到这样一个需求，比如我使用ajax发一个A请求后，成功后拿到数据，需要把数据传给B请求；那么需要如下编写代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line">fs.<span class="title function_">readFile</span>(<span class="string">&#x27;./a.txt&#x27;</span>,<span class="string">&#x27;utf8&#x27;</span>,<span class="keyword">function</span>(<span class="params">err,data</span>)&#123;</span><br><span class="line">  fs.<span class="title function_">readFile</span>(data,<span class="string">&#x27;utf8&#x27;</span>,<span class="keyword">function</span>(<span class="params">err,data</span>)&#123;</span><br><span class="line">    fs.<span class="title function_">readFile</span>(data,<span class="string">&#x27;utf8&#x27;</span>,<span class="keyword">function</span>(<span class="params">err,data</span>)&#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(data)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上面的代码有如下缺点：</p><ul><li>后一个请求需要依赖于前一个请求成功后，将数据往下传递，会导致多个ajax请求嵌套的情况，代码不够直观。</li><li>如果前后两个请求不需要传递参数的情况下，那么后一个请求也需要前一个请求成功后再执行下一步操作，这种情况下，那么也需要如上编写代码，导致代码不够直观。</li></ul><p><code>Promise</code>出现之后，代码变成这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">read</span>(<span class="params">url</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    fs.<span class="title function_">readFile</span>(url,<span class="string">&#x27;utf8&#x27;</span>,<span class="keyword">function</span>(<span class="params">error,data</span>)&#123;</span><br><span class="line">      error &amp;&amp; <span class="title function_">reject</span>(error)</span><br><span class="line">      <span class="title function_">resolve</span>(data)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">read</span>(<span class="string">&#x27;./a.txt&#x27;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">read</span>(data) </span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">read</span>(data)  </span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这样代码看起了就简洁了很多，解决了地狱回调的问题。</p><h3 id="6-Promise-all和Promise-race的区别的使用场景"><a href="#6-Promise-all和Promise-race的区别的使用场景" class="headerlink" title="6. Promise.all和Promise.race的区别的使用场景"></a>6. Promise.all和Promise.race的区别的使用场景</h3><p><strong>（1）Promise.all</strong> <code>Promise.all</code>可以将多个<code>Promise</code>实例包装成一个新的Promise实例。同时，成功和失败的返回值是不同的，成功的时候返回的是<strong>一个结果数组</strong>，而失败的时候则返回<strong>最先被reject失败状态的值</strong>。</p><p>Promise.all中传入的是数组，返回的也是是数组，并且会将进行映射，传入的promise对象返回的值是按照顺序在数组中排列的，但是注意的是他们执行的顺序并不是按照顺序的，除非可迭代对象为空。</p><p>需要注意，Promise.all获得的成功结果的数组里面的数据顺序和Promise.all接收到的数组顺序是一致的，这样当遇到发送多个请求并根据请求顺序获取和使用数据的场景，就可以使用Promise.all来解决。</p><p><strong>（2）Promise.race</strong></p><p>顾名思义，Promse.race就是赛跑的意思，意思就是说，Promise.race([p1, p2, p3])里面哪个结果获得的快，就返回那个结果，不管结果本身是成功状态还是失败状态。当要做一件事，超过多长时间就不做了，可以用这个方法来解决：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">race</span>([promise1,<span class="title function_">timeOutPromise</span>(<span class="number">5000</span>)]).<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span>&#123;&#125;)</span><br></pre></td></tr></table></figure><h3 id="7-对async-await-的理解"><a href="#7-对async-await-的理解" class="headerlink" title="7.  对async/await 的理解"></a>7.  对async/await 的理解</h3><p>async/await其实是<code>Generator</code> 的语法糖，它能实现的效果都能用then链来实现，它是为优化then链而开发出来的。从字面上来看，async是“异步”的简写，await则为等待，所以很好理解async 用于申明一个 function 是异步的，而 await 用于等待一个异步方法执行完成。当然语法上强制规定await只能出现在asnyc函数中，先来看看async函数返回了什么：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">testAsy</span>(<span class="params"></span>)&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="string">&#x27;hello world&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> result = <span class="title function_">testAsy</span>(); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result)</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230610150957114.png" alt="image-20230610150957114"></p><p>所以，async 函数返回的是一个 Promise 对象。async 函数（包含函数语句、函数表达式、Lambda表达式)会返回一个 Promise 对象，如果在函数中 <code>return</code> 一个直接量，async 会把这个直接量通过 <code>Promise.resolve()</code> 封装成 Promise 对象。</p><p>async 函数返回的是一个 Promise 对象，所以在最外层不能用 await 获取其返回值的情况下，当然应该用原来的方式：<code>then()</code> 链来处理这个 Promise 对象，就像这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">testAsy</span>(<span class="params"></span>)&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="string">&#x27;hello world&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> result = <span class="title function_">testAsy</span>() </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result)</span><br><span class="line">result.<span class="title function_">then</span>(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(v)   <span class="comment">// hello world</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>那如果 async 函数没有返回值，又该如何？很容易想到，它会返回 <code>Promise.resolve(undefined)</code>。</p><p>联想一下 Promise 的特点——无等待，所以在没有 <code>await</code> 的情况下执行 async 函数，它会立即执行，返回一个 Promise 对象，并且，绝不会阻塞后面的语句。这和普通返回 Promise 对象的函数并无二致。</p><p><strong>注意：</strong><code>Promise.resolve(x)</code> 可以看作是 <code>new Promise(resolve =&gt; resolve(x))</code> 的简写，可以用于快速封装字面量对象或其他对象，将其封装成 Promise 实例。</p><h3 id="8-await-到底在等啥？"><a href="#8-await-到底在等啥？" class="headerlink" title="8. await 到底在等啥？"></a>8. await 到底在等啥？</h3><p><strong>await 在等待什么呢？</strong> 一般来说，都认为 await 是在等待一个 async 函数完成。不过按语法说明，await 等待的是一个表达式，这个表达式的计算结果是 Promise 对象或者其它值（换句话说，就是没有特殊限定）。</p><p>因为 async 函数返回一个 Promise 对象，所以 await 可以用于等待一个 async 函数的返回值——这也可以说是 await 在等 async 函数，但要清楚，它等的实际是一个返回值。注意到 await 不仅仅用于等 Promise 对象，它可以等任意表达式的结果，所以，await 后面实际是可以接普通函数调用或者直接量的。所以下面这个示例完全可以正确运行：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getSomething</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;something&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">testAsync</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&quot;hello async&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> v1 = <span class="keyword">await</span> <span class="title function_">getSomething</span>();</span><br><span class="line">    <span class="keyword">const</span> v2 = <span class="keyword">await</span> <span class="title function_">testAsync</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(v1, v2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">test</span>();</span><br></pre></td></tr></table></figure><p>await 表达式的运算结果取决于它等的是什么。</p><ul><li>如果它等到的不是一个 Promise 对象，那 await 表达式的运算结果就是它等到的东西。</li><li>如果它等到的是一个 Promise 对象，await 就忙起来了，它会阻塞后面的代码，等着 Promise 对象 resolve，然后得到 resolve 的值，作为 await 表达式的运算结果。</li></ul><p>来看一个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">testAsy</span>(<span class="params">x</span>)&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span>=&gt;</span>&#123;<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">       <span class="title function_">resolve</span>(x);</span><br><span class="line">     &#125;, <span class="number">3000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">   )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">testAwt</span>(<span class="params"></span>)&#123;    </span><br><span class="line">  <span class="keyword">let</span> result =  <span class="keyword">await</span> <span class="title function_">testAsy</span>(<span class="string">&#x27;hello world&#x27;</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(result);    <span class="comment">// 3秒钟之后出现hello world</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;cuger&#x27;</span>)   <span class="comment">// 3秒钟之后出现cug</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">testAwt</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;cug&#x27;</span>)  <span class="comment">//立即输出cug</span></span><br></pre></td></tr></table></figure><p>这就是 await 必须用在 async 函数中的原因。async 函数调用不会造成阻塞，它内部所有的阻塞都被封装在一个 Promise 对象中异步执行。await暂停当前async的执行，所以’cug’’最先输出，hello world’和‘cuger’是3秒钟后同时出现的。</p><h3 id="9-async-await的优势"><a href="#9-async-await的优势" class="headerlink" title="9.  async/await的优势"></a>9.  async/await的优势</h3><p>单一的 Promise 链并不能发现 async/await 的优势，但是，如果需要处理由多个 Promise 组成的 then 链的时候，优势就能体现出来了（很有意思，Promise 通过 then 链来解决多层回调的问题，现在又用 async/await 来进一步优化它）。</p><p>假设一个业务，分多个步骤完成，每个步骤都是异步的，而且依赖于上一个步骤的结果。仍然用 <code>setTimeout</code> 来模拟异步操作：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 传入参数 n，表示这个函数执行的时间（毫秒）</span></span><br><span class="line"><span class="comment"> * 执行的结果是 n + 200，这个值将用于下一步骤</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">takeLongTime</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(n + <span class="number">200</span>), n);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">step1</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`step1 with <span class="subst">$&#123;n&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">takeLongTime</span>(n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">step2</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`step2 with <span class="subst">$&#123;n&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">takeLongTime</span>(n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">step3</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`step3 with <span class="subst">$&#123;n&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">takeLongTime</span>(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在用 Promise 方式来实现这三个步骤的处理：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">doIt</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">time</span>(<span class="string">&quot;doIt&quot;</span>);</span><br><span class="line">    <span class="keyword">const</span> time1 = <span class="number">300</span>;</span><br><span class="line">    <span class="title function_">step1</span>(time1)</span><br><span class="line">        .<span class="title function_">then</span>(<span class="function"><span class="params">time2</span> =&gt;</span> <span class="title function_">step2</span>(time2))</span><br><span class="line">        .<span class="title function_">then</span>(<span class="function"><span class="params">time3</span> =&gt;</span> <span class="title function_">step3</span>(time3))</span><br><span class="line">        .<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`result is <span class="subst">$&#123;result&#125;</span>`</span>);</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">timeEnd</span>(<span class="string">&quot;doIt&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">doIt</span>();</span><br><span class="line"><span class="comment">// c:\var\test&gt;node --harmony_async_await .</span></span><br><span class="line"><span class="comment">// step1 with 300</span></span><br><span class="line"><span class="comment">// step2 with 500</span></span><br><span class="line"><span class="comment">// step3 with 700</span></span><br><span class="line"><span class="comment">// result is 900</span></span><br><span class="line"><span class="comment">// doIt: 1507.251ms</span></span><br></pre></td></tr></table></figure><p>输出结果 <code>result</code> 是 <code>step3()</code> 的参数 <code>700 + 200</code> = <code>900</code>。<code>doIt()</code> 顺序执行了三个步骤，一共用了 <code>300 + 500 + 700 = 1500</code> 毫秒，和 <code>console.time()/console.timeEnd()</code> 计算的结果一致。</p><p>如果用 async/await 来实现呢，会是这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">doIt</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">time</span>(<span class="string">&quot;doIt&quot;</span>);</span><br><span class="line">    <span class="keyword">const</span> time1 = <span class="number">300</span>;</span><br><span class="line">    <span class="keyword">const</span> time2 = <span class="keyword">await</span> <span class="title function_">step1</span>(time1);</span><br><span class="line">    <span class="keyword">const</span> time3 = <span class="keyword">await</span> <span class="title function_">step2</span>(time2);</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> <span class="title function_">step3</span>(time3);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`result is <span class="subst">$&#123;result&#125;</span>`</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">timeEnd</span>(<span class="string">&quot;doIt&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">doIt</span>();</span><br></pre></td></tr></table></figure><p>结果和之前的 Promise 实现是一样的，但是这个代码看起来是不是清晰得多，几乎跟同步代码一样</p><h3 id="10-async-await对比Promise的优势"><a href="#10-async-await对比Promise的优势" class="headerlink" title="10. async/await对比Promise的优势"></a>10. async/await对比Promise的优势</h3><ul><li>代码读起来更加同步，Promise虽然摆脱了回调地狱，但是then的链式调⽤也会带来额外的阅读负担</li><li>Promise传递中间值⾮常麻烦，⽽async/await⼏乎是同步的写法，⾮常优雅</li><li>错误处理友好，async/await可以⽤成熟的try/catch，Promise的错误捕获⾮常冗余</li><li>调试友好，Promise的调试很差，由于没有代码块，你不能在⼀个返回表达式的箭头函数中设置断点，如果你在⼀个.then代码块中使⽤调试器的步进(step-over)功能，调试器并不会进⼊后续的.then代码块，因为调试器只能跟踪同步代码的每⼀步。</li></ul><h3 id="11-async-await-如何捕获异常"><a href="#11-async-await-如何捕获异常" class="headerlink" title="11. async/await 如何捕获异常"></a>11. async/await 如何捕获异常</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> a = <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&#x27;error&#x27;</span>)</span><br><span class="line">    &#125;<span class="keyword">catch</span>(error)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="八、面向对象"><a href="#八、面向对象" class="headerlink" title="八、面向对象"></a>八、面向对象</h2><h3 id="1-对象创建的方式有哪些？"><a href="#1-对象创建的方式有哪些？" class="headerlink" title="1. 对象创建的方式有哪些？"></a>1. 对象创建的方式有哪些？</h3><p>一般使用字面量的形式直接创建对象，但是这种创建方式对于创建大量相似对象的时候，会产生大量的重复代码。但 js和一般的面向对象的语言不同，在 ES6 之前它没有类的概念。但是可以使用函数来进行模拟，从而产生出可复用的对象创建方式，常见的有以下几种：</p><p>（1）第一种是工厂模式，工厂模式的主要工作原理是用函数来封装创建对象的细节，从而通过调用函数来达到复用的目的。但是它有一个很大的问题就是创建出来的对象无法和某个类型联系起来，它只是简单的封装了复用代码，而没有建立起对象和类型间的关系。</p><p>（2）第二种是构造函数模式。js 中每一个函数都可以作为构造函数，只要一个函数是通过 new 来调用的，那么就可以把它称为构造函数。执行构造函数首先会创建一个对象，然后将对象的原型指向构造函数的 prototype 属性，然后将执行上下文中的 this 指向这个对象，最后再执行整个函数，如果返回值不是对象，则返回新建的对象。因为 this 的值指向了新建的对象，因此可以使用 this 给对象赋值。构造函数模式相对于工厂模式的优点是，所创建的对象和构造函数建立起了联系，因此可以通过原型来识别对象的类型。但是构造函数存在一个缺点就是，造成了不必要的函数对象的创建，因为在 js 中函数也是一个对象，因此如果对象属性中如果包含函数的话，那么每次都会新建一个函数对象，浪费了不必要的内存空间，因为函数是所有的实例都可以通用的。</p><p>（3）第三种模式是原型模式，因为每一个函数都有一个 prototype 属性，这个属性是一个对象，它包含了通过构造函数创建的所有实例都能共享的属性和方法。因此可以使用原型对象来添加公用属性和方法，从而实现代码的复用。这种方式相对于构造函数模式来说，解决了函数对象的复用问题。但是这种模式也存在一些问题，一个是没有办法通过传入参数来初始化值，另一个是如果存在一个引用类型如 Array 这样的值，那么所有的实例将共享一个对象，一个实例对引用类型值的改变会影响所有的实例。</p><p>（4）第四种模式是组合使用构造函数模式和原型模式，这是创建自定义类型的最常见方式。因为构造函数模式和原型模式分开使用都存在一些问题，因此可以组合使用这两种模式，通过构造函数来初始化对象的属性，通过原型对象来实现函数方法的复用。这种方法很好的解决了两种模式单独使用时的缺点，但是有一点不足的就是，因为使用了两种不同的模式，所以对于代码的封装性不够好。</p><p>（5）第五种模式是动态原型模式，这一种模式将原型方法赋值的创建过程移动到了构造函数的内部，通过对属性是否存在的判断，可以实现仅在第一次调用函数时对原型对象赋值一次的效果。这一种方式很好地对上面的混合模式进行了封装。</p><p>（6）第六种模式是寄生构造函数模式，这一种模式和工厂模式的实现基本相同，我对这个模式的理解是，它主要是基于一个已有的类型，在实例化时对实例化的对象进行扩展。这样既不用修改原来的构造函数，也达到了扩展对象的目的。它的一个缺点和工厂模式一样，无法实现对象的识别。</p><h3 id="2-对象继承的方式有哪些？"><a href="#2-对象继承的方式有哪些？" class="headerlink" title="2. 对象继承的方式有哪些？"></a>2. 对象继承的方式有哪些？</h3><p>（1）第一种是以原型链的方式来实现继承，但是这种实现方式存在的缺点是，在包含有引用类型的数据时，会被所有的实例对象所共享，容易造成修改的混乱。还有就是在创建子类型的时候不能向超类型传递参数。</p><p>（2）第二种方式是使用借用构造函数的方式，这种方式是通过在子类型的函数中调用超类型的构造函数来实现的，这一种方法解决了不能向超类型传递参数的缺点，但是它存在的一个问题就是无法实现函数方法的复用，并且超类型原型定义的方法子类型也没有办法访问到。</p><p>（3）第三种方式是组合继承，组合继承是将原型链和借用构造函数组合起来使用的一种方式。通过借用构造函数的方式来实现类型的属性的继承，通过将子类型的原型设置为超类型的实例来实现方法的继承。这种方式解决了上面的两种模式单独使用时的问题，但是由于我们是以超类型的实例来作为子类型的原型，所以调用了两次超类的构造函数，造成了子类型的原型中多了很多不必要的属性。</p><p>（4）第四种方式是原型式继承，原型式继承的主要思路就是基于已有的对象来创建新的对象，实现的原理是，向函数中传入一个对象，然后返回一个以这个对象为原型的对象。这种继承的思路主要不是为了实现创造一种新的类型，只是对某个对象实现一种简单继承，ES5 中定义的 Object.create() 方法就是原型式继承的实现。缺点与原型链方式相同。</p><p>（5）第五种方式是寄生式继承，寄生式继承的思路是创建一个用于封装继承过程的函数，通过传入一个对象，然后复制一个对象的副本，然后对象进行扩展，最后返回这个对象。这个扩展的过程就可以理解是一种继承。这种继承的优点就是对一个简单对象实现继承，如果这个对象不是自定义类型时。缺点是没有办法实现函数的复用。</p><p>（6）第六种方式是寄生式组合继承，组合继承的缺点就是使用超类型的实例做为子类型的原型，导致添加了不必要的原型属性。寄生式组合继承的方式是使用超类型的原型的副本来作为子类型的原型，这样就避免了创建不必要的属性。</p><h2 id="九、垃圾回收与内存泄漏"><a href="#九、垃圾回收与内存泄漏" class="headerlink" title="九、垃圾回收与内存泄漏"></a>九、垃圾回收与内存泄漏</h2><h3 id="1-浏览器的垃圾回收机制"><a href="#1-浏览器的垃圾回收机制" class="headerlink" title="1. 浏览器的垃圾回收机制"></a>1. 浏览器的垃圾回收机制</h3><h4 id="（1）垃圾回收的概念"><a href="#（1）垃圾回收的概念" class="headerlink" title="（1）垃圾回收的概念"></a>（1）垃圾回收的概念</h4><p><strong>垃圾回收</strong>：JavaScript代码运行时，需要分配内存空间来储存变量和值。当变量不在参与运行时，就需要系统收回被占用的内存空间，这就是垃圾回收。</p><p><strong>回收机制</strong>：</p><ul><li>Javascript 具有自动垃圾回收机制，会定期对那些不再使用的变量、对象所占用的内存进行释放，原理就是找到不再使用的变量，然后释放掉其占用的内存。</li><li>JavaScript中存在两种变量：局部变量和全局变量。全局变量的生命周期会持续要页面卸载；而局部变量声明在函数中，它的生命周期从函数执行开始，直到函数执行结束，在这个过程中，局部变量会在堆或栈中存储它们的值，当函数执行结束后，这些局部变量不再被使用，它们所占有的空间就会被释放。</li><li>不过，当局部变量被外部函数使用时，其中一种情况就是闭包，在函数执行结束后，函数外部的变量依然指向函数内部的局部变量，此时局部变量依然在被使用，所以不会回收。</li></ul><h4 id="（2）垃圾回收的方式"><a href="#（2）垃圾回收的方式" class="headerlink" title="（2）垃圾回收的方式"></a>（2）垃圾回收的方式</h4><p>浏览器通常使用的垃圾回收方法有两种：标记清除，引用计数。 <strong>1）标记清除</strong></p><ul><li>标记清除是浏览器常见的垃圾回收方式，当变量进入执行环境时，就标记这个变量“进入环境”，被标记为“进入环境”的变量是不能被回收的，因为他们正在被使用。当变量离开环境时，就会被标记为“离开环境”，被标记为“离开环境”的变量会被内存释放。</li><li>垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记。然后，它会去掉环境中的变量以及被环境中的变量引用的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后。垃圾收集器完成内存清除工作，销毁那些带标记的值，并回收他们所占用的内存空间。</li></ul><p><strong>2）引用计数</strong></p><ul><li>另外一种垃圾回收机制就是引用计数，这个用的相对较少。引用计数就是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型赋值给该变量时，则这个值的引用次数就是1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数就减1。当这个引用次数变为0时，说明这个变量已经没有价值，因此，在在机回收期下次再运行时，这个变量所占有的内存空间就会被释放出来。</li><li>这种方法会引起<strong>循环引用</strong>的问题：例如：<code> obj1</code>和<code>obj2</code>通过属性进行相互引用，两个对象的引用次数都是2。当使用循环计数时，由于函数执行完后，两个对象都离开作用域，函数执行结束，<code>obj1</code>和<code>obj2</code>还将会继续存在，因此它们的引用次数永远不会是0，就会引起循环引用。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fun</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> obj1 = &#123;&#125;;</span><br><span class="line">    <span class="keyword">let</span> obj2 = &#123;&#125;;</span><br><span class="line">    obj1.<span class="property">a</span> = obj2; <span class="comment">// obj1 引用 obj2</span></span><br><span class="line">    obj2.<span class="property">a</span> = obj1; <span class="comment">// obj2 引用 obj1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种情况下，就要手动释放变量占用的内存：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj1.<span class="property">a</span> =  <span class="literal">null</span></span><br><span class="line"> obj2.<span class="property">a</span> =  <span class="literal">null</span></span><br></pre></td></tr></table></figure><h4 id="（3）减少垃圾回收"><a href="#（3）减少垃圾回收" class="headerlink" title="（3）减少垃圾回收"></a>（3）减少垃圾回收</h4><p>虽然浏览器可以进行垃圾自动回收，但是当代码比较复杂时，垃圾回收所带来的代价比较大，所以应该尽量减少垃圾回收。</p><ul><li><strong>对数组进行优化：</strong> 在清空一个数组时，最简单的方法就是给其赋值为[ ]，但是与此同时会创建一个新的空对象，可以将数组的长度设置为0，以此来达到清空数组的目的。</li><li><strong>对</strong><code>object</code><strong>进行优化：</strong> 对象尽量复用，对于不再使用的对象，就将其设置为null，尽快被回收。</li><li><strong>对函数进行优化：</strong> 在循环中的函数表达式，如果可以复用，尽量放在函数的外面。</li></ul><h3 id="2-哪些情况会导致内存泄漏"><a href="#2-哪些情况会导致内存泄漏" class="headerlink" title="2. 哪些情况会导致内存泄漏"></a>2. 哪些情况会导致内存泄漏</h3><p>以下四种情况会造成内存的泄漏：</p><ul><li><strong>意外的全局变量：</strong> 由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。</li><li><strong>被遗忘的计时器或回调函数：</strong> 设置了 setInterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。</li><li><strong>脱离 DOM 的引用：</strong> 获取一个 DOM 元素的引用，而后面这个元素被删除，由于一直保留了对这个元素的引用，所以它也无法被回收。</li><li><strong>闭包：</strong> 不合理的使用闭包，从而导致某些变量一直被留在内存当中。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vela快应用框架</title>
      <link href="/posts/d9795d89.html"/>
      <url>/posts/d9795d89.html</url>
      
        <content type="html"><![CDATA[<p>Vela上快应用框架的一些实现原理和编程实践</p><span id="more"></span><h1 id="快应用框架构成"><a href="#快应用框架构成" class="headerlink" title="快应用框架构成"></a>快应用框架构成</h1><p>一个简单的图用来描述快应用框架的模块构成，主要由Native（C++）部分和JS部分（framework.js）构成。</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/images/48c4d276-9d71-439a-a720-7f268da27d85.svg" alt="48c4d276-9d71-439a-a720-7f268da27d85"></p><p>在框架的C++代码中，最核心的两大组件就是 quickjs和libuv，分别提供JS运行环境和异步消息循环机制。框架还用到了一些其他的C/C++库如libcurl作为http客户端，rapidjson提供json解析能力等。</p><p>下面给出项目目录结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── bin                                     # 生成目录</span><br><span class="line">│   ├── app                                 # 测试应用</span><br><span class="line">│   ├── apps.json                           # 应用配置文件</span><br><span class="line">│   ├── font                                # 应用字体资源</span><br><span class="line">│   ├── quickapp</span><br><span class="line">│   └── vapp                                # 项目生成的可执行文件</span><br><span class="line">├── build                                   # cmake构建目录</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── deps                                    # 依赖项目录</span><br><span class="line">│   ├── curl                                # 多协议文件传输库</span><br><span class="line">│   ├── ext                                 # 扩展，主要是lvgl非标准扩展</span><br><span class="line">│   ├── FFmpeg                              # 音视频编解码库</span><br><span class="line">│   ├── freetype2                           # 字体渲染库</span><br><span class="line">│   ├── libuv                               # 跨平台事件驱动的消息循环库</span><br><span class="line">│   ├── littlefs                            # lvgl相关</span><br><span class="line">│   ├── lv_conf.h</span><br><span class="line">│   ├── lv_drivers</span><br><span class="line">│   ├── lv_drv_conf.h</span><br><span class="line">│   ├── lv_ffmpeg_interface</span><br><span class="line">│   ├── lv_fs_interface</span><br><span class="line">│   ├── lvgl                                # lvgl 嵌入式gui库</span><br><span class="line">│   ├── lv_lib_freetype                     # lvgl的freetype库</span><br><span class="line">│   ├── lv_lib_png                          # lvgl的png解码库</span><br><span class="line">│   ├── quickjs                             # 嵌入式JS引擎</span><br><span class="line">│   ├── rapidjson                           # Json库</span><br><span class="line">│   ├── tools                               # 工具目录，目前存放了Ffmpeg编译脚本</span><br><span class="line">│   ├── unqlite                             # no sql数据库</span><br><span class="line">│   ├── uvws                                # 基于libuv实现的websocket库</span><br><span class="line">│   ├── wasm3                               # web assembely支持库</span><br><span class="line">│   └── yoga                                # yoga排版引擎</span><br><span class="line">├── Kconfig                                 # 供vela使用的kconfg配置</span><br><span class="line">├── Make.defs</span><br><span class="line">├── Makefile                                # vela makefile</span><br><span class="line">├── README.md                               # 本文件</span><br><span class="line">├── src                                     # 源码</span><br><span class="line">│   ├── aiotjs.h</span><br><span class="line">│   ├── ajs_vm.cpp</span><br><span class="line">│   ├── ....</span><br><span class="line">│   ├── framework                           # 框架源码</span><br><span class="line">│   ├── gui                                 # GUI相关代码，包含lvgl渲染器实现</span><br><span class="line">│   ├── jse                                 # JS Environment JS环境相关</span><br><span class="line">│   └── Kconfig</span><br><span class="line">├── tests                                   # 测试</span><br><span class="line">│   ├── gui</span><br><span class="line">│   ├── helpers</span><br><span class="line">│   ├── run.js</span><br><span class="line">│   ├── ... </span><br><span class="line">│   ├── test-feature-vibrator.js</span><br><span class="line">│   ├── wasi</span><br><span class="line">│   └── wasm</span><br><span class="line">└── toolchain                               # 交叉编译相关</span><br><span class="line">    └── cross-m32.cmake                     # linux 32位构建</span><br></pre></td></tr></table></figure><h1 id="框架启动流程分析"><a href="#框架启动流程分析" class="headerlink" title="框架启动流程分析"></a>框架启动流程分析</h1><p><img src="https://raw.githubusercontent.com/why862555625/images/main/images/6ca169bc-84af-4252-9758-54c853feefef.svg" alt="6ca169bc-84af-4252-9758-54c853feefef"></p><p>框架的整个启动和执行流程较为复杂，里面涉及到了JS和C++的互调用。</p><p>启动流程以C++的入口函数为入口点，会初始化quickjs，创建app，启动子线程并加载Native module和内置JS框架代码。</p><p>然后流程转交到JS，由JS通过调用初始化时注册的Native函数来完成整个快应用的加载。</p><h1 id="VDOM渲染流程分析"><a href="#VDOM渲染流程分析" class="headerlink" title="VDOM渲染流程分析"></a>VDOM渲染流程分析</h1><p>VDOM的创建和渲染出于性能考虑，放在了C++层实现，整个VDOM的创建由Native通过执行template上的渲染函数来创建。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function">(<span class="params"><span class="variable language_">module</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">function</span> (<span class="params">vm</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> _vm_ = vm || <span class="variable language_">this</span></span><br><span class="line">      <span class="keyword">return</span> aiot.<span class="title function_">__ce__</span>(<span class="string">&quot;div&quot;</span>, &#123;</span><br><span class="line">        <span class="string">&quot;classList&quot;</span>: [</span><br><span class="line">          <span class="string">&quot;page&quot;</span>,</span><br><span class="line">          <span class="string">&quot;home-page&quot;</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;, [</span><br><span class="line">        aiot.<span class="title function_">__ci__</span>(&#123;</span><br><span class="line">          <span class="attr">shown</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="keyword">return</span> _vm_.<span class="property">status</span> !== <span class="number">0</span> &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">          <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> aiot.<span class="title function_">__ce__</span>(<span class="string">&quot;text&quot;</span>, &#123;</span><br><span class="line">              <span class="string">&quot;classList&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;text-time&quot;</span></span><br><span class="line">              ],</span><br><span class="line">              <span class="string">&quot;value&quot;</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="keyword">return</span> _vm_.$t(<span class="string">&quot;a.b&quot;</span>) &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">          &#125;),</span><br><span class="line">        aiot.<span class="title function_">__ci__</span>(&#123;</span><br><span class="line">          <span class="attr">shown</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="keyword">return</span> _vm_.<span class="property">status</span> === <span class="number">0</span> &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">          <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> aiot.<span class="title function_">__ce__</span>(<span class="string">&quot;div&quot;</span>, &#123;</span><br><span class="line">              <span class="string">&quot;classList&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;body&quot;</span>,</span><br><span class="line">                <span class="string">&quot;launch-panel&quot;</span></span><br><span class="line">              ]</span><br><span class="line">            &#125;, [</span><br><span class="line">              aiot.<span class="title function_">__ce__</span>(<span class="string">&quot;image&quot;</span>, &#123;</span><br><span class="line">                <span class="string">&quot;src&quot;</span>: <span class="string">&quot;/Common/logo.png&quot;</span>,</span><br><span class="line">                <span class="string">&quot;classList&quot;</span>: [</span><br><span class="line">                  <span class="string">&quot;logo&quot;</span></span><br><span class="line">                ]</span><br><span class="line">              &#125;),</span><br><span class="line">              aiot.<span class="title function_">__ce__</span>(<span class="string">&quot;text&quot;</span>, &#123;</span><br><span class="line">                <span class="string">&quot;classList&quot;</span>: [</span><br><span class="line">                  <span class="string">&quot;app-name&quot;</span></span><br><span class="line">                ],</span><br><span class="line">                <span class="string">&quot;value&quot;</span>: <span class="string">&quot;航旅纵横&quot;</span></span><br><span class="line">              &#125;)</span><br><span class="line">            ])</span><br><span class="line">          &#125;),</span><br><span class="line">        aiot.<span class="title function_">__ci__</span>(&#123;...&#125;),</span><br><span class="line">        aiot.<span class="title function_">__ci__</span>(&#123;...&#125;),</span><br><span class="line">        ....</span><br><span class="line">      ])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/***/</span></span><br><span class="line">&#125;),</span><br></pre></td></tr></table></figure><p>Template本身是一个嵌套结构，它被翻译成了对aiot.<strong>ce</strong>, aiot__cf__, aiot.__ci__等函数的嵌套调用，嵌套调用的过程就是在Native层完成整个dom树构建的过程。</p><p>我们来看__cf__对应的C++源码，它用于创建一个逻辑循环节点：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DomEntity* <span class="title">dom_create_for_fragment</span><span class="params">(jse_context_ref ctx, <span class="type">jse_value_t</span> options, <span class="type">jse_value_t</span> func)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">AIOTJS_LOG_DEBUG</span>(<span class="string">&quot;dom_create_for_fragment ==================== &quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   ....</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建DomForFragment节点</span></span><br><span class="line">    DomForFragment *frag = <span class="keyword">new</span> <span class="built_in">DomForFragment</span>();</span><br><span class="line">    page-&gt;<span class="built_in">addDomEntity</span>(frag);</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存JS端传入的表达式和render函数</span></span><br><span class="line">    <span class="type">jse_value_t</span> exp = <span class="built_in">jse_get_object_property</span>(ctx, options, <span class="string">&quot;exp&quot;</span>);</span><br><span class="line">    frag-&gt;<span class="built_in">setExpress</span>(<span class="built_in">jse_dup_value</span>(ctx, exp));</span><br><span class="line">    frag-&gt;<span class="built_in">setRenderFunction</span>(<span class="built_in">jse_dup_value</span>(ctx, func));</span><br><span class="line">    <span class="built_in">jse_free_value</span>(ctx, exp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置key或者$idx</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建effect函数</span></span><br><span class="line">    <span class="type">jse_value_t</span> eff = <span class="built_in">create_effect</span>(ctx, dom_update_for_fragment, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">AIOTJS_LOG_DEBUG</span>(<span class="string">&quot;AddEffect for %d&quot;</span>, frag-&gt;<span class="built_in">uid</span>());</span><br><span class="line">    <span class="comment">//调用framework的effectWrap函数将effect函数传递给JS层保存</span></span><br><span class="line">    frag-&gt;<span class="built_in">addEffect</span>(ctx, <span class="built_in">dom_effect</span>(ctx, eff, frag-&gt;<span class="built_in">uid</span>(), <span class="number">0</span>));</span><br><span class="line">    <span class="built_in">jse_free_value</span>(ctx, eff);</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回创建好的frag vdom节点</span></span><br><span class="line">    <span class="keyword">return</span> frag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dom_update_for_fragment是C++端的节点更新函数，它最终会触发节点的render函数更新子节点：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DomForFragment::render</span><span class="params">(jse_context_ref ctx)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 递归构造</span></span><br><span class="line">    <span class="type">jse_value_t</span> exp_obj = <span class="built_in">jse_call</span>(ctx, exp_, JSE_UNDEFINED, <span class="number">0</span>, &#123;&#125;);</span><br><span class="line">    <span class="type">jse_value_t</span> expValue = JSE_UNDEFINED;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* str_tid = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用JS端的求值函数获取for循环对应的list对象 expValue</span></span><br><span class="line">    expValue = <span class="built_in">get_from_js_expression</span>();</span><br><span class="line">    </span><br><span class="line">    ....</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历数组</span></span><br><span class="line">    <span class="type">jse_size_t</span> len = <span class="built_in">jse_get_array_length</span>(ctx, expValue);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">jse_size_t</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="comment">//为每个element分别调用render函数</span></span><br><span class="line">        <span class="type">jse_value_t</span> idx = <span class="built_in">jse_uint</span>(ctx, i);</span><br><span class="line">        <span class="type">jse_value_t</span> args[] = &#123;</span><br><span class="line">            idx,</span><br><span class="line">            item</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">jse_value_t</span> res = <span class="built_in">jse_call</span>(ctx, render_, JSE_UNDEFINED, <span class="number">2</span>, args);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">jse_is_number</span>(res)) &#123;</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">int</span> cid = <span class="built_in">jse_to_uint_def</span>(ctx, res, <span class="number">0</span>);</span><br><span class="line">            DomEntity* ent = p-&gt;<span class="built_in">entity</span>(cid);</span><br><span class="line">            <span class="built_in">AIOTJS_CHECK_NE</span>(ent, <span class="literal">nullptr</span>);</span><br><span class="line">            ent-&gt;<span class="built_in">setDiffOperationType</span>(DomEntityDiffOperationType::Add);</span><br><span class="line">            <span class="built_in">addChild</span>(ent);</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">jse_is_undefined</span>(tid_value)) &#123;</span><br><span class="line">                <span class="type">jse_value_t</span> v_tid = <span class="built_in">jse_dup_value</span>(ctx, tid_value);</span><br><span class="line">                ent-&gt;<span class="built_in">setTid</span>(v_tid);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">jse_is_array</span>(ctx, res)) &#123;</span><br><span class="line">            <span class="type">jse_size_t</span> childlen = <span class="built_in">jse_get_array_length</span>(ctx, res);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">size_t</span> j=<span class="number">0</span>; j&lt;childlen; j++) &#123;</span><br><span class="line">                <span class="type">unsigned</span> <span class="type">int</span> cid = <span class="built_in">jse_get_array_idx_uint</span>(ctx, res, j, <span class="number">0</span>);</span><br><span class="line">                DomEntity* ent = p-&gt;<span class="built_in">entity</span>(cid);</span><br><span class="line">                <span class="built_in">AIOTJS_CHECK_NE</span>(ent, <span class="literal">nullptr</span>);</span><br><span class="line">                ent-&gt;<span class="built_in">setDiffOperationType</span>(DomEntityDiffOperationType::Add);</span><br><span class="line">                <span class="built_in">addChild</span>(ent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">jse_free_value</span>(ctx, res);</span><br><span class="line">        <span class="built_in">jse_free_value</span>(ctx, idx);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">jse_free_value</span>(ctx, item);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">jse_free_value</span>(ctx, expValue);</span><br><span class="line">    <span class="built_in">AIOTJS_LOG_DEBUG</span>(<span class="string">&quot;DomForFragment::build finished - &lt;%u&gt;&quot;</span>, <span class="built_in">uid</span>());</span><br><span class="line">    <span class="comment">// 只有初始化的时候返回true表示需要flush，其它情况下延迟flush</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">isBindingEffect</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="框架线程模型"><a href="#框架线程模型" class="headerlink" title="框架线程模型"></a>框架线程模型</h1><p>框架采用多线程模式，主要有如下两类线程：</p><ul><li>主线程：负责渲染，只有一个</li><li>应用线程：负责执行JS代码，响应数据变更并更新vdom</li></ul><p>主线程和应用线程各启动一个uv loop进行消息处理，这两个线程通过libuv进行异步通信，主要有如下几种场景：</p><ol><li>应用线程退出后异步通知主线程退出</li><li>应用线程更新vdom后异步通知主线程刷新ui</li><li>系统消息（如应用后台，应用退出等）由主线程发出，通过libuv转到应用线程执行</li></ol><h1 id="渲染流程分析"><a href="#渲染流程分析" class="headerlink" title="渲染流程分析"></a>渲染流程分析</h1><h2 id="渲染流程图"><a href="#渲染流程图" class="headerlink" title="渲染流程图"></a>渲染流程图</h2><p><img src="https://raw.githubusercontent.com/why862555625/images/main/images/33f7e704-ec72-4782-b8ff-1e58df0bef2d.svg" alt="33f7e704-ec72-4782-b8ff-1e58df0bef2d"></p><h2 id="渲染流程"><a href="#渲染流程" class="headerlink" title="渲染流程"></a>渲染流程</h2><p><img src="https://raw.githubusercontent.com/why862555625/images/main/images/6e8b9b04-5afd-47aa-9263-d3a379c1ac5b.svg" alt="6e8b9b04-5afd-47aa-9263-d3a379c1ac5b"></p><h1 id="框架核心部分介绍"><a href="#框架核心部分介绍" class="headerlink" title="框架核心部分介绍"></a>框架核心部分介绍</h1><h2 id="核心类图"><a href="#核心类图" class="headerlink" title="核心类图"></a>核心类图</h2><p><img src="https://raw.githubusercontent.com/why862555625/images/main/images/a8dc8b49-a594-454c-9309-164e3269c5e9.svg" alt="a8dc8b49-a594-454c-9309-164e3269c5e9"></p><p>解释：</p><ol><li>Framework是内部使用的框架类表示，FrameworkExt从Framework继承并添加了对vela系统的消息集成，在vela中使用FrameworkExt表示唯一的框架实例</li><li>FrameworkExt中会维护多个app实例，框架支持多应用切换</li><li>每个app实例包含一个JS运行上下文环境和相关的libuv句柄，它们封装在RuntimeContxt中，作为Application的成员变量保存，即一个Application对象唯一对应一个js运行上下文。</li><li>一个Applicatoin对象可以拥有多个Page对象，一个Page对象表示一个可显示的页面，实际是一颗vdom树</li><li>Page对象的继承关系较为复杂，框架支持自定义组件，从逻辑上讲，一个Component包含一颗vdom子树，它可以被任意组合来形成最终的完整vdom树。Page是最顶层的Component组件，唯一。从继承关系上讲，DomDocument这一层应该去掉，在添加子组件支持后它的语义已被Component取代，这层抽象当前代码中没有意义但仍然存在。</li></ol>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> quickjs </tag>
            
            <tag> devtools </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
