<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>js面试手写</title>
      <link href="/posts/a09ef191.html"/>
      <url>/posts/a09ef191.html</url>
      
        <content type="html"><![CDATA[<p>js面试手写</p><span id="more"></span><h2 id="一、JavaScript-基础"><a href="#一、JavaScript-基础" class="headerlink" title="一、JavaScript 基础"></a>一、JavaScript 基础</h2><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230607140248211.png" alt="image-20230607140248211"></p><h3 id="1-手写-Object-create"><a href="#1-手写-Object-create" class="headerlink" title="1. 手写 Object.create"></a>1. 手写 Object.create</h3><p>思路：将传入的对象作为原型</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="keyword">function</span> <span class="title function_">create</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">F</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">  F.<span class="property"><span class="keyword">prototype</span></span> = obj</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">F</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-手写-instanceof-方法"><a href="#2-手写-instanceof-方法" class="headerlink" title="2. 手写 instanceof 方法"></a>2. 手写 instanceof 方法</h3><p>instanceof 运算符用于判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。</p><p>实现步骤：</p><ol><li>首先获取类型的原型</li><li>然后获得对象的原型</li><li>然后一直循环判断对象的原型是否等于类型的原型，直到对象原型为 <code>null</code>，因为原型链最终为 <code>null</code></li></ol><p>具体实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="keyword">function</span> <span class="title function_">myInstanceof</span>(<span class="params">left, right</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> proto = <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(left), <span class="comment">// 获取对象的原型</span></span><br><span class="line">      prototype = right.<span class="property"><span class="keyword">prototype</span></span>; <span class="comment">// 获取构造函数的 prototype 对象</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断构造函数的 prototype 对象是否在对象的原型链上</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!proto) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (proto === prototype) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    proto = <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(proto);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-手写-new-操作符"><a href="#3-手写-new-操作符" class="headerlink" title="3. 手写 new 操作符"></a>3. 手写 new 操作符</h3><p>在调用 <code>new</code> 的过程中会发生以上四件事情：</p><p>（1）首先创建了一个新的空对象</p><p>（2）设置原型，将对象的原型设置为函数的 prototype 对象。</p><p>（3）让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）</p><p>（4）判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="keyword">function</span> <span class="title function_">objectFactory</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> newObject = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> constructor = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">shift</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>);</span><br><span class="line">  <span class="keyword">let</span> result = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 判断参数是否是一个函数</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> constructor !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;type error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 新建一个空对象，对象的原型为构造函数的 prototype 对象</span></span><br><span class="line">  newObject = <span class="title class_">Object</span>.<span class="title function_">create</span>(constructor.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line">  <span class="comment">// 将 this 指向新建对象，并执行函数</span></span><br><span class="line">  result = constructor.<span class="title function_">apply</span>(newObject, <span class="variable language_">arguments</span>);</span><br><span class="line">  <span class="comment">// 判断返回对象</span></span><br><span class="line">  <span class="keyword">let</span> flag = result &amp;&amp; (<span class="keyword">typeof</span> result === <span class="string">&quot;object&quot;</span> || <span class="keyword">typeof</span> result === <span class="string">&quot;function&quot;</span>);</span><br><span class="line">  <span class="comment">// 判断返回结果</span></span><br><span class="line">  <span class="keyword">return</span> flag ? result : newObject;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用方法</span></span><br><span class="line"><span class="title function_">objectFactory</span>(构造函数, 初始化参数);</span><br></pre></td></tr></table></figure><h3 id="4-手写-Promise"><a href="#4-手写-Promise" class="headerlink" title="4. 手写 Promise"></a>4. 手写 Promise</h3><h4 id="常见-Promise-面试题"><a href="#常见-Promise-面试题" class="headerlink" title="常见 Promise 面试题"></a>常见 Promise 面试题</h4><p>首先，我们以常见的 Promise 面试题为切入点，我们看看面试官们都爱考什么：</p><ol><li>Promise 解决了什么问题？</li><li>Promise 的业界实现都有哪些？</li><li>Promise 常用的 API 有哪些？</li><li>能不能手写一个符合 Promise/A+ 规范的 Promise?</li><li>Promise 在事件循环中的执行过程是怎样的？</li><li>Promise 有什么缺陷，可以如何解决？</li></ol><p>这几个问题由浅入深，我们一个一个来看：</p><h4 id="Promise-出现的原因-amp-业界实现"><a href="#Promise-出现的原因-amp-业界实现" class="headerlink" title="Promise 出现的原因 &amp; 业界实现"></a>Promise 出现的原因 &amp; 业界实现</h4><p>在 Promise 出现以前，在我们处理多个异步请求嵌套时，代码往往是这样的。。。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"></span><br><span class="line">fs.<span class="title function_">readFile</span>(<span class="string">&#x27;./name.txt&#x27;</span>,<span class="string">&#x27;utf8&#x27;</span>,<span class="keyword">function</span>(<span class="params">err,data</span>)&#123;</span><br><span class="line">  fs.<span class="title function_">readFile</span>(data, <span class="string">&#x27;utf8&#x27;</span>,<span class="keyword">function</span>(<span class="params">err,data</span>)&#123;</span><br><span class="line">    fs.<span class="title function_">readFile</span>(data,<span class="string">&#x27;utf8&#x27;</span>,<span class="keyword">function</span>(<span class="params">err,data</span>)&#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>为了拿到回调的结果，我们必须一层一层的嵌套，可以说是相当恶心了。而且基本上我们还要对每次请求的结果进行一系列的处理，使得代码变的更加难以阅读和难以维护，这就是传说中臭名昭著的<strong>回调地狱</strong>～产生<strong>回调地狱</strong>的原因归结起来有两点：</p><p>1.<strong>嵌套调用</strong>，第一个函数的输出往往是第二个函数的输入；</p><p>2.<strong>处理多个异步请求并发</strong>，开发时往往需要同步请求最终的结果。</p><p>原因分析出来后，那么问题的解决思路就很清晰了：</p><p>1.<strong>消灭嵌套调用</strong>：通过 Promise 的链式调用可以解决；</p><p>2.<strong>合并多个任务的请求结果</strong>：使用 Promise.all 获取合并多个任务的错误处理。</p><p>Promise 正是用一种更加友好的代码组织方式，解决了异步嵌套的问题。</p><p>我们来看看上面的例子用 Promise 实现是什么样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">read</span>(<span class="params">filename</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    fs.<span class="title function_">readFile</span>(filename, <span class="string">&#x27;utf8&#x27;</span>, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) <span class="title function_">reject</span>(err);</span><br><span class="line">      <span class="title function_">resolve</span>(data);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">read</span>(<span class="string">&#x27;./name.txt&#x27;</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">read</span>(data) </span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">read</span>(data)  </span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">&#125;,<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>臃肿的嵌套变得线性多了有木有？没错，他就是我们的异步神器 Promise！</p><p>让我们再次回归刚才的问题，<strong>Promise 为我们解决了什么问题？</strong>在传统的异步编程中，如果异步之间存在依赖关系，就需要通过层层嵌套回调的方式满足这种依赖，如果嵌套层数过多，可读性和可以维护性都会变得很差，产生所谓的“回调地狱”，而 Promise 将嵌套调用改为链式调用，增加了可阅读性和可维护性。也就是说，Promise 解决的是异步编码风格的问题。<strong>那 Promise 的业界实现都有哪些呢？</strong>业界比较著名的实现 Promise 的类库有 bluebird、Q、ES6-Promise。</p><h4 id="从零开始，手写-Promise"><a href="#从零开始，手写-Promise" class="headerlink" title="从零开始，手写 Promise"></a>从零开始，手写 Promise</h4><h5 id="Promise-A"><a href="#Promise-A" class="headerlink" title="Promise/A+"></a>Promise/A+</h5><p>我们想要手写一个 Promise，就要遵循 <a href="https://link.zhihu.com/?target=https://promisesaplus.com/">Promise/A+</a> 规范，业界所有 Promise 的类库都遵循这个规范。</p><p>其实 Promise/A+ 规范对如何实现一个符合标准的 Promise 类库已经阐述的很详细了。每一行代码在 Promise/A+ 规范中都有迹可循，所以在下面的实现的过程中，我会尽可能的将代码和 Promise/A+ 规范一一对应起来。</p><p>下面开始步入正题啦～</p><h4 id="基础版-Promise"><a href="#基础版-Promise" class="headerlink" title="基础版 Promise"></a>基础版 Promise</h4><p>我们先来回顾下最简单的 Promise 使用方式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;create a promise&#x27;</span>);</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&#x27;成功了&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;after new promise&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = p1.<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data)</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;失败了&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p3 = p2.<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;success&#x27;</span>, data)</span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;faild&#x27;</span>, err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>控制台输出：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;create a promise&quot;</span></span><br><span class="line"><span class="string">&quot;after new promise&quot;</span></span><br><span class="line"><span class="string">&quot;成功了&quot;</span></span><br><span class="line"><span class="string">&quot;faild Error: 失败了&quot;</span></span><br></pre></td></tr></table></figure><ul><li>首先我们在调用 Promise 时，会返回一个 Promise 对象。</li><li>构建 Promise 对象时，需要传入一个 <strong>executor 函数</strong>，Promise 的主要业务流程都在 executor 函数中执行。</li><li>如果运行在 excutor 函数中的业务执行成功了，会调用 resolve 函数；如果执行失败了，则调用 reject 函数。</li><li>Promise 的状态不可逆，同时调用 resolve 函数和 reject 函数，默认会采取第一次调用的结果。</li></ul><p>以上简单介绍了 Promise 的一些主要的使用方法，结合 <a href="https://link.zhihu.com/?target=https://promisesaplus.com/">Promise/A+</a> 规范，我们可以分析出 Promise 的基本特征：</p><ol><li>promise 有三个状态：<code>pending</code>，<code>fulfilled</code>，or <code>rejected</code>；「规范 Promise/A+ 2.1」</li><li><code>new promise</code>时， 需要传递一个<code>executor()</code>执行器，执行器立即执行；</li><li><code>executor</code>接受两个参数，分别是<code>resolve</code>和<code>reject</code>；</li><li>promise 的默认状态是 <code>pending</code>；</li><li>promise 有一个<code>value</code>保存成功状态的值，可以是<code>undefined/thenable/promise</code>；「规范 Promise/A+ 1.3」</li><li>promise 有一个<code>reason</code>保存失败状态的值；「规范 Promise/A+ 1.5」</li><li>promise 只能从<code>pending</code>到<code>rejected</code>, 或者从<code>pending</code>到<code>fulfilled</code>，状态一旦确认，就不会再改变；</li><li>promise 必须有一个<code>then</code>方法，then 接收两个参数，分别是 promise 成功的回调 onFulfilled, 和 promise 失败的回调 onRejected；「规范 Promise/A+ 2.2」</li><li>如果调用 then 时，promise 已经成功，则执行<code>onFulfilled</code>，参数是<code>promise</code>的<code>value</code>；</li><li>如果调用 then 时，promise 已经失败，那么执行<code>onRejected</code>, 参数是<code>promise</code>的<code>reason</code>；</li><li>如果 then 中抛出了异常，那么就会把这个异常作为参数，传递给下一个 then 的失败的回调<code>onRejected</code>；</li></ol><p>按照上面的特征，我们试着勾勒下 Promise 的形状：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 三个状态：PENDING、FULFILLED、REJECTED</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">PENDING</span> = <span class="string">&#x27;PENDING&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">FULFILLED</span> = <span class="string">&#x27;FULFILLED&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">REJECTED</span> = <span class="string">&#x27;REJECTED&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Promise</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">executor</span>) &#123;</span><br><span class="line">    <span class="comment">// 默认状态为 PENDING</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">status</span> = <span class="variable constant_">PENDING</span>;</span><br><span class="line">    <span class="comment">// 存放成功状态的值，默认为 undefined</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = <span class="literal">undefined</span>;</span><br><span class="line">    <span class="comment">// 存放失败状态的值，默认为 undefined</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">reason</span> = <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用此方法就是成功</span></span><br><span class="line">    <span class="keyword">let</span> <span class="title function_">resolve</span> = (<span class="params">value</span>) =&gt; &#123;</span><br><span class="line">      <span class="comment">// 状态为 PENDING 时才可以更新状态，防止 executor 中调用了两次 resovle/reject 方法</span></span><br><span class="line">      <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">status</span> ===  <span class="variable constant_">PENDING</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">status</span> = <span class="variable constant_">FULFILLED</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">value</span> = value;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用此方法就是失败</span></span><br><span class="line">    <span class="keyword">let</span> <span class="title function_">reject</span> = (<span class="params">reason</span>) =&gt; &#123;</span><br><span class="line">      <span class="comment">// 状态为 PENDING 时才可以更新状态，防止 executor 中调用了两次 resovle/reject 方法</span></span><br><span class="line">      <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">status</span> ===  <span class="variable constant_">PENDING</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">status</span> = <span class="variable constant_">REJECTED</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">reason</span> = reason;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 立即执行，将 resolve 和 reject 函数传给使用者  </span></span><br><span class="line">      <span class="title function_">executor</span>(resolve,reject)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      <span class="comment">// 发生异常时执行失败逻辑</span></span><br><span class="line">      <span class="title function_">reject</span>(error)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 包含一个 then 方法，并接收两个参数 onFulfilled、onRejected</span></span><br><span class="line">  <span class="title function_">then</span>(<span class="params">onFulfilled, onRejected</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">FULFILLED</span>) &#123;</span><br><span class="line">      <span class="title function_">onFulfilled</span>(<span class="variable language_">this</span>.<span class="property">value</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">REJECTED</span>) &#123;</span><br><span class="line">      <span class="title function_">onRejected</span>(<span class="variable language_">this</span>.<span class="property">reason</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写完代码我们可以测试一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&#x27;成功&#x27;</span>);</span><br><span class="line">&#125;).<span class="title function_">then</span>(</span><br><span class="line">  <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;success&#x27;</span>, data)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;faild&#x27;</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>控制台输出：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;success 成功&quot;</span></span><br></pre></td></tr></table></figure><p>现在我们已经实现了一个基础版的 Promise，但是还不要高兴的太早噢，这里我们只处理了同步操作的 promise。如果在 <code>executor()</code>中传入一个异步操作的话呢，我们试一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 传入一个异步操作</span></span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&#x27;成功&#x27;</span>);</span><br><span class="line">  &#125;,<span class="number">1000</span>);</span><br><span class="line">&#125;).<span class="title function_">then</span>(</span><br><span class="line">  <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;success&#x27;</span>, data)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;faild&#x27;</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>执行测试脚本后发现，promise 没有任何返回。</p><p>因为 promise 调用 then 方法时，当前的 promise 并没有成功，一直处于 pending 状态。所以如果当调用 then 方法时，当前状态是 pending，我们需要先将成功和失败的回调分别存放起来，在<code>executor()</code>的异步任务被执行时，触发 resolve 或 reject，依次调用成功或失败的回调。</p><p>结合这个思路，我们优化一下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">PENDING</span> = <span class="string">&#x27;PENDING&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">FULFILLED</span> = <span class="string">&#x27;FULFILLED&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">REJECTED</span> = <span class="string">&#x27;REJECTED&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Promise</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">executor</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">status</span> = <span class="variable constant_">PENDING</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = <span class="literal">undefined</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">reason</span> = <span class="literal">undefined</span>;</span><br><span class="line">    <span class="comment">// 存放成功的回调</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">onResolvedCallbacks</span> = [];</span><br><span class="line">    <span class="comment">// 存放失败的回调</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">onRejectedCallbacks</span>= [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="title function_">resolve</span> = (<span class="params">value</span>) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">status</span> ===  <span class="variable constant_">PENDING</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">status</span> = <span class="variable constant_">FULFILLED</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">value</span> = value;</span><br><span class="line">        <span class="comment">// 依次将对应的函数执行</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">onResolvedCallbacks</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">fn</span>=&gt;</span><span class="title function_">fn</span>());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="title function_">reject</span> = (<span class="params">reason</span>) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">status</span> ===  <span class="variable constant_">PENDING</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">status</span> = <span class="variable constant_">REJECTED</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">reason</span> = reason;</span><br><span class="line">        <span class="comment">// 依次将对应的函数执行</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">onRejectedCallbacks</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">fn</span>=&gt;</span><span class="title function_">fn</span>());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="title function_">executor</span>(resolve,reject)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      <span class="title function_">reject</span>(error)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">then</span>(<span class="params">onFulfilled, onRejected</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">FULFILLED</span>) &#123;</span><br><span class="line">      <span class="title function_">onFulfilled</span>(<span class="variable language_">this</span>.<span class="property">value</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">REJECTED</span>) &#123;</span><br><span class="line">      <span class="title function_">onRejected</span>(<span class="variable language_">this</span>.<span class="property">reason</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">PENDING</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果promise的状态是 pending，需要将 onFulfilled 和 onRejected 函数存放起来，等待状态确定后，再依次将对应的函数执行</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">onResolvedCallbacks</span>.<span class="title function_">push</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">onFulfilled</span>(<span class="variable language_">this</span>.<span class="property">value</span>)</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果promise的状态是 pending，需要将 onFulfilled 和 onRejected 函数存放起来，等待状态确定后，再依次将对应的函数执行</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">onRejectedCallbacks</span>.<span class="title function_">push</span>(<span class="function">()=&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">onRejected</span>(<span class="variable language_">this</span>.<span class="property">reason</span>);</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&#x27;成功&#x27;</span>);</span><br><span class="line">  &#125;,<span class="number">1000</span>);</span><br><span class="line">&#125;).<span class="title function_">then</span>(</span><br><span class="line">  <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;success&#x27;</span>, data)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;faild&#x27;</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>控制台等待 <code>1s</code> 后输出：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;success 成功&quot;</span></span><br></pre></td></tr></table></figure><p>ok！大功告成，异步问题已经解决了！</p><p>熟悉设计模式的同学，应该意识到了这其实是一个<strong>发布订阅模式</strong>，这种<code>收集依赖 -&gt; 触发通知 -&gt; 取出依赖执行</code>的方式，被广泛运用于发布订阅模式的实现。</p><h4 id="then-的链式调用-amp-值穿透特性"><a href="#then-的链式调用-amp-值穿透特性" class="headerlink" title="then 的链式调用&amp;值穿透特性"></a>then 的链式调用&amp;值穿透特性</h4><p>我们都知道，promise 的优势在于可以链式调用。在我们使用 Promise 的时候，当 then 函数中 return 了一个值，不管是什么值，我们都能在下一个 then 中获取到，这就是所谓的<strong>then 的链式调用</strong>。而且，当我们不在 then 中放入参数，例：<code>promise.then().then()</code>，那么其后面的 then 依旧可以得到之前 then 返回的值，这就是所谓的<strong>值的穿透</strong>。那具体如何实现呢？简单思考一下，如果每次调用 then 的时候，我们都重新创建一个 promise 对象，并把上一个 then 的返回结果传给这个新的 promise 的 then 方法，不就可以一直 then 下去了么？那我们来试着实现一下。这也是手写 Promise 源码的重中之重，所以，打起精神来，重头戏来咯！</p><p>有了上面的想法，我们再结合 <a href="https://link.zhihu.com/?target=https://promisesaplus.com/">Promise/A+</a> 规范梳理一下思路：</p><ol><li>then 的参数 <code>onFulfilled</code> 和 <code>onRejected</code> 可以缺省，如果 <code>onFulfilled</code> 或者 <code>onRejected</code>不是函数，将其忽略，且依旧可以在下面的 then 中获取到之前返回的值；「规范 Promise/A+ 2.2.1、2.2.1.1、2.2.1.2」</li><li>promise 可以 then 多次，每次执行完 promise.then 方法后返回的都是一个“新的promise”；「规范 Promise/A+ 2.2.7」</li><li>如果 then 的返回值 x 是一个普通值，那么就会把这个结果作为参数，传递给下一个 then 的成功的回调中；</li><li>如果 then 中抛出了异常，那么就会把这个异常作为参数，传递给下一个 then 的失败的回调中；「规范 Promise/A+ 2.2.7.2」</li><li>如果 then 的返回值 x 是一个 promise，那么会等这个 promise 执行完，promise 如果成功，就走下一个 then 的成功；如果失败，就走下一个 then 的失败；如果抛出异常，就走下一个 then 的失败；「规范 Promise/A+ 2.2.7.3、2.2.7.4」</li><li>如果 then 的返回值 x 和 promise 是同一个引用对象，造成循环引用，则抛出异常，把异常传递给下一个 then 的失败的回调中；「规范 Promise/A+ 2.3.1」</li><li>如果 then 的返回值 x 是一个 promise，且 x 同时调用 resolve 函数和 reject 函数，则第一次调用优先，其他所有调用被忽略；「规范 Promise/A+ 2.3.3.3.3」</li></ol><p>我们将代码补充完整：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">PENDING</span> = <span class="string">&#x27;PENDING&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">FULFILLED</span> = <span class="string">&#x27;FULFILLED&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">REJECTED</span> = <span class="string">&#x27;REJECTED&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">resolvePromise</span> = (<span class="params">promise2, x, resolve, reject</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 自己等待自己完成是错误的实现，用一个类型错误，结束掉 promise  Promise/A+ 2.3.1</span></span><br><span class="line">  <span class="keyword">if</span> (promise2 === x) &#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;Chaining cycle detected for promise #&lt;Promise&gt;&#x27;</span>))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Promise/A+ 2.3.3.3.3 只能调用一次</span></span><br><span class="line">  <span class="keyword">let</span> called;</span><br><span class="line">  <span class="comment">// 后续的条件要严格判断 保证代码能和别的库一起使用</span></span><br><span class="line">  <span class="keyword">if</span> ((<span class="keyword">typeof</span> x === <span class="string">&#x27;object&#x27;</span> &amp;&amp; x != <span class="literal">null</span>) || <span class="keyword">typeof</span> x === <span class="string">&#x27;function&#x27;</span>) &#123; </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 为了判断 resolve 过的就不用再 reject 了（比如 reject 和 resolve 同时调用的时候）  Promise/A+ 2.3.3.1</span></span><br><span class="line">      <span class="keyword">let</span> then = x.<span class="property">then</span>;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">&#x27;function&#x27;</span>) &#123; </span><br><span class="line">        <span class="comment">// 不要写成 x.then，直接 then.call 就可以了 因为 x.then 会再次取值，Object.defineProperty  Promise/A+ 2.3.3.3</span></span><br><span class="line">        then.<span class="title function_">call</span>(x, <span class="function"><span class="params">y</span> =&gt;</span> &#123; <span class="comment">// 根据 promise 的状态决定是成功还是失败</span></span><br><span class="line">          <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">          called = <span class="literal">true</span>;</span><br><span class="line">          <span class="comment">// 递归解析的过程（因为可能 promise 中还有 promise） Promise/A+ 2.3.3.3.1</span></span><br><span class="line">          <span class="title function_">resolvePromise</span>(promise2, y, resolve, reject); </span><br><span class="line">        &#125;, <span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// 只要失败就失败 Promise/A+ 2.3.3.3.2</span></span><br><span class="line">          <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">          called = <span class="literal">true</span>;</span><br><span class="line">          <span class="title function_">reject</span>(r);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果 x.then 是个普通值就直接返回 resolve 作为结果  Promise/A+ 2.3.3.4</span></span><br><span class="line">        <span class="title function_">resolve</span>(x);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="comment">// Promise/A+ 2.3.3.2</span></span><br><span class="line">      <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">      called = <span class="literal">true</span>;</span><br><span class="line">      <span class="title function_">reject</span>(e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果 x 是个普通值就直接返回 resolve 作为结果  Promise/A+ 2.3.4  </span></span><br><span class="line">    <span class="title function_">resolve</span>(x)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Promise</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">executor</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">status</span> = <span class="variable constant_">PENDING</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = <span class="literal">undefined</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">reason</span> = <span class="literal">undefined</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">onResolvedCallbacks</span> = [];</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">onRejectedCallbacks</span>= [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="title function_">resolve</span> = (<span class="params">value</span>) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">status</span> ===  <span class="variable constant_">PENDING</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">status</span> = <span class="variable constant_">FULFILLED</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">value</span> = value;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">onResolvedCallbacks</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">fn</span>=&gt;</span><span class="title function_">fn</span>());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="title function_">reject</span> = (<span class="params">reason</span>) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">status</span> ===  <span class="variable constant_">PENDING</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">status</span> = <span class="variable constant_">REJECTED</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">reason</span> = reason;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">onRejectedCallbacks</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">fn</span>=&gt;</span><span class="title function_">fn</span>());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="title function_">executor</span>(resolve,reject)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      <span class="title function_">reject</span>(error)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">then</span>(<span class="params">onFulfilled, onRejected</span>) &#123;</span><br><span class="line">    <span class="comment">//解决 onFufilled，onRejected 没有传值的问题</span></span><br><span class="line">    <span class="comment">//Promise/A+ 2.2.1 / Promise/A+ 2.2.5 / Promise/A+ 2.2.7.3 / Promise/A+ 2.2.7.4</span></span><br><span class="line">    onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">&#x27;function&#x27;</span> ? onFulfilled : <span class="function"><span class="params">v</span> =&gt;</span> v;</span><br><span class="line">    <span class="comment">//因为错误的值要让后面访问到，所以这里也要跑出个错误，不然会在之后 then 的 resolve 中捕获</span></span><br><span class="line">    onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">&#x27;function&#x27;</span> ? onRejected : <span class="function"><span class="params">err</span> =&gt;</span> &#123; <span class="keyword">throw</span> err &#125;;</span><br><span class="line">    <span class="comment">// 每次调用 then 都返回一个新的 promise  Promise/A+ 2.2.7</span></span><br><span class="line">    <span class="keyword">let</span> promise2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">FULFILLED</span>) &#123;</span><br><span class="line">        <span class="comment">//Promise/A+ 2.2.2</span></span><br><span class="line">        <span class="comment">//Promise/A+ 2.2.4 --- setTimeout</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//Promise/A+ 2.2.7.1</span></span><br><span class="line">            <span class="keyword">let</span> x = <span class="title function_">onFulfilled</span>(<span class="variable language_">this</span>.<span class="property">value</span>);</span><br><span class="line">            <span class="comment">// x可能是一个proimise</span></span><br><span class="line">            <span class="title function_">resolvePromise</span>(promise2, x, resolve, reject);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            <span class="comment">//Promise/A+ 2.2.7.2</span></span><br><span class="line">            <span class="title function_">reject</span>(e)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, <span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">REJECTED</span>) &#123;</span><br><span class="line">        <span class="comment">//Promise/A+ 2.2.3</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> x = <span class="title function_">onRejected</span>(<span class="variable language_">this</span>.<span class="property">reason</span>);</span><br><span class="line">            <span class="title function_">resolvePromise</span>(promise2, x, resolve, reject);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            <span class="title function_">reject</span>(e)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, <span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">PENDING</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">onResolvedCallbacks</span>.<span class="title function_">push</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">let</span> x = <span class="title function_">onFulfilled</span>(<span class="variable language_">this</span>.<span class="property">value</span>);</span><br><span class="line">              <span class="title function_">resolvePromise</span>(promise2, x, resolve, reject);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">              <span class="title function_">reject</span>(e)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;, <span class="number">0</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">onRejectedCallbacks</span>.<span class="title function_">push</span>(<span class="function">()=&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">let</span> x = <span class="title function_">onRejected</span>(<span class="variable language_">this</span>.<span class="property">reason</span>);</span><br><span class="line">              <span class="title function_">resolvePromise</span>(promise2, x, resolve, reject)</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">              <span class="title function_">reject</span>(e)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;, <span class="number">0</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> promise2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">reject</span>(<span class="string">&#x27;失败&#x27;</span>);</span><br><span class="line">&#125;).<span class="title function_">then</span>().<span class="title function_">then</span>().<span class="title function_">then</span>(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">&#125;,<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;err&#x27;</span>,err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>控制台输出：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;失败 err&quot;</span></span><br></pre></td></tr></table></figure><p>至此，我们已经完成了 promise 最关键的部分：then 的链式调用和值的穿透。搞清楚了 then 的链式调用和值的穿透，你也就搞清楚了 Promise。</p><h4 id="测试-Promise-是否符合规范"><a href="#测试-Promise-是否符合规范" class="headerlink" title="测试 Promise 是否符合规范"></a>测试 Promise 是否符合规范</h4><p>Promise/A+规范提供了一个专门的测试脚本，可以测试所编写的代码是否符合Promise/A+的规范。</p><p>首先，在 promise 实现的代码中，增加以下代码:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="property">defer</span> = <span class="title class_">Promise</span>.<span class="property">deferred</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> dfd = &#123;&#125;;</span><br><span class="line">  dfd.<span class="property">promise</span> = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">      dfd.<span class="property">resolve</span> = resolve;</span><br><span class="line">      dfd.<span class="property">reject</span> = reject;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> dfd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>安装测试脚本:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g promises-aplus-tests</span><br></pre></td></tr></table></figure><p>如果当前的 promise 源码的文件名为 promise.js</p><p>那么在对应的目录执行以下命令:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">promises-aplus-tests promise.<span class="property">js</span></span><br></pre></td></tr></table></figure><p>promises-aplus-tests 中共有 872 条测试用例。以上代码，可以完美通过所有用例。</p><p><strong>感谢小伙伴的提醒，由于文章中使用 setTimeout 实现 promise 的异步，会对大家造成误解。所以这里添加一些标注:</strong></p><p>由于原生的 Promise 是V8引擎提供的微任务，我们无法还原V8引擎的实现，所以这里使用 setTimeout 模拟异步，所以原生的是微任务，这里是宏任务。</p><p>Promise A+ 规范3.1 中也提到了：这可以通过“宏任务”机制（例如setTimeout或setImmediate）或“微任务”机制（例如MutatonObserver或）来实现process.nextTick。</p><p>如果你想实现 promise 的微任务，可以 mutationObserver 替代 seiTimeout 来实现微任务。</p><p>有小伙伴说可以使用 queueMicrotask 实现微任务，我也查阅了一些资料，是可以的。不过 queueMicrotask 兼容性不是很好，IE 下完全不支持。据我所知 queueMicrotask 的 polyfill 是基于 promise 实现的，如果不支持 promise 会转成 setTimeout。</p><p>总的来说，queueMicrotask 和 mutationObserver 都可以实现微任务机制，不过更建议有执念的小伙伴用 mutationObserver 实现一下，没有执念的小伙伴了解 promise 的微任务机制就好了～</p><h3 id="Promise-的-API"><a href="#Promise-的-API" class="headerlink" title="Promise 的 API"></a>Promise 的 API</h3><p>虽然上述的 promise 源码已经符合 Promise/A+ 的规范，但是原生的 Promise 还提供了一些其他方法，如:</p><ul><li>Promise.resolve()</li><li>Promise.reject()</li><li>Promise.prototype.catch()</li><li>Promise.prototype.finally()</li><li>Promise.all()</li><li>Promise.race(）</li></ul><p>下面具体说一下每个方法的实现:</p><h4 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve"></a>Promise.resolve</h4><p>默认产生一个成功的 promise。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="title function_">resolve</span>(<span class="params">data</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="title function_">resolve</span>(data);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要注意的是，<strong>promise.resolve 是具备等待功能的</strong>。如果参数是 promise 会等待这个 promise 解析完毕，在向下执行，所以这里需要在 resolve 方法中做一个小小的处理：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">resolve</span> = (<span class="params">value</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// ======新增逻辑======</span></span><br><span class="line">  <span class="comment">// 如果 value 是一个promise，那我们的库中应该也要实现一个递归解析</span></span><br><span class="line">  <span class="keyword">if</span>(value <span class="keyword">instanceof</span> <span class="title class_">Promise</span>)&#123;</span><br><span class="line">      <span class="comment">// 递归解析 </span></span><br><span class="line">      <span class="keyword">return</span> value.<span class="title function_">then</span>(resolve,reject)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ===================</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">status</span> ===  <span class="variable constant_">PENDING</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">status</span> = <span class="variable constant_">FULFILLED</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = value;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">onResolvedCallbacks</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">fn</span>=&gt;</span><span class="title function_">fn</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&#x27;ok&#x27;</span>);</span><br><span class="line">  &#125;, <span class="number">3000</span>);</span><br><span class="line">&#125;)).<span class="title function_">then</span>(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data,<span class="string">&#x27;success&#x27;</span>)</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(err,<span class="string">&#x27;error&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>控制台等待 <code>3s</code> 后输出：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;ok success&quot;</span></span><br></pre></td></tr></table></figure><h4 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject"></a>Promise.reject</h4><p>默认产生一个失败的 promise，Promise.reject 是直接将值变成错误结果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="title function_">reject</span>(<span class="params">reason</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="title function_">reject</span>(reason);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Promise-prototype-catch"><a href="#Promise-prototype-catch" class="headerlink" title="Promise.prototype.catch"></a>Promise.prototype.catch</h4><p>Promise.prototype.catch 用来捕获 promise 的异常，<strong>就相当于一个没有成功的 then</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">catch</span> = <span class="keyword">function</span>(<span class="params">errCallback</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">then</span>(<span class="literal">null</span>,errCallback)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Promise-prototype-finally"><a href="#Promise-prototype-finally" class="headerlink" title="Promise.prototype.finally"></a>Promise.prototype.finally</h4><p>finally 表示不是最终的意思，而是无论如何都会执行的意思。 如果返回一个 promise 会等待这个 promise 也执行完毕。如果返回的是成功的 promise，会采用上一次的结果；如果返回的是失败的 promise，会用这个失败的结果，传到 catch 中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">finally</span> = <span class="keyword">function</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="title function_">callback</span>()).<span class="title function_">then</span>(<span class="function">()=&gt;</span>value)</span><br><span class="line">  &#125;,<span class="function">(<span class="params">reason</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="title function_">callback</span>()).<span class="title function_">then</span>(<span class="function">()=&gt;</span>&#123;<span class="keyword">throw</span> reason&#125;)</span><br><span class="line">  &#125;)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">456</span>).<span class="title function_">finally</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="number">123</span>)</span><br><span class="line">    &#125;, <span class="number">3000</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data,<span class="string">&#x27;success&#x27;</span>)</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(err,<span class="string">&#x27;error&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>控制台等待 <code>3s</code> 后输出：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;456 success&quot;</span></span><br></pre></td></tr></table></figure><h4 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h4><p>promise.all 是解决并发问题的，多个异步并发获取最终的结果（如果有一个失败则失败）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="property">all</span> = <span class="keyword">function</span>(<span class="params">values</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="title class_">Array</span>.<span class="title function_">isArray</span>(values)) &#123;</span><br><span class="line">    <span class="keyword">const</span> type = <span class="keyword">typeof</span> values;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">`TypeError: <span class="subst">$&#123;type&#125;</span> <span class="subst">$&#123;values&#125;</span> is not iterable`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> resultArr = [];</span><br><span class="line">    <span class="keyword">let</span> orderIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">processResultByKey</span> = (<span class="params">value, index</span>) =&gt; &#123;</span><br><span class="line">      resultArr[index] = value;</span><br><span class="line">      <span class="keyword">if</span> (++orderIndex === values.<span class="property">length</span>) &#123;</span><br><span class="line">          <span class="title function_">resolve</span>(resultArr)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; values.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> value = values[i];</span><br><span class="line">      <span class="keyword">if</span> (value &amp;&amp; <span class="keyword">typeof</span> value.<span class="property">then</span> === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        value.<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="title function_">processResultByKey</span>(value, i);</span><br><span class="line">        &#125;, reject);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">processResultByKey</span>(value, i);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&#x27;ok1&#x27;</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">reject</span>(<span class="string">&#x27;ok2&#x27;</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,p1,p2]).<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;resolve&#x27;</span>, data);</span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;reject&#x27;</span>, err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>控制台等待 <code>1s</code> 后输出：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;resolve [ 1, 2, 3, &#x27;ok1&#x27;, &#x27;ok2&#x27; ]&quot;</span></span><br></pre></td></tr></table></figure><h4 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a>Promise.race</h4><p>Promise.race 用来处理多个请求，采用最快的（谁先完成用谁的）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="property">race</span> = <span class="keyword">function</span>(<span class="params">promises</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 一起执行就是for循环</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promises.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> val = promises[i];</span><br><span class="line">      <span class="keyword">if</span> (val &amp;&amp; <span class="keyword">typeof</span> val.<span class="property">then</span> === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        val.<span class="title function_">then</span>(resolve, reject);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">// 普通值</span></span><br><span class="line">        <span class="title function_">resolve</span>(val)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特别需要注意的是：因为<strong>Promise 是没有中断方法的</strong>，xhr.abort()、ajax 有自己的中断方法，axios 是基于 ajax 实现的；fetch 基于 promise，所以他的请求是无法中断的。</p><p>这也是 promise 存在的缺陷，我们可以使用 race 来自己封装中断方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">wrap</span>(<span class="params">promise</span>) &#123;</span><br><span class="line">  <span class="comment">// 在这里包装一个 promise，可以控制原来的promise是成功还是失败</span></span><br><span class="line">  <span class="keyword">let</span> abort;</span><br><span class="line">  <span class="keyword">let</span> newPromise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123; <span class="comment">// defer 方法</span></span><br><span class="line">      abort = reject;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">let</span> p = <span class="title class_">Promise</span>.<span class="title function_">race</span>([promise, newPromise]); <span class="comment">// 任何一个先成功或者失败 就可以获取到结果</span></span><br><span class="line">  p.<span class="property">abort</span> = abort;</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; <span class="comment">// 模拟的接口调用 ajax 肯定有超时设置</span></span><br><span class="line">      <span class="title function_">resolve</span>(<span class="string">&#x27;成功&#x27;</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> newPromise = <span class="title function_">wrap</span>(promise);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 超过3秒 就算超时 应该让 proimise 走到失败态</span></span><br><span class="line">  newPromise.<span class="title function_">abort</span>(<span class="string">&#x27;超时了&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line">newPromise.<span class="title function_">then</span>((<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;成功的结果&#x27;</span> + data)</span><br><span class="line">&#125;)).<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;失败的结果&#x27;</span> + e)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>控制台等待 <code>1s</code> 后输出：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;成功的结果成功&quot;</span></span><br></pre></td></tr></table></figure><h4 id="promisify"><a href="#promisify" class="headerlink" title="promisify"></a>promisify</h4><p>promisify 是把一个 node 中的 api 转换成 promise 的写法。 在 node 版本 12.18 以上，已经支持了原生的 promisify 方法：<code>const fs = require(&#39;fs&#39;).promises</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">promisify</span> = (<span class="params">fn</span>) =&gt; &#123; <span class="comment">// 典型的高阶函数 参数是函数 返回值是函数 </span></span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="title function_">fn</span>(...args,<span class="keyword">function</span> (<span class="params">err,data</span>) &#123; <span class="comment">// node中的回调函数的参数 第一个永远是error</span></span><br><span class="line">        <span class="keyword">if</span>(err) <span class="keyword">return</span> <span class="title function_">reject</span>(err);</span><br><span class="line">        <span class="title function_">resolve</span>(data);</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想要把 node 中所有的 api 都转换成 promise 的写法呢：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">promisifyAll</span> = (<span class="params">target</span>) =&gt;&#123;</span><br><span class="line">  <span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(target).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> target[key] === <span class="string">&#x27;function&#x27;</span>)&#123;</span><br><span class="line">      <span class="comment">// 默认会将原有的方法 全部增加一个 Async 后缀 变成 promise 写法</span></span><br><span class="line">      target[key+<span class="string">&#x27;Async&#x27;</span>] = <span class="title function_">promisify</span>(target[key]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-手写防抖函数"><a href="#5-手写防抖函数" class="headerlink" title="5. 手写防抖函数"></a>5. 手写防抖函数</h3><p>函数防抖是指在事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。这可以使用在一些点击请求的事件上，避免因为用户的多次点击向后端发送多次请求。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="comment">// 函数防抖的实现</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">fn, wait</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> context = <span class="variable language_">this</span>,</span><br><span class="line">        args = <span class="variable language_">arguments</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果此时存在定时器的话，则取消之前的定时器重新记时</span></span><br><span class="line">    <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">      <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">      timer = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置定时器，使事件间隔指定事件后执行</span></span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      fn.<span class="title function_">apply</span>(context, args);</span><br><span class="line">    &#125;, wait);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-手写节流函数"><a href="#6-手写节流函数" class="headerlink" title="6. 手写节流函数"></a>6. 手写节流函数</h3><p>函数节流是指规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。节流可以使用在 scroll 函数的事件监听上，通过事件节流来降低事件调用的频率。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="comment">// 函数节流的实现;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">fn, delay</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> curTime = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> context = <span class="variable language_">this</span>,</span><br><span class="line">        args = <span class="variable language_">arguments</span>,</span><br><span class="line">        nowTime = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果两次时间间隔超过了指定时间，则执行函数。</span></span><br><span class="line">    <span class="keyword">if</span> (nowTime - curTime &gt;= delay) &#123;</span><br><span class="line">      curTime = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">      <span class="keyword">return</span> fn.<span class="title function_">apply</span>(context, args);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-手写类型判断函数"><a href="#7-手写类型判断函数" class="headerlink" title="7. 手写类型判断函数"></a>7. 手写类型判断函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="keyword">function</span> <span class="title function_">getType</span>(<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="comment">// 判断数据是 null 的情况</span></span><br><span class="line">  <span class="keyword">if</span> (value === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> value + <span class="string">&quot;&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 判断数据是引用类型的情况</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> value === <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> valueClass = <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(value),</span><br><span class="line">      type = valueClass.<span class="title function_">split</span>(<span class="string">&quot; &quot;</span>)[<span class="number">1</span>].<span class="title function_">split</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    type.<span class="title function_">pop</span>();</span><br><span class="line">    <span class="keyword">return</span> type.<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>).<span class="title function_">toLowerCase</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 判断数据是基本数据类型的情况和函数的情况</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-手写-call-函数"><a href="#8-手写-call-函数" class="headerlink" title="8. 手写 call 函数"></a>8. 手写 call 函数</h3><p>call 函数的实现步骤：</p><ol><li>判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li><li>判断传入上下文对象是否存在，如果不存在，则设置为 window 。</li><li>处理传入的参数，截取第一个参数后的所有参数。</li><li>将函数作为上下文对象的一个属性。</li><li>使用上下文对象来调用这个方法，并保存返回结果。</li><li>删除刚才新增的属性。</li><li>返回结果。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="comment">// call函数实现</span></span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myCall</span> = <span class="keyword">function</span>(<span class="params">context</span>) &#123;</span><br><span class="line">  <span class="comment">// 判断调用对象</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">this</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;type error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 获取参数</span></span><br><span class="line">  <span class="keyword">let</span> args = [...<span class="variable language_">arguments</span>].<span class="title function_">slice</span>(<span class="number">1</span>),</span><br><span class="line">      result = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 判断 context 是否传入，如果未传入则设置为 window</span></span><br><span class="line">  context = context || <span class="variable language_">window</span>;</span><br><span class="line">  <span class="comment">// 将调用函数设为对象的方法</span></span><br><span class="line">  context.<span class="property">fn</span> = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="comment">// 调用函数</span></span><br><span class="line">  result = context.<span class="title function_">fn</span>(...args);</span><br><span class="line">  <span class="comment">// 将属性删除</span></span><br><span class="line">  <span class="keyword">delete</span> context.<span class="property">fn</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="9-手写-apply-函数"><a href="#9-手写-apply-函数" class="headerlink" title="9. 手写 apply 函数"></a>9. 手写 apply 函数</h3><p>apply 函数的实现步骤：</p><ol><li>判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li><li>判断传入上下文对象是否存在，如果不存在，则设置为 window 。</li><li>将函数作为上下文对象的一个属性。</li><li>判断参数值是否传入</li><li>使用上下文对象来调用这个方法，并保存返回结果。</li><li>删除刚才新增的属性</li><li>返回结果</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="comment">// apply 函数实现</span></span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myApply</span> = <span class="keyword">function</span>(<span class="params">context</span>) &#123;</span><br><span class="line">  <span class="comment">// 判断调用对象是否为函数</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">this</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&quot;Error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 判断 context 是否存在，如果未传入则为 window</span></span><br><span class="line">  context = context || <span class="variable language_">window</span>;</span><br><span class="line">  <span class="comment">// 将函数设为对象的方法</span></span><br><span class="line">  context.<span class="property">fn</span> = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="comment">// 调用方法</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">arguments</span>[<span class="number">1</span>]) &#123;</span><br><span class="line">    result = context.<span class="title function_">fn</span>(...<span class="variable language_">arguments</span>[<span class="number">1</span>]);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    result = context.<span class="title function_">fn</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将属性删除</span></span><br><span class="line">  <span class="keyword">delete</span> context.<span class="property">fn</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="10-手写-bind-函数"><a href="#10-手写-bind-函数" class="headerlink" title="10. 手写 bind 函数"></a>10. 手写 bind 函数</h3><p>bind 函数的实现步骤：</p><ol><li>判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li><li>保存当前函数的引用，获取其余传入参数值。</li><li>创建一个函数返回</li><li>函数内部使用 apply 来绑定函数调用，需要判断函数作为构造函数的情况，这个时候需要传入当前函数的 this 给 apply 调用，其余情况都传入指定的上下文对象。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="comment">// bind 函数实现</span></span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myBind</span> = <span class="keyword">function</span>(<span class="params">context</span>) &#123;</span><br><span class="line">  <span class="comment">// 判断调用对象是否为函数</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">this</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&quot;Error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 获取参数</span></span><br><span class="line">  <span class="keyword">var</span> args = [...<span class="variable language_">arguments</span>].<span class="title function_">slice</span>(<span class="number">1</span>),</span><br><span class="line">      fn = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">Fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 根据调用方式，传入不同绑定值</span></span><br><span class="line">    <span class="keyword">return</span> fn.<span class="title function_">apply</span>(</span><br><span class="line">      <span class="variable language_">this</span> <span class="keyword">instanceof</span> <span class="title class_">Fn</span> ? <span class="variable language_">this</span> : context,</span><br><span class="line">      args.<span class="title function_">concat</span>(...<span class="variable language_">arguments</span>)</span><br><span class="line">    );</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="11-函数柯里化的实现"><a href="#11-函数柯里化的实现" class="headerlink" title="11. 函数柯里化的实现"></a>11. 函数柯里化的实现</h3><p>函数柯里化指的是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="keyword">function</span> <span class="title function_">curry</span>(<span class="params">fn, args</span>) &#123;</span><br><span class="line">  <span class="comment">// 获取函数需要的参数长度</span></span><br><span class="line">  <span class="keyword">let</span> length = fn.<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line">  args = args || [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> subArgs = args.<span class="title function_">slice</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拼接得到现有的所有参数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">arguments</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      subArgs.<span class="title function_">push</span>(<span class="variable language_">arguments</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断参数的长度是否已经满足函数所需参数的长度</span></span><br><span class="line">    <span class="keyword">if</span> (subArgs.<span class="property">length</span> &gt;= length) &#123;</span><br><span class="line">      <span class="comment">// 如果满足，执行函数</span></span><br><span class="line">      <span class="keyword">return</span> fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, subArgs);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果不满足，递归返回科里化的函数，等待参数的传入</span></span><br><span class="line">      <span class="keyword">return</span> curry.<span class="title function_">call</span>(<span class="variable language_">this</span>, fn, subArgs);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// es6 实现</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">curry</span>(<span class="params">fn, ...args</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> fn.<span class="property">length</span> &lt;= args.<span class="property">length</span> ? <span class="title function_">fn</span>(...args) : curry.<span class="title function_">bind</span>(<span class="literal">null</span>, fn, ...args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12-实现AJAX请求"><a href="#12-实现AJAX请求" class="headerlink" title="12. 实现AJAX请求"></a>12. 实现AJAX请求</h3><p>AJAX是 Asynchronous JavaScript and XML 的缩写，指的是通过 JavaScript 的 异步通信，从服务器获取 XML 文档从中提取数据，再更新当前网页的对应部分，而不用刷新整个网页。</p><p>创建AJAX请求的步骤：</p><ul><li><strong>创建一个 XMLHttpRequest 对象。</strong></li><li>在这个对象上<strong>使用 open 方法创建一个 HTTP 请求</strong>，open 方法所需要的参数是请求的方法、请求的地址、是否异步和用户的认证信息。</li><li>在发起请求前，可以为这个对象<strong>添加一些信息和监听函数</strong>。比如说可以通过 setRequestHeader 方法来为请求添加头信息。还可以为这个对象添加一个状态监听函数。一个 XMLHttpRequest 对象一共有 5 个状态，当它的状态变化时会触发onreadystatechange 事件，可以通过设置监听函数，来处理请求成功后的结果。当对象的 readyState 变为 4 的时候，代表服务器返回的数据接收完成，这个时候可以通过判断请求的状态，如果状态是 2xx 或者 304 的话则代表返回正常。这个时候就可以通过 response 中的数据来对页面进行更新了。</li><li>当对象的属性和监听函数设置完成后，最后调<strong>用 sent 方法来向服务器发起请求</strong>，可以传入参数作为发送的数据体。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="keyword">const</span> <span class="variable constant_">SERVER_URL</span> = <span class="string">&quot;/server&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line"><span class="comment">// 创建 Http 请求</span></span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&quot;GET&quot;</span>, <span class="variable constant_">SERVER_URL</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="comment">// 设置状态监听函数</span></span><br><span class="line">xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">readyState</span> !== <span class="number">4</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// 当请求成功时</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="title function_">handle</span>(<span class="variable language_">this</span>.<span class="property">response</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="variable language_">this</span>.<span class="property">statusText</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 设置请求失败时的监听函数</span></span><br><span class="line">xhr.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="variable language_">this</span>.<span class="property">statusText</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 设置请求头信息</span></span><br><span class="line">xhr.<span class="property">responseType</span> = <span class="string">&quot;json&quot;</span>;</span><br><span class="line">xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&quot;Accept&quot;</span>, <span class="string">&quot;application/json&quot;</span>);</span><br><span class="line"><span class="comment">// 发送 Http 请求</span></span><br><span class="line">xhr.<span class="title function_">send</span>(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure><h3 id="13-使用Promise封装AJAX请求"><a href="#13-使用Promise封装AJAX请求" class="headerlink" title="13. 使用Promise封装AJAX请求"></a>13. 使用Promise封装AJAX请求</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="comment">// promise 封装实现：</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getJSON</span>(<span class="params">url</span>) &#123;</span><br><span class="line">  <span class="comment">// 创建一个 promise 对象</span></span><br><span class="line">  <span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">    <span class="comment">// 新建一个 http 请求</span></span><br><span class="line">    xhr.<span class="title function_">open</span>(<span class="string">&quot;GET&quot;</span>, url, <span class="literal">true</span>);</span><br><span class="line">    <span class="comment">// 设置状态的监听函数</span></span><br><span class="line">    xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">readyState</span> !== <span class="number">4</span>) <span class="keyword">return</span>;</span><br><span class="line">      <span class="comment">// 当请求成功或失败时，改变 promise 的状态</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="variable language_">this</span>.<span class="property">response</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="variable language_">this</span>.<span class="property">statusText</span>));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 设置错误监听函数</span></span><br><span class="line">    xhr.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="variable language_">this</span>.<span class="property">statusText</span>));</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 设置响应的数据类型</span></span><br><span class="line">    xhr.<span class="property">responseType</span> = <span class="string">&quot;json&quot;</span>;</span><br><span class="line">    <span class="comment">// 设置请求头信息</span></span><br><span class="line">    xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&quot;Accept&quot;</span>, <span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">    <span class="comment">// 发送 http 请求</span></span><br><span class="line">    xhr.<span class="title function_">send</span>(<span class="literal">null</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="14-实现浅拷贝"><a href="#14-实现浅拷贝" class="headerlink" title="14. 实现浅拷贝"></a>14. 实现浅拷贝</h3><p>浅拷贝是指，一个新的对象对原始对象的属性值进行精确地拷贝，如果拷贝的是基本数据类型，拷贝的就是基本数据类型的值，如果是引用数据类型，拷贝的就是内存地址。如果其中一个对象的引用内存地址发生改变，另一个对象也会发生变化。</p><h4 id="（1）Object-assign"><a href="#（1）Object-assign" class="headerlink" title="（1）Object.assign()"></a>（1）Object.assign()</h4><p><code>Object.assign()</code>是ES6中对象的拷贝方法，接受的第一个参数是目标对象，其余参数是源对象，用法：<code>Object.assign(target, source_1, ···)</code>，该方法可以实现浅拷贝，也可以实现一维对象的深拷贝。</p><p><strong>注意：</strong></p><ul><li>如果目标对象和源对象有同名属性，或者多个源对象有同名属性，则后面的属性会覆盖前面的属性。</li><li>如果该函数只有一个参数，当参数为对象时，直接返回该对象；当参数不是对象时，会先将参数转为对象然后返回。</li><li>因为<code>null</code> 和 <code>undefined</code> 不能转化为对象，所以第一个参数不能为<code>null</code>或 <code>undefined</code>，会报错。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="keyword">let</span> target = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> object2 = &#123;<span class="attr">b</span>: <span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> object3 = &#123;<span class="attr">c</span>: <span class="number">3</span>&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(target,object2,object3);  </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target);  <span class="comment">// &#123;a: 1, b: 2, c: 3&#125;</span></span><br></pre></td></tr></table></figure><h4 id="（2）扩展运算符"><a href="#（2）扩展运算符" class="headerlink" title="（2）扩展运算符"></a>（2）扩展运算符</h4><p>使用扩展运算符可以在构造字面量对象的时候，进行属性的拷贝。语法：<code>let cloneObj = &#123; ...obj &#125;;</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="keyword">let</span> obj1 = &#123;<span class="attr">a</span>:<span class="number">1</span>,<span class="attr">b</span>:&#123;<span class="attr">c</span>:<span class="number">1</span>&#125;&#125;</span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;...obj1&#125;;</span><br><span class="line">obj1.<span class="property">a</span> = <span class="number">2</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1); <span class="comment">//&#123;a:2,b:&#123;c:1&#125;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2); <span class="comment">//&#123;a:1,b:&#123;c:1&#125;&#125;</span></span><br><span class="line">obj1.<span class="property">b</span>.<span class="property">c</span> = <span class="number">2</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1); <span class="comment">//&#123;a:2,b:&#123;c:2&#125;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2); <span class="comment">//&#123;a:1,b:&#123;c:2&#125;&#125;</span></span><br></pre></td></tr></table></figure><h4 id="（3）数组方法实现数组浅拷贝"><a href="#（3）数组方法实现数组浅拷贝" class="headerlink" title="（3）数组方法实现数组浅拷贝"></a>（3）数组方法实现数组浅拷贝</h4><h6 id="1）Array-prototype-slice"><a href="#1）Array-prototype-slice" class="headerlink" title="1）Array.prototype.slice"></a><strong>1）Array.prototype.slice</strong></h6><ul><li><code>slice()</code>方法是JavaScript数组的一个方法，这个方法可以从已有数组中返回选定的元素：用法：<code>array.slice(start, end)</code>，该方法不会改变原始数组。</li><li>该方法有两个参数，两个参数都可选，如果两个参数都不写，就可以实现一个数组的浅拷贝。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">slice</span>()); <span class="comment">// [1,2,3,4]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">slice</span>() === arr); <span class="comment">//false</span></span><br></pre></td></tr></table></figure><h6 id="2）Array-prototype-concat"><a href="#2）Array-prototype-concat" class="headerlink" title="2）Array.prototype.concat"></a><strong>2）Array.prototype.concat</strong></h6><ul><li><code>concat()</code> 方法用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。</li><li>该方法有两个参数，两个参数都可选，如果两个参数都不写，就可以实现一个数组的浅拷贝。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">concat</span>()); <span class="comment">// [1,2,3,4]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">concat</span>() === arr); <span class="comment">//false</span></span><br></pre></td></tr></table></figure><h4 id="（4）手写实现浅拷贝"><a href="#（4）手写实现浅拷贝" class="headerlink" title="（4）手写实现浅拷贝"></a>（4）手写实现浅拷贝</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="comment">// 浅拷贝的实现;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">shallowCopy</span>(<span class="params">object</span>) &#123;</span><br><span class="line">  <span class="comment">// 只拷贝对象</span></span><br><span class="line">  <span class="keyword">if</span> (!object || <span class="keyword">typeof</span> object !== <span class="string">&quot;object&quot;</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据 object 的类型判断是新建一个数组还是对象</span></span><br><span class="line">  <span class="keyword">let</span> newObject = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(object) ? [] : &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历 object，并且判断是 object 的属性才拷贝</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> object) &#123;</span><br><span class="line">    <span class="keyword">if</span> (object.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">      newObject[key] = object[key];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> newObject;</span><br><span class="line">&#125;<span class="comment">// 浅拷贝的实现;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">shallowCopy</span>(<span class="params">object</span>) &#123;</span><br><span class="line">  <span class="comment">// 只拷贝对象</span></span><br><span class="line">  <span class="keyword">if</span> (!object || <span class="keyword">typeof</span> object !== <span class="string">&quot;object&quot;</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据 object 的类型判断是新建一个数组还是对象</span></span><br><span class="line">  <span class="keyword">let</span> newObject = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(object) ? [] : &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历 object，并且判断是 object 的属性才拷贝</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> object) &#123;</span><br><span class="line">    <span class="keyword">if</span> (object.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">      newObject[key] = object[key];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> newObject;</span><br><span class="line">&#125;<span class="comment">// 浅拷贝的实现;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">shallowCopy</span>(<span class="params">object</span>) &#123;</span><br><span class="line">  <span class="comment">// 只拷贝对象</span></span><br><span class="line">  <span class="keyword">if</span> (!object || <span class="keyword">typeof</span> object !== <span class="string">&quot;object&quot;</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// 根据 object 的类型判断是新建一个数组还是对象</span></span><br><span class="line">  <span class="keyword">let</span> newObject = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(object) ? [] : &#123;&#125;;</span><br><span class="line">  <span class="comment">// 遍历 object，并且判断是 object 的属性才拷贝</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> object) &#123;</span><br><span class="line">    <span class="keyword">if</span> (object.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">      newObject[key] = object[key];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="15-实现深拷贝"><a href="#15-实现深拷贝" class="headerlink" title="15. 实现深拷贝"></a>15. 实现深拷贝</h3><ul><li><strong>浅拷贝：</strong> 浅拷贝指的是将一个对象的属性值复制到另一个对象，如果有的属性的值为引用类型的话，那么会将这个引用的地址复制给对象，因此两个对象会有同一个引用类型的引用。浅拷贝可以使用  Object.assign 和展开运算符来实现。</li><li><strong>深拷贝：</strong> 深拷贝相对浅拷贝而言，如果遇到属性值为引用类型的时候，它新建一个引用类型并将对应的值复制给它，因此对象获得的一个新的引用类型而不是一个原有类型的引用。深拷贝对于一些对象可以使用 JSON 的两个函数来实现，但是由于 JSON 的对象格式比 js 的对象格式更加严格，所以如果属性值里边出现函数或者 Symbol 类型的值时，会转换失败</li></ul><h4 id="（1）JSON-stringify"><a href="#（1）JSON-stringify" class="headerlink" title="（1）JSON.stringify()"></a>（1）JSON.stringify()</h4><ul><li><code>JSON.parse(JSON.stringify(obj))</code>是目前比较常用的深拷贝方法之一，它的原理就是利用<code>JSON.stringify</code> 将<code>js</code>对象序列化（JSON字符串），再使用<code>JSON.parse</code>来反序列化(还原)<code>js</code>对象。</li><li>这个方法可以简单粗暴的实现深拷贝，但是还存在问题，拷贝的对象中如果有函数，undefined，symbol，当使用过<code>JSON.stringify()</code>进行处理之后，都会消失。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="keyword">let</span> obj1 = &#123;  <span class="attr">a</span>: <span class="number">0</span>,</span><br><span class="line">              <span class="attr">b</span>: &#123;</span><br><span class="line">                 <span class="attr">c</span>: <span class="number">0</span></span><br><span class="line">                 &#125;</span><br><span class="line">            &#125;;</span><br><span class="line"><span class="keyword">let</span> obj2 = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj1));</span><br><span class="line">obj1.<span class="property">a</span> = <span class="number">1</span>;</span><br><span class="line">obj1.<span class="property">b</span>.<span class="property">c</span> = <span class="number">1</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1); <span class="comment">// &#123;a: 1, b: &#123;c: 1&#125;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2); <span class="comment">// &#123;a: 0, b: &#123;c: 0&#125;&#125;</span></span><br></pre></td></tr></table></figure><h4 id="（2）函数库lodash的-cloneDeep方法"><a href="#（2）函数库lodash的-cloneDeep方法" class="headerlink" title="（2）函数库lodash的_.cloneDeep方法"></a>（2）函数库lodash的_.cloneDeep方法</h4><p>该函数库也有提供_.cloneDeep用来做 Deep Copy</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="keyword">var</span> _ = <span class="built_in">require</span>(<span class="string">&#x27;lodash&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">b</span>: &#123; <span class="attr">f</span>: &#123; <span class="attr">g</span>: <span class="number">1</span> &#125; &#125;,</span><br><span class="line">    <span class="attr">c</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = _.<span class="title function_">cloneDeep</span>(obj1);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1.<span class="property">b</span>.<span class="property">f</span> === obj2.<span class="property">b</span>.<span class="property">f</span>);<span class="comment">// false</span></span><br></pre></td></tr></table></figure><h4 id="（3）手写实现深拷贝函数"><a href="#（3）手写实现深拷贝函数" class="headerlink" title="（3）手写实现深拷贝函数"></a>（3）手写实现深拷贝函数</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="comment">// 深拷贝的实现</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">deepCopy</span>(<span class="params">object</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!object || <span class="keyword">typeof</span> object !== <span class="string">&quot;object&quot;</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> newObject = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(object) ? [] : &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> object) &#123;</span><br><span class="line">    <span class="keyword">if</span> (object.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">      newObject[key] =</span><br><span class="line">        <span class="keyword">typeof</span> object[key] === <span class="string">&quot;object&quot;</span> ? <span class="title function_">deepCopy</span>(object[key]) : object[key];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> newObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、数据处理"><a href="#二、数据处理" class="headerlink" title="二、数据处理"></a>二、数据处理</h2><h3 id="1-实现日期格式化函数"><a href="#1-实现日期格式化函数" class="headerlink" title="1. 实现日期格式化函数"></a>1. 实现日期格式化函数</h3><p>输入：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="title function_">dateFormat</span>(<span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&#x27;2020-12-01&#x27;</span>), <span class="string">&#x27;yyyy/MM/dd&#x27;</span>) <span class="comment">// 2020/12/01</span></span><br><span class="line"><span class="title function_">dateFormat</span>(<span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&#x27;2020-04-01&#x27;</span>), <span class="string">&#x27;yyyy/MM/dd&#x27;</span>) <span class="comment">// 2020/04/01</span></span><br><span class="line"><span class="title function_">dateFormat</span>(<span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&#x27;2020-04-01&#x27;</span>), <span class="string">&#x27;yyyy年MM月dd日&#x27;</span>) <span class="comment">// 2020年04月01日</span></span><br><span class="line">javascript复制代码<span class="keyword">const</span> <span class="title function_">dateFormat</span> = (<span class="params">dateInput, format</span>)=&gt;&#123;</span><br><span class="line">    <span class="keyword">var</span> day = dateInput.<span class="title function_">getDate</span>() </span><br><span class="line">    <span class="keyword">var</span> month = dateInput.<span class="title function_">getMonth</span>() + <span class="number">1</span>  </span><br><span class="line">    <span class="keyword">var</span> year = dateInput.<span class="title function_">getFullYear</span>()   </span><br><span class="line">    format = format.<span class="title function_">replace</span>(<span class="regexp">/yyyy/</span>, year)</span><br><span class="line">    format = format.<span class="title function_">replace</span>(<span class="regexp">/MM/</span>,month)</span><br><span class="line">    format = format.<span class="title function_">replace</span>(<span class="regexp">/dd/</span>,day)</span><br><span class="line">    <span class="keyword">return</span> format</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-交换a-b的值，不能用临时变量"><a href="#2-交换a-b的值，不能用临时变量" class="headerlink" title="2. 交换a,b的值，不能用临时变量"></a>2. 交换a,b的值，不能用临时变量</h3><p>巧妙的利用两个数的和、差：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码a = a + b</span><br><span class="line">b = a - b</span><br><span class="line">a = a - b</span><br></pre></td></tr></table></figure><h3 id="3-实现数组的乱序输出"><a href="#3-实现数组的乱序输出" class="headerlink" title="3. 实现数组的乱序输出"></a>3. 实现数组的乱序输出</h3><p>主要的实现思路就是：</p><ul><li>取出数组的第一个元素，随机产生一个索引值，将该第一个元素和这个索引对应的元素进行交换。</li><li>第二次取出数据数组第二个元素，随机产生一个除了索引为1的之外的索引值，并将第二个元素与该索引值对应的元素进行交换</li><li>按照上面的规律执行，直到遍历完成</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">const</span> randomIndex = <span class="title class_">Math</span>.<span class="title function_">round</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * (arr.<span class="property">length</span> - <span class="number">1</span> - i)) + i;</span><br><span class="line">  [arr[i], arr[randomIndex]] = [arr[randomIndex], arr[i]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr)</span><br></pre></td></tr></table></figure><p>还有一方法就是倒序遍历：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>];</span><br><span class="line"><span class="keyword">let</span> length = arr.<span class="property">length</span>,</span><br><span class="line">    randomIndex,</span><br><span class="line">    temp;</span><br><span class="line">  <span class="keyword">while</span> (length) &#123;</span><br><span class="line">    randomIndex = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * length--);</span><br><span class="line">    temp = arr[length];</span><br><span class="line">    arr[length] = arr[randomIndex];</span><br><span class="line">    arr[randomIndex] = temp;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr)</span><br></pre></td></tr></table></figure><h3 id="4-实现数组元素求和"><a href="#4-实现数组元素求和" class="headerlink" title="4. 实现数组元素求和"></a>4. 实现数组元素求和</h3><ul><li>arr=[1,2,3,4,5,6,7,8,9,10]，求和</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="keyword">let</span> arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>]</span><br><span class="line"><span class="keyword">let</span> sum = arr.<span class="title function_">reduce</span>( <span class="function">(<span class="params">total,i</span>) =&gt;</span> total += i,<span class="number">0</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sum);</span><br></pre></td></tr></table></figure><ul><li>arr=[1,2,3,[[4,5],6],7,8,9]，求和</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="keyword">var</span> = arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,[[<span class="number">4</span>,<span class="number">5</span>],<span class="number">6</span>],<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br><span class="line"><span class="keyword">let</span> arr= arr.<span class="title function_">toString</span>().<span class="title function_">split</span>(<span class="string">&#x27;,&#x27;</span>).<span class="title function_">reduce</span>( <span class="function">(<span class="params">total,i</span>) =&gt;</span> total += <span class="title class_">Number</span>(i),<span class="number">0</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr);</span><br></pre></td></tr></table></figure><p>递归实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>] </span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.<span class="property">length</span> == <span class="number">1</span>) <span class="keyword">return</span> arr[<span class="number">0</span>] </span><br><span class="line">    <span class="keyword">return</span> arr[<span class="number">0</span>] + <span class="title function_">add</span>(arr.<span class="title function_">slice</span>(<span class="number">1</span>)) </span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">add</span>(arr)) <span class="comment">// 21</span></span><br></pre></td></tr></table></figure><h3 id="5-实现数组的扁平化"><a href="#5-实现数组的扁平化" class="headerlink" title="5. 实现数组的扁平化"></a>5. 实现数组的扁平化</h3><p><strong>（1）递归实现</strong></p><p>普通的递归思路很容易理解，就是通过循环递归的方式，一项一项地去遍历，如果每一项还是一个数组，那么就继续往下遍历，利用递归程序的方法，来实现数组的每一项的连接：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="keyword">let</span> arr = [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]]];</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">flatten</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> result = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="title class_">Array</span>.<span class="title function_">isArray</span>(arr[i])) &#123;</span><br><span class="line">      result = result.<span class="title function_">concat</span>(<span class="title function_">flatten</span>(arr[i]));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result.<span class="title function_">push</span>(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">flatten</span>(arr);  <span class="comment">//  [1, 2, 3, 4，5]</span></span><br></pre></td></tr></table></figure><p><strong>（2）reduce 函数迭代</strong></p><p>从上面普通的递归函数中可以看出，其实就是对数组的每一项进行处理，那么其实也可以用reduce 来实现数组的拼接，从而简化第一种方法的代码，改造后的代码如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="keyword">let</span> arr = [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]]];</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">flatten</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> arr.<span class="title function_">reduce</span>(<span class="keyword">function</span>(<span class="params">prev, next</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> prev.<span class="title function_">concat</span>(<span class="title class_">Array</span>.<span class="title function_">isArray</span>(next) ? <span class="title function_">flatten</span>(next) : next)</span><br><span class="line">    &#125;, [])</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">flatten</span>(arr));<span class="comment">//  [1, 2, 3, 4，5]</span></span><br></pre></td></tr></table></figure><p><strong>（3）扩展运算符实现</strong></p><p>这个方法的实现，采用了扩展运算符和 some 的方法，两者共同使用，达到数组扁平化的目的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="keyword">let</span> arr = [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]]];</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">flatten</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (arr.<span class="title function_">some</span>(<span class="function"><span class="params">item</span> =&gt;</span> <span class="title class_">Array</span>.<span class="title function_">isArray</span>(item))) &#123;</span><br><span class="line">        arr = [].<span class="title function_">concat</span>(...arr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">flatten</span>(arr)); <span class="comment">//  [1, 2, 3, 4，5]</span></span><br></pre></td></tr></table></figure><p><strong>（4）split 和 toString</strong></p><p>可以通过 split 和 toString 两个方法来共同实现数组扁平化，由于数组会默认带一个 toString 的方法，所以可以把数组直接转换成逗号分隔的字符串，然后再用 split 方法把字符串重新转换为数组，如下面的代码所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="keyword">let</span> arr = [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]]];</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">flatten</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> arr.<span class="title function_">toString</span>().<span class="title function_">split</span>(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">flatten</span>(arr)); <span class="comment">//  [1, 2, 3, 4，5]</span></span><br></pre></td></tr></table></figure><p>通过这两个方法可以将多维数组直接转换成逗号连接的字符串，然后再重新分隔成数组。</p><p><strong>（5）ES6 中的 flat</strong></p><p>我们还可以直接调用 ES6 中的 flat 方法来实现数组扁平化。flat 方法的语法：<code>arr.flat([depth])</code></p><p>其中 depth 是 flat 的参数，depth 是可以传递数组的展开深度（默认不填、数值是 1），即展开一层数组。如果层数不确定，参数可以传进 Infinity，代表不论多少层都要展开：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="keyword">let</span> arr = [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]]];</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">flatten</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> arr.<span class="title function_">flat</span>(<span class="title class_">Infinity</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">flatten</span>(arr)); <span class="comment">//  [1, 2, 3, 4，5]</span></span><br></pre></td></tr></table></figure><p>可以看出，一个嵌套了两层的数组，通过将 flat 方法的参数设置为 Infinity，达到了我们预期的效果。其实同样也可以设置成 2，也能实现这样的效果。在编程过程中，如果数组的嵌套层数不确定，最好直接使用 Infinity，可以达到扁平化。 <strong>（6）正则和 JSON 方法</strong> 在第4种方法中已经使用 toString 方法，其中仍然采用了将 JSON.stringify 的方法先转换为字符串，然后通过正则表达式过滤掉字符串中的数组的方括号，最后再利用 JSON.parse 把它转换成数组：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="keyword">let</span> arr = [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]]], <span class="number">6</span>];</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">flatten</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> str = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(arr);</span><br><span class="line">  str = str.<span class="title function_">replace</span>(<span class="regexp">/(\[|\])/g</span>, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">  str = <span class="string">&#x27;[&#x27;</span> + str + <span class="string">&#x27;]&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">JSON</span>.<span class="title function_">parse</span>(str); </span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">flatten</span>(arr)); <span class="comment">//  [1, 2, 3, 4，5]</span></span><br></pre></td></tr></table></figure><h3 id="6-实现数组去重"><a href="#6-实现数组去重" class="headerlink" title="6. 实现数组去重"></a>6. 实现数组去重</h3><p>给定某无序数组，要求去除数组中的重复数字并且返回新的无重复数组。</p><p>ES6方法（使用数据结构集合）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="keyword">const</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">8</span>];</span><br><span class="line"></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="keyword">new</span> <span class="title class_">Set</span>(array)); <span class="comment">// [1, 2, 3, 5, 9, 8]</span></span><br></pre></td></tr></table></figure><p>ES5方法：使用map存储不重复的数字</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="keyword">const</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">8</span>];</span><br><span class="line"></span><br><span class="line"><span class="title function_">uniqueArray</span>(array); <span class="comment">// [1, 2, 3, 5, 9, 8]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">uniqueArray</span>(<span class="params">array</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> map = &#123;&#125;;</span><br><span class="line">  <span class="keyword">let</span> res = [];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; array.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!map.<span class="title function_">hasOwnProperty</span>([array[i]])) &#123;</span><br><span class="line">      map[array[i]] = <span class="number">1</span>;</span><br><span class="line">      res.<span class="title function_">push</span>(array[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-实现数组的flat方法"><a href="#7-实现数组的flat方法" class="headerlink" title="7. 实现数组的flat方法"></a>7. 实现数组的flat方法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="keyword">function</span> <span class="title function_">_flat</span>(<span class="params">arr, depth</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(!<span class="title class_">Array</span>.<span class="title function_">isArray</span>(arr) || depth &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">prev, cur</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(cur)) &#123;</span><br><span class="line">      <span class="keyword">return</span> prev.<span class="title function_">concat</span>(<span class="title function_">_flat</span>(cur, depth - <span class="number">1</span>))</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> prev.<span class="title function_">concat</span>(cur);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, []);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-实现数组的push方法"><a href="#8-实现数组的push方法" class="headerlink" title="8. 实现数组的push方法"></a>8. 实现数组的push方法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="keyword">let</span> arr = [];</span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">push</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">let</span> i = <span class="number">0</span> ; i &lt; <span class="variable language_">arguments</span>.<span class="property">length</span> ; i++)&#123;</span><br><span class="line"><span class="variable language_">this</span>[<span class="variable language_">this</span>.<span class="property">length</span>] = <span class="variable language_">arguments</span>[i] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">length</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-实现数组的filter方法"><a href="#9-实现数组的filter方法" class="headerlink" title="9. 实现数组的filter方法"></a>9. 实现数组的filter方法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_filter</span> = <span class="keyword">function</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> fn !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="title class_">Error</span>(<span class="string">&#x27;参数必须是一个函数&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> res = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = <span class="variable language_">this</span>.<span class="property">length</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="title function_">fn</span>(<span class="variable language_">this</span>[i]) &amp;&amp; res.<span class="title function_">push</span>(<span class="variable language_">this</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-实现数组的map方法"><a href="#10-实现数组的map方法" class="headerlink" title="10. 实现数组的map方法"></a>10. 实现数组的map方法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_map</span> = <span class="keyword">function</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">typeof</span> fn !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="title class_">Error</span>(<span class="string">&#x27;参数必须是一个函数&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> res = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = <span class="variable language_">this</span>.<span class="property">length</span>; i &lt; len; i++) &#123;</span><br><span class="line">        res.<span class="title function_">push</span>(<span class="title function_">fn</span>(<span class="variable language_">this</span>[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-实现字符串的repeat方法"><a href="#11-实现字符串的repeat方法" class="headerlink" title="11. 实现字符串的repeat方法"></a>11. 实现字符串的repeat方法</h3><p>输入字符串s，以及其重复的次数，输出重复的结果，例如输入abc，2，输出abcabc。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="keyword">function</span> <span class="title function_">repeat</span>(<span class="params">s, n</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">new</span> <span class="title class_">Array</span>(n + <span class="number">1</span>)).<span class="title function_">join</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="keyword">function</span> <span class="title function_">repeat</span>(<span class="params">s, n</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (n &gt; <span class="number">0</span>) ? s.<span class="title function_">concat</span>(<span class="title function_">repeat</span>(s, --n)) : <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12-实现字符串翻转"><a href="#12-实现字符串翻转" class="headerlink" title="12. 实现字符串翻转"></a>12. 实现字符串翻转</h3><p>在字符串的原型链上添加一个方法，实现字符串翻转：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="title class_">String</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_reverse</span> = <span class="keyword">function</span>(<span class="params">a</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> a.<span class="title function_">split</span>(<span class="string">&quot;&quot;</span>).<span class="title function_">reverse</span>().<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title class_">String</span>();</span><br><span class="line"><span class="keyword">var</span> res = obj.<span class="property">_reverse</span> (<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res);    <span class="comment">// olleh</span></span><br></pre></td></tr></table></figure><p>需要注意的是，必须通过实例化对象之后再去调用定义的方法，不然找不到该方法。</p><h3 id="13-将数字每千分位用逗号隔开"><a href="#13-将数字每千分位用逗号隔开" class="headerlink" title="13. 将数字每千分位用逗号隔开"></a>13. 将数字每千分位用逗号隔开</h3><p><strong>数字有小数版本：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="keyword">let</span> <span class="title function_">format</span> = n =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> num = n.<span class="title function_">toString</span>() <span class="comment">// 转成字符串</span></span><br><span class="line">    <span class="keyword">let</span> decimals = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="comment">// 判断是否有小数</span></span><br><span class="line">    num.<span class="title function_">indexOf</span>(<span class="string">&#x27;.&#x27;</span>) &gt; -<span class="number">1</span> ? decimals = num.<span class="title function_">split</span>(<span class="string">&#x27;.&#x27;</span>)[<span class="number">1</span>] : decimals</span><br><span class="line">    <span class="keyword">let</span> len = num.<span class="property">length</span></span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> num</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> temp = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">let</span> remainder = len % <span class="number">3</span></span><br><span class="line">        decimals ? temp = <span class="string">&#x27;.&#x27;</span> + decimals : temp</span><br><span class="line">        <span class="keyword">if</span> (remainder &gt; <span class="number">0</span>) &#123; <span class="comment">// 不是3的整数倍</span></span><br><span class="line">            <span class="keyword">return</span> num.<span class="title function_">slice</span>(<span class="number">0</span>, remainder) + <span class="string">&#x27;,&#x27;</span> + num.<span class="title function_">slice</span>(remainder, len).<span class="title function_">match</span>(<span class="regexp">/\d&#123;3&#125;/g</span>).<span class="title function_">join</span>(<span class="string">&#x27;,&#x27;</span>) + temp</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 是3的整数倍</span></span><br><span class="line">            <span class="keyword">return</span> num.<span class="title function_">slice</span>(<span class="number">0</span>, len).<span class="title function_">match</span>(<span class="regexp">/\d&#123;3&#125;/g</span>).<span class="title function_">join</span>(<span class="string">&#x27;,&#x27;</span>) + temp </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">format</span>(<span class="number">12323.33</span>)  <span class="comment">// &#x27;12,323.33&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>数字无小数版本：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="keyword">let</span> <span class="title function_">format</span> = n =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> num = n.<span class="title function_">toString</span>() </span><br><span class="line">    <span class="keyword">let</span> len = num.<span class="property">length</span></span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> num</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> remainder = len % <span class="number">3</span></span><br><span class="line">        <span class="keyword">if</span> (remainder &gt; <span class="number">0</span>) &#123; <span class="comment">// 不是3的整数倍</span></span><br><span class="line">            <span class="keyword">return</span> num.<span class="title function_">slice</span>(<span class="number">0</span>, remainder) + <span class="string">&#x27;,&#x27;</span> + num.<span class="title function_">slice</span>(remainder, len).<span class="title function_">match</span>(<span class="regexp">/\d&#123;3&#125;/g</span>).<span class="title function_">join</span>(<span class="string">&#x27;,&#x27;</span>) </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 是3的整数倍</span></span><br><span class="line">            <span class="keyword">return</span> num.<span class="title function_">slice</span>(<span class="number">0</span>, len).<span class="title function_">match</span>(<span class="regexp">/\d&#123;3&#125;/g</span>).<span class="title function_">join</span>(<span class="string">&#x27;,&#x27;</span>) </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">format</span>(<span class="number">1232323</span>)  <span class="comment">// &#x27;1,232,323&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="14-实现非负大整数相加"><a href="#14-实现非负大整数相加" class="headerlink" title="14. 实现非负大整数相加"></a>14. 实现非负大整数相加</h3><p>JavaScript对数值有范围的限制，限制如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="title class_">Number</span>.<span class="property">MAX_VALUE</span> <span class="comment">// 1.7976931348623157e+308</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="property">MAX_SAFE_INTEGER</span> <span class="comment">// 9007199254740991</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="property">MIN_VALUE</span> <span class="comment">// 5e-324</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="property">MIN_SAFE_INTEGER</span> <span class="comment">// -9007199254740991</span></span><br></pre></td></tr></table></figure><p>如果想要对一个超大的整数(<code>&gt; Number.MAX_SAFE_INTEGER</code>)进行加法运算，但是又想输出一般形式，那么使用 + 是无法达到的，一旦数字超过 <code>Number.MAX_SAFE_INTEGER</code> 数字会被立即转换为科学计数法，并且数字精度相比以前将会有误差。</p><p>实现一个算法进行大数的相加：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="keyword">function</span> <span class="title function_">sumBigNumber</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="keyword">let</span> temp = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  a = a.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">  b = b.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span> (a.<span class="property">length</span> || b.<span class="property">length</span> || temp) &#123;</span><br><span class="line">    temp += ~~a.<span class="title function_">pop</span>() + ~~b.<span class="title function_">pop</span>();</span><br><span class="line">    res = (temp % <span class="number">10</span>) + res;</span><br><span class="line">    temp  = temp &gt; <span class="number">9</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res.<span class="title function_">replace</span>(<span class="regexp">/^0+/</span>, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其主要的思路如下：</p><ul><li>首先用字符串的方式来保存大数，这样数字在数学表示上就不会发生变化</li><li>初始化res，temp来保存中间的计算结果，并将两个字符串转化为数组，以便进行每一位的加法运算</li><li>将两个数组的对应的位进行相加，两个数相加的结果可能大于10，所以可能要仅为，对10进行取余操作，将结果保存在当前位</li><li>判断当前位是否大于9，也就是是否会进位，若是则将temp赋值为true，因为在加法运算中，true会自动隐式转化为1，以便于下一次相加</li><li>重复上述操作，直至计算结束</li></ul><h3 id="13-实现-add-1-2-3"><a href="#13-实现-add-1-2-3" class="headerlink" title="13. 实现 add(1)(2)(3)"></a>13. 实现 add(1)(2)(3)</h3><p>函数柯里化概念： 柯里化（Currying）是把接受多个参数的函数转变为接受一个单一参数的函数，并且返回接受余下的参数且返回结果的新函数的技术。</p><p>1）粗暴版</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="keyword">function</span> <span class="title function_">add</span> (a) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">b</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">c</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> a + b + c;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">add</span>(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><p>2）柯里化解决方案</p><ul><li>参数长度固定</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="keyword">var</span> add = <span class="keyword">function</span> (<span class="params">m</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> temp = <span class="keyword">function</span> (<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">add</span>(m + n);</span><br><span class="line">  &#125;</span><br><span class="line">  temp.<span class="property">toString</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> temp;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">add</span>(<span class="number">3</span>)(<span class="number">4</span>)(<span class="number">5</span>)); <span class="comment">// 12</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">add</span>(<span class="number">3</span>)(<span class="number">6</span>)(<span class="number">9</span>)(<span class="number">25</span>)); <span class="comment">// 43</span></span><br></pre></td></tr></table></figure><p>对于add(3)(4)(5)，其执行过程如下：</p><ol><li>先执行add(3)，此时m=3，并且返回temp函数；</li><li>执行temp(4)，这个函数内执行add(m+n)，n是此次传进来的数值4，m值还是上一步中的3，所以add(m+n)=add(3+4)=add(7)，此时m=7，并且返回temp函数</li><li>执行temp(5)，这个函数内执行add(m+n)，n是此次传进来的数值5，m值还是上一步中的7，所以add(m+n)=add(7+5)=add(12)，此时m=12，并且返回temp函数</li><li>由于后面没有传入参数，等于返回的temp函数不被执行而是打印，了解JS的朋友都知道对象的toString是修改对象转换字符串的方法，因此代码中temp函数的toString函数return m值，而m值是最后一步执行函数时的值m=12，所以返回值是12。</li></ol><ul><li>参数长度不固定</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="keyword">function</span> <span class="title function_">add</span> (...args) &#123;</span><br><span class="line">    <span class="comment">//求和</span></span><br><span class="line">    <span class="keyword">return</span> args.<span class="title function_">reduce</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">currying</span> (fn) &#123;</span><br><span class="line">    <span class="keyword">let</span> args = []</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">temp</span> (...newArgs) &#123;</span><br><span class="line">        <span class="keyword">if</span> (newArgs.<span class="property">length</span>) &#123;</span><br><span class="line">            args = [</span><br><span class="line">                ...args,</span><br><span class="line">                ...newArgs</span><br><span class="line">            ]</span><br><span class="line">            <span class="keyword">return</span> temp</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> val = fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args)</span><br><span class="line">            args = [] <span class="comment">//保证再次调用时清空</span></span><br><span class="line">            <span class="keyword">return</span> val</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> addCurry = <span class="title function_">currying</span>(add)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">addCurry</span>(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>, <span class="number">5</span>)())  <span class="comment">//15</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">addCurry</span>(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)())  <span class="comment">//15</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">addCurry</span>(<span class="number">1</span>)(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)())  <span class="comment">//15</span></span><br></pre></td></tr></table></figure><h3 id="14-实现类数组转化为数组"><a href="#14-实现类数组转化为数组" class="headerlink" title="14. 实现类数组转化为数组"></a>14. 实现类数组转化为数组</h3><p>类数组转换为数组的方法有这样几种：</p><ul><li>通过 call 调用数组的 slice 方法来实现转换</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javascript</span><br><span class="line">复制代码<span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(arrayLike);</span><br></pre></td></tr></table></figure><ul><li>通过 call 调用数组的 splice 方法来实现转换</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javascript</span><br><span class="line">复制代码<span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">splice</span>.<span class="title function_">call</span>(arrayLike, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><ul><li>通过 apply 调用数组的 concat 方法来实现转换</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javascript</span><br><span class="line">复制代码<span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">concat</span>.<span class="title function_">apply</span>([], arrayLike);</span><br></pre></td></tr></table></figure><ul><li>通过 Array.from 方法来实现转换</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javascript</span><br><span class="line">复制代码<span class="title class_">Array</span>.<span class="title function_">from</span>(arrayLike);</span><br></pre></td></tr></table></figure><h3 id="15-使用-reduce-求和"><a href="#15-使用-reduce-求和" class="headerlink" title="15. 使用 reduce 求和"></a>15. 使用 reduce 求和</h3><p>arr = [1,2,3,4,5,6,7,8,9,10]，求和</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>]</span><br><span class="line">arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">prev, cur</span>) =&gt;</span> &#123; <span class="keyword">return</span> prev + cur &#125;, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>arr = [1,2,3,[[4,5],6],7,8,9]，求和</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>]</span><br><span class="line">arr.<span class="title function_">flat</span>(<span class="title class_">Infinity</span>).<span class="title function_">reduce</span>(<span class="function">(<span class="params">prev, cur</span>) =&gt;</span> &#123; <span class="keyword">return</span> prev + cur &#125;, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>arr = [{a:1, b:3}, {a:2, b:3, c:4}, {a:3}]，求和</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="keyword">let</span> arr = [&#123;<span class="attr">a</span>:<span class="number">9</span>, <span class="attr">b</span>:<span class="number">3</span>, <span class="attr">c</span>:<span class="number">4</span>&#125;, &#123;<span class="attr">a</span>:<span class="number">1</span>, <span class="attr">b</span>:<span class="number">3</span>&#125;, &#123;<span class="attr">a</span>:<span class="number">3</span>&#125;] </span><br><span class="line"></span><br><span class="line">arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">prev, cur</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> prev + cur[<span class="string">&quot;a&quot;</span>];</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><h3 id="16-将js对象转化为树形结构"><a href="#16-将js对象转化为树形结构" class="headerlink" title="16. 将js对象转化为树形结构"></a>16. 将js对象转化为树形结构</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="comment">// 转换前：</span></span><br><span class="line">source = [&#123;</span><br><span class="line">            <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="attr">pid</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">name</span>: <span class="string">&#x27;body&#x27;</span></span><br><span class="line">          &#125;, &#123;</span><br><span class="line">            <span class="attr">id</span>: <span class="number">2</span>,</span><br><span class="line">            <span class="attr">pid</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="attr">name</span>: <span class="string">&#x27;title&#x27;</span></span><br><span class="line">          &#125;, &#123;</span><br><span class="line">            <span class="attr">id</span>: <span class="number">3</span>,</span><br><span class="line">            <span class="attr">pid</span>: <span class="number">2</span>,</span><br><span class="line">            <span class="attr">name</span>: <span class="string">&#x27;div&#x27;</span></span><br><span class="line">          &#125;]</span><br><span class="line"><span class="comment">// 转换为: </span></span><br><span class="line">tree = [&#123;</span><br><span class="line">          <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">          <span class="attr">pid</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">name</span>: <span class="string">&#x27;body&#x27;</span>,</span><br><span class="line">          <span class="attr">children</span>: [&#123;</span><br><span class="line">            <span class="attr">id</span>: <span class="number">2</span>,</span><br><span class="line">            <span class="attr">pid</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="attr">name</span>: <span class="string">&#x27;title&#x27;</span>,</span><br><span class="line">            <span class="attr">children</span>: [&#123;</span><br><span class="line">              <span class="attr">id</span>: <span class="number">3</span>,</span><br><span class="line">              <span class="attr">pid</span>: <span class="number">1</span>,</span><br><span class="line">              <span class="attr">name</span>: <span class="string">&#x27;div&#x27;</span></span><br><span class="line">            &#125;]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;]</span><br></pre></td></tr></table></figure><p>代码实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="keyword">function</span> <span class="title function_">jsonToTree</span>(<span class="params">data</span>) &#123;</span><br><span class="line">  <span class="comment">// 初始化结果数组，并判断输入数据的格式</span></span><br><span class="line">  <span class="keyword">let</span> result = []</span><br><span class="line">  <span class="keyword">if</span>(!<span class="title class_">Array</span>.<span class="title function_">isArray</span>(data)) &#123;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 使用map，将当前对象的id与当前对象对应存储起来</span></span><br><span class="line">  <span class="keyword">let</span> map = &#123;&#125;;</span><br><span class="line">  data.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    map[item.<span class="property">id</span>] = item;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// </span></span><br><span class="line">  data.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> parent = map[item.<span class="property">pid</span>];</span><br><span class="line">    <span class="keyword">if</span>(parent) &#123;</span><br><span class="line">      (parent.<span class="property">children</span> || (parent.<span class="property">children</span> = [])).<span class="title function_">push</span>(item);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result.<span class="title function_">push</span>(item);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="17-使用ES5和ES6求函数参数的和"><a href="#17-使用ES5和ES6求函数参数的和" class="headerlink" title="17. 使用ES5和ES6求函数参数的和"></a>17. 使用ES5和ES6求函数参数的和</h3><p>ES5：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span></span><br><span class="line">    <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">forEach</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>, <span class="keyword">function</span>(<span class="params">item</span>) &#123;</span><br><span class="line">        sum += item * <span class="number">1</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ES6：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">...nums</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span></span><br><span class="line">    nums.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">item</span>) &#123;</span><br><span class="line">        sum += item * <span class="number">1</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="18-解析-URL-Params-为对象"><a href="#18-解析-URL-Params-为对象" class="headerlink" title="18. 解析 URL Params 为对象"></a>18. 解析 URL Params 为对象</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="keyword">let</span> url = <span class="string">&#x27;http://www.domain.com/?user=anonymous&amp;id=123&amp;id=456&amp;city=%E5%8C%97%E4%BA%AC&amp;enabled&#x27;</span>;</span><br><span class="line"><span class="title function_">parseParam</span>(url)</span><br><span class="line"><span class="comment">/* 结果</span></span><br><span class="line"><span class="comment">&#123; user: &#x27;anonymous&#x27;,</span></span><br><span class="line"><span class="comment">  id: [ 123, 456 ], // 重复出现的 key 要组装成数组，能被转成数字的就转成数字类型</span></span><br><span class="line"><span class="comment">  city: &#x27;北京&#x27;, // 中文需解码</span></span><br><span class="line"><span class="comment">  enabled: true, // 未指定值得 key 约定为 true</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">javascript复制代码<span class="keyword">function</span> <span class="title function_">parseParam</span>(<span class="params">url</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> paramsStr = <span class="regexp">/.+\?(.+)$/</span>.<span class="title function_">exec</span>(url)[<span class="number">1</span>]; <span class="comment">// 将 ? 后面的字符串取出来</span></span><br><span class="line">  <span class="keyword">const</span> paramsArr = paramsStr.<span class="title function_">split</span>(<span class="string">&#x27;&amp;&#x27;</span>); <span class="comment">// 将字符串以 &amp; 分割后存到数组中</span></span><br><span class="line">  <span class="keyword">let</span> paramsObj = &#123;&#125;;</span><br><span class="line">  <span class="comment">// 将 params 存到对象中</span></span><br><span class="line">  paramsArr.<span class="title function_">forEach</span>(<span class="function"><span class="params">param</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="regexp">/=/</span>.<span class="title function_">test</span>(param)) &#123; <span class="comment">// 处理有 value 的参数</span></span><br><span class="line">      <span class="keyword">let</span> [key, val] = param.<span class="title function_">split</span>(<span class="string">&#x27;=&#x27;</span>); <span class="comment">// 分割 key 和 value</span></span><br><span class="line">      val = <span class="built_in">decodeURIComponent</span>(val); <span class="comment">// 解码</span></span><br><span class="line">      val = <span class="regexp">/^\d+$/</span>.<span class="title function_">test</span>(val) ? <span class="built_in">parseFloat</span>(val) : val; <span class="comment">// 判断是否转为数字</span></span><br><span class="line">      <span class="keyword">if</span> (paramsObj.<span class="title function_">hasOwnProperty</span>(key)) &#123; <span class="comment">// 如果对象有 key，则添加一个值</span></span><br><span class="line">        paramsObj[key] = [].<span class="title function_">concat</span>(paramsObj[key], val);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果对象没有这个 key，创建 key 并设置值</span></span><br><span class="line">        paramsObj[key] = val;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 处理没有 value 的参数</span></span><br><span class="line">      paramsObj[param] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> paramsObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、场景应用"><a href="#三、场景应用" class="headerlink" title="三、场景应用"></a>三、场景应用</h2><h3 id="1-循环打印红黄绿"><a href="#1-循环打印红黄绿" class="headerlink" title="1. 循环打印红黄绿"></a>1. 循环打印红黄绿</h3><p>下面来看一道比较典型的问题，通过这个问题来对比几种异步编程方法：<strong>红灯 3s 亮一次，绿灯 1s 亮一次，黄灯 2s 亮一次；如何让三个灯不断交替重复亮灯？</strong></p><p>三个亮灯函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="keyword">function</span> <span class="title function_">red</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;red&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">green</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;green&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">yellow</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;yellow&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题复杂的地方在于<strong>需要“交替重复”亮灯</strong>，而不是“亮完一次”就结束了。</p><h4 id="（1）用-callback-实现"><a href="#（1）用-callback-实现" class="headerlink" title="（1）用 callback 实现"></a>（1）用 callback 实现</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="keyword">const</span> <span class="title function_">task</span> = (<span class="params">timer, light, callback</span>) =&gt; &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (light === <span class="string">&#x27;red&#x27;</span>) &#123;</span><br><span class="line">            <span class="title function_">red</span>()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (light === <span class="string">&#x27;green&#x27;</span>) &#123;</span><br><span class="line">            <span class="title function_">green</span>()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (light === <span class="string">&#x27;yellow&#x27;</span>) &#123;</span><br><span class="line">            <span class="title function_">yellow</span>()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">callback</span>()</span><br><span class="line">    &#125;, timer)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">task</span>(<span class="number">3000</span>, <span class="string">&#x27;red&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">task</span>(<span class="number">2000</span>, <span class="string">&#x27;green&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">task</span>(<span class="number">1000</span>, <span class="string">&#x27;yellow&#x27;</span>, <span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这里存在一个 bug：代码只是完成了一次流程，执行后红黄绿灯分别只亮一次。该如何让它交替重复进行呢？</p><p>上面提到过递归，可以递归亮灯的一个周期：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="keyword">const</span> <span class="title function_">step</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="title function_">task</span>(<span class="number">3000</span>, <span class="string">&#x27;red&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">task</span>(<span class="number">2000</span>, <span class="string">&#x27;green&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">task</span>(<span class="number">1000</span>, <span class="string">&#x27;yellow&#x27;</span>, step)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">step</span>()</span><br></pre></td></tr></table></figure><p><strong>注意看黄灯亮的回调里又再次调用了 step 方法</strong> 以完成循环亮灯。</p><h4 id="（2）用-promise-实现"><a href="#（2）用-promise-实现" class="headerlink" title="（2）用 promise 实现"></a>（2）用 promise 实现</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="keyword">const</span> <span class="title function_">task</span> = (<span class="params">timer, light</span>) =&gt; </span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (light === <span class="string">&#x27;red&#x27;</span>) &#123;</span><br><span class="line">                <span class="title function_">red</span>()</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (light === <span class="string">&#x27;green&#x27;</span>) &#123;</span><br><span class="line">                <span class="title function_">green</span>()</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (light === <span class="string">&#x27;yellow&#x27;</span>) &#123;</span><br><span class="line">                <span class="title function_">yellow</span>()</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="title function_">resolve</span>()</span><br><span class="line">        &#125;, timer)</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">step</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="title function_">task</span>(<span class="number">3000</span>, <span class="string">&#x27;red&#x27;</span>)</span><br><span class="line">        .<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="title function_">task</span>(<span class="number">2000</span>, <span class="string">&#x27;green&#x27;</span>))</span><br><span class="line">        .<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="title function_">task</span>(<span class="number">2100</span>, <span class="string">&#x27;yellow&#x27;</span>))</span><br><span class="line">        .<span class="title function_">then</span>(step)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">step</span>()</span><br></pre></td></tr></table></figure><p>这里将回调移除，在一次亮灯结束后，resolve 当前 promise，并依然使用递归进行。</p><h4 id="（3）用-async-await-实现"><a href="#（3）用-async-await-实现" class="headerlink" title="（3）用 async/await 实现"></a>（3）用 async/await 实现</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="keyword">const</span> <span class="title function_">taskRunner</span> =  <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">task</span>(<span class="number">3000</span>, <span class="string">&#x27;red&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">task</span>(<span class="number">2000</span>, <span class="string">&#x27;green&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">task</span>(<span class="number">2100</span>, <span class="string">&#x27;yellow&#x27;</span>)</span><br><span class="line">    <span class="title function_">taskRunner</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">taskRunner</span>()</span><br></pre></td></tr></table></figure><h3 id="2-实现每隔一秒打印-1-2-3-4"><a href="#2-实现每隔一秒打印-1-2-3-4" class="headerlink" title="2. 实现每隔一秒打印 1,2,3,4"></a>2. 实现每隔一秒打印 1,2,3,4</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="comment">// 使用闭包实现</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  (<span class="keyword">function</span>(<span class="params">i</span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">    &#125;, i * <span class="number">1000</span>);</span><br><span class="line">  &#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用 let 块级作用域</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">  &#125;, i * <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-小孩报数问题"><a href="#3-小孩报数问题" class="headerlink" title="3. 小孩报数问题"></a>3. 小孩报数问题</h3><p>有30个小孩儿，编号从1-30，围成一圈依此报数，1、2、3 数到 3 的小孩儿退出这个圈， 然后下一个小孩 重新报数 1、2、3，问最后剩下的那个小孩儿的编号是多少?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="keyword">function</span> <span class="title function_">childNum</span>(<span class="params">num, count</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> allplayer = [];    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; num; i++)&#123;</span><br><span class="line">        allplayer[i] = i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> exitCount = <span class="number">0</span>;    <span class="comment">// 离开人数</span></span><br><span class="line">    <span class="keyword">let</span> counter = <span class="number">0</span>;      <span class="comment">// 记录报数</span></span><br><span class="line">    <span class="keyword">let</span> curIndex = <span class="number">0</span>;     <span class="comment">// 当前下标</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(exitCount &lt; num - <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(allplayer[curIndex] !== <span class="number">0</span>) counter++;    </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(counter == count)&#123;</span><br><span class="line">            allplayer[curIndex] = <span class="number">0</span>;                 </span><br><span class="line">            counter = <span class="number">0</span>;</span><br><span class="line">            exitCount++;  </span><br><span class="line">        &#125;</span><br><span class="line">        curIndex++;</span><br><span class="line">        <span class="keyword">if</span>(curIndex == num)&#123;</span><br><span class="line">            curIndex = <span class="number">0</span>               </span><br><span class="line">        &#125;;           </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; num; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(allplayer[i] !== <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> allplayer[i]</span><br><span class="line">        &#125;      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">childNum</span>(<span class="number">30</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><h3 id="4-用Promise实现图片的异步加载"><a href="#4-用Promise实现图片的异步加载" class="headerlink" title="4. 用Promise实现图片的异步加载"></a>4. 用Promise实现图片的异步加载</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="keyword">let</span> <span class="title function_">imageAsync</span>=(<span class="params">url</span>)=&gt;&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">                <span class="keyword">let</span> img = <span class="keyword">new</span> <span class="title class_">Image</span>();</span><br><span class="line">                img.<span class="property">src</span> = url;</span><br><span class="line">                img.οnlοad=<span class="function">()=&gt;</span>&#123;</span><br><span class="line">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`图片请求成功，此处进行通用操作`</span>);</span><br><span class="line">                    <span class="title function_">resolve</span>(image);</span><br><span class="line">                &#125;</span><br><span class="line">                img.οnerrοr=<span class="function">(<span class="params">err</span>)=&gt;</span>&#123;</span><br><span class="line">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`失败，此处进行失败的通用操作`</span>);</span><br><span class="line">                    <span class="title function_">reject</span>(err);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"><span class="title function_">imageAsync</span>(<span class="string">&quot;url&quot;</span>).<span class="title function_">then</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;加载成功&quot;</span>);</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;加载失败&quot;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="5-实现发布-订阅模式"><a href="#5-实现发布-订阅模式" class="headerlink" title="5. 实现发布-订阅模式"></a>5. 实现发布-订阅模式</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="keyword">class</span> <span class="title class_">EventCenter</span>&#123;</span><br><span class="line">  <span class="comment">// 1. 定义事件容器，用来装事件数组</span></span><br><span class="line"><span class="keyword">let</span> handlers = &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 添加事件方法，参数：事件名 事件方法</span></span><br><span class="line">  <span class="title function_">addEventListener</span>(<span class="params">type, handler</span>) &#123;</span><br><span class="line">    <span class="comment">// 创建新数组容器</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">handlers</span>[type]) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">handlers</span>[type] = []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 存入事件</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">handlers</span>[type].<span class="title function_">push</span>(handler)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. 触发事件，参数：事件名 事件参数</span></span><br><span class="line">  <span class="title function_">dispatchEvent</span>(<span class="params">type, params</span>) &#123;</span><br><span class="line">    <span class="comment">// 若没有注册该事件则抛出错误</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">handlers</span>[type]) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;该事件未注册&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 触发事件</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">handlers</span>[type].<span class="title function_">forEach</span>(<span class="function"><span class="params">handler</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">handler</span>(...params)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4. 事件移除，参数：事件名 要删除事件，若无第二个参数则删除该事件的订阅和发布</span></span><br><span class="line">  <span class="title function_">removeEventListener</span>(<span class="params">type, handler</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">handlers</span>[type]) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;事件无效&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!handler) &#123;</span><br><span class="line">      <span class="comment">// 移除事件</span></span><br><span class="line">      <span class="keyword">delete</span> <span class="variable language_">this</span>.<span class="property">handlers</span>[type]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> index = <span class="variable language_">this</span>.<span class="property">handlers</span>[type].<span class="title function_">findIndex</span>(<span class="function"><span class="params">el</span> =&gt;</span> el === handler)</span><br><span class="line">      <span class="keyword">if</span> (index === -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;无该绑定事件&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 移除事件</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">handlers</span>[type].<span class="title function_">splice</span>(index, <span class="number">1</span>)</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">handlers</span>[type].<span class="property">length</span> === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">delete</span> <span class="variable language_">this</span>.<span class="property">handlers</span>[type]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-查找文章中出现频率最高的单词"><a href="#6-查找文章中出现频率最高的单词" class="headerlink" title="6. 查找文章中出现频率最高的单词"></a>6. 查找文章中出现频率最高的单词</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="keyword">function</span> <span class="title function_">findMostWord</span>(<span class="params">article</span>) &#123;</span><br><span class="line">  <span class="comment">// 合法性判断</span></span><br><span class="line">  <span class="keyword">if</span> (!article) <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// 参数处理</span></span><br><span class="line">  article = article.<span class="title function_">trim</span>().<span class="title function_">toLowerCase</span>();</span><br><span class="line">  <span class="keyword">let</span> wordList = article.<span class="title function_">match</span>(<span class="regexp">/[a-z]+/g</span>),</span><br><span class="line">    visited = [],</span><br><span class="line">    maxNum = <span class="number">0</span>,</span><br><span class="line">    maxWord = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  article = <span class="string">&quot; &quot;</span> + wordList.<span class="title function_">join</span>(<span class="string">&quot;  &quot;</span>) + <span class="string">&quot; &quot;</span>;</span><br><span class="line">  <span class="comment">// 遍历判断单词出现次数</span></span><br><span class="line">  wordList.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">item</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (visited.<span class="title function_">indexOf</span>(item) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 加入 visited </span></span><br><span class="line">      visited.<span class="title function_">push</span>(item);</span><br><span class="line">      <span class="keyword">let</span> word = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&quot; &quot;</span> + item + <span class="string">&quot; &quot;</span>, <span class="string">&quot;g&quot;</span>),</span><br><span class="line">        num = article.<span class="title function_">match</span>(word).<span class="property">length</span>;</span><br><span class="line">      <span class="keyword">if</span> (num &gt; maxNum) &#123;</span><br><span class="line">        maxNum = num;</span><br><span class="line">        maxWord = item;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> maxWord + <span class="string">&quot;  &quot;</span> + maxNum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-封装异步的fetch，使用async-await方式来使用"><a href="#7-封装异步的fetch，使用async-await方式来使用" class="headerlink" title="7. 封装异步的fetch，使用async await方式来使用"></a>7. 封装异步的fetch，使用async await方式来使用</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">HttpRequestUtil</span> &#123;</span><br><span class="line">        <span class="keyword">async</span> <span class="title function_">get</span>(<span class="params">url</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">fetch</span>(url);</span><br><span class="line">            <span class="keyword">const</span> data = <span class="keyword">await</span> res.<span class="title function_">json</span>();</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">async</span> <span class="title function_">post</span>(<span class="params">url, data</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">fetch</span>(url, &#123;</span><br><span class="line">                <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">                <span class="attr">headers</span>: &#123;</span><br><span class="line">                    <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">body</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(data)</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">const</span> result = <span class="keyword">await</span> res.<span class="title function_">json</span>();</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">async</span> <span class="title function_">put</span>(<span class="params">url, data</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">fetch</span>(url, &#123;</span><br><span class="line">                <span class="attr">method</span>: <span class="string">&#x27;PUT&#x27;</span>,</span><br><span class="line">                <span class="attr">headers</span>: &#123;</span><br><span class="line">                    <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">data</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(data)</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">const</span> result = <span class="keyword">await</span> res.<span class="title function_">json</span>();</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">async</span> <span class="title function_">delete</span>(<span class="params">url, data</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">fetch</span>(url, &#123;</span><br><span class="line">                <span class="attr">method</span>: <span class="string">&#x27;DELETE&#x27;</span>,</span><br><span class="line">                <span class="attr">headers</span>: &#123;</span><br><span class="line">                    <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">data</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(data)</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">const</span> result = <span class="keyword">await</span> res.<span class="title function_">json</span>();</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> httpRequestUtil = <span class="keyword">new</span> <span class="title class_">HttpRequestUtil</span>();</span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">await</span> httpRequestUtil.<span class="title function_">get</span>(<span class="string">&#x27;http://golderbrother.cn/&#x27;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h3 id="8-实现prototype继承"><a href="#8-实现prototype继承" class="headerlink" title="8. 实现prototype继承"></a>8. 实现prototype继承</h3><p>所谓的原型链继承就是让新实例的原型等于父类的实例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="comment">//父方法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SupperFunction</span>(<span class="params">flag1</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">flag1</span> = flag1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子方法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SubFunction</span>(<span class="params">flag2</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">flag2</span> = flag2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//父实例</span></span><br><span class="line"><span class="keyword">var</span> superInstance = <span class="keyword">new</span> <span class="title class_">SupperFunction</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//子继承父</span></span><br><span class="line"><span class="title class_">SubFunction</span>.<span class="property"><span class="keyword">prototype</span></span> = superInstance;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子实例</span></span><br><span class="line"><span class="keyword">var</span> subInstance = <span class="keyword">new</span> <span class="title class_">SubFunction</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="comment">//子调用自己和父的属性</span></span><br><span class="line">subInstance.<span class="property">flag1</span>;   <span class="comment">// true</span></span><br><span class="line">subInstance.<span class="property">flag2</span>;   <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="9-实现双向数据绑定"><a href="#9-实现双向数据绑定" class="headerlink" title="9. 实现双向数据绑定"></a>9. 实现双向数据绑定</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> input = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;input&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> span = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;span&#x27;</span>)</span><br><span class="line"><span class="comment">// 数据劫持</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;text&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;获取数据了&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">set</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;数据更新了&#x27;</span>)</span><br><span class="line">    input.<span class="property">value</span> = newVal</span><br><span class="line">    span.<span class="property">innerHTML</span> = newVal</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 输入监听</span></span><br><span class="line">input.<span class="title function_">addEventListener</span>(<span class="string">&#x27;keyup&#x27;</span>, <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  obj.<span class="property">text</span> = e.<span class="property">target</span>.<span class="property">value</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="10-实现简单路由"><a href="#10-实现简单路由" class="headerlink" title="10. 实现简单路由"></a>10. 实现简单路由</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="comment">// hash路由</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Route</span>&#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">// 路由存储对象</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">routes</span> = &#123;&#125;</span><br><span class="line">    <span class="comment">// 当前hash</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">currentHash</span> = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="comment">// 绑定this，避免监听时this指向改变</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">freshRoute</span> = <span class="variable language_">this</span>.<span class="property">freshRoute</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>)</span><br><span class="line">    <span class="comment">// 监听</span></span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;load&#x27;</span>, <span class="variable language_">this</span>.<span class="property">freshRoute</span>, <span class="literal">false</span>)</span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;hashchange&#x27;</span>, <span class="variable language_">this</span>.<span class="property">freshRoute</span>, <span class="literal">false</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 存储</span></span><br><span class="line">  storeRoute (path, cb) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">routes</span>[path] = cb || <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 更新</span></span><br><span class="line">  freshRoute () &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">currentHash</span> = location.<span class="property">hash</span>.<span class="title function_">slice</span>(<span class="number">1</span>) || <span class="string">&#x27;/&#x27;</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">routes</span>[<span class="variable language_">this</span>.<span class="property">currentHash</span>]()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-实现斐波那契数列"><a href="#11-实现斐波那契数列" class="headerlink" title="11. 实现斐波那契数列"></a>11. 实现斐波那契数列</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="comment">// 递归</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span> (n)&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">fn</span>(n-<span class="number">2</span>)+<span class="title function_">fn</span>(n-<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 优化</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fibonacci2</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">const</span> arrLen = arr.<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n &lt;= arrLen) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr[n];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = arrLen; i &lt; n; i++) &#123;</span><br><span class="line">        arr.<span class="title function_">push</span>(arr[i - <span class="number">1</span>] + arr[ i - <span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arr[arr.<span class="property">length</span> - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 非递归</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> pre1 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> pre2 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> current = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> current;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">        pre1 = pre2;</span><br><span class="line">        pre2 = current;</span><br><span class="line">        current = pre1 + pre2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> current;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12-字符串出现的不重复最长长度"><a href="#12-字符串出现的不重复最长长度" class="headerlink" title="12. 字符串出现的不重复最长长度"></a>12. 字符串出现的不重复最长长度</h3><p>用一个滑动窗口装没有重复的字符，枚举字符记录最大值即可。用 map 维护字符的索引，遇到相同的字符，把左边界移动过去即可。挪动的过程中记录最大长度：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="keyword">var</span> lengthOfLongestSubstring = <span class="keyword">function</span> (<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">    <span class="keyword">let</span> i = -<span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> n = s.<span class="property">length</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.<span class="title function_">has</span>(s[j])) &#123;</span><br><span class="line">            i = <span class="title class_">Math</span>.<span class="title function_">max</span>(i, map.<span class="title function_">get</span>(s[j]))</span><br><span class="line">        &#125;</span><br><span class="line">        res = <span class="title class_">Math</span>.<span class="title function_">max</span>(res, j - i)</span><br><span class="line">        map.<span class="title function_">set</span>(s[j], j)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="13-使用-setTimeout-实现-setInterval"><a href="#13-使用-setTimeout-实现-setInterval" class="headerlink" title="13. 使用 setTimeout 实现 setInterval"></a>13. 使用 setTimeout 实现 setInterval</h3><p>setInterval 的作用是每隔一段指定时间执行一个函数，但是这个执行不是真的到了时间立即执行，它真正的作用是每隔一段时间将事件加入事件队列中去，只有当当前的执行栈为空的时候，才能去从事件队列中取出事件执行。所以可能会出现这样的情况，就是当前执行栈执行的时间很长，导致事件队列里边积累多个定时器加入的事件，当执行栈结束的时候，这些事件会依次执行，因此就不能到间隔一段时间执行的效果。</p><p>针对 setInterval 的这个缺点，我们可以使用 setTimeout 递归调用来模拟 setInterval，这样我们就确保了只有一个事件结束了，我们才会触发下一个定时器事件，这样解决了 setInterval 的问题。</p><p>实现思路是使用递归函数，不断地去执行 setTimeout 从而达到 setInterval 的效果</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="keyword">function</span> <span class="title function_">mySetInterval</span>(<span class="params">fn, timeout</span>) &#123;</span><br><span class="line">  <span class="comment">// 控制器，控制定时器是否继续执行</span></span><br><span class="line">  <span class="keyword">var</span> timer = &#123;</span><br><span class="line">    <span class="attr">flag</span>: <span class="literal">true</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 设置递归函数，模拟定时器执行。</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">interval</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (timer.<span class="property">flag</span>) &#123;</span><br><span class="line">      <span class="title function_">fn</span>();</span><br><span class="line">      <span class="built_in">setTimeout</span>(interval, timeout);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 启动定时器</span></span><br><span class="line">  <span class="built_in">setTimeout</span>(interval, timeout);</span><br><span class="line">  <span class="comment">// 返回控制器</span></span><br><span class="line">  <span class="keyword">return</span> timer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="14-实现-jsonp"><a href="#14-实现-jsonp" class="headerlink" title="14. 实现 jsonp"></a>14. 实现 jsonp</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="comment">// 动态的加载js文件</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addScript</span>(<span class="params">src</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">  script.<span class="property">src</span> = src;</span><br><span class="line">  script.<span class="property">type</span> = <span class="string">&quot;text/javascript&quot;</span>;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(script);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">addScript</span>(<span class="string">&quot;http://xxx.xxx.com/xxx.js?callback=handleRes&quot;</span>);</span><br><span class="line"><span class="comment">// 设置一个全局的callback函数来接收回调结果</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">handleRes</span>(<span class="params">res</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 接口返回的数据格式</span></span><br><span class="line"><span class="title function_">handleRes</span>(&#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;);</span><br></pre></td></tr></table></figure><h3 id="15-判断对象是否存在循环引用"><a href="#15-判断对象是否存在循环引用" class="headerlink" title="15. 判断对象是否存在循环引用"></a>15. 判断对象是否存在循环引用</h3><p>循环引用对象本来没有什么问题，但是序列化的时候就会发生问题，比如调用<code>JSON.stringify()</code>对该类对象进行序列化，就会报错: <code>Converting circular structure to JSON.</code></p><p>下面方法可以用来判断一个对象中是否已存在循环引用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="keyword">const</span> <span class="title function_">isCycleObject</span> = (<span class="params">obj,parent</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> parentArr = parent || [obj];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> obj[i] === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> flag = <span class="literal">false</span>;</span><br><span class="line">            parentArr.<span class="title function_">forEach</span>(<span class="function">(<span class="params">pObj</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(pObj === obj[i])&#123;</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="keyword">if</span>(flag) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            flag = <span class="title function_">isCycleObject</span>(obj[i],[...parentArr,obj[i]]);</span><br><span class="line">            <span class="keyword">if</span>(flag) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> b = &#123;a&#125;;</span><br><span class="line"><span class="keyword">const</span> c = &#123;b&#125;;</span><br><span class="line"><span class="keyword">const</span> o = &#123;<span class="attr">d</span>:&#123;<span class="attr">a</span>:<span class="number">3</span>&#125;,c&#125;</span><br><span class="line">o.<span class="property">c</span>.<span class="property">b</span>.<span class="property">aa</span> = a;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">isCycleObject</span>(o)</span><br></pre></td></tr></table></figure><p>查找有序二维数组的目标值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="keyword">var</span> findNumberIn2DArray = <span class="keyword">function</span>(<span class="params">matrix, target</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix == <span class="literal">null</span> || matrix.<span class="property">length</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> row = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> column = matrix[<span class="number">0</span>].<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (row &lt; matrix.<span class="property">length</span> &amp;&amp; column &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix[row][column] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (matrix[row][column] &gt; target) &#123;</span><br><span class="line">            column--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            row++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>二维数组斜向打印：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="keyword">function</span> <span class="title function_">printMatrix</span>(<span class="params">arr</span>)&#123;</span><br><span class="line">  <span class="keyword">let</span> m = arr.<span class="property">length</span>, n = arr[<span class="number">0</span>].<span class="property">length</span></span><br><span class="line"><span class="keyword">let</span> res = []</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 左上角，从0 到 n - 1 列进行打印</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> k = <span class="number">0</span>; k &lt; n; k++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, j = k; i &lt; m &amp;&amp; j &gt;= <span class="number">0</span>; i++, j--) &#123;</span><br><span class="line">      res.<span class="title function_">push</span>(arr[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 右下角，从1 到 n - 1 行进行打印</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> k = <span class="number">1</span>; k &lt; m; k++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = k, j = n - <span class="number">1</span>; i &lt; m &amp;&amp; j &gt;= <span class="number">0</span>; i++, j--) &#123;</span><br><span class="line">      res.<span class="title function_">push</span>(arr[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 类别 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>加油</title>
      <link href="/posts/8857f1a4.html"/>
      <url>/posts/8857f1a4.html</url>
      
        <content type="html"><![CDATA[<p>文字鉴赏</p><span id="more"></span><h1 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h1><p>我从来不想鹤立鸡群，我只想快点离开那群鸡。我目睹了一场谋杀，但我看不见他，他站在道德的制高点，站在阳光下，怪异的动物会被保护起来，怪异的人会被孤立，圣人也有过去，罪人也有未来，当愚昧成为主流，清醒就成为了犯罪，你要么闭嘴，要么使用他们的语言，每个人都在愤世嫉俗，每个人都在同流合污。你是在拜佛还是在拜自己的欲望。伊洛先生说：有钱能治愈一切自卑，光善良没有用你得优秀，活着就应该遇山开路，遇水架桥，其实，真正让你好起来的只有自律和自信，没有人能阻止你变好，除了你自己，如果你每天只是在床上追逐剧集，刷抖音，不积极运动，到了晚上还为感情问题而怀疑人生，那你迟早会被这个世界抛弃，不要失去信心，在工作中努力拼搏，不努力就会失去你想要的一切，你一定要努力奋斗，努力成为一个出色的人，不要让别人知道你得计划，直到有一天，你可以自由地离开那些让你不舒服的圈子和人，让他们都对你刮目相看。现在开始悄悄努力吧，做最好的自己，等待那些值得的人，趁现在还有时间，全力以赴去完成你一直想做的事情，成为你一直梦寐以求的那种人，过上你一直向往的那种生活。不要在等待中浪费岁月，每一天都给予自己最大的努力，让自己的光芒照亮前行的路，即使面临困难和挫折，也要坚持住，因为在哪些努力中，你将发现自己的价值和无限的可能。</p>]]></content>
      
      
      <categories>
          
          <category> 加油 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 加油 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法复习</title>
      <link href="/posts/fa264d8c.html"/>
      <url>/posts/fa264d8c.html</url>
      
        <content type="html"><![CDATA[<p>算法复习</p><span id="more"></span><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h2><p><img src="https://raw.githubusercontent.com/why862555625/images/main/images/image-20230531202054172.png" alt="image-20230531202054172"></p><p>由于会直接返回翻转链表，最后一个就是翻转后的链表头。因此只需要保留前一个链表，让后一个链表不停的指向前一个链表就可以。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">ReverseList</span>(<span class="params">pHead</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> pred =<span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span>(pHead)&#123;</span><br><span class="line">        [pHead.<span class="property">next</span>,pred,pHead] = [pred,pHead,pHead.<span class="property">next</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pred</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h2><p><img src="https://raw.githubusercontent.com/why862555625/images/main/images/image-20230531225422160.png" alt="image-20230531225422160"></p><p>首先将中间需要翻转的那段拿出来单独翻转，可以将这段的最后一个设为null作为翻转结束的标志。然后将这段在插回来就可以了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">reverse</span>(<span class="params">head</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> pre = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> cur = head;</span><br><span class="line">    <span class="keyword">let</span> next;</span><br><span class="line">    <span class="keyword">while</span>(cur) &#123;</span><br><span class="line">        next = cur.<span class="property">next</span>;</span><br><span class="line">        cur.<span class="property">next</span> = pre;</span><br><span class="line">         </span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [pre, head];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reverseBetween</span>(<span class="params"> head ,  m ,  n </span>) &#123;</span><br><span class="line">    <span class="comment">// 增加一个origin方便返回最终结果 origin.next</span></span><br><span class="line">    <span class="comment">// 因为head也有可能被翻转了</span></span><br><span class="line">    <span class="keyword">const</span> origin = &#123; <span class="attr">next</span>: head &#125;;</span><br><span class="line">    head = origin;</span><br><span class="line">    <span class="keyword">let</span> left, right;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(; i &lt; m - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        head = head.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    left = head;</span><br><span class="line">    <span class="keyword">for</span>(; i &lt; n; i++) &#123;</span><br><span class="line">        head = head.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    right = head.<span class="property">next</span>;</span><br><span class="line">    head.<span class="property">next</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">const</span> [ start, end ] = <span class="title function_">reverse</span>(left.<span class="property">next</span>);</span><br><span class="line">    left.<span class="property">next</span> = start;</span><br><span class="line">    end.<span class="property">next</span> = right;</span><br><span class="line">    <span class="keyword">return</span>  origin.<span class="property">next</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    reverseBetween : reverseBetween</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h2><p><img src="https://raw.githubusercontent.com/why862555625/images/main/images/image-20230531232244456.png" alt="image-20230531232244456"></p><p>和上一题类似 只需要翻转前记录下前一个节点 和后一个节点  然后拼接起来就可以</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">reverse</span>(<span class="params">head</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> pre = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> cur = head;</span><br><span class="line">    <span class="keyword">while</span>(cur) &#123;</span><br><span class="line">        [cur.<span class="property">next</span>,pre,cur] = [pre,cur,cur.<span class="property">next</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [pre, head];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reverseKGroup</span>(<span class="params">head, k</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!head||!head.<span class="property">next</span>||k ==<span class="number">1</span>) <span class="keyword">return</span> head</span><br><span class="line">    <span class="keyword">let</span> result =&#123;<span class="string">&#x27;next&#x27;</span>:head&#125;,</span><br><span class="line">    num = <span class="number">0</span>,</span><br><span class="line">    <span class="comment">//记录前一个翻转列表的尾结点</span></span><br><span class="line">    prev = result</span><br><span class="line">    <span class="comment">//记录下一个翻转开始节点</span></span><br><span class="line">    nextNode = head</span><br><span class="line">    <span class="keyword">while</span>(head)&#123;</span><br><span class="line">        <span class="keyword">if</span>(num+<span class="number">1</span> == k)&#123;</span><br><span class="line">            <span class="comment">//此时head为这一次翻转列表的最后一个节点  需要记录一下下一个翻转周期的开始节点</span></span><br><span class="line">            <span class="keyword">let</span> temp = head.<span class="property">next</span></span><br><span class="line">            head.<span class="property">next</span> = <span class="literal">null</span></span><br><span class="line">            <span class="keyword">let</span> [start,end] = <span class="title function_">reverse</span>(nextNode)</span><br><span class="line">            nextNode  = temp</span><br><span class="line">            prev.<span class="property">next</span> = start</span><br><span class="line">            prev = end</span><br><span class="line">            num = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span>(!nextNode)&#123;<span class="keyword">break</span>&#125;</span><br><span class="line">            head = nextNode.<span class="property">next</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            head = head.<span class="property">next</span></span><br><span class="line">        &#125;</span><br><span class="line">        num ++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(num)&#123;</span><br><span class="line">        <span class="comment">//如果还有剩余 补充到末尾</span></span><br><span class="line">        prev.<span class="property">next</span> = nextNode</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result.<span class="property">next</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">reverseKGroup</span>: reverseKGroup,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="4"><a href="#4" class="headerlink" title="4."></a>4.</h2><p><img src="https://raw.githubusercontent.com/why862555625/images/main/images/image-20230601125414404.png" alt="image-20230601125414404"></p><p>双指针遍历 小的放到新链表中、由于是引用不会增加额外空间</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">Merge</span>(<span class="params">pHead1: ListNode, pHead2: ListNode</span>): <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">let</span> cur = result</span><br><span class="line">    <span class="keyword">while</span>(pHead1&amp;&amp;pHead2)&#123;</span><br><span class="line">        <span class="keyword">if</span>(pHead1.<span class="property">val</span>&gt;pHead2.<span class="property">val</span>)&#123;</span><br><span class="line">            cur .<span class="property">next</span> = pHead2</span><br><span class="line">            pHead2 =pHead2.<span class="property">next</span></span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cur .<span class="property">next</span> = pHead1</span><br><span class="line">            pHead1 =pHead1.<span class="property">next</span></span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.<span class="property">next</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pHead1) </span><br><span class="line">            cur .<span class="property">next</span> = pHead1</span><br><span class="line">    <span class="keyword">if</span>(pHead2) </span><br><span class="line">            cur .<span class="property">next</span> = pHead2</span><br><span class="line">    <span class="keyword">return</span> result.<span class="property">next</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5"><a href="#5" class="headerlink" title="5."></a>5.</h2>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法总结</title>
      <link href="/posts/1213ac56.html"/>
      <url>/posts/1213ac56.html</url>
      
        <content type="html"><![CDATA[<p>算法总结</p><span id="more"></span><h1 id="1-动态规划"><a href="#1-动态规划" class="headerlink" title="1. 动态规划"></a>1. 动态规划</h1><h4 id="传统递归-vs-DP"><a href="#传统递归-vs-DP" class="headerlink" title="传统递归 vs. DP"></a>传统递归 vs. DP</h4><p>先用一个被大佬们举例举到烂的🌰，这个栗子很烂，但是真的<strong>很香</strong>：必须着重<strong>强调</strong>.</p><p><strong>《斐波那契（Fibonacci）数列的第n项》</strong></p><p><strong>举荐理由：</strong>在我自己看来Fibonacci是动态规划设计中的入门级案例，就好比说编程中的“hello world”，大数据中的“word count”.</p><p>Fibonacci几乎完美的诠释了<strong>动态规划带来的思想和技巧</strong>然而没有任何其他的要考虑的细枝末节，这种很清晰的方法看起来很适合整个的动态规划的思维方式，很适合入门来进行的思考方式.</p><p>接下来咱们先来看题目：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">题目复制代码写一个函数，输入n，求斐波那契（Fibonacci）数列的第 n 项。斐波那契数列的定义如下：</span><br><span class="line"></span><br><span class="line">F(0) = 0, F(1) = 1</span><br><span class="line">F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.</span><br><span class="line">斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</span><br></pre></td></tr></table></figure><p>比较一下传统递归解法和动态规划思想下的解决对比</p><h4 id="1-先-递归解决"><a href="#1-先-递归解决" class="headerlink" title="1. 先 递归解决"></a>1. 先 递归解决</h4><p>传统对于这种题目的思考方式会利用递归求解，做起来比较简单，就是不断的去递归调用，看下面代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fib_recur</span>(<span class="params">N</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line">    <span class="keyword">if</span> N &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> N</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">fib_recur</span>(N-<span class="number">1</span>) + <span class="title function_">fib_recur</span>(N-<span class="number">2</span>)  # 递归输出  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出的结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">F( <span class="number">1</span> ) =  <span class="number">3</span></span><br><span class="line">F( <span class="number">2</span> ) =  <span class="number">2</span></span><br><span class="line">F( <span class="number">3</span> ) =  <span class="number">1</span></span><br><span class="line">F( <span class="number">4</span> ) =  <span class="number">0</span></span><br><span class="line">F( <span class="number">5</span> ) =  <span class="number">1</span></span><br><span class="line">F( <span class="number">6</span> ) =  <span class="number">2</span></span><br><span class="line">F( <span class="number">7</span> ) =  <span class="number">1</span></span><br><span class="line">F( <span class="number">8</span> ) =  <span class="number">0</span></span><br></pre></td></tr></table></figure><p><strong>重复计算</strong></p><p>明显可以看到，总计 8 次的计算过程中，相同的计算结果有三对进行了<strong>重复计算</strong>（下图中同色项，不包含灰色），也就是说在递归的过程中，把曾经计算过的项进行了<strong>又一次的重复计算</strong>，这样对于时间效率是比较低的，唯一的好处可能就是代码看起来比较好懂，但是终归不是一个好的算法设计方法。</p><p>代码中，在计算N的时候就去递归计算 <code>fib(N-1) + fib(N-2)</code>，那么，这种情况下的计算过程中。会是下面图中的一个计算过程。</p><p>可以发现，会有相当一部分的重复计算，这样对于时间都是重复的消耗。</p><blockquote><p>参考图中相同颜色的项，比如说粉色的重复计算、黄色的重复计算等</p><p>注意：递归中没有对空间进行了增加，始终都是同样的长度，仅仅是不断的弹出和压入</p></blockquote><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230605114156368.png" alt="image-20230605114156368"></p><p>为了更好的说明这种重复计算带来时间效率的低下。再比如说，相比上述图中的计算节点，再增加一个节点的计算，增加计算F(5)，那么由于递归的计算方式，会有更多的项（下图中线框中部分）进行了重复的计算。在计算<code>F(5)</code>的时候，会递归调用<code>F(4)</code>和<code>F(3)</code>，而在下图中，计算<code>F(4)</code>的时候，又会完整的去计算<code>F(3)</code>。这样，如果N很大的话，会有更大的时间消耗.</p><p>这样，这棵树的规模进行进行成倍增加，时间复杂度很明显的进行了成倍的扩张。对于时间上来说是很恐怖的.</p><p>时间复杂度带来的低效率严重超过了代码的可读性，所以我们可以想办法将<strong>过去计算</strong>过的节点<strong>进行保存</strong>。这样，我们就会用到下面要说的动态规划思想带来的时间上的高效.</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230605114342318.png" alt="image-20230605114342318"></p><blockquote><p>时间复杂度：o(2**n) —&gt; 指数级</p><p>空间复杂度：o(n)</p></blockquote><h4 id="2-后-动态规划解决"><a href="#2-后-动态规划解决" class="headerlink" title="2. 后 动态规划解决"></a>2. 后 动态规划解决</h4><p><strong>大概解释一下字面意思：</strong></p><p><strong>动态规划：我们不直接去解决问题，而是在每一步解决问题的时候，达到每一步的最优情况。换句话说，就是在每一步解决问题过程中，利用过去的状态</strong>以及<strong>当前状态</strong>的情况而达到一个当前的最优状态.</p><p><em>*规划：在一般解决该类问题的时候，会有一个“填表格”的过程，无论是简单情况下的**一维表格**还是复杂一点的</em>*二维表格<strong>，都是以</strong>开辟空间换时间**的思想，以争取最佳的时间效率. （保存过程中间值，方便后续直接使用）.</p><p><strong>动态：</strong>用上面的案例来说，递归解决过程中的每一步都会从基本问题不断的“自顶向下”去求解，在每一步骤中，会有相同的计算逻辑进行了重复的计算。相比于递归思想，动态规划思想增加了对历史上计算结果的保存，逐步记录下中间的计算结果，在每一步求得最优值.</p><p>因此，动态规划可以避免重复计算，达到了时间上的最优，从O(2N)O(2^N)O(2N)指数级变为O(N)O(N)O(N)常数级别，相较于开辟的一段内存空间存放中间过程值的开销，是非常值得的.</p><p><strong>那么，接下来咱们依照动态规划的思路进行对Fibonacci进行下解决</strong></p><p>依据题中的规则：</p><p>F(0) = 0, F(1) = 1</p><p>F(N) = F(N - 1) + F(N - 2),  when N &gt; 1</p><p>那么，👇👇F(N) 的值只与他的前两个状态有关系👇👇</p><p>a. 初始化值 : F(0) = 0, F(1) = 1 b. 想要计算得到F(2)， 那么F(2) = F(0) + F(1)   –&gt;  保存 F(2) c. 想要计算得到F(3)， 那么F(3) = F(2) + F(1)   –&gt;  保存 F(3) d. 想要计算得到F(3)， 那么F(4) = F(3) + F(2)   –&gt;  保存 F(4)</p><p>利用动态规划思想，以一维数组辅助实现的Fibonacci，看下图</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230605114740415.png" alt="image-20230605114740415"></p><p>是不是很简单的思路，仅仅靠保存过程中的一些值就能很简单的利用循环就可以实现了，没必要用递归反复计算进行实现。</p><p>想要计算得到第 n 个值的多少？那么，以下几点是我们必须要做到的</p><p>​    a. <strong>定义一个一维数组</strong>   —&gt;  一般用dp来命名</p><p>​    b. <strong>动态方程的设定</strong>   —&gt;  题中的F(N) = F(N - 1) + F(N - 2)</p><p>​    c. <strong>初始化数值</strong>   —&gt;  F(0) = 0和F(1) = 1</p><p>上述的 a、b 和 c 点就是动态规划思想的几个核心要素</p><p>下面来看下要实现的代码（代码中，用dp来代替上面的F()）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fib</span>(<span class="params">self, N</span>):</span><br><span class="line">        <span class="keyword">if</span> N == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(N+<span class="number">1</span>)] <span class="comment"># 1定义dp[i]保存第i个计算得到的数值</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>   <span class="comment"># 2初始化</span></span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span><span class="comment"># 2初始化</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, N+<span class="number">1</span>):<span class="comment"># 3动态方程实现，由于0和1都实现了赋值，现在需要从第2个位置开始赋值</span></span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>]</span><br><span class="line">       </span><br><span class="line">        <span class="built_in">print</span> dp <span class="comment"># 记录计算过程中的次数，与上述递归形成对比</span></span><br><span class="line">        <span class="keyword">return</span> dp[N]</span><br></pre></td></tr></table></figure><p>输出:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p>以上，最重要的就是1 2 3 点，而执行过程参照<strong>输出</strong>对比递归算法，计算少了很多，同样的计算只计算了一次。</p><blockquote><p>时间复杂度：O(N)</p><p>空间复杂度：O(N)</p></blockquote><p>介绍了上面的内容了，此处来条分割线吧，针对上述的 <strong>递归 vs. DP</strong></p><hr><p>既然动态规划的方案也介绍了，下面咱们再仔细看看，是否有优化的空间，毕竟对于一个算法方案的设计，都有找到其优化点，无论是时间还是空间的效率都想要达到一个理想的值。</p><h4 id="3-动态规划-优化"><a href="#3-动态规划-优化" class="headerlink" title="3. 动态规划 + 优化"></a>3. 动态规划 + 优化</h4><p>咱们看下这张图解，发现每个计算节点都<strong>只与前两个项有关系</strong>。换句话说，咱们只要保存两个值就好了，计算新的节点值的时候，把新的值赋值给前两个值的第一个就好了</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230605115233956.png" alt="image-20230605115233956"></p><p>话说只要两个值，现在定义两个变量 dp1 和 dp2。那么，现在咱们一步一步模拟一下：</p><p>a. 初始化值 : F(0) = 0, F(1) = 1</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230605115254829.png" alt="image-20230605115254829"></p><p>b. 想要计算得到F(2)， 那么F(2) = F(0) + F(1) –&gt; 保存 F(2)</p><p> 顺带将F(1)赋值给dp1， f(2)赋值给dp2</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230605115319902.png" alt="image-20230605115319902"></p><p>c. 想要计算得到F(3)， 那么F(3) = F(2) + F(1) –&gt; 保存 F(3)</p><p> 顺带将F(2)赋值给dp1， F(3)赋值给dp2</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230605115336720.png" alt="image-20230605115336720"></p><p>d. 想要计算得到F(3)， 那么F(4) = F(3) + F(2) –&gt; 保存 F(4)</p><p> 顺带将F(3)赋值给dp1， F(4)赋值给dp2</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230605115356096.png" alt="image-20230605115356096"></p><p>至此为止，整个过程仅仅用到了两个变量来存储过程中产生的值，也就之前没有优化的空间效率得到了优化</p><p>咱们把代码也贴一下吧，供参考</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fib_dp1</span>(<span class="params">self, N</span>):</span><br><span class="line">        <span class="keyword">if</span> N == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        dp1, dp2 = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, N+<span class="number">1</span>):</span><br><span class="line">            dp1 = dp1 + dp2</span><br><span class="line">            dp1, dp2 = dp2, dp1</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp2</span><br></pre></td></tr></table></figure><p>看起来是不是更加简洁了。</p><p>三点说明：<strong>1.定义dp数组 2.动态方程 3.初始化数值</strong></p><p>这也说明了为什么用<strong>斐波那契数列</strong>来引入<strong>动态规划</strong>的，因为斐波那契数列本身就明确的告诉你动态方程是什么，初始化的值是什么，所以好好的体会这种思想，尤其是从传统递归 -&gt; 动态规划的思想解决，再到优化的方面，很值得深思。</p><p>那接下来，咱们就找几个有代表性的栗子来尝尝鲜</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230605115624586.png" alt="image-20230605115624586"></p><h2 id="二、动态规划四大解题步骤处理问题"><a href="#二、动态规划四大解题步骤处理问题" class="headerlink" title="二、动态规划四大解题步骤处理问题"></a>二、动态规划四大解题步骤处理问题</h2><p>上面用斐波那契数列问题，引出了下面的几点，在这里再详细赘述一下</p><p>在后面的案例中将会尽量严格按照这几个步骤进行解决问题</p><blockquote><p>步骤一：定义dp数组的含义</p><p>步骤二：定义状态转移方程</p><p>步骤三：初始化过程转移的初始值</p><p>步骤四：可优化点(可选)</p></blockquote><h4 id="步骤一：定义dp数组的含义"><a href="#步骤一：定义dp数组的含义" class="headerlink" title="步骤一：定义dp数组的含义"></a>步骤一：定义dp数组的含义</h4><p>绝大部分情况下，我们需要定义一维数组或者二维数组进行存储在计算过程中产生的最优值，这里为什么是最优值呢？是因为在解决问题过程中，一般情况dp数组用来保存<strong>从开始到当前情况的最优值</strong>，故而保存的是截止到目前的最优值，避免重复计算（这里看起来思维有混乱的同学们，想想上面Fibonacci 递归解法和动态规划的对比）</p><p><strong>所以，dp无论是一维的还是二维的，要想清楚代表什么，一般来说代表的是截止到目前情况下的最优值</strong></p><h4 id="步骤二：定义状态转移方程"><a href="#步骤二：定义状态转移方程" class="headerlink" title="步骤二：定义状态转移方程"></a>步骤二：定义状态转移方程</h4><p>什么是动态转移方程？ 如果有一个问题摆在我们面前，然后这个问题在解决的过程中，会发现有很多的重叠的子问题，重叠子结构，而通过这些子问题的解决，最终将会把该问题进行解决</p><p>通俗来说，在解决问题过程中，能够发现一个不断解决子问题的动态规律，比如说Fibonacci中的F(N) = F(N - 1) + F(N - 2)，而在其他的可以用动态规划解决的问题中，需要我们自己去发现这样的内在规律。这个是最难的也是最终于要的，只要这一步解决了，接下来我们解决这个问题基本就没问题了.</p><h4 id="步骤三：初始化过程转移的初始值"><a href="#步骤三：初始化过程转移的初始值" class="headerlink" title="步骤三：初始化过程转移的初始值"></a>步骤三：初始化过程转移的初始值</h4><p>顺着步骤二的思路来，既然动态方程定义好了，是不是需要一个<strong>支点</strong>来撬动它进行不断的计算下去。</p><p>那么，这个<strong>支点</strong>就需要我们来初始定义，将动态方程激活，进行计算。举例来说Fibonacci中的F(0) = 0和F(1) = 1，有了这两个值，它的动态方程F(N) = F(N - 1) + F(N - 2)就可以进行下去了</p><p>这个就是我们要想好的初始值，实际问题可能还需要我们想想清楚.</p><h4 id="步骤四：可优化点-可选"><a href="#步骤四：可优化点-可选" class="headerlink" title="步骤四：可优化点(可选)"></a>步骤四：可优化点(可选)</h4><p>可优化的这里，最重要的会是dp数组这块，也会有不同问题不同的优化点</p><p>在例子中，我们会进行不同的优化.</p><p>总之一点，建议大家动笔多画画图，很多细节慢慢就会出现了.</p><h3 id="案例一：打家劫舍I-「来自leetcode198」"><a href="#案例一：打家劫舍I-「来自leetcode198」" class="headerlink" title="案例一：打家劫舍I 「来自leetcode198」"></a>案例一：打家劫舍I 「来自leetcode198」</h3><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">代码输入: [1,2,3,1]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。</span><br><span class="line">     偷窃到的最高金额 = 1 + 3 = 4 。</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="number">2</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">输出: <span class="number">12</span></span><br><span class="line">解释: 偷窃 <span class="number">1</span> 号房屋 (金额 = <span class="number">2</span>), 偷窃 <span class="number">3</span> 号房屋 (金额 = <span class="number">9</span>)，接着偷窃 <span class="number">5</span> 号房屋 (金额 = <span class="number">1</span>)。</span><br><span class="line">     偷窃到的最高金额 = <span class="number">2</span> + <span class="number">9</span> + <span class="number">1</span> = <span class="number">12</span> 。</span><br></pre></td></tr></table></figure><p>把经典案例系列拆分开讨论下吧，咱们首先将「打家劫舍I」来看看</p><p>该题可以用动态规划的思想来解决的原因是，在小偷不断偷取的过程中，始终想要偷得的物品价值最大，最优，每一步骤都与之前的偷取情况有关系，而且每一步都要考虑是否能偷，是否会带来最大利益，这就使得我们可以用动态规划的思想来解决问题。  然后严格按照四步骤进行解题.</p><h5 id="步骤一：-定义dp数组的含义"><a href="#步骤一：-定义dp数组的含义" class="headerlink" title="步骤一： 定义dp数组的含义"></a>步骤一： 定义dp数组的含义</h5><p>​    之前提到的，dp数组存储的值一般代表截止目前的最优值，在该题目中，我们定义：</p><p>​    <strong>dp[i] 代表到达第 i 个房屋偷得的最高金额，也就是当前最大子序和</strong></p><p>​    无论房屋有几间，最后我们取到dp数组的最后一个值就求得小偷偷得的最高金额</p><h5 id="步骤二：找出关系元素间的动态方程"><a href="#步骤二：找出关系元素间的动态方程" class="headerlink" title="步骤二：找出关系元素间的动态方程"></a>步骤二：找出关系元素间的动态方程</h5><p>​    动态规划解决的问题，一般来说就是解决最优子问题，“自顶向下” 的去不断的计算每一步骤的最优值。</p><p>​    也就是想要得到dp[i]的值，我们必须要知道dp[i-1]，dp[i-2]，dp[i-3] … 的每一步的最优值，在这个状态转移的过程中，我们必须要想清楚怎么去定义关系式。然而在每一步的计算中，都与前几项有关系，这个固定的关系就是我们要寻找的重叠子问题，也同样是接下来要详细定义的动态方程</p><p>​    该题目中，当小偷到达第 i 个屋子的时候，他的选择有两种：一种是偷，另外一种是不偷， 然后选择价值较大者</p><p>​    a. 偷的情况计算：必然是dp[3] = nums[2] + dp[1]，如果是偷取该屋子的话，相邻屋子是不能偷取的，因此，通项式子是：dp[i] =  nums[i-1] + dp[i-2]</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230605123128436.png" alt="image-20230605123128436"></p><p> b. 不偷的情况计算：必然是dp[3] = dp[2]，如果是不偷取该屋子的话，相邻屋子就是其最优值，因此，通项式子是：dp[i] = dp[i-1]</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230605123322989.png" alt="image-20230605123322989"></p><p>​    最后，要想偷得最高金额，那么，必须选取在偷与不偷之间的最大值作为我们是否选取的关键点。即：</p><p>​    <strong>动态方程:</strong> dp[i] = max(dp[i-1], nums[i-1]+dp[i-2])</p><h5 id="步骤三：初始化数值设定"><a href="#步骤三：初始化数值设定" class="headerlink" title="步骤三：初始化数值设定"></a>步骤三：初始化数值设定</h5><p>​    初始化: 给没有房子时，dp一个位置，即：dp[0]         1 当size=0时，没有房子，dp[0]=0；         2 当size=1时，有一间房子，偷即可：dp[1]=nums[0]</p><p>那么，按照这个思路来整理一下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rob</span>(<span class="params">self, nums</span>):</span><br><span class="line">      <span class="comment"># 1.dp[i] 代表当前最大子序和</span></span><br><span class="line">      <span class="comment"># 2.动态方程: dp[i] = max(dp[i-1], nums[i-1]+dp[i-2])</span></span><br><span class="line">      <span class="comment"># 3.初始化: 给没有房子时，dp一个位置，即：dp[0]</span></span><br><span class="line">      <span class="comment">#   3.1 当size=0时，没有房子，dp[0]=0；</span></span><br><span class="line">      <span class="comment">#   3.2 当size=1时，有一间房子，偷即可：dp[1]=nums[0]</span></span><br><span class="line">      size = <span class="built_in">len</span>(nums)</span><br><span class="line">      <span class="keyword">if</span> size == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">      dp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size+<span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">      dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">      dp[<span class="number">1</span>] = nums[<span class="number">0</span>]</span><br><span class="line">      <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, size+<span class="number">1</span>):</span><br><span class="line">        dp[i] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>], nums[i-<span class="number">1</span>]+dp[i-<span class="number">2</span>])</span><br><span class="line">        <span class="keyword">return</span> dp[size]</span><br></pre></td></tr></table></figure><blockquote><p>时间复杂度：O(N)</p><p>空间复杂度：O(N)</p></blockquote><p>那下面想想看有没有可优化的地方，尽量的释放一部分计算机资源</p><h5 id="步骤四：优化"><a href="#步骤四：优化" class="headerlink" title="步骤四：优化"></a>步骤四：优化</h5><p>​    从 dp[i] = max(dp[i-1], nums[i-1]+dp[i-2]) 关系来看，每一次动态变化，都与前两次状态有关系（dp[i-1], dp[i-2])，而前面的一些值是没有必要留存的.</p><p>​    所以，dp只需要定义两个变量就好，将空间复杂度降为O(1)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rob_o</span>(<span class="params">self, nums</span>):</span><br><span class="line">        <span class="comment"># 依照上面的思路，其实我们用到的数据永远都是dp的dp[i-1]和dp[i-2]两个变量</span></span><br><span class="line">        <span class="comment"># 因此，我们可以使用两个变量来存放前两个状态值</span></span><br><span class="line">        <span class="comment"># 空间使用由O(N) -&gt; O(1)</span></span><br><span class="line"></span><br><span class="line">        size = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> size == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        dp1 = <span class="number">0</span></span><br><span class="line">        dp2 = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, size+<span class="number">1</span>):</span><br><span class="line">            dp1 = <span class="built_in">max</span>(dp2, nums[i-<span class="number">1</span>]+dp1)</span><br><span class="line">            dp1, dp2 = dp2, dp1</span><br><span class="line">        <span class="keyword">return</span> dp2</span><br></pre></td></tr></table></figure><blockquote><p>时间复杂度：O(N)</p><p>空间复杂度：O(1)</p></blockquote><p>说完《打家劫舍I 》，中间穿插另外一道题目，利用二维dp来解决的一个问题。</p><p>最后再说说《打家劫舍II 》和《打家劫舍III》，把这一系列的<strong>打家劫舍</strong>问题搞明白了，相信你对动态规划有一个较为深刻的入门体验</p><h3 id="案例二：不同路径「来自leetcode62」"><a href="#案例二：不同路径「来自leetcode62」" class="headerlink" title="案例二：不同路径「来自leetcode62」"></a>案例二：不同路径「来自leetcode62」</h3><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p><p>问总共有多少条不同的路径？</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230605130822926.png" alt="image-20230605130822926"></p><p><strong>示例 1:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: m = <span class="number">3</span>, n = <span class="number">2</span></span><br><span class="line">输出: <span class="number">3</span></span><br><span class="line">解释:</span><br><span class="line">从左上角开始，总共有 <span class="number">3</span> 条路径可以到达右下角。</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 向右 -&gt; 向右 -&gt; 向下</span><br><span class="line"><span class="number">2.</span> 向右 -&gt; 向下 -&gt; 向右</span><br><span class="line"><span class="number">3.</span> 向下 -&gt; 向右 -&gt; 向右</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python复制代码输入: m = <span class="number">7</span>, n = <span class="number">3</span></span><br><span class="line">输出: <span class="number">28</span></span><br></pre></td></tr></table></figure><p><em>提示：</em></p><p>1 &lt;= m, n &lt;= 100 题目数据保证答案小于等于 2 * 10 ^ 9</p><p>下面依然按照四个步骤来进行讨论：</p><h5 id="步骤一：定义dp数组的含义-1"><a href="#步骤一：定义dp数组的含义-1" class="headerlink" title="步骤一：定义dp数组的含义"></a>步骤一：定义dp数组的含义</h5><p>​    当前这道题是从左上角到右下角的，题目中规定只能向右或者向下走，所以我们必须要定义一个二维数组来保存计算过程中的值。所以，这块定义：</p><p>​    <strong>dp[i][j]: 代表到达位置 (i, j) 的所有路径的总数</strong></p><p>​    即：机器人从左上角到右下角所有路径的总和，dp中每个位置的值代表行走到达 (i, j) 每个位置的总共的路径数</p><h5 id="步骤二：找出关系元素间的动态方程-1"><a href="#步骤二：找出关系元素间的动态方程-1" class="headerlink" title="步骤二：找出关系元素间的动态方程"></a>步骤二：找出关系元素间的动态方程</h5><p>​    由于题目中规定只能向右或者向下走，所以在机器人行进的时候，只能是向右或向下.</p><p>​    那么，分别讨论下两种情况，想要到达位置(i, j)，可以从位置(i-1, j)或者(i, j-1)出发到达。因此，到达位置(i, j) 的总的路径数一定是 <strong>到达位置(i-1, j)路径数</strong> + <strong>到达位置(i, j-1)路径数</strong>。那么，现在可以定义动态方程：</p><p>​    <strong>动态方程：dp[i][j] = dp[i-1][j] + dp[i][j-1]</strong></p><h5 id="步骤三：初始化数值设定-1"><a href="#步骤三：初始化数值设定-1" class="headerlink" title="步骤三：初始化数值设定"></a>步骤三：初始化数值设定</h5><p>​    很明显，在机器人走第 0 行，第 0 列的时候，无论怎么走，都只有 1 种走法。</p><p>​    因此，初始化值的设定，一定是 dp[0..m][1] 或者 dp[1][0..n] 都等于1</p><p>​    因此初始值如下：</p><p>​    <strong>dp[0] [0….n-1] = 1;</strong>  // 机器人一直向右走，第 0 列统统为 1</p><p>​    <strong>dp[0…m-1] [0] = 1;</strong>  // 机器人一直向下走，第 0 列统统为 1</p><p>​    现在，按照这个思路来整理一下代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">uniquePaths1</span>(<span class="params">self, m, n</span>):</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 初始化表格，由于初始化0行 0列都为1。那么，先全部置为1</span></span><br><span class="line">        dp = [[<span class="number">1</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m):</span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j] + dp[i][j-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n-<span class="number">1</span>][m-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>上述代码中由于dp[[0..m][1] ][1]或者 dp[1][0..n] 都等于1，所以在定义二维数组dp时候，统统赋初始值为 1</p><p>然后从位置(1, 1)开始计算每个位置的总路径数</p><blockquote><p>时间复杂度：O(M*N)</p><p>空间复杂度：O(M*N)</p></blockquote><p>既然到这里了，下面再想想看有没有可优化的地方</p><h5 id="步骤四：优化-1"><a href="#步骤四：优化-1" class="headerlink" title="步骤四：优化"></a>步骤四：优化</h5><p>​    可以依照前面的解决的思路，应该也可以从空间上进行一定的优化</p><p>​    参照前面的案例，之前定义的是一维数组dp，优化点是每一步骤都只与前面的两个计算好的数值有关系，然后优化点就是将dp[N] -&gt; dp1和dp2，空间复杂度由 O(N) -&gt; O(1)，如果是很大规模的数据计算的话，空间效率提升了不少.</p><p>​    现在这个例子中的动态方程是**dp[i][j] = dp[i-1][j] + dp[i][j-1]*<em>，很明显，每一步骤中的状态值只与左边相邻的值和上面的值相关。举例（为了方便，用 3</em>4 来举例）：</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230605131507215.png" alt="image-20230605131507215"></p><p>​    这个完整的图片描述中，机器人从左上角的位置(1, 1)开始移动，逐渐每一步都根据动态方程进行前进，明显的可以看出机器人每移动一格，所得到的路径总和只与它的上方和左方数值有关系。也就是我们会发现，机器人移动到第2行的时候，第0行数据完全是没有用的状态。</p><p>​    因此，这个优化点就出来了，在算法设计的时候，dp仅仅定义2行N列的数组就ok了，省去了m-2行的空间开销。这个代码如果大家想明白了请自行设计出来，自己写出来一定会有更加深刻的理解，再强调：多思考，形成潜移默化的思维方式.</p><p>​    看完这个步骤之后，是不是很明显的优化点，为什么上面没有给出大家代码呢？是因为我看到貌似可以继续优化的点（粘住空间优化项了哈哈哈），那就继续在空间开销上做文章。</p><p>​    <strong>引导：</strong>根据上述咱们的优化方案，说道 “机器人移动到第2行的时候，第0行数据完全是没有用的状态”，其实当前聪明的读者你想想，再看看，下面的图中（从上图截取过来）。 其实，不仅仅是第 0 行完全没用了，而且在第2 行做移动的时候，移动到位置(i, j)的时候，计算好位置(i, j)，那么接下来，位置(i-1, j)的数据也就没用了。换句话说，边走，第 1 行开始的某些数据也就没用了，还在占着空间</p><p>​    <strong>这块大家一定多想想，多理解，多画图</strong></p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230605131650290.png" alt="image-20230605131650290"></p><p>下面按照这种思路，看下图的步骤，也画好了用一维数组进行解决问题，也画出来每一步骤与上图的类比过程：</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230605131721361.png" alt="image-20230605131721361"></p><p>在这里，有犯困的同学可以自己动手画一画，理解一下，个人感觉是一个很好的思维扩展</p><p>接下来，就按照这样的思路进行代码实现，会发现码起来很简单</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">uniquePaths2</span>(<span class="params">self, m, n</span>):</span><br><span class="line">        <span class="keyword">if</span> m &gt; n:</span><br><span class="line">            m, n = n, m</span><br><span class="line"></span><br><span class="line">        dp = [<span class="number">1</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m):</span><br><span class="line">                dp[j] = dp[j] + dp[j-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[m-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><blockquote><p>时间复杂度：O(m*n)</p><p>空间复杂度：O(min(m ,n))</p></blockquote><p>是不是从思维方面简单干净了许多</p><p>搞清楚上面的栗子之后呢，我们将上面的例题进行一个简单的难度增加，说白了，就是在路上打几个阻碍点</p><p>来看:</p><h3 id="案例三：不同路径II-「来自leetcode63」"><a href="#案例三：不同路径II-「来自leetcode63」" class="headerlink" title="案例三：不同路径II 「来自leetcode63」"></a>案例三：不同路径II 「来自leetcode63」</h3><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p><p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230605131800138.png" alt="image-20230605131800138"></p><blockquote><p>说明：m 和 n 的值均不超过 100。</p></blockquote><p><strong>示例 1:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">代码输入:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">  [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>],</span><br><span class="line">  [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">]</span><br><span class="line">输出: <span class="number">2</span></span><br><span class="line">解释:</span><br><span class="line">3x3 网格的正中间有一个障碍物。</span><br><span class="line">从左上角到右下角一共有 <span class="number">2</span> 条不同的路径：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下</span><br><span class="line"><span class="number">2.</span> 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右</span><br></pre></td></tr></table></figure><p><strong>咱们先看一下题中的两个关键点：</strong> 关键点1：只能向右或者向下 关键点2：有障碍物为1， 无障碍物为0</p><p>根据 关键点1 和 关键点2 依然按照四个步骤来进行讨论：</p><h5 id="步骤一：定义dp数组的含义-2"><a href="#步骤一：定义dp数组的含义-2" class="headerlink" title="步骤一：定义dp数组的含义"></a>步骤一：定义dp数组的含义</h5><p>这个题目中定义的dp数组是和上一个例题中定义的dp数组的含义是相同的，但由于该题中已经定义有数组obstacleGrid，可以直接利用，无需额外开辟空间 那么，就利用obstacleGrid作为动态规划中存储计算过程中的最优值</p><h5 id="步骤二：找出关系元素间的动态方程-2"><a href="#步骤二：找出关系元素间的动态方程-2" class="headerlink" title="步骤二：找出关系元素间的动态方程"></a>步骤二：找出关系元素间的动态方程</h5><p>参照上一题目，规定动态方程: obstacleGrid[i][j] = obstacleGrid[i-1][j] + obstacleGrid[i][j-1] 由于机器人在移动过程中有障碍物，那么，对上面动态方程加一些限制条件 a.若当前 obstacleGrid[i][j] 为0。那么，直接计算动态方程下的计算过程 b.若当前 obstacleGrid[i][j] 不为0。那么，直接置该位置的值为0</p><p>所以，在进行动态方程遍历的时候，先进行 obstacleGrid[i][j]的判断，再进行动态方程的计算执行</p><h5 id="步骤三：初始化数值设定-2"><a href="#步骤三：初始化数值设定-2" class="headerlink" title="步骤三：初始化数值设定"></a>步骤三：初始化数值设定</h5><p>​    相比于上一题目，相似的是，在机器人走第 0 行，第 0 列的时候，无论怎么走，都只有 1 种走法     但由于有障碍物，那走到障碍物的时候，后面都是走不下去的（下图用第一行来举例）。</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230605131926886.png" alt="image-20230605131926886"></p><p>​    所以，初始化第 0 行，第 0 列的时候，障碍物 1 后面的都是不可达的。所以，初始化行和列的逻辑表达：</p><p>​    <strong>该位置是否可达=前一个位置的状态and该位置能否可达 得到能否到达这个位置</strong></p><p>​    只有前一个位置为1（可达，只有1种方式） ，当前位置为0（无障碍物）这种情况才能到达该位置，然后为该位置设 1 （可达，只有1种方式）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 0 行初始化表达式: </span></span><br><span class="line">obstacleGrid[<span class="number">0</span>][row] = <span class="built_in">int</span>(obstacleGrid[<span class="number">0</span>][row] == <span class="number">0</span> <span class="keyword">and</span> obstacleGrid[<span class="number">0</span>][row-<span class="number">1</span>] == <span class="number">1</span>)</span><br><span class="line"><span class="comment"># 0 列初始化表达式: </span></span><br><span class="line">obstacleGrid[clo][<span class="number">0</span>] = <span class="built_in">int</span>(obstacleGrid[clo][<span class="number">0</span>] == <span class="number">0</span> <span class="keyword">and</span> obstacleGrid[clo-<span class="number">1</span>][<span class="number">0</span>] == <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>这些都准备就绪之后，按照相关思路进行编码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">uniquePathsWithObstacles1</span>(<span class="params">self, obstacleGrid</span>):</span><br><span class="line">      <span class="comment"># 行列长度</span></span><br><span class="line">        m = <span class="built_in">len</span>(obstacleGrid)</span><br><span class="line">        n = <span class="built_in">len</span>(obstacleGrid[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果在位置(0, 0)，哪里都去不了，直接返回0</span></span><br><span class="line">        <span class="keyword">if</span> obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 否则，位置(0, 0)可以到达</span></span><br><span class="line">        obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 初始化 0 列</span></span><br><span class="line">        <span class="keyword">for</span> clo <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m):</span><br><span class="line">            obstacleGrid[clo][<span class="number">0</span>] = <span class="built_in">int</span>(obstacleGrid[clo][<span class="number">0</span>] == <span class="number">0</span> <span class="keyword">and</span> obstacleGrid[clo-<span class="number">1</span>][<span class="number">0</span>] == <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 初始化 0 行</span></span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            obstacleGrid[<span class="number">0</span>][row] = <span class="built_in">int</span>(obstacleGrid[<span class="number">0</span>][row] == <span class="number">0</span> <span class="keyword">and</span> obstacleGrid[<span class="number">0</span>][row-<span class="number">1</span>] == <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 从位置(1, 1)根据动态方程开始计算</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">                <span class="keyword">if</span> obstacleGrid[i][j] == <span class="number">0</span>:</span><br><span class="line">                    obstacleGrid[i][j] = obstacleGrid[i-<span class="number">1</span>][j] + obstacleGrid[i][j-<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    obstacleGrid[i][j] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> obstacleGrid[m-<span class="number">1</span>][n-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><blockquote><p>时间复杂度: O(mxn)</p><p>空间复杂度: O(1)</p></blockquote><h5 id="步骤四：优化-2"><a href="#步骤四：优化-2" class="headerlink" title="步骤四：优化"></a>步骤四：优化</h5><p>​    这块的优化先不谈了，这里基本没有什么优化点，之前都是由于自己要开辟内存空间，通过空间的优化来进行，而本题是在给定的数组中进行操作的</p><p>有了这几个案例的基础之后，咱们后面把经典的《打家劫舍》系列剩下的两个题目讨论完，就先告一段落，后面也希望以不同的方式与大家多多交流，互相学习</p><p>如果有读者看着累了，可以先保存，收藏下来，待消化了前面的内容，方便再回来看看。</p><h3 id="案例四：打家劫舍II-「来自leetcode213」"><a href="#案例四：打家劫舍II-「来自leetcode213」" class="headerlink" title="案例四：打家劫舍II 「来自leetcode213」"></a>案例四：打家劫舍II 「来自leetcode213」</h3><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。</p><p><strong>示例 1:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python复制代码输入: [<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>]</span><br><span class="line">输出: <span class="number">3</span></span><br><span class="line">解释: 你不能先偷窃 <span class="number">1</span> 号房屋（金额 = <span class="number">2</span>），然后偷窃 <span class="number">3</span> 号房屋（金额 = <span class="number">2</span>）, 因为他们是相邻的。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">python复制代码输入: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">输出: <span class="number">4</span></span><br><span class="line">解释: 你可以先偷窃 <span class="number">1</span> 号房屋（金额 = <span class="number">1</span>），然后偷窃 <span class="number">3</span> 号房屋（金额 = <span class="number">3</span>）。</span><br><span class="line">     偷窃到的最高金额 = <span class="number">1</span> + <span class="number">3</span> = <span class="number">4</span> 。</span><br></pre></td></tr></table></figure><p>与《打家劫舍I》不同的是，《打家劫舍I》的屋子是线性的，而《打家劫舍II》是环状的，所以要考虑的点会增加一些，因为首位相连接的情况，咱们分为下面三种情况进行设定：</p><p>a. 不偷首偷尾</p><p>b. 偷首不偷尾</p><p>c. 首位都不偷 显然，c 种方式损失太大，不会获得最高的金额，故选取 a 和 b。 那么，下面分为两种情况，分别计算不包含首和不包含尾这两种情况来判断小偷哪种方式偷取的金额最高。</p><p>下面依然按照之前的四个步骤来进行分析</p><h5 id="步骤一：-定义dp数组的含义-1"><a href="#步骤一：-定义dp数组的含义-1" class="headerlink" title="步骤一： 定义dp数组的含义"></a>步骤一： 定义dp数组的含义</h5><p>​    dp[i] 代表的含义和之前一致，dp数组存储的值一般代表截止目前的最优值</p><p>​    所以，<strong>dp[i] 代表到达第 i 个房屋偷得的最高金额，也就是当前最大子序和</strong></p><p>​    但是最后会讨论<strong>不包含首</strong>和<strong>不包含尾</strong>这两种情况下得到的dp数组的最后一位，然后获取其中较大者，就是我们要取得的最高金额</p><h5 id="步骤二：找出关系元素间的动态方程-3"><a href="#步骤二：找出关系元素间的动态方程-3" class="headerlink" title="步骤二：找出关系元素间的动态方程"></a>步骤二：找出关系元素间的动态方程</h5><p>​    动态方程可参照《打家劫舍I》，有很详细的图解过程，该例子动态方程的变化和之前是完全一致的：</p><p>​    <strong>dp[i] = max(dp[i-1], nums[i-1]+dp[i-2])</strong></p><h5 id="步骤三：初始化设定"><a href="#步骤三：初始化设定" class="headerlink" title="步骤三：初始化设定"></a>步骤三：初始化设定</h5><p>​    初始化: 给没有房子时，dp一个位置，即：dp[0]         a. 当size=0时，没有房子，小偷没办法偷：dp[0]=0；         b. 当size=1时，有一间房子，只要偷即可：dp[1]=nums[0]</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/imagesimage-20230605150914733.png" alt="image-20230605150914733"></p><p>​    由于屋子首位相连接，所以在计算时候，直接分为两种情况。第一种略过第一个屋子，第二种略过第二个屋子，这样得到的两个数组结果。最后只要比较最后一位数值的大小就ok了。解决！</p><p>该例子步骤三之后，感兴趣的同学可以自己写一下代码，和《打家劫舍I》的代码很类似，后面我写了优化后的代码，可能会更加的明白怎么写。咱们直接到步骤四，有了上面的案例，直接来看看优化后的方案:</p><h5 id="步骤四：优化-3"><a href="#步骤四：优化-3" class="headerlink" title="步骤四：优化"></a>步骤四：优化</h5><p>​    同样从 dp[i] = max(dp[i-1], nums[i-1]+dp[i-2]) 关系来看，每一次动态变化，都与前两次状态有关系（dp[i-1], dp[i-2])，而前面的一些值是没有必要留存的，只要保存两个变量来保存过程最优值就好.</p><p>​    代码中有详细的注释：</p><pre><code>class Solution(object):def rob(self, nums):    # 点睛：与打家劫舍I的区别是屋子围成了一个环    #   那么，很明显可以分为三种情况：    #   1. 首位都不偷    #   2. 偷首不偷尾    #   3. 不偷首偷尾    # 显然，第1种方式损失太大，选取2、3。    # 那么，分为两种情况，分别计算不包含首和不包含尾这两种情况来判断哪个大哪个小    # 1.dp[i] 代表当前最大子序和    # 2.动态方程: dp[i] = max(dp[i-1] and , nums[i-1]+dp[i-2])    # 3.初始化: 给没有房子时，dp一个位置，即：dp[0]    #   3.1 当size=0时，没有房子，dp[0]=0；    #   3.2 当size=1时，有一间房子，偷即可：dp[1]=nums[0]    # 依照《打家劫舍I》的优化方案进行计算    # nums处理，分别切割出去首和去尾的子串    nums1 = nums[1:]    nums2 = nums[:-1]    size = len(nums)    if size == 0:        return 0    if size == 1:        return nums[0]    def handle(size, nums):        dp1 = 0        dp2 = nums[0]        for i in range(2, size+1):            dp1 = max(dp2, nums[i-1]+dp1)            dp1, dp2 = dp2, dp1        return dp2    res1 = handle(size-1, nums1)    res2 = handle(size-1, nums2)    return max(res1, res2)</code></pre><blockquote><p>时间复杂度：O(N)</p><p>空间复杂度：O(1)</p></blockquote><p>再看看下面小偷遇到的情况，感叹：即使当小偷，也要步步规划才能拿到最高的金额啊…</p><h3 id="案例五：打家劫舍III-「来自leetcode337」"><a href="#案例五：打家劫舍III-「来自leetcode337」" class="headerlink" title="案例五：打家劫舍III 「来自leetcode337」"></a>案例五：打家劫舍III 「来自leetcode337」</h3><p>在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。</p><p>计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。</p><p><strong>示例 1:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">代码输入: [<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,null,<span class="number">3</span>,null,<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">     <span class="number">3</span></span><br><span class="line">/ \</span><br><span class="line">   <span class="number">2</span>   <span class="number">3</span></span><br><span class="line">    \   \ </span><br><span class="line">     <span class="number">3</span>   <span class="number">1</span></span><br><span class="line"></span><br><span class="line">输出: <span class="number">7</span> </span><br><span class="line">解释: 小偷一晚能够盗取的最高金额 = <span class="number">3</span> + <span class="number">3</span> + <span class="number">1</span> = <span class="number">7.</span></span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">3</span>,null,<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">  <span class="number">3</span></span><br><span class="line">/ \</span><br><span class="line">   <span class="number">4</span>   <span class="number">5</span></span><br><span class="line">  / \   \ </span><br><span class="line"> <span class="number">1</span>   <span class="number">3</span>   <span class="number">1</span></span><br><span class="line">输出: <span class="number">9</span></span><br><span class="line">解释: 小偷一晚能够盗取的最高金额 = <span class="number">4</span> + <span class="number">5</span> = <span class="number">9.</span></span><br></pre></td></tr></table></figure><p>题目出的很好，但是立马会给人一种小偷也不是好当的的赶脚…</p><p>言归正传，咱们先来说说题目本身</p><p>《打家劫舍》的小偷从一维线性到环形，再到二维矩形的屋子？是我想简单了，直接就干到树形了，是不是看着很香，而且很想，看下去，研究研究…</p><p>来整理几点思路，再来按照四步走：</p><p>1.由于房屋是树状的，因此，我们可以使用遍历树的传统方法进行遍历(前序、中序、后续) 2.简单的思路是，从树低进行往上遍历，拿到最优的打劫值。可以选用后续遍历 3.得到每一节点的最优值，最后选取最优的结果</p><p>依然按照三个步骤来进行分析（无优化点）</p><h5 id="步骤一：-定义dp数组的含义-2"><a href="#步骤一：-定义dp数组的含义-2" class="headerlink" title="步骤一： 定义dp数组的含义"></a>步骤一： 定义dp数组的含义</h5><p>​    dp[i]代表该节点及以下打最多的劫（拿到最多的钱）</p><h5 id="步骤二：找出关系元素间的动态方程-4"><a href="#步骤二：找出关系元素间的动态方程-4" class="headerlink" title="步骤二：找出关系元素间的动态方程"></a>步骤二：找出关系元素间的动态方程</h5><p>​    根据我们每走到一个节点，都会有两种情况，那就是 <strong>偷(1)</strong> 与 **不偷(0)**。我们分开来讨论：</p><p>​    a. 用 <strong>dp[0]</strong> 代表不偷取该节点到目前为止拿到最多的钱，那么儿子节点偷不偷都ok。</p><p>​        所以： <strong>dp[0] = max(left[0], left[1]) + max(right[0], right[1])</strong></p><p>​    b. 用 <strong>dp[1]</strong> 代表偷了该节点到目前为止拿到最多的钱，则儿子节点都不能被偷。</p><p>​        所以：<strong>dp[1] = value + left[0] + right[0]</strong>  (value代表该节点的价值)</p><p>​    有看不懂的地方吗？再紧接着解释一下：</p><p>​        left[0]代表不偷取左孩子拿到最高的金额</p><p>​        left[1]代表偷取左孩子拿到最高的金额</p><p>​        right[0]代表不偷取右孩子拿到最高的金额</p><p>​        right[1]代表偷取右孩子拿到最高的金额</p><p>​    <em>如果还有不太懂的话，留言或者私信我联系我，随时骚扰我哈</em></p><h5 id="步骤三：初始化设定-1"><a href="#步骤三：初始化设定-1" class="headerlink" title="步骤三：初始化设定"></a>步骤三：初始化设定</h5><p>​    该例子的初始化比较简单，就是当前树的形状为空的时候，直接返回dp[0, 0]</p><p>下面贴出完整代码，其中包含<strong>树的初始化</strong>代码 &amp;&amp; 一大堆的注释：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x</span>):</span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rob</span>(<span class="params">self, root</span>):</span><br><span class="line">        <span class="comment"># 说明：</span></span><br><span class="line">        <span class="comment"># 1.由于房屋是树状的，因此，我们可以使用遍历树的传统方法进行遍历(前序、中序、后续)</span></span><br><span class="line">        <span class="comment"># 2.简单的思路是，从树低进行往上遍历，拿到最优的打劫值。可以选用后续遍历</span></span><br><span class="line">        <span class="comment"># 3.得到每一节点的最优值，最后选取最优的结果</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 1.dp[i]代表该节点及以下拿到的最多的钱</span></span><br><span class="line">        <span class="comment"># 2.动态方程：</span></span><br><span class="line">        <span class="comment">#   2.1 dp[0]代表不偷该节点拿到最多的钱，则儿子节点偷不偷都ok。dp[0] = max(left[0], left[1]) + max(right[0], right[1])</span></span><br><span class="line">        <span class="comment">#   2.2 dp[1]代表偷了该节点拿到最多的钱，则儿子节点都不能被偷。dp[1] = var + left[0] + right[0]</span></span><br><span class="line">        <span class="comment"># 3.初始化：当前树的形状为空的时候，直接返回dp[0, 0]</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">postTrasval</span>(<span class="params">root</span>):</span><br><span class="line">            dp = [<span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> dp</span><br><span class="line">            left = postTrasval(root.left)</span><br><span class="line">            right = postTrasval(root.right)</span><br><span class="line"></span><br><span class="line">            dp[<span class="number">0</span>] = <span class="built_in">max</span>(left[<span class="number">0</span>], left[<span class="number">1</span>]) + <span class="built_in">max</span>(right[<span class="number">0</span>], right[<span class="number">1</span>])</span><br><span class="line">            dp[<span class="number">1</span>] = root.val + left[<span class="number">0</span>] + right[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">return</span> dp</span><br><span class="line">        dp = postTrasval(root)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp[<span class="number">0</span>], dp[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># initial tree structure</span></span><br><span class="line">    T = TreeNode(<span class="number">3</span>)</span><br><span class="line">    T.left = TreeNode(<span class="number">2</span>)</span><br><span class="line">    T.right = TreeNode(<span class="number">3</span>)</span><br><span class="line">    T.left.right = TreeNode(<span class="number">3</span>)</span><br><span class="line">    T.right.right = TreeNode(<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># The solution to the Question</span></span><br><span class="line">    s = Solution()</span><br><span class="line">    <span class="built_in">print</span>(s.rob(T))</span><br></pre></td></tr></table></figure><h1 id="2-递归"><a href="#2-递归" class="headerlink" title="2. 递归"></a>2. 递归</h1>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端工程化</title>
      <link href="/posts/7db00131.html"/>
      <url>/posts/7db00131.html</url>
      
        <content type="html"><![CDATA[<p>前端工程化</p><span id="more"></span>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react复习</title>
      <link href="/posts/667b4089.html"/>
      <url>/posts/667b4089.html</url>
      
        <content type="html"><![CDATA[<p>摘要</p><span id="more"></span>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络</title>
      <link href="/posts/50daec4.html"/>
      <url>/posts/50daec4.html</url>
      
        <content type="html"><![CDATA[<p>摘要</p><span id="more"></span>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端安全问题</title>
      <link href="/posts/ab232981.html"/>
      <url>/posts/ab232981.html</url>
      
        <content type="html"><![CDATA[<p>摘要</p><span id="more"></span>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue复习</title>
      <link href="/posts/c9a941a3.html"/>
      <url>/posts/c9a941a3.html</url>
      
        <content type="html"><![CDATA[<p>vue复习</p><span id="more"></span><h3 id="MVVM模型？"><a href="#MVVM模型？" class="headerlink" title="MVVM模型？"></a>MVVM模型？</h3><p>MVVM，是<code>Model-View-ViewModel</code>的简写，其本质是<code>MVC</code>模型的升级版。其中 <code>Model</code> 代表数据模型，<code>View</code> 代表看到的页面，<code>ViewModel</code>是<code>View</code>和<code>Model</code>之间的桥梁，数据会绑定到<code>ViewModel</code>层并自动将数据渲染到页面中，视图变化的时候会通知<code>ViewModel</code>层更新数据。以前是通过操作<code>DOM</code>来更新视图，现在是<code>数据驱动视图</code>。</p><h3 id="Vue的生命周期"><a href="#Vue的生命周期" class="headerlink" title="Vue的生命周期"></a>Vue的生命周期</h3><p>Vue 的生命周期可以分为8个阶段：创建前后、挂载前后、更新前后、销毁前后，以及一些特殊场景的生命周期。Vue 3 中还新增了是3个用于调试和服务端渲染的场景。</p><table><thead><tr><th>Vue 2中的生命周期钩子</th><th>Vue 3选项式API的生命周期选项</th><th>Vue 3 组合API中生命周期钩子</th><th>描述</th></tr></thead><tbody><tr><td><code>beforeCreate</code></td><td><code>beforeCreate</code></td><td><code>setup()</code></td><td>创建前，此时<code>data</code>和 <code>methods</code>的数据都还没有初始化</td></tr><tr><td><code>created</code></td><td><code>created</code></td><td><code>setup()</code></td><td>创建后，<code>data</code>中有值，尚未挂载，可以进行一些<code>Ajax</code>请求</td></tr><tr><td><code>beforeMount</code></td><td><code>beforeMount</code></td><td><code>onBeforeMount</code></td><td>挂载前，会找到虚拟<code>DOM</code>，编译成<code>Render</code></td></tr><tr><td><code>mounted</code></td><td><code>mounted</code></td><td><code>onMounted</code></td><td>挂载后，<code>DOM</code>已创建，可用于获取访问数据和<code>DOM</code>元素</td></tr><tr><td><code>beforeUpdate</code></td><td><code>beforeUpdate</code></td><td><code>onBeforeUpdate</code></td><td>更新前，可用于获取更新前各种状态</td></tr><tr><td><code>updated</code></td><td><code>updated</code></td><td><code>onUpdated</code></td><td>更新后，所有状态已是最新</td></tr><tr><td><code>beforeDestroy</code></td><td><code>beforeUnmount</code></td><td><code>onBeforeUnmount</code></td><td>销毁前，可用于一些定时器或订阅的取消</td></tr><tr><td><code>destroyed</code></td><td><code>unmounted</code></td><td><code>onUnmounted</code></td><td>销毁后，可用于一些定时器或订阅的取消</td></tr><tr><td><code>activated</code></td><td><code>activated</code></td><td><code>onActivated</code></td><td><code>keep-alive</code>缓存的组件激活时</td></tr><tr><td><code>deactivated</code></td><td><code>deactivated</code></td><td><code>onDeactivated</code></td><td><code>keep-alive</code>缓存的组件停用时</td></tr><tr><td><code>errorCaptured</code></td><td><code>errorCaptured</code></td><td><code>onErrorCaptured</code></td><td>捕获一个来自子孙组件的错误时调用</td></tr><tr><td>—</td><td><code>renderTracked</code></td><td><code>onRenderTracked</code></td><td>调试钩子，响应式依赖被收集时调用</td></tr><tr><td>—</td><td><code>renderTriggered</code></td><td><code>onRenderTriggered</code></td><td>调试钩子，响应式依赖被触发时调用</td></tr><tr><td>—</td><td><code>serverPrefetch</code></td><td><code>onServerPrefetch</code></td><td>组件实例在服务器上被渲染前调用</td></tr></tbody></table><p><strong>关于Vue 3中的生命周期建议阅读官方文档!!!!</strong></p><p><a href="https://link.juejin.cn/?target=https://cn.vuejs.org/api/composition-api-lifecycle.html">组合式 API：生命周期钩子–官方文档</a><br><a href="https://link.juejin.cn/?target=https://cn.vuejs.org/api/options-lifecycle.html">选项式 API：生命周期选项–官方文档</a></p><p><strong>父子组件的生命周期：</strong></p><ul><li><code>加载渲染阶段</code>：父 beforeCreate -&gt; 父 created -&gt; 父 beforeMount -&gt; 子 beforeCreate -&gt; 子 created -&gt; 子 beforeMount -&gt; 子 mounted -&gt; 父 mounted</li><li><code>更新阶段</code>：父 beforeUpdate -&gt; 子 beforeUpdate -&gt; 子 updated -&gt; 父 updated</li><li><code>销毁阶段</code>：父 beforeDestroy -&gt; 子 beforeDestroy -&gt; 子 destroyed -&gt; 父 destroyed</li></ul><h3 id="Vue-nextTick"><a href="#Vue-nextTick" class="headerlink" title="Vue.$nextTick"></a>Vue.$nextTick</h3><p><strong>在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。</strong></p><p><code>nextTick</code> 是 Vue 提供的一个全局 API，由于 Vue 的异步更新策略，导致我们对数据修改后不会直接体现在 DOM 上，此时如果想要立即获取更新后的 DOM 状态，就需要借助该方法。</p><p>Vue 在更新 DOM 时是异步执行的。当数据发生变化，Vue 将开启一个异步更新队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 <code>watcher</code> 被多次触发，只会被推入队列一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。<code>nextTick</code>方法会在队列中加入一个回调函数，确保该函数在前面的 DOM 操作完成后才调用。</p><p>使用场景：</p><ol><li>如果想要在修改数据后立刻得到更新后的<code>DOM</code>结构，可以使用<code>Vue.nextTick()</code></li><li>在<code>created</code>生命周期中进行<code>DOM</code>操作</li></ol><h3 id="Vue-实例挂载过程中发生了什么？"><a href="#Vue-实例挂载过程中发生了什么？" class="headerlink" title="Vue 实例挂载过程中发生了什么？"></a>Vue 实例挂载过程中发生了什么？</h3><p>挂载过程指的是 <code>app.mount()</code>过程，这是一个初始化过程，整体上做了两件事情：<code>初始化</code>和<code>建立更新机制</code>。</p><p>初始化会创建组件实例、初始化组件状态、创建各种响应式数据。</p><p>建立更新机制这一步会立即执行一次组件的更新函数，这会首次执行组件渲染函数并执行<code>patch</code>将<code>vnode</code> 转换为 <code>dom</code>； 同时首次执行渲染函数会创建它内部响应式数据和组件更新函数之间的依赖关系，这使得以后数据发生变化时会执行对应的更新函数。</p><h3 id="Vue-的模版编译原理"><a href="#Vue-的模版编译原理" class="headerlink" title="Vue 的模版编译原理"></a>Vue 的模版编译原理</h3><p>Vue 中有个独特的编译器模块，称为<code>compiler</code>，它的主要作用是将用户编写的<code>template</code>编译为js中可执行的<code>render</code>函数。<br> 在Vue 中，编译器会先对<code>template</code>进行解析，这一步称为<code>parse</code>，结束之后得到一个JS对象，称之为<code>抽象语法树AST</code>；然后是对<code>AST</code>进行深加工的转换过程，这一步称为<code>transform</code>，最后将前面得到的<code>AST</code>生成JS代码，也就是<code>render</code>函数。</p><h3 id="Vue-的响应式原理"><a href="#Vue-的响应式原理" class="headerlink" title="Vue 的响应式原理"></a>Vue 的响应式原理</h3><ol><li><p>Vue 2 中的数据响应式会根据数据类型做不同的处理。如果是对象，则通过</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object.defineProperty(obj,key,descriptor)</span><br></pre></td></tr></table></figure><p>拦截对象属性访问，当数据被访问或改变时，感知并作出反应；如果是数组，则通过覆盖数组原型的方法，扩展它的7个变更方法（push、pop、shift、unshift、splice、sort、reverse），使这些方法可以额外的做更新通知，从而做出响应。</p><p>缺点：</p><ul><li>初始化时的递归遍历会造成性能损失；</li><li>通知更新过程需要维护大量 <code>dep</code> 实例和 <code>watcher</code> 实例，额外占用内存较多；</li><li>新增或删除对象属性无法拦截，需要通过 <code>Vue.set</code> 及 <code>delete</code> 这样的 API 才能生效；</li><li>对于<code>ES6</code>中新产生的<code>Map</code>、<code>Set</code>这些数据结构不支持。</li></ul></li><li><p>Vue 3 中利用<code>ES6</code>的<code>Proxy</code>机制代理需要响应化的数据。可以同时支持对象和数组，动态属性增、删都可以拦截，新增数据结构均支持，对象嵌套属性运行时递归，用到时才代理，也不需要维护特别多的依赖关系，性能取得很大进步。</p></li></ol><h3 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a>虚拟DOM</h3><ol><li>概念：<br> 虚拟DOM，顾名思义就是虚拟的DOM对象，它本身就是一个JS对象，只不过是通过不同的属性去描述一个视图结构。</li><li>虚拟DOM的好处：<br> (1) 性能提升<br> 直接操作DOM是有限制的，一个真实元素上有很多属性，如果直接对其进行操作，同时会对很多额外的属性内容进行了操作，这是没有必要的。如果将这些操作转移到JS对象上，就会简单很多。另外，操作DOM的代价是比较昂贵的，频繁的操作DOM容易引起页面的重绘和回流。如果通过抽象VNode进行中间处理，可以有效减少直接操作DOM次数，从而减少页面的重绘和回流。<br> (2) 方便跨平台实现<br> 同一VNode节点可以渲染成不同平台上对应的内容，比如：渲染在浏览器是DOM元素节点，渲染在Native（iOS、Android）变为对应的控件。Vue 3 中允许开发者基于VNode实现自定义渲染器（renderer），以便于针对不同平台进行渲染。</li><li>结构：<br> 没有统一的标准，一般包括<code>tag</code>、<code>props</code>、<code>children</code>三项。<br> <code>tag</code>：必选。就是标签，也可以是组件，或者函数。<br> <code>props</code>：非必选。就是这个标签上的属性和方法。<br> <code>children</code>：非必选。就是这个标签的内容或者子节点。如果是文本节点就是字符串；如果有子节点就是数组。换句话说，如果判断<code>children</code>是字符串的话，就表示一定是文本节点，这个节点肯定没有子元素。</li></ol><h3 id="diff-算法"><a href="#diff-算法" class="headerlink" title="diff 算法"></a>diff 算法</h3><p>由于目前<code>Vue3</code>对于性能的优化做了很多的处理，所以其在更新时并不会对所有的节点都进行<code>diff</code>更新。目前会进行<code>diff</code>更新的有以下两种情况：</p><ul><li><code>v-for</code>容器节点</li><li>自写的<code>render()</code>函数</li></ul><p>还有一种特殊情况会进行无<code>diff</code>的按序更新，这种更新是全替换模式，非常耗时：</p><ul><li>无<code>key</code>值的<code>v-for</code>语句，此时会打上<code>UNKEYED_FRAGMENT</code>标记</li></ul><p>注意，<code>Vue3</code>没有主动提供片段这个功能，仅会在出现以下写法时会生成片段：</p><ul><li>一个组件有多个根节点，会生成一个片段包裹，此时其为稳定片段(<code>STABLE_FRAGMENT</code>)</li><li><code>v-for</code>语句，会生成一个片段包裹</li><li><code>v-if</code>语句，有多个子节点或不为单个文本节点，会生成一个片段包裹(<code>STABLE_FRAGMENT</code>)</li></ul><blockquote><p>本文上述论点都是基于浏览器环境，非<em>NodeJS</em>环境(<em>SSR</em>)。文中提供的代码进行了<strong>适当的简化</strong>。</p></blockquote><p>在我们使用<code>template</code>的情况下，更新基本上会通过<code>block</code>进行更新——即节点自更新</p><h4 id="diff-更新"><a href="#diff-更新" class="headerlink" title="diff 更新"></a>diff 更新</h4><h5 id="VUE2"><a href="#VUE2" class="headerlink" title="VUE2"></a>VUE2</h5><p><img src="https://raw.githubusercontent.com/why862555625/images/main/images/image-20230528150909234.png" alt="image-20230528150909234"></p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/images/image-20230528150936549.png" alt="image-20230528150936549"></p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/images/image-20230528151019742.png" alt="image-20230528151019742"></p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/images/image-20230528151119230.png" alt="image-20230528151119230"></p><p>第一次对比后结果</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/images/image-20230528151309763.png" alt="image-20230528151309763"></p><p>第二次</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/images/image-20230528151400771.png" alt="image-20230528151400771"></p><p>第三次</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/images/image-20230528151428703.png" alt="image-20230528151428703"></p><p>最后整理</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/images/image-20230528151504941.png" alt="image-20230528151504941"></p><h5 id="VUE3"><a href="#VUE3" class="headerlink" title="VUE3"></a>VUE3</h5><p><code>diff</code>更新调用的内部的<code>patchKeyedChildren</code>方法，其大致流程分为三步：</p><ol><li>对比新旧节点头部相同指针的节点，相同则进行<code>diff</code>，不同则跳转下一步。</li><li>对比新旧节点尾部指针指向节点，相同则进行<code>diff</code>，不同则跳转下一步。</li><li>此时剩余新旧节点，可能存在乱序、已移除或新增的情况，进行特殊处理来更新。</li></ol><p>下面是函数最开始做的初始化，其中<code>c1/c2</code>分别代表新旧节点的子节点数组；<code>i</code>表示两个新旧节点指向同步的指针，它们是同步的；<code>e1/e2</code>分别代表指向两个子节点数组尾部的指针：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">0</span></span><br><span class="line"><span class="keyword">const</span> l2 = c2.<span class="property">length</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 变更前节点的尾下标</span></span><br><span class="line"><span class="keyword">let</span> e1 = c1.<span class="property">length</span> - <span class="number">1</span> <span class="comment">// prev ending index</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 变更后节点的尾下标</span></span><br><span class="line"><span class="keyword">let</span> e2 = l2 - <span class="number">1</span> <span class="comment">// next ending index</span></span><br></pre></td></tr></table></figure><p>其中<code>patch()</code>函数用于对节点进行更新，<code>isSameVNodeType()</code>函数用于判断两个节点是否具有相同的类型，此时其需要满足类型一样且<code>key</code>值相等。</p><blockquote><p>这里的类型指，例如组件，则其为组件的配置对象，元素则为元素的标记。</p></blockquote><h4 id="1-对比头部等位指针节点"><a href="#1-对比头部等位指针节点" class="headerlink" title="1. 对比头部等位指针节点"></a>1. 对比头部等位指针节点</h4><p>首先其会从头部指针开始，对比新旧节点是否相同：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">js复制代码<span class="comment">// 1. sync from start</span></span><br><span class="line"><span class="comment">// 1. 从开始位置同步</span></span><br><span class="line"><span class="comment">// (a b) c</span></span><br><span class="line"><span class="comment">// (a b) d e</span></span><br><span class="line"><span class="keyword">while</span> (i &lt;= e1 &amp;&amp; i &lt;= e2) &#123;</span><br><span class="line">  <span class="keyword">const</span> n1 = c1[i]</span><br><span class="line">  <span class="keyword">const</span> n2 = c2[i]</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 节点没有发生变更时，进行patch</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isSameVNodeType</span>(n1, n2)) &#123;</span><br><span class="line">    <span class="title function_">patch</span>(n1, n2)</span><br><span class="line">    <span class="comment">// 不同节点时，立刻结束</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line">  i++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释中给出了一个例子，即如果存在下图的新旧队列：</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/images/image-20230527224906472.png" alt="image-20230527224906472"></p><p>由于此时两个指针的<code>VNode</code>相同，那么可以复用则直接进行<code>patch()</code>更新。之后指针向右移动一位，对比两个数组下标为 <code>1</code> 的位置：</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/images/image-20230527225018797.png" alt="image-20230527225018797"></p><p>同样的，节点相同，进行更新然后指针向后移动：</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/images/image-20230527225137121.png" alt="image-20230527225137121"></p><p>此时两个节点不一样了，那么本次头部对比到此结束。到此我们排除了头部位置可复用的节点，接下来那么肯定是排除尾部位置的可复用节点。</p><h3 id="2-对比尾部等位指针节点"><a href="#2-对比尾部等位指针节点" class="headerlink" title="2. 对比尾部等位指针节点"></a>2. 对比尾部等位指针节点</h3><p>尾部的可复用节点检查方法与头部一样，唯一一点不同的是，它们有各自的指针分别指向子节点数组尾部。所以此时要使用两个指针<code>e1/e2</code>。</p><p>以此时要使用两个指针<code>e1/e2</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">js复制代码<span class="comment">// 2. sync from end</span></span><br><span class="line"><span class="comment">// 2. 从尾部位置开始查找</span></span><br><span class="line"><span class="comment">// a (b c)</span></span><br><span class="line"><span class="comment">// d e (b c)</span></span><br><span class="line"><span class="keyword">while</span> (i &lt;= e1 &amp;&amp; i &lt;= e2) &#123;</span><br><span class="line">  <span class="keyword">const</span> n1 = c1[e1]</span><br><span class="line">  <span class="keyword">const</span> n2 = c2[e2]</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isSameVNodeType</span>(n1, n2)) &#123;</span><br><span class="line">    <span class="title function_">patch</span>(n1, n2)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line">  e1--</span><br><span class="line">  e2--</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还是按注释中的例子放图：</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/images/image-20230527225256542.png" alt="image-20230527225256542"></p><p>当前指针指向节点相同，节点可复用，直接更新，同时指针向前一起移动：</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/images/image-20230527225417598.png" alt="image-20230527225417598"></p><p>当前指针指向节点相同，节点可复用，直接更新，同时指针向前一起移动：</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/images/image-20230527225513256.png"></p><p>此时，两个指针指向节点不再相同，停止此处的对比。</p><hr><p>经过前两步的处理，新旧队列已经进一步缩短了，此时剩下的节点就可能存在下面三种情况：</p><ul><li>有新增的节点</li><li>有节点被删除了</li><li>相同的节点，但是移动了位置</li></ul><p>在实际的场景中，那么就只能存在下面三种剩余情况：</p><ul><li>仅有新增的节点(此时一定<code>i &gt; e1</code>)</li><li>仅进行了节点删除(此时一定<code>i &gt; e2</code>)</li><li>乱序的，一定有移动的节点，其中可能包含新增或有删除的节点(此时一定有<code>i &lt;= e2</code>且<code>i &lt;= e1</code>)</li></ul><p><code>Vue</code>按处理的简易程度，<code>Vue</code>先对前两种情况进行了单独的处理，再对三种混有的情况进行了处理。</p><h4 id="3-1-处理新增的节点的单独情况"><a href="#3-1-处理新增的节点的单独情况" class="headerlink" title="3.1 处理新增的节点的单独情况"></a>3.1 处理新增的节点的单独情况</h4><p>判断新增的节点是以旧队列为基准，那么此时的情况是这样的：</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/images/image-20230527230120660.png" alt="image-20230527230120660"></p><p>或新增的节点在首部：</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/images/image-20230527230226562.png" alt="image-20230527230226562"></p><p>此时会存在这样的情况<code>e1 &lt; i</code>且<code>e2 &gt;= i</code>，那么我们只需要更新<code>e1 =&gt; i</code>间的节点即可，于是有了这些代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3. common sequence + mount</span></span><br><span class="line"><span class="comment">// 3. 有新增的节点时</span></span><br><span class="line"><span class="comment">// (a b)</span></span><br><span class="line"><span class="comment">// (a b) c</span></span><br><span class="line"><span class="comment">// i = 2, e1 = 1, e2 = 2</span></span><br><span class="line"><span class="comment">// (a b)</span></span><br><span class="line"><span class="comment">// c (a b)</span></span><br><span class="line"><span class="comment">// i = 0, e1 = -1, e2 = 0</span></span><br><span class="line"><span class="keyword">if</span> (i &lt;= e2) &#123;</span><br><span class="line">  <span class="keyword">if</span> (i &gt; e1) &#123;</span><br><span class="line">    <span class="comment">//  当前节点后面的节点</span></span><br><span class="line">    <span class="keyword">const</span> nextPos = e2 + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我们要以这个节点为锚点在其之前添加元素，没有则添加到父节点最后</span></span><br><span class="line">    <span class="keyword">const</span> anchor = nextPos &lt; l2 ? c2[nextPos].<span class="property">el</span> : parentAnchor</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= e2) &#123;</span><br><span class="line">      <span class="title function_">patch</span>(<span class="literal">null</span>, c2[i])</span><br><span class="line">      i++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-处理删除节点的单独情况"><a href="#3-2-处理删除节点的单独情况" class="headerlink" title="3.2 处理删除节点的单独情况"></a>3.2 处理删除节点的单独情况</h4><p>如果没有存在仅有新增节点的情况，那么其会判断是否是仅进行删除节点的情况，此时可能出现下图的两种情况：</p><p>删除节点在尾部：</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/images/image-20230527230416959.png"></p><p>删除节点在尾部：</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/images/image-20230527230458558.png" alt="image-20230527230458558"></p><p>此时<code>i &gt; e2</code>，那么我们只需要将旧节点数组中<code>i =&gt; e1</code>之间的所有节点删除即可(下面的<code>else if</code>语句承接上面)：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">js复制代码<span class="comment">// 4. common sequence + unmount</span></span><br><span class="line"><span class="comment">// 4. 节点移除</span></span><br><span class="line"><span class="comment">// (a b) c</span></span><br><span class="line"><span class="comment">// (a b)</span></span><br><span class="line"><span class="comment">// i = 2, e1 = 2, e2 = 1</span></span><br><span class="line"><span class="comment">// a (b c)</span></span><br><span class="line"><span class="comment">// (b c)</span></span><br><span class="line"><span class="comment">// i = 0, e1 = 0, e2 = -1</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (i &gt; e2) &#123;</span><br><span class="line">  <span class="keyword">while</span> (i &lt;= e1) &#123;</span><br><span class="line">    <span class="comment">// 移除原节点</span></span><br><span class="line">    <span class="title function_">unmount</span>(c1[i])</span><br><span class="line">    i++</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-乱序，但一定有移动的节点的情况"><a href="#3-3-乱序，但一定有移动的节点的情况" class="headerlink" title="3.3 乱序，但一定有移动的节点的情况"></a>3.3 乱序，但一定有移动的节点的情况</h4><p>最后一种情况就是比较复杂的情况，此时<code>Vue</code>做的处理是，先查看旧节点序列在变为新节点序列后，旧节点序列中是否有些节点还是按现在的顺序排列的(可以间断)，此时只对其余变更的节点进行操作，就能进行最小幅度的<code>DOM</code>操作了。</p><blockquote><p>此时相对于求旧节点的最长递增序列，这里你可以会想到为什么不求最小编辑距离，因为最小编辑距离的时间复杂度在大多数情况下比它高</p></blockquote><h5 id="3-3-1-建立新节点-key-与其下标的映射"><a href="#3-3-1-建立新节点-key-与其下标的映射" class="headerlink" title="3.3.1 建立新节点 key 与其下标的映射"></a>3.3.1 建立新节点 key 与其下标的映射</h5><p>首先，<code>Vue</code>先将新节点数组进行遍历，将它们有<code>key</code>值的节点与其在新节点数组中的下标建立映射，存储在<code>keyToNewIndexMap</code>中，方便在复用时查找：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s1 = i <span class="comment">// prev starting index</span></span><br><span class="line"><span class="keyword">const</span> s2 = i <span class="comment">// next starting index</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.1 build key:index map for newChildren</span></span><br><span class="line"><span class="comment">// 5.1 生成一个key map</span></span><br><span class="line"><span class="keyword">const</span> keyToNewIndexMap = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历新节点，乱序的部分，将这些具有key的节点存入map</span></span><br><span class="line"><span class="keyword">for</span> (i = s2; i &lt;= e2; i++) &#123;</span><br><span class="line">  <span class="keyword">const</span> nextChild = c2[i]</span><br><span class="line">  <span class="keyword">if</span> (nextChild.<span class="property">key</span> != <span class="literal">null</span>) &#123;</span><br><span class="line">    keyToNewIndexMap.<span class="title function_">set</span>(nextChild.<span class="property">key</span>, i)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-3-2-移除新节点队列中不存在的旧节点并更新复用节点"><a href="#3-3-2-移除新节点队列中不存在的旧节点并更新复用节点" class="headerlink" title="3.3.2 移除新节点队列中不存在的旧节点并更新复用节点"></a>3.3.2 移除新节点队列中不存在的旧节点并更新复用节点</h5><p>之后，遍历旧节点数组，通过刚刚建立的<code>Map</code>，如果当前旧节点在新节点数组中已经不存在了，那么说明要移除了。</p><p>整个过程比较复杂，因为要预先做处理，为后续是否需要移动节点做准备：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 5.2 loop through old children left to be patched and try to patch</span></span><br><span class="line"><span class="comment">// matching nodes &amp; remove nodes that are no longer present</span></span><br><span class="line"><span class="comment">// 5.2 遍历旧节点，patch匹配的节点，移除不再在节点</span></span><br><span class="line"><span class="keyword">let</span> j</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前处理过的节点数</span></span><br><span class="line"><span class="keyword">let</span> patched = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要patch的节点数</span></span><br><span class="line"><span class="keyword">const</span> toBePatched = e2 - s2 + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否需要移动节点</span></span><br><span class="line"><span class="keyword">let</span> moved = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// used to track whether any node has moved</span></span><br><span class="line"><span class="comment">// 记录节点是否已经移动</span></span><br><span class="line"><span class="keyword">let</span> maxNewIndexSoFar = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// works as Map&lt;newIndex, oldIndex&gt;</span></span><br><span class="line"><span class="comment">// Note that oldIndex is offset by +1</span></span><br><span class="line"><span class="comment">// and oldIndex = 0 is a special value indicating the new node has</span></span><br><span class="line"><span class="comment">// no corresponding old node.</span></span><br><span class="line"><span class="comment">// 注意旧下标的值都会+1，因为0表示没有对应的旧节点</span></span><br><span class="line"><span class="comment">// used for determining longest stable subsequence</span></span><br><span class="line"><span class="comment">// 新下标与旧下标的map</span></span><br><span class="line"><span class="comment">// 这里的新下标以s2位置为0下标，而旧下标为旧下标值 +１</span></span><br><span class="line"><span class="keyword">const</span> newIndexToOldIndexMap = <span class="keyword">new</span> <span class="title class_">Array</span>(toBePatched)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化值为0</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; toBePatched; i++) newIndexToOldIndexMap[i] = <span class="number">0</span></span><br></pre></td></tr></table></figure><p>这里我说明下三个变量，首先是<code>newIndexToOldIndexMap</code>，其用来记录节点的新坐标到旧坐标的映射(当然是节点可复用的情况下)。为了后续计算最长递增子序列，所以其新坐标以<code>s2</code>为起点，长度为当前需要处理的节点总数，并且其存入的旧节点下标要在原值的基础上<code>+ 1</code>(因为<code>0</code>表示当前节点没有对应的旧节点)。举个例子，有如下图一样的更新序列：</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/images/image-20230527230956800.png" alt="image-20230527230956800"></p><p>那么节点<code>e</code>存入<code>newIndexToOldIndexMap</code>后为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 展示，不是赋值语句</span></span><br><span class="line">newIndexToOldIndexMap = [<span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>其余全部节点存入后为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 展示，不是赋值语句</span></span><br><span class="line">newIndexToOldIndexMap = [<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p><code>moved</code>变量则是表示是否有节点需要移动，其判定要基于<code>maxNewIndexSoFar</code>的值。</p><p><code>maxNewIndexSoFar</code>表示当前可复用节点距离<code>s2</code>(即第一个乱序节点的最远距离)。如果有对应可以复用的节点，那么在每次迭代处理节点时，如果当前节点所处位置距离<code>s2</code>距离超过<code>maxNewIndexSoFar</code>，那么<code>maxNewIndexSoFar</code>会更新为当前节点在新队列中的下标；当其小于<code>maxNewIndexSoFar</code>时，就会标记<code>moved = true</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断是否需要移动当前节点，想象一下，如果每个节点都按序递增，</span></span><br><span class="line"><span class="comment">// 那么每次都会进入该if语句</span></span><br><span class="line"><span class="keyword">if</span> (newIndex &gt;= maxNewIndexSoFar) &#123;</span><br><span class="line">  <span class="comment">// 当前节点未移动，更新下标</span></span><br><span class="line">  maxNewIndexSoFar = newIndex</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果进入该else语句说明有节点之前节点交叉了</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  moved = <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>想象一下，如果节点在新旧序列中，都是按照相同的顺序递增，那么<code>maxNewIndexSoFar</code>也会一直递增，即每次迭代<code>newIndex &gt;= maxNewIndexSoFar</code>，那么就不需要移动节点；但是如果某次迭代，<code>newIndex &lt; maxNewIndexSoFar</code>，那么说明当前节点由之前靠后的位置移动了现在靠前的位置。</p><p>就拿刚刚乱序的图举例，第一次迭代<code>c</code>节点的<code>newIndex = 4</code>，则<code>maxNewIndexSoFar = 4</code>；第二次迭代<code>d</code>节点时，其<code>newIndex = 3</code>，此时<code>newIndex &lt; maxNewIndexSoFar</code>，说明<code>c/d</code>节点之间的位置在新旧发生了交叉，所以我们至少需要移动它们其中一个节点。</p><p>理解了这个道理，现在我们可以正式看看这段代码了。由于要卸载节点，那么本次遍历要以<code>s1 &lt;-&gt; e1</code>之间的节点为基准进行遍历，整体遍历代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历旧节点</span></span><br><span class="line"><span class="keyword">for</span> (i = s1; i &lt;= e1; i++) &#123;</span><br><span class="line">  <span class="comment">// 当前下标的旧节点</span></span><br><span class="line">  <span class="keyword">const</span> prevChild = c1[i]</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当前patch的节点数超过新节点中要patch的总数时，执行unmount操作</span></span><br><span class="line">  <span class="comment">// 直接进行卸载操作，因为多余的节点不需要了</span></span><br><span class="line">  <span class="keyword">if</span> (patched &gt;= toBePatched) &#123;</span><br><span class="line">    <span class="comment">// all new children have been patched so this can only be a removal</span></span><br><span class="line">    <span class="title function_">unmount</span>(prevChild)</span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 尝试寻找是否有对应的新节点</span></span><br><span class="line">  <span class="keyword">let</span> newIndex</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 旧节点具有key时，获取相同key值节点所处的下标</span></span><br><span class="line">  <span class="keyword">if</span> (prevChild.<span class="property">key</span> != <span class="literal">null</span>) &#123;</span><br><span class="line">    newIndex = keyToNewIndexMap.<span class="title function_">get</span>(prevChild.<span class="property">key</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有key时则找相同类型的节点是否存在</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// key-less node, try to locate a key-less node of the same type</span></span><br><span class="line">    <span class="comment">// 当前查找范围为新节点中需要patch的节点之间</span></span><br><span class="line">    <span class="keyword">for</span> (j = s2; j &lt;= e2; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        <span class="comment">// 0表示对应下标下当前还未有节点(注意当前是以s2为0下标基准)</span></span><br><span class="line">        <span class="comment">// 这里确认当前新下标位置未有对应的旧下标，防止是已在map中的节点</span></span><br><span class="line"></span><br><span class="line">        newIndexToOldIndexMap[j - s2] === <span class="number">0</span> &amp;&amp;</span><br><span class="line">        <span class="title function_">isSameVNodeType</span>(prevChild, c2[j])</span><br><span class="line">      ) &#123;</span><br><span class="line">        newIndex = j</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 没找到对应节点时说明该节点已经不存在了，直接进行unmount</span></span><br><span class="line">  <span class="keyword">if</span> (newIndex === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="title function_">unmount</span>(prevChild)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到时进行位置移动操作，并patch</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 将旧节点位置下标+1后存入，新节点以s2为起点，即0坐标</span></span><br><span class="line">    newIndexToOldIndexMap[newIndex - s2] = i + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否需要移动当前节点，想象一下，如果每个节点都按序递增，</span></span><br><span class="line">    <span class="comment">// 那么每次都会进入该if语句</span></span><br><span class="line">    <span class="keyword">if</span> (newIndex &gt;= maxNewIndexSoFar) &#123;</span><br><span class="line">      <span class="comment">// 当前节点未移动，更新下标</span></span><br><span class="line">      maxNewIndexSoFar = newIndex</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果进入该else语句说明有节点之前节点交叉了</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      moved = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// patch该节点</span></span><br><span class="line">    <span class="title function_">patch</span>(prevChild, c2[newIndex])</span><br><span class="line">    patched++</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先当当前可复用的节点复用时，会使<code>patched</code>值<code>+1</code>，当复用的节点超过乱序的新节点长度时，那么其余的节点肯定是要卸载的节点(因为新节点序列都处理完毕了)：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (patched &gt;= toBePatched) &#123;</span><br><span class="line">    <span class="comment">// all new children have been patched so this can only be a removal</span></span><br><span class="line">    <span class="title function_">unmount</span>(prevChild)</span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>之后，<code>Vue</code>尝试寻找一下当前旧节点是否被复用，即它被移动到了新节点序列的其他位置。首先如果当前节点有<code>key</code>值，那么其会尝试直接从刚刚的<code>keyToNewIndexMap</code>中查找；如果没有找到，那么其会遍历当前所有的新节点序列，依次对比是否与当前节点相同，在复合同类型节点时对其进行复用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 尝试寻找是否有对应的新节点</span></span><br><span class="line"><span class="keyword">let</span> newIndex</span><br><span class="line"></span><br><span class="line"><span class="comment">// 旧节点具有 key 时，获取相同 key 值节点所处的下标</span></span><br><span class="line"><span class="keyword">if</span> (prevChild.<span class="property">key</span> != <span class="literal">null</span>) &#123;</span><br><span class="line">  newIndex = keyToNewIndexMap.<span class="title function_">get</span>(prevChild.<span class="property">key</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 没有key时则找相同类型的节点是否存在</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// key-less node, try to locate a key-less node of the same type</span></span><br><span class="line">  <span class="comment">// 当前查找范围为新节点中需要 patch 的节点之间</span></span><br><span class="line">  <span class="keyword">for</span> (j = s2; j &lt;= e2; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      <span class="comment">// 0 表示对应下标下当前还未有节点(注意当前是以 s2 为 0 下标基准)</span></span><br><span class="line">      <span class="comment">// 这里确认当前新下标位置未有对应的旧下标，防止是已在 map 中的节点</span></span><br><span class="line">      newIndexToOldIndexMap[j - s2] === <span class="number">0</span> &amp;&amp;</span><br><span class="line">      <span class="title function_">isSameVNodeType</span>(prevChild, c2[j])</span><br><span class="line">    ) &#123;</span><br><span class="line">      newIndex = j</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在直接通过类型查找复用节点时，其存在一个<code>newIndexToOldIndexMap[j - s2] === 0</code>条件，它表示当前新节点下标未有对应的旧节点(<code>0</code>表示没有，在之后的代码中，如果查找到对应的<code>newIndex</code>，其会存入<code>newIndexToOldIndexMap</code>中)。这样可以防止新旧节点被重复复用或已被处理再次被处理。</p><p>到此，对于旧节点的<code>newIndex</code>是否被查找到就会出现两种情况了：</p><ol><li>没有，说明当前节点已删除了，移除该<code>DOM</code>节点</li><li>有，复用，<strong>更新节点属性</strong></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没找到对应节点时说明该节点已经不存在了，直接进行unmount</span></span><br><span class="line"><span class="keyword">if</span> (newIndex === <span class="literal">undefined</span>) &#123;</span><br><span class="line">  <span class="title function_">unmount</span>(prevChild)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 找到时进行位置移动操作，并patch</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 将旧节点位置下标+1后存入，新节点以s2为起点，即0坐标</span></span><br><span class="line">  newIndexToOldIndexMap[newIndex - s2] = i + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断是否需要移动当前节点，想象一下，如果每个节点都按序递增，</span></span><br><span class="line">  <span class="comment">// 那么每次都会进入该if语句</span></span><br><span class="line">  <span class="keyword">if</span> (newIndex &gt;= maxNewIndexSoFar) &#123;</span><br><span class="line">    <span class="comment">// 当前节点未移动，更新下标</span></span><br><span class="line">    maxNewIndexSoFar = newIndex</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果进入该else语句说明有节点之前节点交叉了</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    moved = <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// patch该节点</span></span><br><span class="line">  <span class="title function_">patch</span>(prevChild, c2[newIndex])</span><br><span class="line">  patched++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在复用的情况下，有我们刚刚提到的<a href="#332-%E7%A7%BB%E9%99%A4%E6%96%B0%E8%8A%82%E7%82%B9%E9%98%9F%E5%88%97%E4%B8%AD%E4%B8%8D%E5%AD%98%E5%9C%A8%E7%9A%84%E6%97%A7%E8%8A%82%E7%82%B9%E5%B9%B6%E6%9B%B4%E6%96%B0%E5%A4%8D%E7%94%A8%E8%8A%82%E7%82%B9">计算节点交叉(是否需要移动)</a>的场景：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断是否需要移动当前节点，想象一下，如果每个节点都按序递增，</span></span><br><span class="line"><span class="comment">// 那么每次都会进入该if语句</span></span><br><span class="line"><span class="keyword">if</span> (newIndex &gt;= maxNewIndexSoFar) &#123;</span><br><span class="line">  <span class="comment">// 当前节点未移动，更新下标</span></span><br><span class="line">  maxNewIndexSoFar = newIndex</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果进入该else语句说明有节点之前节点交叉了</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  moved = <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就不赘述了。</p><blockquote><p>注意，这里对复用的节点进行了<code>patch()</code>更新，那么后面就只用进行移动即可，而不需要更新了。</p></blockquote><h4 id="3-3-3-处理新增节点与移动的节点"><a href="#3-3-3-处理新增节点与移动的节点" class="headerlink" title="3.3.3 处理新增节点与移动的节点"></a>3.3.3 处理新增节点与移动的节点</h4><p>到此为止，就只有新增节点与移动节点的情况没有处理了。</p><p>首先其会需要移动节点时(<code>moved = true</code>)根据刚刚创建的<code>newIndexToOldIndexMap</code>生成一个最长递增的新节点序列<code>increasingNewIndexSequence</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">js复制代码<span class="comment">// 5.3 move and mount</span></span><br><span class="line"><span class="comment">// 5.3 移动与mount</span></span><br><span class="line"><span class="comment">// generate longest stable subsequence only when nodes have moved</span></span><br><span class="line"><span class="comment">// 有节点需要移动，生成长期稳定的子序列，仅对移动过的节点处理</span></span><br><span class="line"><span class="keyword">const</span> increasingNewIndexSequence = moved</span><br><span class="line">  ? <span class="comment">// 获取最长递增子序列的下标数组</span></span><br><span class="line">    <span class="title function_">getSequence</span>(newIndexToOldIndexMap)</span><br><span class="line">  : <span class="variable constant_">EMPTY_ARR</span></span><br></pre></td></tr></table></figure><p>那么这个序列的作用是什么？它就是用来<strong>辅助移动节点</strong>，而且是在最小次数下移动节点。由于<code>newIndexToOldIndexMap</code>是根据新旧节点之间的映射创建的，其<strong>下标天然代表乱序的新节点数组的顺序</strong>，而且其对应下标中存储的元素也代表该新节点复用的旧节点的下标，那么这里我们就可以看到两个序列：</p><ol><li>新节点下标组成的序列(<strong>递增</strong>的，因为我们以它为基准创建的数组)</li><li><code>newIndexToOldIndexMap</code>中旧节点下标组成的序列，可能递增也可能乱序</li></ol><blockquote><p>关于如何求<a href="https://link.juejin.cn/?target=https://en.wikipedia.org/wiki/Longest_increasing_subsequence">最长递增子序列</a>，请单独自行学习，这里就不说明了。</p></blockquote><p>此时倘若旧节点下标组成的序列<strong>也</strong>呈现递增趋势，那么我们便可以操作那些非递增的节点来达到变更为新节点序列的目的。并且这个递增的序列越长，那么我们要操作(移动)的节点就越少。比如下图的情况：</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/images/image-20230528124733993.png" alt="image-20230528124733993"></p><p>从图中观察，我们可以清楚的看到<code>c/d</code>两个节点在前后都保持了递增的关系，那么此时我们只需要移动<code>e</code>节点与创建<code>h</code>节点即可。</p><p>此时其<code>newIndexToOldIndexMap</code>为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">js复制代码newIndexToOldIndexMap = [<span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该数组返回的是对应的元素在newIndexToOldIndexMap的下标</span></span><br><span class="line"><span class="comment">// 而并非实际的旧节点下标</span></span><br><span class="line">increasingNewIndexSequence = [<span class="number">1</span>, <span class="number">2</span>]</span><br></pre></td></tr></table></figure><p>可以看到<code>2、3</code>节点与新节点的下标的<strong>递增关系保持一致</strong>，其最长递增子序列(<code>increasingNewIndexSequence</code>)为<code>[1, 2]</code>，此时我们只需要操作<code>4/0</code>两个节点即可。</p><blockquote><p><code>increasingNewIndexSequence</code>返回的结果为对应的元素在 <code>newIndexToOldIndexMap</code>的下标而并非实际的旧节点下标</p></blockquote><p>明白了这个现在我们来看其具体处理的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取递增序列的尾坐标</span></span><br><span class="line">j = increasingNewIndexSequence.<span class="property">length</span> - <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// looping backwards so that we can use last patched node as anchor</span></span><br><span class="line"><span class="comment">// 向后循环，这样我们可以用上一个patch过了的节点做锚点</span></span><br><span class="line"><span class="keyword">for</span> (i = toBePatched - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">  <span class="comment">// 当前要处理的新节点下标及其节点</span></span><br><span class="line">  <span class="keyword">const</span> nextIndex = s2 + i</span><br><span class="line">  <span class="keyword">const</span> nextChild = c2[nextIndex]</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取其后一个节点，如果没有则获取其父节点</span></span><br><span class="line">  <span class="keyword">const</span> anchor = nextIndex + <span class="number">1</span> &lt; l2 ? c2[nextIndex + <span class="number">1</span>].<span class="property">el</span> : parentAnchor</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果当前新旧节点Map中未找到当前位置新节点的旧节点信息，</span></span><br><span class="line">  <span class="comment">// 说明是新增节点</span></span><br><span class="line">  <span class="keyword">if</span> (newIndexToOldIndexMap[i] === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// mount new</span></span><br><span class="line">    <span class="title function_">patch</span>(<span class="literal">null</span>, nextChild)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// moved说明有节点需要移动，通过塑造一个递增序列，处于递增序列的节点就可以</span></span><br><span class="line">    <span class="comment">// 不进行移动，只移动其余节点，这样就减少了节点的移动</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (moved) &#123;</span><br><span class="line">    <span class="comment">// 如果存在以下情况则移动：</span></span><br><span class="line">    <span class="comment">// 1. 没有稳定的子序列</span></span><br><span class="line">    <span class="comment">// 2. 当前节点不在这个稳定的子序列中</span></span><br><span class="line">    <span class="comment">// move if:</span></span><br><span class="line">    <span class="comment">// There is no stable subsequence (e.g. a reverse)</span></span><br><span class="line">    <span class="comment">// OR current node is not among the stable sequence</span></span><br><span class="line">    <span class="keyword">if</span> (j &lt; <span class="number">0</span> || i !== increasingNewIndexSequence[j]) &#123;</span><br><span class="line">      <span class="title function_">move</span>(nextChild, container, anchor)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      j--</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本次遍历以新节点的乱序序列(<code>s2 &lt;-&gt; e2</code>)为基准，逆向进行遍历。逆向的原因是因为其在新增节点或更新节点时，可以以后面已经操作过的节点为锚点进行更新(想象一下<code>Node.insertBefore()/Node.appendChild()</code>的参数)。</p><p>每次遍历会出现三种情况：</p><ul><li>当前节点未有对应的旧节点下标，则说明是新增节点</li><li>该节点需要移动，进行移动</li><li>该节点与旧节点序列都保持递增顺序，直接跳过即可(实际反应在代码里面就是没做任何处理)</li></ul><blockquote><p>情况<code>2</code>与<code>3</code>在完整的迭代中是互斥的，两者不会同时出现在整个迭代流程中。</p></blockquote><p>第一种情况，比较简单，这里就不解释了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果当前新旧节点Map中未找到当前位置新节点的旧节点信息，</span></span><br><span class="line"><span class="comment">// 说明是新增节点</span></span><br><span class="line"><span class="keyword">if</span> (newIndexToOldIndexMap[i] === <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="comment">// mount new</span></span><br><span class="line">  <span class="title function_">patch</span>(<span class="literal">null</span>, nextChild</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种情况要判定<code>moved = true</code>，它的原理<a href="#332-%E7%A7%BB%E9%99%A4%E6%96%B0%E8%8A%82%E7%82%B9%E9%98%9F%E5%88%97%E4%B8%AD%E4%B8%8D%E5%AD%98%E5%9C%A8%E7%9A%84%E6%97%A7%E8%8A%82%E7%82%B9%E5%B9%B6%E6%9B%B4%E6%96%B0%E5%A4%8D%E7%94%A8%E8%8A%82%E7%82%B9">之前我们已经解释过了</a>。这里我们要关注的是它的函数体。根据我们刚刚对递增子序列的理解，那么其应该会在以下情况移动或不移动节点：</p><ul><li>当前节点处于最长递增子序列中 —— 跳过</li><li>当前节点不存在最长递增子序列中 —— 移动<ul><li>递增序列已经没有需要跳过的节点了但任存在节点需要更新(实际和不存在的情况一样)</li><li>当前节点不存在最长递增子序列</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果存在以下情况则移动：</span></span><br><span class="line"><span class="comment">// 1. 没有稳定的子序列(实际和情况2一致，反序时会返回任意一个节点作为最长序列)</span></span><br><span class="line"><span class="comment">// 2. 当前节点不在这个稳定的子序列中</span></span><br><span class="line"><span class="comment">// move if:</span></span><br><span class="line"><span class="comment">// There is no stable subsequence (e.g. a reverse)</span></span><br><span class="line"><span class="comment">// OR current node is not among the stable sequence</span></span><br><span class="line"><span class="keyword">if</span> (j &lt; <span class="number">0</span> || i !== increasingNewIndexSequence[j]) &#123;</span><br><span class="line">  <span class="comment">// 将当前节点移动到锚点节点前或容器节点最后(没有锚点时)</span></span><br><span class="line">  <span class="title function_">move</span>(nextChild, container, anchor)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  j--</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/why862555625/images/main/images/image-20230528124834143.png" alt="image-20230528124834143"></p><p>在第二次更新中，发现<code>d</code>节点存在于单调增序列中，所以本次更新可以跳过：</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/images/image-20230528124910205.png" alt="image-20230528124910205"></p><p>同理<code>c</code>节点也一样，这里就不放图了，处理完<code>c</code>节点后此时为这样</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/images/image-20230528124931580.png" alt="image-20230528124931580"></p><p>此时<code>e</code>节点可复用，则将其移动到新<code>c</code>节点前即可。</p><p>到此为止，上图的<code>diff</code>就结束了。</p><p>对于第三种情况，由于复用的节点在前后都保持了递增的关系，所以此时我们不需要再重复对节点进行处理，所以遇到复用的节点时直接跳过即可：</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/images/image-20230528125006064.png" alt="image-20230528125006064"></p><p>到此为止全部节点的更新就已经完毕了。</p><h3 id="为什么组件中的-data-是一个函数？"><a href="#为什么组件中的-data-是一个函数？" class="headerlink" title="为什么组件中的 data 是一个函数？"></a>为什么组件中的 data 是一个函数？</h3><p>在 new Vue() 中，可以是函数也可以是对象，因为根实例只有一个，不会产生数据污染。</p><p>在组件中，data 必须为函数，目的是为了防止多个组件实例对象之间共用一个 data，产生数据污染；而采用函数的形式，initData 时会将其作为工厂函数都会返回全新的 data 对象。</p><h3 id="Vue-中组件间的通信方式？"><a href="#Vue-中组件间的通信方式？" class="headerlink" title="Vue 中组件间的通信方式？"></a>Vue 中组件间的通信方式？</h3><ol><li><p>父子组件通信：</p><p>父向子传递数据是通过<code>props</code>，子向父是通过<code>$emit</code>触发事件；通过父链/子链也可以通信（<code>$parent</code>/<code>$children</code>）；<code>ref</code>也可以访问组件实例；<code>provide</code>/<code>inject</code>；<code>$attrs</code>/<code>$listeners</code>。</p></li><li><p>兄弟组件通信：</p><p>全局事件总线<code>EventBus</code>、<code>Vuex</code>。</p></li><li><p>跨层级组件通信：</p><p>全局事件总线<code>EventBus</code>、<code>Vuex</code>、<code>provide</code>/<code>inject</code>。</p></li></ol><h3 id="v-show-和-v-if-的区别？"><a href="#v-show-和-v-if-的区别？" class="headerlink" title="v-show 和 v-if 的区别？"></a>v-show 和 v-if 的区别？</h3><ol><li>控制手段不同。<code>v-show</code>是通过给元素添加 css 属性<code>display: none</code>，但元素仍然存在；而<code>v-if</code>控制元素显示或隐藏是将元素整个添加或删除。</li><li>编译过程不同。<code>v-if</code>切换有一个局部编译/卸载的过程，切换过程中合适的销毁和重建内部的事件监听和子组件；<code>v-show</code>只是简单的基于 css 切换。</li><li>编译条件不同。<code>v-if</code>是真正的条件渲染，它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建，渲染条件为假时，并不做操作，直到为真才渲染。</li><li>触发生命周期不同。<code>v-show</code>由 false 变为 true 的时候不会触发组件的生命周期；<code>v-if</code>由 false 变为 true 的时候，触发组件的<code>beforeCreate</code>、<code>created</code>、<code>beforeMount</code>、<code>mounted</code>钩子，由 true 变为 false 的时候触发组件的<code>beforeDestory</code>、<code>destoryed</code>钩子。</li><li>性能消耗不同。<code>v-if</code>有更高的切换消耗；<code>v-show</code>有更高的初始渲染消耗。</li></ol><p>使用场景：<br> 如果需要非常频繁地切换，则使用<code>v-show</code>较好，如：手风琴菜单，tab 页签等； 如果在运行时条件很少改变，则使用<code>v-if</code>较好，如：用户登录之后，根据权限不同来显示不同的内容。</p><h3 id="computed-和-watch-的区别？"><a href="#computed-和-watch-的区别？" class="headerlink" title="computed 和 watch 的区别？"></a>computed 和 watch 的区别？</h3><ul><li><code>computed</code>计算属性，依赖其它属性计算值，内部任一依赖项的变化都会重新执行该函数，计算属性有缓存，多次重复使用计算属性时会从缓存中获取返回值，计算属性必须要有<code>return</code>关键词。</li><li><code>watch</code>侦听到某一数据的变化从而触发函数。当数据为对象类型时，对象中的属性值变化时需要使用深度侦听<code>deep</code>属性，也可在页面第一次加载时使用立即侦听<code>immdiate</code>属性。</li></ul><p>运用场景：<br> 计算属性一般用在模板渲染中，某个值是依赖其它响应对象甚至是计算属性而来；而侦听属性适用于观测某个值的变化去完成一段复杂的业务逻辑。</p><h3 id="v-if-和-v-for-为什么不建议放在一起使用？"><a href="#v-if-和-v-for-为什么不建议放在一起使用？" class="headerlink" title="v-if 和 v-for 为什么不建议放在一起使用？"></a>v-if 和 v-for 为什么不建议放在一起使用？</h3><p>Vue 2 中，<code>v-for</code>的优先级比<code>v-if</code>高，这意味着<code>v-if</code>将分别重复运行于每一个<code>v-for</code>循环中。如果要遍历的数组很大，而真正要展示的数据很少时，将造成很大的性能浪费。</p><p>Vue 3 中，则完全相反，<code>v-if</code>的优先级高于<code>v-for</code>，所以<code>v-if</code>执行时，它调用的变量还不存在，会导致异常。</p><p>通常有两种情况导致要这样做：</p><ul><li>为了过滤列表中的项目，比如：<code>v-for = &quot;user in users&quot; v-if = &quot;user.active&quot;</code>。这种情况，可以定义一个计算属性，让其返回过滤后的列表即可。</li><li>为了避免渲染本该被隐藏的列表，比如<code>v-for = &quot;user in users&quot;  v-if = &quot;showUsersFlag&quot;</code>。这种情况，可以将<code>v-if</code>移至容器元素上或在外面包一层<code>template</code>即可。</li></ul><h3 id="Vue-2中的set方法？"><a href="#Vue-2中的set方法？" class="headerlink" title="Vue 2中的set方法？"></a>Vue 2中的set方法？</h3><p><a href="https://link.juejin.cn/?target=https://v2.cn.vuejs.org/v2/api/%23Vue-set"><code>set</code>是Vue 2中的一个全局API</a>。可手动添加响应式数据，解决数据变化视图未更新问题。当在项目中直接设置数组的某一项的值，或者直接设置对象的某个属性值，会发现页面并没有更新。这是因为<code>Object.defineProperty()</code>的限制，监听不到数据变化，可通过<code>this.$set(数组或对象，数组下标或对象的属性名，更新后的值)</code>解决。</p><h3 id="keep-alive-是什么？"><a href="#keep-alive-是什么？" class="headerlink" title="keep-alive 是什么？"></a>keep-alive 是什么？</h3><ul><li>作用：实现组件缓存，保持组件的状态，避免反复渲染导致的性能问题。</li><li>工作原理：Vue.js 内部将 DOM 节点，抽象成了一个个的 VNode 节点，<code>keep-alive</code>组件的缓存也是基于 VNode 节点的。它将满足条件的组件在 cache 对象中缓存起来，重新渲染的时候再将 VNode 节点从 cache 对象中取出并渲染。</li><li>可以设置以下属性：<br> ① <code>include</code>：字符串或正则，只有名称匹配的组件会被缓存。<br> ② <code>exclude</code>：字符串或正则，任何名称匹配的组件都不会被缓存。<br> ③ <code>max</code>：数字，最多可以缓存多少组件实例。<br> 匹配首先检查组件的<code>name</code>选项，如果<code>name</code>选项不可用，则匹配它的局部注册名称（父组件 components选项的键值），匿名组件不能被匹配。</li></ul><p>如果同时使用了<code>include</code>、<code>exclude</code>，那么<code>exclude</code>的优先级高于<code>include</code>。</p><p>设置了<code>keep-alive</code>缓存的组件，会多出两个生命周期钩子：<code>activated</code>、<code>deactivated</code>。<br> 首次进入组件时：beforeCreate –&gt; created –&gt; beforeMount –&gt; mounted –&gt; activated –&gt; beforeUpdate –&gt; updated –&gt; deactivated<br> 再次进入组件时：activated –&gt; beforeUpdate –&gt; updated –&gt; deactivated</p><h3 id="mixin"><a href="#mixin" class="headerlink" title="mixin"></a>mixin</h3><p><code>mixin</code>（混入）， 它提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。</p><p>使用场景： 不同组件中经常会用到一些相同或相似的代码，这些代码的功能相对独立。可以通过mixin 将相同或相似的代码提出来。</p><p>缺点：</p><ol><li>变量来源不明确</li><li>多 mixin 可能会造成命名冲突（解决方式：Vue 3的组合API）</li><li>mixin 和组件出现多对多的关系，使项目复杂度变高。</li></ol><h3 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h3><p><code>slot</code>插槽，一般在组件内部使用，封装组件时，在组件内部不确定该位置是以何种形式的元素展示时，可以通过<code>slot</code>占据这个位置，该位置的元素需要父组件以内容形式传递过来。<code>slot</code>分为：</p><ul><li><code>默认插槽</code>：子组件用<code>&lt;slot&gt;</code>标签来确定渲染的位置，标签里面可以放<code>DOM</code>结构作为后备内容，当父组件在使用的时候，可以直接在子组件的标签内写入内容，该部分内容将插入子组件的<code>&lt;slot&gt;</code>标签位置。如果父组件使用的时候没有往插槽传入内容，后备内容就会显示在页面。</li><li><code>具名插槽</code>：子组件用<code>name</code>属性来表示插槽的名字，没有指定<code>name</code>的插槽，会有隐含的名称叫做 <code>default</code>。父组件中在使用时在默认插槽的基础上通过<code>v-slot</code>指令指定元素需要放在哪个插槽中，<code>v-slot</code>值为子组件插槽<code>name</code>属性值。使用<code>v-slot</code>指令指定元素放在哪个插槽中，必须配合<code>&lt;template&gt;</code>元素，且一个<code>&lt;template&gt;</code>元素只能对应一个预留的插槽，即不能多个<code>&lt;template&gt;</code> 元素都使用<code>v-slot</code>指令指定相同的插槽。<code>v-slot</code>的简写是<code>#</code>，例如<code>v-slot:header</code>可以简写为<code>#header</code>。</li><li>作用域插槽：子组件在<slot>标签上绑定props数据，以将子组件数据传给父组件使用。父组件获取插槽绑定 props 数据的方法：<ol><li>scope=”接收的变量名”：<code>&lt;template scope=&quot;接收的变量名&quot;&gt;</code></li><li>slot-scope=”接收的变量名”：<code>&lt;template slot-scope=&quot;接收的变量名&quot;&gt;</code></li><li>v-slot:插槽名=”接收的变量名”：<code>&lt;template v-slot:插槽名=&quot;接收的变量名&quot;&gt;</code></li></ol></li></ul><h3 id="Vue-中的修饰符有哪些？"><a href="#Vue-中的修饰符有哪些？" class="headerlink" title="Vue 中的修饰符有哪些？"></a>Vue 中的修饰符有哪些？</h3><p>在Vue 中，修饰符处理了许多 DOM 事件的细节，让我们不再需要花大量的时间去处理这些烦恼的事情，而能有更多的精力专注于程序的逻辑处理。Vue中修饰符分为以下几种：</p><ol><li><p>表单修饰符<br> <code>lazy</code> 填完信息，光标离开标签的时候，才会将值赋予给value，也就是在<code>change</code>事件之后再进行信息同步。<br> <code>number</code> 自动将用户输入值转化为数值类型，但如果这个值无法被<code>parseFloat</code>解析，则会返回原来的值。<br> <code>trim</code> 自动过滤用户输入的首尾空格，而中间的空格不会被过滤。</p></li><li><p>事件修饰符<br> <code>stop</code> 阻止了事件冒泡，相当于调用了<code>event.stopPropagation</code>方法。<br> <code>prevent</code> 阻止了事件的默认行为，相当于调用了<code>event.preventDefault</code>方法。<br> <code>self</code> 只当在 <code>event.target</code> 是当前元素自身时触发处理函数。<br> <code>once</code> 绑定了事件以后只能触发一次，第二次就不会触发。<br> <code>capture</code> 使用事件捕获模式，即元素自身触发的事件先在此处处理，然后才交由内部元素进行处理。<br> <code>passive</code> 告诉浏览器你不想阻止事件的默认行为。<br> <code>native</code> 让组件变成像<code>html</code>内置标签那样监听根元素的原生事件，否则组件上使用 <code>v-on</code> 只会监听自定义事件。</p></li><li><p>鼠标按键修饰符<br> <code>left</code> 左键点击。<br> <code>right</code> 右键点击。<br> <code>middle</code> 中键点击。</p></li><li><p>键值修饰符</p><p>键盘修饰符是用来修饰键盘事件（onkeyup，onkeydown）的，有如下：keyCode</p><p>存在很多，但vue为我们提供了别名，分为以下两种：</p><ul><li>普通键（enter、tab、delete、space、esc、up…）</li><li>系统修饰键（ctrl、alt、meta、shift…）</li></ul></li></ol><h3 id="对-SPA-的理解？"><a href="#对-SPA-的理解？" class="headerlink" title="对 SPA 的理解？"></a>对 SPA 的理解？</h3><ol><li><p>概念：<br> <code>SPA（Single-page  application）</code>，即单页面应用，它是一种网络应用程序或网站的模型，通过动态重写当前页面来与用户交互，这种方法避免了页面之间切换时打断用户体验。在<code>SPA</code>中，所有必要的代码（HTML、JavaScript 和 CSS）都通过单个页面的加载而检索，或者根据需要（通常是响应用户操作）动态装载适当的资源并添加到页面。页面在任何时间点都不会重新加载，也不会将控制转移到其他页面。举个例子，就像一个杯子，上午装的是牛奶，中午装的是咖啡，下午装的是茶，变得始终是内容，杯子始终不变。</p></li><li><p><code>SPA</code>与<code>MPA</code>的区别：<br> <code>MPA（Muti-page application）</code>，即多页面应用。在<code>MPA</code>中，每个页面都是一个主页面，都是独立的，每当访问一个页面时，都需要重新加载 Html、CSS、JS 文件，公共文件则根据需求按需加载。</p><table><thead><tr><th></th><th>SPA</th><th>MPA</th></tr></thead><tbody><tr><td>组成</td><td>一个主页面和多个页面片段</td><td>多个主页面</td></tr><tr><td>url模式</td><td>hash模式</td><td>history模式</td></tr><tr><td>SEO搜索引擎优化</td><td>难实现，可使用SSR方式改善</td><td>容易实现</td></tr><tr><td>数据传递</td><td>容易</td><td>通过url、cookie、localStorage等传递</td></tr><tr><td>页面切换</td><td>速度快，用户体验良好</td><td>切换加载资源，速度慢，用户体验差</td></tr><tr><td>维护成本</td><td>相对容易</td><td>相对复杂</td></tr></tbody></table></li><li><p><code>SPA</code>的优缺点：<br> 优点：</p><ul><li>具有桌面应用的即时性、网站的可移植性和可访问性</li><li>用户体验好、快，内容的改变不需要重新加载整个页面</li><li>良好的前后端分离，分工更明确</li></ul><p>缺点：</p><ul><li>不利于搜索引擎的抓取</li><li>首次渲染速度相对较慢</li></ul></li></ol><h3 id="双向绑定？"><a href="#双向绑定？" class="headerlink" title="双向绑定？"></a>双向绑定？</h3><ol><li>概念：<br> Vue 中双向绑定是一个指令<code>v-model</code>，可以绑定一个响应式数据到视图，同时视图的变化能改变该值。<code>v-model</code>是语法糖，默认情况下相当于<code>:value</code>和<code>@input</code>，使用<code>v-model</code>可以减少大量繁琐的事件处理代码，提高开发效率。</li><li>使用：<br> 通常在表单项上使用<code>v-model</code>，还可以在自定义组件上使用，表示某个值的输入和输出控制。</li><li>原理：<br> <code>v-model</code>是一个指令，双向绑定实际上是Vue 的编译器完成的，通过输出包含<code>v-model</code>模版的组件渲染函数，实际上还是<code>value</code>属性的绑定及<code>input</code>事件监听，事件回调函数中会做相应变量的更新操作。</li></ol><h3 id="子组件是否可以直接改变父组件的数据？"><a href="#子组件是否可以直接改变父组件的数据？" class="headerlink" title="子组件是否可以直接改变父组件的数据？"></a>子组件是否可以直接改变父组件的数据？</h3><ol><li>所有的<code>prop</code>都遵循着单项绑定原则，<code>props</code>因父组件的更新而变化，自然地将新状态向下流往子组件，而不会逆向传递。这避免了子组件意外修改父组件的状态的情况，不然应用的数据流将很容易变得混乱而难以理解。<br> 另外，每次父组件更新后，所有的子组件中的<code>props</code>都会被更新为最新值，这就意味着不应该子组件中去修改一个<code>prop</code>，若这么做了，Vue 会在控制台上抛出警告。</li><li>实际开发过程中通常有两个场景导致要修改prop：<ul><li><code>prop</code>被用于传入初始值，而子组件想在之后将其作为一个局部数据属性。这种情况下，最好是新定义一个局部数据属性，从<code>props</code>获取初始值即可。</li><li>需要对传入的<code>prop</code>值做进一步转换。最好是基于该<code>prop</code>值定义一个计算属性。</li></ul></li><li>实践中，如果确实要更改父组件属性，应<code>emit</code>一个事件让父组件变更。当对象或数组作为<code>props</code>被传入时，虽然子组件无法更改<code>props</code>绑定，但仍然<strong>可以</strong>更改对象或数组内部的值。这是因为JS的对象和数组是按引用传递，而对于 Vue 来说，禁止这样的改动虽然可能，但是有很大的性能损耗，比较得不偿失。</li></ol><h3 id="router-和-route-的区别？"><a href="#router-和-route-的区别？" class="headerlink" title="router 和 route 的区别？"></a>router 和 route 的区别？</h3><ol><li><code>$router</code>是VueRouter的实例对象，是一个全局的路由对象，包含了所有路由的对象和属性。</li><li><code>$route</code>是一个跳转的路由对象，可以认为是当前组件的路由管理，指当前激活的路由对象，包含当前url解析得到的数据，可以从对象里获取一些数据，如：name，path，params，query等。</li></ol><h3 id="vue-router-的路由传参方式？"><a href="#vue-router-的路由传参方式？" class="headerlink" title="vue-router 的路由传参方式？"></a>vue-router 的路由传参方式？</h3><ol><li>声明式导航 <code>router-link</code>：</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link :to=<span class="string">&quot;&#x27;/users?userId:1&#x27;&quot;</span>&gt;&lt;/router-link&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">&quot;&#123; name: &#x27;users&#x27;, params: &#123; userId: 1 &#125; &#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">&quot;&#123; path: &#x27;/users&#x27;, query: &#123; userId: 1 &#125; &#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span></span><br></pre></td></tr></table></figure><ol><li><p>编程式导航 router-push：</p><ul><li>通过<code>params</code>传参</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;users&#x27;</span>,</span><br><span class="line">    <span class="attr">params</span>: &#123;</span><br><span class="line">        <span class="attr">userId</span>: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 路由配置</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/users&#x27;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;users&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="title class_">User</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 跳转后获取路由参数</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$route</span>.<span class="property">params</span>.<span class="property">userId</span> <span class="comment">// 为 1</span></span><br></pre></td></tr></table></figure><ul><li>通过<code>query</code>传参</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">this.<span class="variable">$router</span>.<span class="title function_ invoke__">push</span>(&#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/users&#x27;</span>,</span><br><span class="line">    <span class="attr">query</span>: &#123;</span><br><span class="line">        <span class="attr">userId</span>: <span class="number">1</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 路由配置</span></span><br><span class="line">&#123;</span><br><span class="line">    path: <span class="string">&#x27;/users&#x27;</span>,</span><br><span class="line">    name: <span class="string">&#x27;users&#x27;</span>,</span><br><span class="line">    component: User</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 跳转后获取路由参数</span></span><br><span class="line">this.<span class="variable">$route</span>.query.userId</span><br></pre></td></tr></table></figure><ul><li>动态路由</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(<span class="string">&#x27;/users/$&#123;userId&#125;&#x27;</span>);</span><br><span class="line"><span class="comment">// 路由配置</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/users/:userId&#x27;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;users&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="title class_">User</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 跳转后获取路由参数</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$route</span>.<span class="property">params</span>.<span class="property">userId</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="Vue-Router中的常用路由模式和原理？"><a href="#Vue-Router中的常用路由模式和原理？" class="headerlink" title="Vue Router中的常用路由模式和原理？"></a>Vue Router中的常用路由模式和原理？</h3><ol><li>hash 模式：</li></ol><ul><li><code>location.hash</code>的值就是url中 <code>#</code> 后面的东西。它的特点在于：hash虽然出现url中，但不会被包含在HTTP请求中，对后端完全没有影响，因此改变hash不会重新加载页面。</li><li>可以为hash的改变添加监听事件<code>window.addEventListener(&quot;hashchange&quot;, funcRef, false)</code>，每一次改变<code>hash (window.location.hash)</code>，都会在浏览器的访问历史中增加一个记录，利用hash的以上特点，就可以实现<strong>前端路由更新视图但不重新请求页面</strong>的功能了。<br> 特点：兼容性好但是不美观</li></ul><ol><li>history 模式：<br> 利用 HTML5 History Interface 中新增的<code>pushState()</code>和<code>replaceState()</code>方法。<br> 这两个方法应用于浏览器的历史记录栈，在当前已有的<code>back</code>、<code>forward</code>、<code>go</code> 的基础上(使用<code>popState()</code>方法)，他们提供了对历史记录进行修改的功能。<br> 这两个方法有个共同点：当调用他们修改浏览器历史记录栈后，虽然当前url改变了，但浏览器不会刷新页面，这就为单页面应用前端路由“更新视图但不重新请求页面”提供了基础<br> 特点：虽然美观，但是刷新会出现 404 需要后端进行配置。</li></ol><h3 id="动态路由？"><a href="#动态路由？" class="headerlink" title="动态路由？"></a>动态路由？</h3><p>很多时候，我们需要将给定匹配模式的路由映射到同一个组件，这种情况就需要定义动态路由。例如，我们有一个 User组件，对于所有 ID 各不相同的用户，都要使用这个组件来渲染。那么，我们可以在 vue-router 的路由路径中使用<code>动态路径参数（dynamic segment）</code>来达到这个效果：<code>&#123;path: &#39;/user/:id&#39;, compenent: User&#125;</code>，其中<code>:id</code>就是动态路径参数。</p><h3 id="对Vuex的理解？"><a href="#对Vuex的理解？" class="headerlink" title="对Vuex的理解？"></a>对Vuex的理解？</h3><ol><li>概念：<br> Vuex 是 Vue 专用的状态管理库，它以全局方式集中管理应用的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</li><li>解决的问题：<br> Vuex 主要解决的问题是多组件之间状态共享。利用各种通信方式，虽然也能够实现状态共享，但是往往需要在多个组件之间保持状态的一致性，这种模式很容易出问题，也会使程序逻辑变得复杂。Vuex 通过把组件的共享状态抽取出来，以全局单例模式管理，这样任何组件都能用一致的方式获取和修改状态，响应式的数据也能够保证简洁的单向流动，使代码变得更具结构化且易于维护。</li><li>什么时候用:<br> Vuex 并非是必须的，它能够管理状态，但同时也带来更多的概念和框架。如果我们不打算开发大型单页应用或应用里没有大量全局的状态需要维护，完全没有使用Vuex的必要，一个简单的 store 模式就够了。反之，Vuex将是自然而然的选择。</li><li>用法：<br> Vuex 将全局状态放入<code>state</code>对象中，它本身是一颗状态树，组件中使用<code>store</code>实例的<code>state</code>访问这些状态；然后用配套的<code>mutation</code>方法修改这些状态，并且只能用<code>mutation</code>修改状态，在组件中调用<code>commit</code>方法提交<code>mutation</code>；如果应用中有异步操作或复杂逻辑组合，需要编写<code>action</code>，执行结束如果有状态修改仍需提交<code>mutation</code>，组件中通过<code>dispatch</code>派发<code>action</code>。最后是模块化，通过<code>modules</code>选项组织拆分出去的各个子模块，在访问状态（state）时需注意添加子模块的名称，如果子模块有设置<code>namespace</code>，那么提交<code>mutation</code>和派发<code>action</code>时还需要额外的命名空间前缀。</li></ol><h3 id="页面刷新后Vuex-状态丢失怎么解决？"><a href="#页面刷新后Vuex-状态丢失怎么解决？" class="headerlink" title="页面刷新后Vuex 状态丢失怎么解决？"></a>页面刷新后Vuex 状态丢失怎么解决？</h3><p>Vuex 只是在内存中保存状态，刷新后就会丢失，如果要持久化就需要保存起来。</p><p><code>localStorage</code>就很合适，提交<code>mutation</code>的时候同时存入<code>localStorage</code>，在<code>store</code>中把值取出来作为<code>state</code>的初始值即可。</p><p>也可以使用第三方插件，推荐使用<code>vuex-persist</code>插件，它是为 Vuex 持久化储存而生的一个插件，不需要你手动存取<code>storage</code>，而是直接将状态保存至 <code>cookie</code> 或者 <code>localStorage</code>中。</p><h3 id="关于-Vue-SSR-的理解？"><a href="#关于-Vue-SSR-的理解？" class="headerlink" title="关于 Vue SSR 的理解？"></a>关于 Vue SSR 的理解？</h3><p><code>SSR</code>即<code>服务端渲染（Server Side Render）</code>，就是将 Vue 在客户端把标签渲染成 html 的工作放在服务端完成，然后再把 html 直接返回给客户端。</p><ul><li>优点：<br> 有着更好的 SEO，并且首屏加载速度更快。</li><li>缺点：<br> 开发条件会受限制，服务器端渲染只支持 beforeCreate 和 created 两个钩子，当我们需要一些外部扩展库时需要特殊处理，服务端渲染应用程序也需要处于 Node.js 的运行环境。服务器会有更大的负载需求。</li></ul><h3 id="了解哪些-Vue-的性能优化方法？"><a href="#了解哪些-Vue-的性能优化方法？" class="headerlink" title="了解哪些 Vue 的性能优化方法？"></a>了解哪些 Vue 的性能优化方法？</h3><ul><li>路由懒加载。有效拆分应用大小，访问时才异步加载。</li><li><code>keep-alive</code>缓存页面。避免重复创建组件实例，且能保留缓存组件状态。</li><li><code>v-for</code>遍历避免同时使用<code>v-if</code>。实际上在 Vue 3 中已经是一个错误用法了。</li><li>长列表性能优化，可采用虚拟列表。</li><li><code>v-once</code>。不再变化的数据使用<code>v-once</code>。</li><li>事件销毁。组件销毁后把全局变量和定时器销毁。</li><li>图片懒加载。</li><li>第三方插件按需引入。</li><li>子组件分割。较重的状态组件适合拆分。</li><li>服务端渲染。</li></ul>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vela运行时</title>
      <link href="/posts/d9795f88.html"/>
      <url>/posts/d9795f88.html</url>
      
        <content type="html"><![CDATA[<p>vela运行时</p><span id="more"></span><ol><li>响应式数据实现和原理</li><li>vdom和组件</li><li>计算属性</li><li>watch实现</li></ol>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c </tag>
            
            <tag> js </tag>
            
            <tag> 运行时 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML &amp; CSS复习</title>
      <link href="/posts/d9795d88.html"/>
      <url>/posts/d9795d88.html</url>
      
        <content type="html"><![CDATA[<p>JS复习记录</p><span id="more"></span><h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><h2 id="1-语义化"><a href="#1-语义化" class="headerlink" title="1. 语义化"></a>1. 语义化</h2><ol><li><p>语义化，指对文本内容的结构化（内容语义化），选择合乎语义的标签（代码语义化）。</p></li><li><p>语义化标签：<code>header</code>、<code>nav</code>、<code>main</code>、<code>article</code>、<code>section</code>、<code>aside</code>、<code>footer</code>等。</p></li><li><p>优点：</p><ul><li>代码结构清晰，易于阅读，有利于维护</li><li>方便其他设备解析（如：屏幕阅读器）</li><li>有利于搜索引擎优化（SEO），搜索引擎爬虫会根据不同的标签来赋予不同的权重</li></ul></li></ol><h2 id="2-script-标签中属性-async-和-defer-的区别？"><a href="#2-script-标签中属性-async-和-defer-的区别？" class="headerlink" title="2. script 标签中属性 async 和 defer 的区别？"></a>2. script 标签中属性 async 和 defer 的区别？</h2><ul><li><code>script</code> 会阻碍 HTML 解析，只有下载好并执行完脚本才会继续解析 HTML</li><li><code>async script</code>：解析 HTML 的过程中会进行脚本的异步下载，下载成功后立马执行，因此有可能会阻断 HTML 的解析。多个脚本的执行顺序无法保证。</li><li><code>defer script</code>：也是异步下载脚步，加载完成后，如果此时 HTML 还没有解析完，浏览器不会暂停解析去执行 JS 代码，而是等待 HTML 解析完毕再执行 JS 代码，如果存在多个 <code>defer script </code>标签，浏览器（IE9及以下除外）会保证它们按照在 HTML 中出现的顺序执行，不会破坏 JS 脚本之间的依赖关系。</li></ul><h2 id="3-DOCTYPE-的作用是什么？"><a href="#3-DOCTYPE-的作用是什么？" class="headerlink" title="3. DOCTYPE 的作用是什么？"></a>3. DOCTYPE 的作用是什么？</h2><p><code>&lt;!DOCTYE&gt;</code> 声明一般位于文档的第一行，它的作用主要是告诉浏览器以什么样的模式来解析文档。一般指定了之后会以“标准模式”进行文档解析，否则就以“兼容模式”进行解析。</p><ul><li>在<code>标准模式</code>下，浏览器的解析规则都是按照最新的标准进行解析的。</li><li>而在<code>兼容模式</code>下，浏览器会以向后兼容的方式来模拟老式浏览器的行为，以保证一些老的网站能正常访问。</li></ul><h2 id="4-SGML、HTML、XML-和-XHTML的区别"><a href="#4-SGML、HTML、XML-和-XHTML的区别" class="headerlink" title="4. SGML、HTML、XML 和 XHTML的区别"></a>4. SGML、HTML、XML 和 XHTML的区别</h2><ul><li><code>SGML</code> 是标准通用标记语言，是一种定义电子文档结构和描述其内容的国际标准语言，是所有电子文档标记语言的起源。</li><li><code>HTML</code> 是超文本标记语言，主要是用于规定怎样显示网页。</li><li><code>XML</code> 是可扩展标记语言，是未来网页语言的发展方向，XML 和 HTML 的最大区别就在于 XML 的标签是可以自己创建的，数量无限多，而 HTML 的标签都是固定的而且数量有限。</li><li><code>XHTML</code> 也是现在基本上所有网页都在用的标记语言，他其实和 HTML 没什么本质的区别，标签都一样，用法也都一样，就是比 HTML 更严格，比如标签必须都用小写，标签都必须有闭合标签等。</li></ul><h2 id="5-HTML5-有哪些新特性、移除了哪些元素？"><a href="#5-HTML5-有哪些新特性、移除了哪些元素？" class="headerlink" title="5. HTML5 有哪些新特性、移除了哪些元素？"></a>5. HTML5 有哪些新特性、移除了哪些元素？</h2><p>HTML5 现在已经不是 SGML 的子集，主要是关于图像、位置、存储、多任务等功能的增加。</p><p>新增的：</p><ul><li>绘图 <code>canvas</code></li><li>用于媒介回放的 <code>video</code> 和 <code>audio</code> 元素</li><li>本地离线存储 <code>localStorage</code> 、<code>sessionStorage</code></li><li>语义化更好的内容元素，如：<code>header</code>、<code>article</code>、<code>nav</code>、<code>section</code>、<code>footer</code>等</li><li>表单控件 <code>calendar</code>、<code>date</code>、<code>time</code>、<code>email</code>、<code>url</code>、<code>search</code> 等</li><li>新的技术 <code>webworker</code>、<code>websocket</code></li><li>新的文档属性 <code>document.visibilityState</code></li></ul><p>移除的：</p><ul><li>纯表现的元素：<code>basefont</code>、<code>big</code>、<code>center</code>、<code>s</code>、<code>tt</code>、<code>u</code></li><li>对可用性产生负面影响的元素：<code>frame</code>、<code>frameset</code>、<code>noframes</code></li></ul><h2 id="6-对浏览器内核的理解"><a href="#6-对浏览器内核的理解" class="headerlink" title="6. 对浏览器内核的理解"></a>6. 对浏览器内核的理解</h2><p>主要分为两部分：渲染引擎和JS引擎。</p><ul><li><code>渲染引擎</code>：其职责就是渲染，即在浏览器窗口中显示所请求的内容。默认情况下，渲染引擎可以显示 HTML、 XML 文档及图片，它也可以借助一些浏览器扩展插件显示其他类型数据，如：使用PDF阅读器插件可以显示 PDF 格式。</li><li><code>JS引擎</code>：解析和执行 JavaScript 来实现网页的动态效果。</li></ul><p>最开始渲染引擎和JS引擎并没有区分的很明显，后来JS引擎越来越独立，内核就倾向于只指渲染引擎了</p><h2 id="7-什么是文档的预解析？"><a href="#7-什么是文档的预解析？" class="headerlink" title="7. 什么是文档的预解析？"></a>7. 什么是文档的预解析？</h2><p>当执行 JavaScript 脚本时，另一个线程解析剩下的文档，并加载后面需要通过网络加载的资源。这种方式可以使资源并行加载，从而使整体速度更快。</p><p>需要注意的是，预解析并不改变DOM树，它将这个工作交给主解析过程，自己只解析外部资源的引用，比如：外部脚本、样式及图片。</p><h2 id="8-浏览器的渲染原理"><a href="#8-浏览器的渲染原理" class="headerlink" title="8. 浏览器的渲染原理"></a>8. 浏览器的渲染原理</h2><p>简记： 生成DOM树 –&gt; 生成CSS规则树 –&gt; 构建渲染树 –&gt; 布局 –&gt; 绘制</p><ol><li>首先解析收到的文档，根据文档定义构建一颗 <code>DOM 树</code>，DOM 树是由 DOM 元素及属性节点组成的。</li><li>然后对 CSS 进行解析，生成一颗 <code>CSS 规则树</code>。</li><li>根据 DOM 树和 CSS 规则树构建<code>渲染树</code>。渲染树的节点被称为渲染对象，它是一个包含有颜色等属性的矩形。渲染对象和 DOM 元素相对应，但这种关系不是一对一的，不可见的 DOM 元素不会插入渲染树。还有一些 DOM 元素对应几个可见对象，它们一般是一些具有复杂结构的元素，无法用一个矩形来描述。</li><li>当渲染对象被创建并添加到树中，它们没有位置和大小，所以当浏览器生成渲染树以后，就会根据渲染树来进行<code>布局</code>（也可以叫做回流）。这一阶段浏览器要做的是计算出各个节点在页面中确切位置和大小。通常这一行为也被称为自动重排。</li><li>布局阶段结束后是<code>绘制</code>阶段，遍历渲染树并调用渲染对象的 paint 方法将它们的内容显示到屏幕上。值得注意的是，这个过程是逐步完成的，为了更好的用户体验，渲染引擎会尽早的将内容呈现到屏幕上，并不会等到所有 HMTL 内容都解析完之后再去构建和布局渲染树，它是解析完一部分内容就显示一部分内容，同时，可能还通过网络下载其余内容。</li></ol><h2 id="9-什么是回流和重绘？"><a href="#9-什么是回流和重绘？" class="headerlink" title="9. 什么是回流和重绘？"></a>9. 什么是回流和重绘？</h2><p>1.概念：</p><ul><li><code>回流</code>：当 DOM 的变化影响了元素的几何信息，浏览器需要重新计算元素的几何属性，将其安放在界面中的正确位置，这个过程叫做回流（也可以叫做重排）。表现为重新生成布局，重新排列元素。</li><li><code>重绘</code>：当一个元素的外观发生改变，重新把元素外观绘制出来的过程，叫做重绘。表现为某些元素的外观被改变。</li></ul><p>2.常见引起回流和重绘的属性和方法：</p><p>任何会改变元素几何信息（元素的位置和尺寸大小）的操作都会触发回流。</p><ul><li>添加或删除可见的 DOM 元素</li><li>元素尺寸改变–边距、填充、宽度、高度</li><li>浏览器尺寸改变– resize 事件发生时</li><li>计算 offsetWidth 和 offsetHeight 属性</li><li>设置 style 属性的值</li><li>修改网页默认字体</li></ul><p><strong>回流必定会发生重绘，重绘不一定会引发回流。</strong></p><p><strong>回流所需的成本比重绘高得多</strong></p><p>建议阅读文章：<a href="https://juejin.cn/post/6844903779700047885">你真的了解回流和重绘吗</a></p><h2 id="10-如何减少回流？"><a href="#10-如何减少回流？" class="headerlink" title="10. 如何减少回流？"></a>10. 如何减少回流？</h2><ul><li>使用 transform 代替 top</li><li>不要把节点的属性值放在一个循环里，当成循环里的变量</li><li>不要使用 table 布局，可能很小的一个改动会造成整个 table 的重新布局</li><li>把 DOM 离线后修改。如：使用 documentFragment 对象在内存里操作 DOM</li><li>不要一条一条的修改样式，可以预先定义好 class，然后修改 DOM 的 className</li><li>使用 absolute 或 fixed 使元素脱离文档流</li></ul><h2 id="11-sessionStorage，localStorage-和-cookie-的区别"><a href="#11-sessionStorage，localStorage-和-cookie-的区别" class="headerlink" title="11. sessionStorage，localStorage 和 cookie 的区别"></a>11. sessionStorage，localStorage 和 cookie 的区别</h2><ol><li>共同点：都是保存在浏览器端，且同源的</li><li>区别:</li></ol><ul><li>cookie 始终在同源的 http 请求中携带（即使不需要），即 cookie 在浏览器和服务器之间来回传递；而 sessionStorage 和 localStorage 不会自动把数据发送到服务器，仅在本地保存。cookie 还有路径（path）的概念，可以限制 cookie 只属于某个路径下。</li><li>存储大小限制不同。cookie 不能超过 4K，因为每次 http 请求都会携带 cookie，所以 cookie 只适合保存很小的数据，如：会话标识。sessionStorage 和 localStorage 虽然也有存储大小限制，但比 cookie 大得多，可以达到 5M 或更大。</li><li>数据有效期不同。sessionStorage 仅在当前浏览器窗口关闭之前有效；localStorage 始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie 只在设置的 cookie 过期时间之前有效。</li><li>作用域不同。sessionStorage 不在不同的浏览器窗口中共享，即使是同一个页面；localStorage 和 cookie 在所有同源窗口中都是共享的。</li></ul><h2 id="12-iframe-有哪些优缺点？"><a href="#12-iframe-有哪些优缺点？" class="headerlink" title="12. iframe 有哪些优缺点？"></a>12. iframe 有哪些优缺点？</h2><p>优点：</p><ol><li>iframe 能原封不动的把嵌入的网页展现出来。</li><li>如果有多个网页引用 iframe，只需修改 iframe 的内容，就可以实现调用每一个页面的更改，方便快捷。</li></ol><p>缺点：</p><ol><li>iframe 会阻塞主页面的 onload 事件。</li><li>iframe 和主页面共享链接池，而浏览器对相同域的链接有限制，所以会影响页面的并行加载。</li><li>不利于 SEO，代码复杂，无法一下被搜索引擎索引到。</li><li>iframe 框架页面会增加服务器的 http 请求，对于大型网站不可取。</li><li>很多移动设备无法完全显示框架，设备兼容性差。</li></ol><p>注意：通过动态给 iframe 添加 src 属性值，可解决前两个问题。</p><h2 id="13-什么是-canvas，基本用法是什么？"><a href="#13-什么是-canvas，基本用法是什么？" class="headerlink" title="13. 什么是 canvas，基本用法是什么？"></a>13. 什么是 canvas，基本用法是什么？</h2><p>canvas 元素是 HTML5 的一部分，允许脚步语言动态渲染位图像。canvas 由一个可控制区域 HTML 代码中的属性定义决定高度和宽度。JavaScript 代码可以访问该区域，通过一套完整的绘图功能类似于其他通用二维的 API，从而生成动态的图形。</p><ol><li>创建 canvas 标签</li></ol><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arduino</span><br><span class="line">复制代码&lt;canvas id=<span class="string">&quot;myCanvas&quot;</span> width=<span class="string">&quot;150&quot;</span> height=<span class="string">&quot;150&quot;</span>&gt;该浏览器不支持canvas&lt;/canvas&gt;</span><br></pre></td></tr></table></figure><ol><li>渲染上下文</li></ol><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ini复制代码var <span class="attr">canvas</span> = document.getElementById(<span class="string">&#x27;myCanvas&#x27;</span>)<span class="comment">;</span></span><br><span class="line">var <span class="attr">ctx</span> = canvas.getContext(<span class="string">&#x27;2d&#x27;</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>代码第一行通过使用 <code>document.getElementById()</code> 方法获取 <code>&lt;canvas&gt;</code> 元素对应的 DOM 对象，然后可以通过使用它的 <code>getContext()</code> 方法来绘制上下文。 创建 canvas 标签时可以在标签内写上不支持的提示信息；也可以通过 <code>getContext()</code> 方法判读是否支持编程。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ini复制代码var <span class="attr">canvas</span> = document.getElementById(<span class="string">&#x27;myCanvas&#x27;</span>)<span class="comment">;</span></span><br><span class="line">if (canvas.getContext) &#123;</span><br><span class="line">  var <span class="attr">ctx</span> = canvas.getContext(<span class="string">&#x27;2d&#x27;</span>)<span class="comment">;</span></span><br><span class="line">  // other code</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  // 不支持 canvas 的其他代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用途：</p><p>canvas 可用于游戏和图表（echarts.js、heightchart.js 都是基于 canvas 来绘图）制作。</p><h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><h2 id="1-css3-有哪些新特性？"><a href="#1-css3-有哪些新特性？" class="headerlink" title="1. css3 有哪些新特性？"></a>1. css3 有哪些新特性？</h2><ul><li>rgba 和 透明度</li><li>background-image、background-origin、background-size、background-repeat</li><li>word-wrap: break-word（对长的不可分割的单词换行）</li><li>文字阴影 text-shadow</li><li>font-face属性，定义自己的字体</li><li>border-radius</li><li>边框图片 border-image</li><li>盒阴影 box-shadow</li><li>媒体查询：定义多套 css，当浏览器尺寸发生变化时采用不同的属性</li></ul><h2 id="2-style-标签写在-body-后与-body-前有什么区别？"><a href="#2-style-标签写在-body-后与-body-前有什么区别？" class="headerlink" title="2. style 标签写在 body 后与 body 前有什么区别？"></a>2. style 标签写在 body 后与 body 前有什么区别？</h2><ol><li>写在 body 标签前有利于浏览器逐步渲染： resources downloading –&gt; cssDOM + DOM –&gt; Render Tree –&gt; layout –&gt; paint</li><li>写在 body 标签后： 由于浏览器以逐行方式对 HTML 文档进行解析，当解析到写在尾部的样式表（外联或写在 style 标签）会导致浏览器停止之前的渲染，等待加载且解析样式完成后重新渲染；在 windows 的 IE 下可能出现样式失效导致的页面闪烁问题。</li></ol><h2 id="3-CSS选择器及优先级"><a href="#3-CSS选择器及优先级" class="headerlink" title="3. CSS选择器及优先级"></a>3. CSS选择器及优先级</h2><ol><li>选择器<ul><li>id选择器(#myid)</li><li>类选择器(.myclass)</li><li>属性选择器(a[rel=”external”])</li><li>伪类选择器(a:hover, li:nth-child)</li><li>标签选择器(div, h1, p)</li><li>伪元素选择器(p::first-line)</li><li>相邻选择器（h1 + p）</li><li>子选择器(ul &gt; li)</li><li>后代选择器(li a)</li><li>通配符选择器(*)</li></ul></li><li>优先级<ul><li><code>!important</code></li><li>内联样式（1000）</li><li>ID选择器（0100）</li><li>类选择器 / 属性选择器 / 伪类选择器（0010）</li><li>标签选择器 / 伪元素选择器（0001）</li><li>关系选择器 / 通配符选择器（0000）</li></ul></li></ol><p>带 !important 标记的样式属性优先级最高；样式表的来源相同时：<code>!important &gt; 行内样式&gt; ID选择器 &gt; 类选择器 &gt; 标签 &gt; 通配符 &gt; 继承 &gt; 浏览器默认属性</code></p><h2 id="4-rgba-和-opacity-设置透明度的区别是什么？"><a href="#4-rgba-和-opacity-设置透明度的区别是什么？" class="headerlink" title="4. rgba() 和 opacity 设置透明度的区别是什么？"></a>4. rgba() 和 opacity 设置透明度的区别是什么？</h2><p>rgba() 和 opacity 都能实现透明效果，但最大的不同是 opacity 作用于元素，以及元素内的所有内容的透明度；而 rgba() 只作用于元素的颜色或其背景色，设置 rgba() 透明的元素的子元素不会继承透明效果。</p><h2 id="5-浏览器是如何解析-css-选择器的？"><a href="#5-浏览器是如何解析-css-选择器的？" class="headerlink" title="5. 浏览器是如何解析 css 选择器的？"></a>5. 浏览器是如何解析 css 选择器的？</h2><p><code>从右向左解析的。</code>若从左向右匹配，发现不符合规则，需要回溯，会损失很多性能。若从右向左匹配，先找到所有的最后节点，对于每一个节点，向上寻找其父节点直到查找至根元素或满足条件的匹配规则，则结束这个分支的遍历。</p><p>在 css 解析完毕后，需将解析结果 css 规则树和 DOM Tree 一起进行分析建立一颗 Render Tree，最终用来进行绘图。</p><h2 id="6-display-none-和-visibility-hidden-两者的区别"><a href="#6-display-none-和-visibility-hidden-两者的区别" class="headerlink" title="6. display: none 和 visibility: hidden 两者的区别"></a>6. display: none 和 visibility: hidden 两者的区别</h2><ol><li>display: none 隐藏后不占用文档流；而 visibility: hidden 会占用文档流。</li><li>visibility 具有继承性，给父元素设置 “visibility: hidden”，子元素也会继承该属性，但如果重新给子元素设置 “visibility: visible”，则子元素又会显示出来。</li><li>visibility: hidden 不会影响计数器的计数，虽然隐藏了，但计数器依然运行着。</li><li>在 css3 中 transition 支持 visibility 属性，但不支持 display。因为 transition 可以延迟执行，因此配合 visibility 使用纯 css 延时显示效果可以提高用户体验。</li><li>display: none 会引起回流（重排）和重绘；visibility: hidden 会引起重绘。</li></ol><h2 id="7-简述-transform，transition，animation-的作用"><a href="#7-简述-transform，transition，animation-的作用" class="headerlink" title="7. 简述 transform，transition，animation 的作用"></a>7. 简述 transform，transition，animation 的作用</h2><ol><li><code>transform</code>：描述了元素的静态样式，本身不会呈现动画效果，可以对元素进行旋转 rotate、扭曲 skew、缩放 scale 和移动 translate 以及矩阵变形 matrix。<code>transition</code> 和 <code>animation</code> 两者都能实现动画效果。<code>transform</code> 常配合<code>transition</code> 和 <code>animation</code> 使用。</li><li><code>transition</code>：样式过渡，从一种效果逐渐改变为另一种效果，它是一个合写属性。transition: transition-property  transition-duration  transition-timing-function  transition-delay 从左到右，依次是：过渡效果的css属性名称、过渡效果花费时间、速度曲线、过渡开始的延迟时间  <code>transition</code> 通常和 hover 等事件配合使用，需要由事件来触发过渡。</li><li><code>animation</code>：动画，有 <code>@keyframes</code> 来描述每一帧的样式。</li></ol><p>区别：</p><ul><li><code>transform</code> 仅描述元素的静态样式，常配合<code>transition</code> 和 <code>animation</code> 使用。</li><li><code>transition</code> 通常和 hover 等事件配合使用；<code>animation</code> 是自发的，立即播放。</li><li><code>animation</code> 可以设置循环次数。</li><li><code>animation</code> 可以设置每一帧的样式和时间，<code>transition</code> 只能设置头尾。</li><li><code>transition</code> 可以与 js 配合使用， js 设定要变化的样式，<code>transition</code> 负责动画效果。</li></ul><h2 id="8-line-height-如何继承？"><a href="#8-line-height-如何继承？" class="headerlink" title="8. line-height 如何继承？"></a>8. line-height 如何继承？</h2><ul><li>父元素的 <code>line-height</code> 是具体数值，则子元素 <code>line-height</code> 继承该值。</li><li>父元素的 <code>line-height</code> 是比例值，如’2’，则子元素 <code>line-height</code> 继承该比例。</li><li>父元素的 <code>line-height</code> 是百分比，则子元素 <code>line-height</code> 继承的是父元素的 font-size * 百分比 计算出来的值。</li></ul><h2 id="9-如何让-chrome-支持-10px-的文字？"><a href="#9-如何让-chrome-支持-10px-的文字？" class="headerlink" title="9. 如何让 chrome 支持 10px 的文字？"></a>9. 如何让 chrome 支持 10px 的文字？</h2><ol><li>font-size: 12px; -webkit-transform: scale(0.84);</li><li>font-size: 20px; -webkit-transform: scale(0.5);</li></ol><h2 id="10-position-属性的值有哪些？"><a href="#10-position-属性的值有哪些？" class="headerlink" title="10. position 属性的值有哪些？"></a>10. position 属性的值有哪些？</h2><ol><li><code>static</code>：默认定位。元素出现在正常的文档流中（忽略top，bottom，left，right 或 z-index声明）</li><li><code>relative</code>：相对定位。如果对一个元素进行相对定位，将出现在它所在的位置上。然后，可以通过设置垂直或水平位置，使其“相对于”它的起点进行移动。使用相对定位时，无论是否移动，元素仍然占据原来的空间；移动元素会导致其覆盖其他元素。</li><li><code>absolute</code>：绝对定位。元素的位置相对于最近的已定位的父元素，如果元素没有已定位的父元素，则相对于根元素（即 html 元素）定位。绝对定位的元素会脱离文档流，不占据空间，会与其他元素重叠。</li><li><code>fixed</code>：固定定位。元素的位置相对于浏览器窗口是固定位置，即使窗口滚动它也不会移动。固定定位的元素会脱离文档流，不占据空间，会与其他元素重叠。</li><li><code>sticky</code>：粘性定位。粘性定位可以被认为是相对定位和固定定位的混合，元素在跨越特定阈值前为相对定位，之后为固定定位。top，right，buttom，left，必须指定这四个阈值中的一个，才可以使粘性定位生效，否则行为与其相对定位相同。</li><li><code>inherit</code>：规定应该从父元素继承 position 属性的值。</li></ol><h2 id="11-css-盒模型？"><a href="#11-css-盒模型？" class="headerlink" title="11. css 盒模型？"></a>11. css 盒模型？</h2><ul><li><code>标准盒模型</code>，width 指 content 部分的宽度，总宽度 = width + border(左右) + padding（左右）+ margin（左右）；高度同理。</li><li><code>怪异盒模型（IE盒模型）</code>，width 指 content + border（左右） + padding（左右）三部分的宽度，因此，总宽度 = width + margin（左右）；高度同理。</li></ul><h2 id="12-box-sizing-属性"><a href="#12-box-sizing-属性" class="headerlink" title="12. box-sizing 属性"></a>12. box-sizing 属性</h2><ol><li><code>content-box</code>，对应标准盒模型。</li><li><code>border-box</code>，IE盒模型。</li><li><code>inherit</code>，继承父元素的 box-sizing 值。</li></ol><h2 id="13-BFC（块级格式上下文）"><a href="#13-BFC（块级格式上下文）" class="headerlink" title="13. BFC（块级格式上下文）"></a>13. BFC（块级格式上下文）</h2><ol><li>概念： BFC（Block Formatting Context），块级格式上下文。BFC 是 css 布局的一个概念，是一个独立的渲染区域，规定了内部 box 如何布局，且这个区域内的子元素不会影响到外面的元素。</li><li>布局规则：</li></ol><ul><li>内部的 box 会在垂直方向一个接一个的放置</li><li>box 垂直方向的距离由 margin 决定，同一个 BFC 相邻的 box 的 margin 会发生重叠</li><li>每个 box 的 margin 左边，与包含块的左 border 相接触（对于从左往右的格式化，否则相反）</li><li>BFC 的区域不会与 float box 重叠</li><li>BFC 是一个独立容器，容器内的子元素不会影响到外面的元素</li><li>计算 BFC 高度时，浮动元素也参与计算高度</li></ul><ol><li>如何创建 BFC ？</li></ol><ul><li>根元素，即 html 元素</li><li>float 值不为 none</li><li>position 值为 absolute 或 fixed</li><li>display 的值为 inline-block、tabl-cell、table-caption</li><li>overflow 的值不为 visible</li></ul><ol><li>BFC 的使用场景</li></ol><ul><li>去除边距重叠问题</li><li>清除浮动（让父元素的高度包含子浮动元素）</li><li>阻止元素被浮动元素覆盖</li></ul><h2 id="14-让一个元素水平-垂直居中"><a href="#14-让一个元素水平-垂直居中" class="headerlink" title="14. 让一个元素水平/垂直居中"></a>14. 让一个元素水平/垂直居中</h2><ol><li>水平居中</li></ol><ul><li>行内元素：<code>text-align: center;</code></li><li>对于确定宽度的块级元素<ul><li>width 和 margin 实现： <code>mragin: 0 auto;</code></li><li>绝对定位和 margin-left 实现： <code>margin-left: (父width - 子 width)/2；</code>(前提是父元素相对定位)</li></ul></li><li>对于宽度未知的块级元素<ul><li>table 标签配合 margin 左右 auto 实现</li><li>inline-block 实现：<code>display: inline-block; text-align: center;</code></li><li>绝对定位和 transform 实现， translateX 可以移动本身元素的50%</li><li>flex 布局 <code>justify-content: center</code></li></ul></li></ul><ol><li>垂直居中</li></ol><ul><li>纯文字类，设置 line-height 等于 height</li><li>子绝父相，子元素通过 margin 实现自适应居中</li><li>子绝父相，通过位移 transform 实现</li><li>flex 布局，<code>align-items: center;</code></li><li>table 布局，父级通过转换为表格形式，子级设置 vertical-align 实现</li></ul><h2 id="15-flex-布局"><a href="#15-flex-布局" class="headerlink" title="15. flex 布局"></a>15. flex 布局</h2><p>flex 布局，是一种弹性盒布局模型，给子元素提供了空间分布和对齐能力，由<code>container</code>（容器）及<code>item</code>（项目）组成。该布局模型提供了一种更加高效的方式来对容器中的项目进行布局、对齐和分配空间。适用于在不同尺寸的屏幕中创建可自动扩展和收缩布局，通常可用于<code>水平/垂直居中</code>，<code>两栏</code>、<code>三栏布局</code>等的场景里。</p><p>其中<code>flex</code>属性是<code>flex-grow</code>，<code>flex-shrink</code>和<code>flex-basis</code>的简写，默认值为<code>0 1 auto</code>。<strong>该属性有两个快捷值：<code>auto (1 1 auto)</code> 和 <code>none (0 0 auto)</code>。</strong></p><ul><li><code>flex-grow</code>：定义项目的放大比例，默认值为 0，即如果存在剩余空间，也不放大。如果所有项目的<code>flex-grow</code>属性都为 1，则它们将等分剩余空间（如果有的话）。如果一个项目的<code>flex-grow</code>属性为 2，其他项目都为 1，则前者占据的剩余空间将比其他项多一倍。</li><li><code>flex-shrink</code>：项目的缩小比例，默认为 1，即如果空间不足，项目将缩小。如果所有项目的<code>flex-shrink</code>属性都为 1，当空间不足时，都将等比例缩小。如果一个项目的<code>flex-shrink</code>属性为 0，其他项目都为 1，则空间不足时，前者不缩小。</li><li><code>flex-basis</code>：定义了在分配多余空间之前，项目占据的主轴空间。浏览器会根据该属性，计算主轴是否有多余空间。它的默认值为 auto，即项目的本来大小。当设置为 0 的是，会根据内容撑开。也可以设为跟<code>width</code>或<code>height</code>属性一样的值（比如 350px），则项目将占据固定空间。</li></ul><p><code>flex</code>常用的属性值：</p><ul><li>flex: 1 –&gt; flex: 1 1 0%</li><li>flex: 2 –&gt; flex: 2 1 0%</li><li>flex: auto –&gt; flex: 1 1 auto</li><li>flex: none –&gt; flex: 0 0 auto【常用于固定尺寸不伸缩】</li></ul><h2 id="16-清除浮动"><a href="#16-清除浮动" class="headerlink" title="16. 清除浮动"></a>16. 清除浮动</h2><ol><li><p>直接把 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=&quot;clear: both;&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>作为最后一个子标签</p><ul><li>优点：通俗易懂，容易掌握；</li><li>缺点：会添加较多无意义的空标签，有违结构与表现的分离，在后期维护中将是噩梦</li></ul></li><li><p>.clearfix { overflow: hidden; zoom: 1; }</p><ul><li>优点：不存在结构和语义化问题，代码量极少</li><li>缺点：内容增多时容易造成不自动换行，导致内容被隐藏掉，无法显示需要溢出的元素</li></ul></li><li><p>建立伪类选择器</p></li></ol><p><img src="https://raw.githubusercontent.com/why862555625/images/main/images/98e2353e3275475095bd26ecedfa32e9%7Etplv-k3u1fbpfcp-zoom-in-crop-mark%3A1512%3A0%3A0%3A0.awebp" alt="image.png"></p><h2 id="17-css-中优雅降级和渐进增强有什么区别？"><a href="#17-css-中优雅降级和渐进增强有什么区别？" class="headerlink" title="17. css 中优雅降级和渐进增强有什么区别？"></a>17. css 中优雅降级和渐进增强有什么区别？</h2><p>优雅降级和渐进增强是随着 css3 流出来的一个概念。由于低级浏览器不支持 css3， 但 css3 的效果又很优秀不忍放弃，所以在高级浏览器中使用 css3 ，而在低级浏览器只保证最基本的功能。二者最关键的区别是它们所侧重的内容，以及这种不同所造成的工作流程的差异。</p><ul><li><code>优雅降级</code>：一开始就构建完整的功能，然后针对浏览器测试和修复。</li><li><code>渐进增强</code>：一开始就针对低版本浏览器进行构建页面，完成基本的功能，然后再针对高级浏览器进行效果、交互、追加功能以达到更好的体验。</li></ul><h2 id="18-img-的-alt-和-title-的异同？实现图片懒加载的原理？"><a href="#18-img-的-alt-和-title-的异同？实现图片懒加载的原理？" class="headerlink" title="18. img 的 alt 和 title 的异同？实现图片懒加载的原理？"></a>18. img 的 alt 和 title 的异同？实现图片懒加载的原理？</h2><ul><li><code>alt</code>是图片加载失败时显示在网页上的替代文字；<code>title</code>是鼠标放在图片上面时显示的文字，是对图片的进一步描述和说明。</li><li><code>alt</code>是 img 的必要属性；<code>title</code>不是。</li><li>对于网站 SEO 优先来说，搜索引擎对图片意思的判断，主要是靠<code>alt</code>属性，所以在图片<code>alt</code>属性中以简要文字说明，同时包含关键字，也是页面优化的一部分。</li></ul><p><code>懒加载原理</code>：先设置图片的 <code>data-set</code> 属性值（也可以是其他任意的，只要不发生 http 请求就可以，作用是为了存取值）为图片路径，由于不是 <code>src</code> 属性，故不会发生 http 请求。然后计算出页面的 scrollTop 的高度和浏览器的高度之和，如果图片距页面顶端距离小于前两者之和，说明图片要显示出来了，这时将 <code>data-set</code> 属性替换为 <code>src</code> 属性即可。</p><h2 id="19-css-sprites-（雪碧图-精灵图）"><a href="#19-css-sprites-（雪碧图-精灵图）" class="headerlink" title="19. css sprites （雪碧图/精灵图）"></a>19. css sprites （雪碧图/精灵图）</h2><p>css sprites 就是把网页中一些小图片整合到一张图片文件中，再利用 css 的 background-image、background-repeat、background-position 的组合进行背景定位。</p><p>优点： 减少图片体积；减少 http 请求次数</p><p>缺点：维护比较麻烦；不能随便改变大小，会失真模糊</p><h2 id="20-什么是字体图标？"><a href="#20-什么是字体图标？" class="headerlink" title="20. 什么是字体图标？"></a>20. 什么是字体图标？</h2><p>字体图标简单的说，就是一种特殊的字体，通过这种字体，显示给用户的就像一个个图片一样。字体图标最大的好处，在于它不会变形和加载速度快。字体图标可以像文字一样，随意通过 css 来控制它的大小和颜色，非常方便。</p><h2 id="21-主流浏览器内核私有属性-css-前缀？"><a href="#21-主流浏览器内核私有属性-css-前缀？" class="headerlink" title="21. 主流浏览器内核私有属性 css 前缀？"></a>21. 主流浏览器内核私有属性 css 前缀？</h2><ul><li>mozilla(firefox、flock等): -moz</li><li>webkit 内核(safari、chrome等): -webkit</li><li>opera 内核(opera浏览器): -o</li><li>trident 内核(ie 浏览器): -ms</li></ul>]]></content>
      
      
      <categories>
          
          <category> HTML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS复习</title>
      <link href="/posts/d9795d86.html"/>
      <url>/posts/d9795d86.html</url>
      
        <content type="html"><![CDATA[<p>JS复习记录</p><span id="more"></span><h1 id="1-JS-的数据类型有哪些？"><a href="#1-JS-的数据类型有哪些？" class="headerlink" title="1. JS 的数据类型有哪些？"></a>1. JS 的数据类型有哪些？</h1><ul><li>基本数据类型（值类型）：Number、String、Boolean、Null、Undefined、Symbol、BigInt。保存在栈内存中。</li><li>复杂数据类型（引用类型）：Object、Function、Array、RegExp、Date 基本包装类型及单体内置对象(Global、Math)等。</li></ul><blockquote><p>基本数据类型保存在栈里面，可以直接访问它的值；引用数据类型保存在堆里面，栈里面保存的是地址，通过栈里面的地址去访问堆里面的值。</p></blockquote><h1 id="2-null-和-undefined-的区别？"><a href="#2-null-和-undefined-的区别？" class="headerlink" title="2.null 和 undefined 的区别？"></a>2.null 和 undefined 的区别？</h1><ul><li>null表示一个对象被定义了，值为“空值”。用法：<br>① 作为函数的参数，表示该函数的参数不是对象。<br>② 作为对象原型链的终点。</li><li>undefined表示不存在这个值。就是此处应该有一个值，但是还没有定义，当尝试读取时就会返回 undefined。用法：<br>① 函数没有返回值时，默认返回 undefined。<br>② 变量已声明，没有赋值时，为 undefined。<br>③ 对象中没有赋值的属性，该属性的值为 undefined。<br>④ 调用函数时，应该提供的参数没有提供，该参数等于 undefined。</li></ul><h1 id="3-如何判断-JS-的数据类型？"><a href="#3-如何判断-JS-的数据类型？" class="headerlink" title="3. 如何判断 JS 的数据类型？"></a>3. 如何判断 JS 的数据类型？</h1><h2 id="1-typeof"><a href="#1-typeof" class="headerlink" title="1.typeof"></a>1.typeof</h2><p>typeof可以区分除了Null类型以外的其他基本数据类型，以及从对象类型中识别出函数（function）。<br>其返回值有：number、string、boolean、undefined、symbol、bigint、function、object。<br>其中, typeof null返回 “object”<br>如果要识别null，可直接使用===全等运算符来判断。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="number">1</span> <span class="comment">// &#x27;number&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">&#x27;1&#x27;</span> <span class="comment">// &#x27;string&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span> <span class="comment">// &#x27;boolean&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span> <span class="comment">// &#x27;undefined&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="title class_">Symbol</span>() <span class="comment">// &#x27;symbol&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span> <span class="comment">// &#x27;object&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> [] <span class="comment">// &#x27;object&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125; <span class="comment">// &#x27;object&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="variable language_">console</span> <span class="comment">// &#x27;object&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="variable language_">console</span>.<span class="property">log</span> <span class="comment">// &#x27;function&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-instanceof"><a href="#2-instanceof" class="headerlink" title="2.instanceof"></a>2.instanceof</h2><p>instanceof一般是用来判断引用数据类型，但不能正确判断基本数据类型，根据在原型链中查找判断当前数据的原型对象是否存在返回布尔类型。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">instanceof</span> <span class="title class_">Number</span>; <span class="comment">// false</span></span><br><span class="line"><span class="literal">true</span> <span class="keyword">instanceof</span> <span class="title class_">Boolean</span>; <span class="comment">// false</span></span><br><span class="line"><span class="string">&#x27;str&#x27;</span> <span class="keyword">instanceof</span> <span class="title class_">String</span>; <span class="comment">// false</span></span><br><span class="line">[] <span class="keyword">instanceof</span> <span class="title class_">Array</span>; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">function</span>(<span class="params"></span>)&#123;&#125; <span class="keyword">instanceof</span> <span class="title class_">Function</span>; <span class="comment">// true</span></span><br><span class="line">&#123;&#125; <span class="keyword">instanceof</span> <span class="title class_">Object</span>; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">let</span> date = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">date instance <span class="keyword">of</span> <span class="title class_">Date</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="3-Object-prototype-toString"><a href="#3-Object-prototype-toString" class="headerlink" title="3. Object.prototype.toString"></a>3. Object.prototype.toString</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">toString</span>(&#123;&#125;) <span class="comment">// &quot;[object Object]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(&#123;&#125;) <span class="comment">// 同上结果，加上call也ok</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="number">1</span>) <span class="comment">// &quot;[object Number]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="string">&#x27;1&#x27;</span>) <span class="comment">// &quot;[object String]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="literal">true</span>) <span class="comment">// &quot;[object Boolean]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;) <span class="comment">// &quot;[object Function]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="literal">null</span>) <span class="comment">//&quot;[object Null]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="literal">undefined</span>) <span class="comment">//&quot;[object Undefined]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="regexp">/123/g</span>) <span class="comment">//&quot;[object RegExp]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="keyword">new</span> <span class="title class_">Date</span>()) <span class="comment">//&quot;[object Date]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>([]) <span class="comment">//&quot;[object Array]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="variable language_">document</span>) <span class="comment">//&quot;[object HTMLDocument]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="variable language_">window</span>) <span class="comment">//&quot;[object Window]&quot;</span></span><br></pre></td></tr></table></figure><h2 id="4-Array-isArray"><a href="#4-Array-isArray" class="headerlink" title="4. Array.isArray"></a>4. Array.isArray</h2><p>Array.isArray(value)可以判断 value 是否为数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="title function_">isArray</span>([]); <span class="comment">// true</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">isArray</span>(&#123;&#125;); <span class="comment">// false</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">isArray</span>(<span class="number">1</span>); <span class="comment">// false</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">isArray</span>(<span class="string">&#x27;string&#x27;</span>); <span class="comment">// false</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">isArray</span>(<span class="literal">true</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h1 id="3-如何遍历对象的属性？"><a href="#3-如何遍历对象的属性？" class="headerlink" title="3.如何遍历对象的属性？"></a>3.如何遍历对象的属性？</h1><ul><li>遍历自身可枚举的属性（可枚举、非继承属性）：Object.keys() 方法,该方法会返回一个由给定对象的自身可枚举属性组成的数组。</li><li>遍历自身的所有属性（可枚举、不可枚举、非继承属性）：Object.getOwnPropertyNames()方法，该方法会返回一个由指定对象的所有自身属性组成的数组</li><li>遍历可枚举的自身属性和继承属性：for … in …</li></ul><h1 id="4-和-的区别？"><a href="#4-和-的区别？" class="headerlink" title="4. == 和 === 的区别？"></a>4. == 和 === 的区别？</h1><ul><li>==：两个等号称为等值符，当等号两边的值为相同类型时比较值是否相同，类型不同时会发生类型的自动转换，转换为相同的类型后再做比较。</li><li>===：三个等号称为等同符，当等号两边的值为相同类型时，直接比较等号两边的值，值相同则返回 true；若等号两边值的类型不同时直接返回 false。也就是三个等号既要判断类型也要判断值是否相等。</li></ul><h1 id="5-如何判断两个对象是否相等？"><a href="#5-如何判断两个对象是否相等？" class="headerlink" title="5.如何判断两个对象是否相等？"></a>5.如何判断两个对象是否相等？</h1><ol><li><p>Object.is(obj1, obj2)，判断两个对象都引用地址是否一致，true 则一致，false 不一致。</p></li><li><p>判断两个对象内容是否一致，思路是遍历对象的所有键名和键值是否都一致<br>① 判断两个对象是否指向同一内存<br>② 使用 Object.getOwnPropertyNames 获取对象所有键名数组<br>③ 判断两个对象的键名数组是否相等<br>④ 遍历键名，判断键值是否都相等</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isObjValueEqual</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="comment">// 判断两个对象是否指向同一内存，指向同一内存返回 true</span></span><br><span class="line">  <span class="keyword">if</span> (a === b) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="comment">// 获取两个对象的键名数组</span></span><br><span class="line">  <span class="keyword">let</span> aProps = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(a);</span><br><span class="line">  <span class="keyword">let</span> bProps = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(b);</span><br><span class="line">  <span class="comment">// 判断两键名数组长度是否一致，不一致返回 false</span></span><br><span class="line">  <span class="keyword">if</span> (aProps.<span class="property">length</span> !== bProps.<span class="property">length</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">// 遍历对象的键值</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> prop <span class="keyword">in</span> a) &#123;</span><br><span class="line">    <span class="comment">// 判断 a 的键名，在 b 中是否存在，不存在，直接返回 false</span></span><br><span class="line">    <span class="keyword">if</span> (b.<span class="title function_">hasOwnProperty</span>(prop)) &#123;</span><br><span class="line">      <span class="comment">// 判断 a 的键值是否为对象，是对象的话需要递归；</span></span><br><span class="line">      <span class="comment">// 不是对象，直接判断键值是否相等，不相等则返回 false</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> a[prop] === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="title function_">isObjValueEqual</span>(a[prop], b[prop])) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[prop] !== b[prop])&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="6-强制类型转换和隐式类型转换有哪些"><a href="#6-强制类型转换和隐式类型转换有哪些" class="headerlink" title="6. 强制类型转换和隐式类型转换有哪些"></a>6. 强制类型转换和隐式类型转换有哪些</h1><ul><li>强制：<br>转换成字符串: toString()、String()<br>转换成数字：Number()、parseInt()、parseFloat()<br>转换成布尔类型：Boolean()</li><li>隐式：<br>拼接字符串：let str = 1 + “”;</li></ul><h1 id="7-JS-中的作用域和作用域链"><a href="#7-JS-中的作用域和作用域链" class="headerlink" title="7. JS 中的作用域和作用域链"></a>7. JS 中的作用域和作用域链</h1><ul><li><p>作用域，即变量（变量作用域又称上下文）和函数生效（能被访问）的区域或集合。作用域决定了代码区块中变量和其他资源的可见性。一般可分为：全局作用域、局部作用域（函数作用域）、块级作用域。</p></li><li><p>全局作用域：任何不在函数中或是大括号中声明的变量，都是在全局作用域下，全局作用域下声明的变量可以在程序的任意位置访问。</p></li><li><p>局部作用域：也叫做函数作用域，如果一个变量是在函数内部声明的，它就在一个函数作用域下面。这些变量只能在函数内部访问，不能在函数以外去访问。<br>块级作用域：凡是代码块就可以划分变量的作用域，这种作用域的规则就叫做块级作用域。</p></li><li><p>作用域链：当在 JS 中使用一个变量时，JS 引擎会尝试在当前作用域下寻找该变量，如果没找到，再到它的上层作用域寻找，以此类推，直至找到该变量或是查找至全局作用域，如果在全局作用域里仍然找不到该变量，它就会在全局范围内隐式声明该变量(非严格模式下)或是直接报错。</p></li><li><p>js 采用的是静态作用域，所以函数的作用域在函数定义时就确定了</p></li></ul><h1 id="8-JS-的预解析"><a href="#8-JS-的预解析" class="headerlink" title="8. JS 的预解析"></a>8. JS 的预解析</h1><p>JS 代码的执行是由浏览器中的 JS 解析器来执行的，JS 解析器执行 JS 代码时，分为两个过程：预解析过程和代码执行过程。预解析分为变量预解析（变量提升）和函数预解析（函数提升）；代码执行是指按顺序从上至下执行。</p><ul><li>变量提升：把变量的声明提升到当前作用域的最前面，只提升声明，不提升赋值；</li><li>函数提升：把函数的声明提升到当前作用域的最前面，只提升声明，不提升调用；</li></ul><blockquote><p>函数表达式的写法不存在函数提升</p></blockquote><blockquote><p>函数提升优先级高于变量提升，即函数提升在变量提升之上，且不会被同名变量声明时覆盖，但是会被同名变量赋值后覆盖</p></blockquote><h1 id="9-原型和原型链"><a href="#9-原型和原型链" class="headerlink" title="9. 原型和原型链"></a>9. 原型和原型链</h1><p>JS是面向对象的，每个实例对象都有一个__proto__属性，该属性指向它的原型对象。该实例的构造函数有一个原型属性prototype，与实例的__proto__属性指向同一个对象。同时，原型对象的constructor 指向构造函数本身。</p><p>当一个对象在查找一个属性时，自身没有就会根据__proto__属性向它的原型进行查找，如果还是没有，则向它的原型的原型继续查找，直至查到Object.prototype.__proto__也就是null，这样就形成了原型链。</p><h1 id="10-闭包"><a href="#10-闭包" class="headerlink" title="10. 闭包"></a>10. 闭包</h1><p>在 JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来。可以在一个内层函数中访问到其外层函数的作用域。</p><p>闭包就是能够读取其他函数内部变量的函数。主要作用是解决变量污染问题，也可以用来延长局部变量的生命周期。</p><ul><li>优点：延长局部变量的生命周期</li><li>缺点：会导致函数的变量一直保存在内存中，过多的闭包可能会导致内存泄漏</li></ul><h1 id="11-new-操作符的实现机制"><a href="#11-new-操作符的实现机制" class="headerlink" title="11. new 操作符的实现机制"></a>11. new 操作符的实现机制</h1><ol><li>首先创建了一个新的空对象</li><li>设置原型，将对象的原型设置为函数的prototype对象。</li><li>让函数的this指向这个对象，执行构造函数的代码（为这个新对象添加属性）</li><li>判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myNew</span>(<span class="params">context</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> obj = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">  obj.<span class="property">__proto__</span> = context.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line">  <span class="keyword">const</span> res = context.<span class="title function_">apply</span>(obj, [...<span class="variable language_">arguments</span>].<span class="title function_">slice</span>(<span class="number">1</span>));</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> res === <span class="string">&quot;object&quot;</span> ? res : obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="12-this-的理解？"><a href="#12-this-的理解？" class="headerlink" title="12. this 的理解？"></a>12. this 的理解？</h1><ol><li>概念：<br>this是 JS 的一个关键字，它是函数运行时，自动生成的一个内部对象，只能在函数内部使用，随着函数使用场合的不同，this的值会发生变化，但有一个总的原则：this指的是调用函数的那个对象。</li><li>this的指向：</li></ol><ul><li>① 作为普通函数执行时，this指向window，但在严格模式下this指向undefined。</li><li>② 函数作为对象里的方法被调用时，this指向该对象.</li><li>③ 当用new运算符调用构造函数时，this指向返回的这个对象。</li><li>④ 箭头函数的this绑定看的是this所在函数定义在哪个对象下，就绑定哪个对象。- 如果存在嵌套，则this绑定到最近的一层对象上。</li><li>⑤ call()、apply()、bind()是函数的三个方法，都可以显式的指定调用函数的this指向。</li></ul><h1 id="13-call、apply、bind的区别以及手写实现"><a href="#13-call、apply、bind的区别以及手写实现" class="headerlink" title="13.call、apply、bind的区别以及手写实现"></a>13.call、apply、bind的区别以及手写实现</h1><ul><li><code>call()</code>可以传递两个参数，第一个参数是指定函数内部中<code>this</code>的指向，第二个参数是函数调用时需要传递的参数。改变<code>this</code>指向后原函数会立即执行，且此方法只是临时改变<code>this</code>指向一次。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="comment">// 实现call方法</span></span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myCall</span> = <span class="keyword">function</span> (<span class="params">context</span>) &#123;</span><br><span class="line">  <span class="comment">// 判断调用对象</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">this</span> != <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;type error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 首先获取参数</span></span><br><span class="line">  <span class="keyword">let</span> args = [...<span class="variable language_">arguments</span>].<span class="title function_">slice</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">let</span> res = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 判断context是否传入，如果没有，就设置为window</span></span><br><span class="line">  context = context || <span class="variable language_">window</span>;</span><br><span class="line">  <span class="comment">// 将被调用的方法置入context的属性</span></span><br><span class="line">  <span class="comment">// this 即为要调用的方法</span></span><br><span class="line">  context.<span class="property">fn</span> = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="comment">// 执行要被调用的方法</span></span><br><span class="line">  res = context.<span class="title function_">fn</span>(...args);</span><br><span class="line">  <span class="comment">// 删除手动增加的属性方法</span></span><br><span class="line">  <span class="keyword">delete</span> context.<span class="property">fn</span>;</span><br><span class="line">  <span class="comment">// 执行结果返回</span></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>apply()</code>接受两个参数，第一个参数是<code>this</code>的指向，第二个参数是函数接受的参数，以<code>数组</code>的形式传入。改变<code>this</code>指向后原函数会立即执行，且此方法只是临时改变<code>this</code>指向一次。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="comment">// 实现apply方法</span></span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myApply</span> = <span class="keyword">function</span>(<span class="params">context</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">this</span> != <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;type error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="literal">null</span>;</span><br><span class="line">  context = context || <span class="variable language_">window</span>;</span><br><span class="line">  <span class="comment">// 使用 symbol 来保证属性唯一</span></span><br><span class="line">  <span class="comment">// 也就是保证不会重写用户自己原来定义在context中的同名属性</span></span><br><span class="line">  <span class="keyword">const</span> fnSymbol = <span class="title class_">Symbol</span>();</span><br><span class="line">  context[fnSymbol] = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="comment">// 执行被调用的方法</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">arguments</span>[<span class="number">1</span>]) &#123;</span><br><span class="line">    res = context[fnSymbol](...<span class="variable language_">arguments</span>[<span class="number">1</span>]);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    res = context[fnSymbol]();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">delete</span> context[fnSymbol];</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>bind()</code>方法的第一参数也是<code>this</code>的指向，后面传入的也是一个参数列表(但是这个参数列表可以分多次传入)。改变<code>this</code>指向后不会立即执行，而是返回一个永久改变<code>this</code>指向的函数。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="comment">// 实现bind方法</span></span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myBind</span> = <span class="keyword">function</span> (<span class="params">context</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">this</span> != <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;type error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> args = [...<span class="variable language_">arguments</span>].<span class="title function_">slice</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">const</span> fn = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">Fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> fn.<span class="title function_">apply</span>(</span><br><span class="line">      <span class="variable language_">this</span> <span class="keyword">instanceof</span> <span class="title class_">Fn</span> ? <span class="variable language_">this</span> : context,</span><br><span class="line">      <span class="comment">// 当前这个 arguments 是指 Fn 的参数</span></span><br><span class="line">      args.<span class="title function_">concat</span>(...<span class="variable language_">arguments</span>)</span><br><span class="line">    );</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>共同点：改变函数执行时的上下文，简而言之就是改变函数运行时的<code>this</code>指向。<br> 不同：</p><ul><li><code>call()</code>和<code>bind()</code>第二个参数是列表形式的；<code>apply()</code>第二个参数是数组形式。</li><li><code>call()</code>和<code>apply()</code>是立即执行；<code>bind()</code>不会立即执行而是生成一个修改<code>this</code>之后的新函数。</li></ul><h1 id="14-箭头函数"><a href="#14-箭头函数" class="headerlink" title="14. 箭头函数"></a>14. 箭头函数</h1><ol><li>箭头函数是定义函数一种新的方式，比普通函数定义更加方便和简单。</li><li>箭头函数不绑定<code>this</code>，会捕获其所在上下文的<code>this</code>，作为自己的<code>this</code>。</li><li>箭头函数不能用作构造函数，也就是说不可以使用<code>new</code>命令，否则会抛出错误。</li><li>箭头函数不绑定<code>arguments</code>，取而代之用<code>rest</code>参数解决，同时没有<code>super</code>和<code>new.target</code>。</li><li>使用<code>call</code>，<code>apply</code>，<code>bind</code>并不会改变箭头函数中的<code>this</code>指向。对箭头函数使用<code>call</code>或<code>apply</code>方法时，只会传入参数并调用函数；对箭头函数使用<code>bind</code>方法时，只会返回一个预设参数的新函数，并不会改变这个新函数的<code>this</code>指向。</li></ol><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h1 id="15-浅拷贝和深拷贝的实现"><a href="#15-浅拷贝和深拷贝的实现" class="headerlink" title="15. 浅拷贝和深拷贝的实现"></a>15. 浅拷贝和深拷贝的实现</h1><p><code>浅拷贝</code>：如果属性是基本类型，拷贝的就是基本类型的值；如果属性是引用类型，拷贝的就是内存地址。即浅拷贝是<code>拷贝一层</code>，深层次的引用类型则共享内存地址。常用的方法有：object.assign，扩展运算符等等</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ini复制代码var <span class="attr">a</span> = &#123; count: <span class="number">1</span>, deep: &#123; count: <span class="number">2</span> &#125; &#125;<span class="comment">;</span></span><br><span class="line">var <span class="attr">b</span> = Object.assign(&#123;&#125;, a)<span class="comment">;</span></span><br><span class="line">// 或者</span><br><span class="line">var <span class="attr">c</span> = &#123;...a&#125;<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">// 实现一个浅拷贝</span><br><span class="line">function shallowClone(obj) &#123;</span><br><span class="line">  const <span class="attr">newObj</span> = &#123;&#125;<span class="comment">;</span></span><br><span class="line">  for (let prop in obj) &#123;</span><br><span class="line">    if (obj.hasOwnProperty(prop)) &#123;</span><br><span class="line">      newObj<span class="section">[prop]</span> = obj<span class="section">[prop]</span><span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return newObj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>深拷贝</code>：开辟一个新的栈，两个对象的属性完全相同，但是对应两个不同的地址，修改一个对象的属性，不会改变另一个对象的属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 深拷贝</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Object</span>&#125; obj 要拷贝的对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Map</span>&#125; map 用于存储循环引用对象的地址</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">deepClone</span>(<span class="params">obj = &#123;&#125;, map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (obj === <span class="literal">null</span>) <span class="keyword">return</span> obj <span class="comment">// 如果是null或者undefined我就不进行拷贝操作</span></span><br><span class="line">  <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="title class_">Date</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Date</span>(obj)</span><br><span class="line">  <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="title class_">RegExp</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RegExp</span>(obj)</span><br><span class="line">  <span class="comment">// 可能是对象或者普通的值  如果是函数的话是不需要深拷贝</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span>) <span class="keyword">return</span> obj</span><br><span class="line">  <span class="keyword">if</span> (map.<span class="title function_">get</span>(obj)) &#123;</span><br><span class="line">    <span class="keyword">return</span> map.<span class="title function_">get</span>(obj);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> result = &#123;&#125;; <span class="comment">// 初始化返回结果</span></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    obj <span class="keyword">instanceof</span> <span class="title class_">Array</span> ||</span><br><span class="line">    <span class="comment">// 加 || 的原因是为了防止 Array 的 prototype 被重写，Array.isArray 也是如此</span></span><br><span class="line">    <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">toString</span>(obj) === <span class="string">&quot;[object Array]&quot;</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    result = [];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 防止循环引用</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="comment">// 保证 key 不是原型属性</span></span><br><span class="line">    <span class="keyword">if</span> (obj.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">      <span class="comment">// 递归调用</span></span><br><span class="line">      result[key] = <span class="title function_">deepClone</span>(obj[key], map);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="16-JavaScript-中内存泄漏的几种情况"><a href="#16-JavaScript-中内存泄漏的几种情况" class="headerlink" title="16. JavaScript 中内存泄漏的几种情况"></a>16. JavaScript 中内存泄漏的几种情况</h1><p><code>内存泄漏</code>一般是指系统进程不再用到的内存，没有及时释放，造成内存资源浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。</p><p>造成内存泄漏的原因有：</p><ol><li><code>全局变量。</code>在局部作用域中，函数执行完毕后，变量就没有存在的必要了，垃圾回收机制很快的做出判断并回收；但是对于全局变量，很难判断什么时候不用这些变量，无法正常回收。<br> 解决办法：<br> ① 尽量少使用全局变量；<br> ② 使用严格模式，在 js 文件头部或者函数的顶部加上<code>use strict</code>。</li><li><code>闭包引起的内存泄露。</code>闭包可以读取函数内部的变量，然后让这些变量始终保存在内存中，如果在使用结束后没有将局部变量清除，就可能导致内存泄露。<br> 解决办法：将事件处理函数定义在外部，解除闭包。</li><li><code>被遗忘的定时器。</code>定时器<code>setInterval</code>或者<code>setTimeout</code>不再需要使用时，且没有被清除，导致定时器的回调函数及其内部依赖的变量都不能被回收，就会造成内存泄漏。<br> 解决办法：当不需要定时器的时候，调用<code>clearInterval</code>或者<code>clearTimeout</code>手动清除。</li><li><code>事件监听。</code>垃圾回收机制不好判断事件是否需要被解除，导致<code>callback</code>不能被释放，此时需要手动解除绑定。<br> 解决办法：及时使用<code>removeEventListener</code>移除事件监听。</li><li><code>元素引用没有清理。</code><br> 解决办法：移除元素后，手动设置元素的引用为<code>null</code>。</li><li><code>console</code>。传递给<code>console.log</code>的对象是不能被垃圾回收，可能会存在内存泄漏。<br> 解决办法：清除不必要的<code>console</code>。</li></ol><h1 id="17-防抖和节流的区别，以及手写实现"><a href="#17-防抖和节流的区别，以及手写实现" class="headerlink" title="17. 防抖和节流的区别，以及手写实现"></a>17. 防抖和节流的区别，以及手写实现</h1><p><code>防抖</code>：多次触发事件，事件处理函数只执行一次，并且是在触发操作结束时执行。也就是说，当一个事件被触发，准备执行事件函数前，会等待一定的时间，在这个等待时间内，如果没有再次被触发，那么就执行，如果又触发了，那就本次作废，重置等待时间，直到最终能执行。<br> 主要应用场景：搜索框搜索输入，用户最后一次输入完，再发送请求；手机号、邮箱验证输入检测</p><p><code>节流</code>：事件触发后，规定时间内，事件处理函数不能再次被调用。也就是说在规定的时间内，函数只能被调用一次，且是最先被触发调用的那次。<br> 主要应用场景：高频点击、表单重复提交等。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="comment">/*** 防抖函数 n 秒后再执行该事件，若在 n 秒内被重复触发，则重新计时</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> func 要被防抖的函数</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> wait 规定的时间</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">func, wait</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> timeout;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> context = <span class="variable language_">this</span>; <span class="comment">// 保存this指向</span></span><br><span class="line">    <span class="keyword">let</span> args = <span class="variable language_">arguments</span>; <span class="comment">// 拿到event对象</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line">    timeout = <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      func.<span class="title function_">apply</span>(context, args)</span><br><span class="line">    &#125;, wait)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*** 节流函数 n 秒内只运行一次，若在 n 秒内重复触发，只有一次生效</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> fn 要被节流的函数</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> wait 规定的时间</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">throttled</span>(<span class="params">fn, wait</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!timer) &#123;</span><br><span class="line">      timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">        timer = <span class="literal">null</span>;</span><br><span class="line">      &#125;, wait);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="18-EventLoop-事件循环"><a href="#18-EventLoop-事件循环" class="headerlink" title="18. EventLoop 事件循环"></a>18. EventLoop 事件循环</h1><p>js 是单线程运行的，当遇到一个异步事件后并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务。当一个异步事件返回结果后，js会将这个事件加入与当前执行栈不同的另一个队列–<code>事件队列（Task Queue）</code>。被放入事件队列不会立刻执行其回调，而是等待当前执行栈中的所有任务都执行完毕， 主线程处于闲置状态时，主线程会去查找事件队列是否有任务。如果有，那么主线程会从中取出排在第一位的事件，并把这个事件对应的回调放入执行栈中，然后执行其中的同步代码…，如此反复，这样就形成了一个无限的循环，这个过程被称为<code>事件循环（Event Loop）</code>。</p><p>实际上,异步任务之间并不相同，它们的执行优先级也有区别。异步任务分两类：<code>微任务（micro task</code>）和<code>宏任务（macro task）</code>。</p><p>微任务包括： <code>promise 的回调</code>、node 中的 <code>process.nextTick</code> 、对 Dom 变化监听的 <code>MutationObserver</code>。</p><p>宏任务包括： script 脚本的执行，<code>setTimeout</code> 、<code>setInterval</code> 和<code>setImmediate</code> 一类的定时事件，还有如 I/O 操作，UI 渲染等。</p><p>在一个事件循环中，异步事件返回结果后会被放到一个事件队列中。然而，根据这个异步事件的类型，这个事件实际上会被对应的<code>宏任务队列</code>或者<code>微任务队列</code>中去。并且在当前执行栈为空的时候，主线程会查看微任务队列是否有事件存在。如果不存在，那么再去宏任务队列中取出一个事件并把对应的回调加入当前执行栈；如果存在，则会依次执行队列中事件对应的回调，直到微任务队列为空，然后去宏任务队列中取出最前面的一个事件，把对应的回调加入当前执行栈…如此反复，进入循环。</p><p><strong>在当前执行栈执行完毕时会立刻先处理所有微任务队列中的事件，然后再去宏任务队列中取出一个事件。同一次事件循环中，微任务永远在宏任务之前执行</strong>。</p><h1 id="19-Promise"><a href="#19-Promise" class="headerlink" title="19. Promise"></a>19. Promise</h1><p><code>Promise</code>异步编程的一种解决方案。<code>Promise</code>是一个构造函数，接收一个函数作为参数，返回一个 Promise 实例。一个 Promise 实例有三种状态，分别是<code>pending</code>、<code>fulfilled</code>和<code>rejected</code>，分别代表了进行中、已成功和已失败。实例的状态只能由 pending 转变 fulfilled 或者 rejected 状态，并且状态一经改变，就无法再改变了。状态的改变是通过<code>resolve()</code>和<code>reject()</code>函数来实现的，可以在异步操作结束后调用这两个函数改变 Promise 实例的状态。Promise 的原型上定义了一个 <code>then</code>方法，使用这个 then 方法可以为两个状态的改变注册回调函数。这个回调函数属于微任务，会在本轮事件循环的末尾执行。</p>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>quickjs调试工具</title>
      <link href="/posts/d9795d10.html"/>
      <url>/posts/d9795d10.html</url>
      
        <content type="html"><![CDATA[<p>vela系统quickjs对接devtools</p><span id="more"></span><h2 id="vela快应用调试功能概览"><a href="#vela快应用调试功能概览" class="headerlink" title="vela快应用调试功能概览"></a>vela快应用调试功能概览</h2><p><img src="https://raw.githubusercontent.com/why862555625/images/main/image-20230525102147522.png" alt="image-20230525102147522"></p><h1 id="vela-debug调试功能"><a href="#vela-debug调试功能" class="headerlink" title="vela debug调试功能"></a>vela debug调试功能</h1><p>debug调试功能图</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/image-20230525111407415.png" alt="image-20230525111407415"></p><p>vela debug调试功能实现大致分为4个步骤：</p><ol><li><strong>连接时将所有的源码发送给devtools。</strong></li><li><strong>在devtools 的source功能中打断点、将请求发送给下层cdp.</strong></li><li><strong>cdp计算断点具体在字节码中的位置、并记录。</strong></li><li><strong>在引擎执行字节码时判断有无命中断点。</strong></li></ol><p>下面具体说明这四个步骤：</p><h2 id="1-连接时将所有的源码发送给devtools"><a href="#1-连接时将所有的源码发送给devtools" class="headerlink" title="1. 连接时将所有的源码发送给devtools"></a>1. 连接时将所有的源码发送给devtools</h2><p>在调用loadApplication时会将app的路径保存在APP类中，也就是app的rpk的最外层路径。在监听到devtool连接时，会将rpk包中的所js文件发送给devtools，devtools会将这些js文件拼接成上图中的source文件。</p><h2 id="2-在devtools-的source功能中打断点、将请求发送给下层cdp"><a href="#2-在devtools-的source功能中打断点、将请求发送给下层cdp" class="headerlink" title="2. 在devtools 的source功能中打断点、将请求发送给下层cdp"></a>2. 在devtools 的source功能中打断点、将请求发送给下层cdp</h2><p>当打开source文件上打断点、devtools会将断点的文件名、行号发送到下层cdp.</p><h2 id="3-cdp计算断点具体在字节码中的位置、并记录。"><a href="#3-cdp计算断点具体在字节码中的位置、并记录。" class="headerlink" title="3. cdp计算断点具体在字节码中的位置、并记录。"></a>3. cdp计算断点具体在字节码中的位置、并记录。</h2><ul><li><p>断点功能的输入实际上是文件名和断点行信息，第一步我们需要利用这个信息，找到模块，进而首先找到目标函数。</p><ul><li>quickjs在真实加载module的时候都会调用JS_EvalInternal。我们可以在这个函数里面监听并记录已经加载完的模块。</li></ul></li><li><p>每个函数对象上都记录了自身的起始行，通过pc2line table可以计算得到结束行，进而和传入的行号进行范围匹配计算。</p><ul><li>函数和字节码的映射规则：<ul><li>如果一行源码对应的字节码较短，就将前4位存源码的行数，后四位存字节码对应的行数</li><li>如果一个源码对应的字节码较长，就先存入一个0值（解析pc2line_buf的时候遇到0值会自动将下一个当做128  int来解析），后面补一个128的int，这个int的高位用来存源码行数、低位存字节码的行数。</li></ul></li></ul></li></ul><p><strong>计算结束行函数：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PC2LINE_BASE     (-1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PC2LINE_RANGE    5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PC2LINE_OP_FIRST 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PC2LINE_DIFF_PC_MAX ((255 - PC2LINE_OP_FIRST) / PC2LINE_RANGE)</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">caculate_function_last_line</span><span class="params">(JSFunctionBytecode* b)</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> op;</span><br><span class="line">    <span class="type">int</span> ret, v;</span><br><span class="line">    FunctionBytecodeDebugInfo* debug = <span class="built_in">js_debugger_get_bytecode_debug_info</span>(b);</span><br><span class="line">    <span class="type">int</span> line_num = debug-&gt;line_num, new_line_num;</span><br><span class="line">    <span class="type">uint8_t</span> *p = debug-&gt;pc2line_buf;</span><br><span class="line">    <span class="type">uint8_t</span> *p_end = p + debug-&gt;pc2line_len;</span><br><span class="line">    <span class="type">int</span> succ = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// scan line by line</span></span><br><span class="line">    <span class="keyword">while</span> (p &lt; p_end) &#123;</span><br><span class="line">        op = *p++;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">uint32_t</span> val;</span><br><span class="line">            ret = <span class="built_in">get_leb128</span>(&amp;val, p, p_end);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                succ = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// pc += val;</span></span><br><span class="line">            p += ret;</span><br><span class="line">            ret = <span class="built_in">get_sleb128</span>(&amp;v, p, p_end);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                succ = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p += ret;</span><br><span class="line">            new_line_num = line_num + v;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            op -= PC2LINE_OP_FIRST;</span><br><span class="line">            new_line_num = line_num + (op % PC2LINE_RANGE) + PC2LINE_BASE;</span><br><span class="line">        &#125;</span><br><span class="line">        line_num = new_line_num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> succ ? line_num : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">STATIC <span class="type">int</span> <span class="title">get_leb128</span><span class="params">(<span class="type">uint32_t</span> *pval, <span class="type">const</span> <span class="type">uint8_t</span> *buf,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="type">const</span> <span class="type">uint8_t</span> *buf_end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">uint8_t</span> *ptr = buf;</span><br><span class="line">    <span class="type">uint32_t</span> v, a, i;</span><br><span class="line">    v = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">unlikely</span>(ptr &gt;= buf_end))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        a = *ptr++;</span><br><span class="line">        v |= (a &amp; <span class="number">0x7f</span>) &lt;&lt; (i * <span class="number">7</span>);</span><br><span class="line">        <span class="keyword">if</span> (!(a &amp; <span class="number">0x80</span>)) &#123;</span><br><span class="line">            *pval = v;</span><br><span class="line">            <span class="keyword">return</span> ptr - buf;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *pval = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">STATIC <span class="type">int</span> <span class="title">get_sleb128</span><span class="params">(<span class="type">int32_t</span> *pval, <span class="type">const</span> <span class="type">uint8_t</span> *buf,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="type">const</span> <span class="type">uint8_t</span> *buf_end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="type">uint32_t</span> val;</span><br><span class="line">    ret = <span class="built_in">get_leb128</span>(&amp;val, buf, buf_end);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        *pval = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *pval = (val &gt;&gt; <span class="number">1</span>) ^ -(val &amp; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>源码表和字节码表对应规则：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">compute_pc2line_info</span><span class="params">(JSFunctionDef *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(s-&gt;js_mode &amp; JS_MODE_STRIP) &amp;&amp; s-&gt;line_number_slots) &#123;</span><br><span class="line">        <span class="type">int</span> last_line_num = s-&gt;line_num;</span><br><span class="line">        <span class="type">uint32_t</span> last_pc = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">js_dbuf_init</span>(s-&gt;ctx, &amp;s-&gt;pc2line);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; s-&gt;line_number_count; i++) &#123;</span><br><span class="line">            <span class="type">uint32_t</span> pc = s-&gt;line_number_slots[i].pc;</span><br><span class="line">            <span class="type">int</span> line_num = s-&gt;line_number_slots[i].line_num;</span><br><span class="line">            <span class="type">int</span> diff_pc, diff_line;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (line_num &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            diff_pc = pc - last_pc;</span><br><span class="line">            diff_line = line_num - last_line_num;</span><br><span class="line">            <span class="keyword">if</span> (diff_line == <span class="number">0</span> || diff_pc &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (diff_line &gt;= PC2LINE_BASE &amp;&amp;</span><br><span class="line">                diff_line &lt; PC2LINE_BASE + PC2LINE_RANGE &amp;&amp;</span><br><span class="line">                diff_pc &lt;= PC2LINE_DIFF_PC_MAX) &#123;</span><br><span class="line">                <span class="built_in">dbuf_putc</span>(&amp;s-&gt;pc2line, (diff_line - PC2LINE_BASE) +</span><br><span class="line">                          diff_pc * PC2LINE_RANGE + PC2LINE_OP_FIRST);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/* longer encoding */</span></span><br><span class="line">                <span class="built_in">dbuf_putc</span>(&amp;s-&gt;pc2line, <span class="number">0</span>);</span><br><span class="line">                <span class="built_in">dbuf_put_leb128</span>(&amp;s-&gt;pc2line, diff_pc);</span><br><span class="line">                <span class="built_in">dbuf_put_sleb128</span>(&amp;s-&gt;pc2line, diff_line);</span><br><span class="line">            &#125;</span><br><span class="line">            last_pc = pc;</span><br><span class="line">            last_line_num = line_num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>需要注意匹配到的函数可能只是外层函数，具体的断点偏移计算时要考虑递归子函数。</p><ul><li>基于pc2line table计算断点在函数字节码中的偏移位置，计算时如果目出现计算出来的行号比目标行号大的情况 <code>end_line_num&gt;cur_line_num&gt;targe_num</code>，说明断点落在了子函数中，需要递归，直到最终找到或全部失败。</li></ul><p><img src="https://raw.githubusercontent.com/why862555625/images/main/image-20230525125207891.png" alt="image-20230525125207891"></p></li><li><p>断点断到、将pause消息和目前上下文的变量信息和调用栈发送给devtools。</p><ul><li>runtime上面保留了当前栈的信息JSStackFrame，JSStackFrame上面保存了栈上的变量、参数、函数信息；并且JSStackFrame可以通过prev_frame向上查找栈信息。这样遍历下来就可以完整的得到栈上的变量和调用栈。</li></ul></li></ul><p><strong>JSRuntime和JSStackFrame的数据结构</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">JSRuntime</span> &#123;</span><br><span class="line">    JSMallocFunctions mf;</span><br><span class="line">    JSMallocState malloc_state;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *rt_info;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> atom_hash_size; <span class="comment">/* power of two */</span></span><br><span class="line">    <span class="type">int</span> atom_count;</span><br><span class="line">    <span class="type">int</span> atom_size;</span><br><span class="line">    <span class="type">int</span> atom_count_resize; <span class="comment">/* resize hash table at this count */</span></span><br><span class="line">    <span class="type">uint32_t</span> *atom_hash;</span><br><span class="line">    JSAtomStruct **atom_array;</span><br><span class="line">    <span class="type">int</span> atom_free_index; <span class="comment">/* 0 = none */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> class_count;    <span class="comment">/* size of class_array */</span></span><br><span class="line">    JSClass *class_array;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">list_head</span> context_list; <span class="comment">/* list of JSContext.link */</span></span><br><span class="line">    <span class="comment">/* list of JSGCObjectHeader.link. List of allocated GC objects (used</span></span><br><span class="line"><span class="comment">       by the garbage collector) */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">list_head</span> gc_obj_list;</span><br><span class="line">    <span class="comment">/* list of JSGCObjectHeader.link. Used during JS_FreeValueRT() */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">list_head</span> gc_zero_ref_count_list;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">list_head</span> tmp_obj_list; <span class="comment">/* used during GC */</span></span><br><span class="line">    JSGCPhaseEnum gc_phase : <span class="number">8</span>;</span><br><span class="line">    <span class="type">size_t</span> malloc_gc_threshold;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DUMP_LEAKS</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">list_head</span> string_list; <span class="comment">/* list of JSString.link */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">/* stack limitation */</span></span><br><span class="line">    <span class="type">uintptr_t</span> stack_size; <span class="comment">/* in bytes, 0 if no limit */</span></span><br><span class="line">    <span class="type">uintptr_t</span> stack_top;</span><br><span class="line">    <span class="type">uintptr_t</span> stack_limit; <span class="comment">/* lower stack limit */</span></span><br><span class="line"></span><br><span class="line">    JSValue current_exception;</span><br><span class="line">    <span class="comment">/* true if inside an out of memory error, to avoid recursing */</span></span><br><span class="line">    BOOL in_out_of_memory : <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">JSStackFrame</span> *current_stack_frame;  <span class="comment">// current stack info</span></span><br><span class="line"></span><br><span class="line">    JSInterruptHandler *interrupt_handler;</span><br><span class="line">    <span class="type">void</span> *interrupt_opaque;</span><br><span class="line"></span><br><span class="line">    JSHostPromiseRejectionTracker *host_promise_rejection_tracker;</span><br><span class="line">    <span class="type">void</span> *host_promise_rejection_tracker_opaque;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">list_head</span> job_list; <span class="comment">/* list of JSJobEntry.link */</span></span><br><span class="line"></span><br><span class="line">    JSModuleNormalizeFunc *module_normalize_func;</span><br><span class="line">    JSModuleLoaderFunc *module_loader_func;</span><br><span class="line">    <span class="type">void</span> *module_loader_opaque;</span><br><span class="line"></span><br><span class="line">    BOOL can_block : <span class="number">8</span>; <span class="comment">/* TRUE if Atomics.wait can block */</span></span><br><span class="line">    <span class="comment">/* used to allocate, free and clone SharedArrayBuffers */</span></span><br><span class="line">    JSSharedArrayBufferFunctions sab_funcs;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Shape hash table */</span></span><br><span class="line">    <span class="type">int</span> shape_hash_bits;</span><br><span class="line">    <span class="type">int</span> shape_hash_size;</span><br><span class="line">    <span class="type">int</span> shape_hash_count; <span class="comment">/* number of hashed shapes */</span></span><br><span class="line">    JSShape **shape_hash;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_BIGNUM</span></span><br><span class="line">    <span class="type">bf_context_t</span> bf_ctx;</span><br><span class="line">    JSNumericOperations bigint_ops;</span><br><span class="line">    JSNumericOperations bigfloat_ops;</span><br><span class="line">    JSNumericOperations bigdecimal_ops;</span><br><span class="line">    <span class="type">uint32_t</span> operator_count;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">void</span> *user_opaque;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_INTERPRETERS_QUICKJS_DEBUG</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">JSDebuggerInfo</span> debugger_info;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">DumpMemoryInfo</span> dump_memory_info;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    JSOutOfMemoryTracker* oom_tracker;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MEMORY_LEAK_TRACK</span></span><br><span class="line">    <span class="type">int</span> isStartMemoryDump;</span><br><span class="line">    vector* newObjVector;</span><br><span class="line">    JSContext* currentCtx;</span><br><span class="line">    <span class="type">char</span>* pageStatus;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">JSStackFrame</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">JSStackFrame</span> *prev_frame; <span class="comment">/* NULL if first stack frame */</span></span><br><span class="line">    JSValue cur_func; <span class="comment">/* current function, JS_UNDEFINED if the frame is detached */</span></span><br><span class="line">    JSValue *arg_buf; <span class="comment">/* arguments */</span></span><br><span class="line">    JSValue *var_buf; <span class="comment">/* variables */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">list_head</span> var_ref_list; <span class="comment">/* list of JSVarRef.link */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">uint8_t</span> *cur_pc; <span class="comment">/* only used in bytecode functions : PC of the</span></span><br><span class="line"><span class="comment">                        instruction after the call */</span></span><br><span class="line">    <span class="type">int</span> arg_count;</span><br><span class="line">    <span class="type">int</span> js_mode; <span class="comment">/* 0 or JS_MODE_MATH for C functions */</span></span><br><span class="line">    <span class="comment">/* only used in generators. Current stack pointer value. NULL if</span></span><br><span class="line"><span class="comment">       the function is running. */</span></span><br><span class="line">    JSValue *cur_sp;</span><br><span class="line">&#125; JSStackFrame;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>函数数据结构：</strong></p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/image-20230525144252998.png"></p><p><strong>查找目标函数流程：</strong></p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/image-20230525124949165.png"></p><h2 id="4-在引擎执行字节码时判断有无命中断点。"><a href="#4-在引擎执行字节码时判断有无命中断点。" class="headerlink" title="4. 在引擎执行字节码时判断有无命中断点。"></a>4. 在引擎执行字节码时判断有无命中断点。</h2><p>命中断点有两个设计思路：</p><p><strong>第一种：</strong></p><p>直接修改字节码、插入debugger指令和nop\需要额外注意在命中后和取消时将字节码恢复、否则会出现问题。</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/image-20230525161322186.png" alt="image-20230525161322186"></p><p><strong>第二种：</strong></p><p>分配一块和字节码相同长度的数组、在相同的便宜位置写入1、作为断点标志、方便命中检查。</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/image-20230525161507336.png" alt="image-20230525161507336"></p><p>断点命中的核心思路实在引擎解释执行字节码的时候插入堆断点命中的检查、命中断电后停止执行（不在继续解释下一条指令）。</p><p>这里选择重定义字节码的case定义、如果开启了调试功能、则每次解释执行字节码都会插入对js_debugger_check函数执行、他负责检查每一步执行是否命中断点。检查方法很简单、检查当前pc是否落在了断点的范围内（依赖设置断点）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_INTERPRETERS_QUICKJS_DEBUG</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASE(op)        case op: js_debugger_check(ctx, pc); stub_ ## op</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASE(op)        case op: stub_ ## op</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><strong>执行字节码：</strong></p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/image-20230525170447952.png" alt="image-20230525170447952"></p><p>js_debugger_check 中暂停的主要逻辑是一个<code>while(ture)</code>循环，然后每次执行libuv_run_once()推一次主循环的句柄，用来判断服务端是否放开断点。</p><h1 id="memory-功能"><a href="#memory-功能" class="headerlink" title="memory 功能"></a>memory 功能</h1><p>memory功能大概可以概述为三个部分：</p><ol><li>接受devtools  memory dump的请求之后，开始遍历引擎的堆内存链表（v8是使用图结构来表示的堆内存、quickjs是使用链表表示的）。</li><li>将quickjs中的链表内存转化为图结构内存。（devtools snapshot需要图结构）</li><li>将图结构转化为snapshot发送给devtools、devtools进行解析并显示。</li></ol><h2 id="1-理解引擎的堆内存结构"><a href="#1-理解引擎的堆内存结构" class="headerlink" title="1. 理解引擎的堆内存结构"></a>1. 理解引擎的堆内存结构</h2><p>quickjs的runtime中的gc_obj_list保存了引擎中的所有堆对象的JSGCObjectHeader.遍历gc_obj_list就可以得到所有的堆对象信息</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">JSGCObjectHeader</span> &#123;</span><br><span class="line">    <span class="type">int</span> ref_count; <span class="comment">/* must come first, 32-bit */</span></span><br><span class="line">    JSGCObjectTypeEnum gc_obj_type : <span class="number">4</span>;</span><br><span class="line">    <span class="type">uint8_t</span> mark : <span class="number">4</span>; <span class="comment">/* used by the GC */</span></span><br><span class="line">    <span class="type">uint8_t</span> dummy1; <span class="comment">/* not used by the GC */</span></span><br><span class="line">    <span class="type">uint16_t</span> dummy2; <span class="comment">/* not used by the GC */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">list_head</span> link;</span><br><span class="line">    <span class="type">int64_t</span> id;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/why862555625/images/main/image-20230525171354456.png" alt="image-20230525171354456"></p><h2 id="2-理解snapshot文件格式"><a href="#2-理解snapshot文件格式" class="headerlink" title="2. 理解snapshot文件格式"></a>2. 理解snapshot文件格式</h2><ul><li>V8 HeapSnapshot文件整体采用JSON格式存储。</li><li>存储时采用Meta + 内容的方式，Meta里描述了各个字段的含义，各个节点的数量等。</li><li>内存dump信息按照点集和边集的形式存储。点集存储节点信息，边集存储对象之间的链接关系。</li><li>字符串是单独存储的，节点中使用时采用下标引用的方式以节约内存。</li></ul><p><img src="https://raw.githubusercontent.com/why862555625/images/main/image-20230525172031289.png" alt="image-20230525172031289"></p><h2 id="3-堆对象处理：从链表到图"><a href="#3-堆对象处理：从链表到图" class="headerlink" title="3.堆对象处理：从链表到图"></a>3.堆对象处理：从链表到图</h2><p>Quickjs中GC对象是通过链表保存的，但HeapSnapshot中是按照图结构保存的，所以需要有一个从链表构建对象图的过程，我生成了一个代理结构，额外记录了对象间的链接关系。</p><p>如果不这样做，就需要修改quickjs的GC list结构，这样改动会很大。</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/image-20230525172159734.png" alt="image-20230525172159734"></p><h2 id="4-Proxy图的构建算法"><a href="#4-Proxy图的构建算法" class="headerlink" title="4. Proxy图的构建算法"></a>4. Proxy图的构建算法</h2><p><img src="https://raw.githubusercontent.com/why862555625/images/main/image-20230525172302551.png" alt="image-20230525172302551"></p>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vela快应用框架</title>
      <link href="/posts/d9795d89.html"/>
      <url>/posts/d9795d89.html</url>
      
        <content type="html"><![CDATA[<p>Vela上快应用框架的一些实现原理和编程实践</p><span id="more"></span><h1 id="快应用框架构成"><a href="#快应用框架构成" class="headerlink" title="快应用框架构成"></a>快应用框架构成</h1><p>一个简单的图用来描述快应用框架的模块构成，主要由Native（C++）部分和JS部分（framework.js）构成。</p><p><img src="https://raw.githubusercontent.com/why862555625/images/main/images/48c4d276-9d71-439a-a720-7f268da27d85.svg" alt="48c4d276-9d71-439a-a720-7f268da27d85"></p><p>在框架的C++代码中，最核心的两大组件就是 quickjs和libuv，分别提供JS运行环境和异步消息循环机制。框架还用到了一些其他的C/C++库如libcurl作为http客户端，rapidjson提供json解析能力等。</p><p>下面给出项目目录结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── bin                                     # 生成目录</span><br><span class="line">│   ├── app                                 # 测试应用</span><br><span class="line">│   ├── apps.json                           # 应用配置文件</span><br><span class="line">│   ├── font                                # 应用字体资源</span><br><span class="line">│   ├── quickapp</span><br><span class="line">│   └── vapp                                # 项目生成的可执行文件</span><br><span class="line">├── build                                   # cmake构建目录</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── deps                                    # 依赖项目录</span><br><span class="line">│   ├── curl                                # 多协议文件传输库</span><br><span class="line">│   ├── ext                                 # 扩展，主要是lvgl非标准扩展</span><br><span class="line">│   ├── FFmpeg                              # 音视频编解码库</span><br><span class="line">│   ├── freetype2                           # 字体渲染库</span><br><span class="line">│   ├── libuv                               # 跨平台事件驱动的消息循环库</span><br><span class="line">│   ├── littlefs                            # lvgl相关</span><br><span class="line">│   ├── lv_conf.h</span><br><span class="line">│   ├── lv_drivers</span><br><span class="line">│   ├── lv_drv_conf.h</span><br><span class="line">│   ├── lv_ffmpeg_interface</span><br><span class="line">│   ├── lv_fs_interface</span><br><span class="line">│   ├── lvgl                                # lvgl 嵌入式gui库</span><br><span class="line">│   ├── lv_lib_freetype                     # lvgl的freetype库</span><br><span class="line">│   ├── lv_lib_png                          # lvgl的png解码库</span><br><span class="line">│   ├── quickjs                             # 嵌入式JS引擎</span><br><span class="line">│   ├── rapidjson                           # Json库</span><br><span class="line">│   ├── tools                               # 工具目录，目前存放了Ffmpeg编译脚本</span><br><span class="line">│   ├── unqlite                             # no sql数据库</span><br><span class="line">│   ├── uvws                                # 基于libuv实现的websocket库</span><br><span class="line">│   ├── wasm3                               # web assembely支持库</span><br><span class="line">│   └── yoga                                # yoga排版引擎</span><br><span class="line">├── Kconfig                                 # 供vela使用的kconfg配置</span><br><span class="line">├── Make.defs</span><br><span class="line">├── Makefile                                # vela makefile</span><br><span class="line">├── README.md                               # 本文件</span><br><span class="line">├── src                                     # 源码</span><br><span class="line">│   ├── aiotjs.h</span><br><span class="line">│   ├── ajs_vm.cpp</span><br><span class="line">│   ├── ....</span><br><span class="line">│   ├── framework                           # 框架源码</span><br><span class="line">│   ├── gui                                 # GUI相关代码，包含lvgl渲染器实现</span><br><span class="line">│   ├── jse                                 # JS Environment JS环境相关</span><br><span class="line">│   └── Kconfig</span><br><span class="line">├── tests                                   # 测试</span><br><span class="line">│   ├── gui</span><br><span class="line">│   ├── helpers</span><br><span class="line">│   ├── run.js</span><br><span class="line">│   ├── ... </span><br><span class="line">│   ├── test-feature-vibrator.js</span><br><span class="line">│   ├── wasi</span><br><span class="line">│   └── wasm</span><br><span class="line">└── toolchain                               # 交叉编译相关</span><br><span class="line">    └── cross-m32.cmake                     # linux 32位构建</span><br></pre></td></tr></table></figure><h1 id="框架启动流程分析"><a href="#框架启动流程分析" class="headerlink" title="框架启动流程分析"></a>框架启动流程分析</h1><p><img src="https://raw.githubusercontent.com/why862555625/images/main/images/6ca169bc-84af-4252-9758-54c853feefef.svg" alt="6ca169bc-84af-4252-9758-54c853feefef"></p><p>框架的整个启动和执行流程较为复杂，里面涉及到了JS和C++的互调用。</p><p>启动流程以C++的入口函数为入口点，会初始化quickjs，创建app，启动子线程并加载Native module和内置JS框架代码。</p><p>然后流程转交到JS，由JS通过调用初始化时注册的Native函数来完成整个快应用的加载。</p><h1 id="VDOM渲染流程分析"><a href="#VDOM渲染流程分析" class="headerlink" title="VDOM渲染流程分析"></a>VDOM渲染流程分析</h1><p>VDOM的创建和渲染出于性能考虑，放在了C++层实现，整个VDOM的创建由Native通过执行template上的渲染函数来创建。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function">(<span class="params"><span class="variable language_">module</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">function</span> (<span class="params">vm</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> _vm_ = vm || <span class="variable language_">this</span></span><br><span class="line">      <span class="keyword">return</span> aiot.<span class="title function_">__ce__</span>(<span class="string">&quot;div&quot;</span>, &#123;</span><br><span class="line">        <span class="string">&quot;classList&quot;</span>: [</span><br><span class="line">          <span class="string">&quot;page&quot;</span>,</span><br><span class="line">          <span class="string">&quot;home-page&quot;</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;, [</span><br><span class="line">        aiot.<span class="title function_">__ci__</span>(&#123;</span><br><span class="line">          <span class="attr">shown</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="keyword">return</span> _vm_.<span class="property">status</span> !== <span class="number">0</span> &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">          <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> aiot.<span class="title function_">__ce__</span>(<span class="string">&quot;text&quot;</span>, &#123;</span><br><span class="line">              <span class="string">&quot;classList&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;text-time&quot;</span></span><br><span class="line">              ],</span><br><span class="line">              <span class="string">&quot;value&quot;</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="keyword">return</span> _vm_.$t(<span class="string">&quot;a.b&quot;</span>) &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">          &#125;),</span><br><span class="line">        aiot.<span class="title function_">__ci__</span>(&#123;</span><br><span class="line">          <span class="attr">shown</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="keyword">return</span> _vm_.<span class="property">status</span> === <span class="number">0</span> &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">          <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> aiot.<span class="title function_">__ce__</span>(<span class="string">&quot;div&quot;</span>, &#123;</span><br><span class="line">              <span class="string">&quot;classList&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;body&quot;</span>,</span><br><span class="line">                <span class="string">&quot;launch-panel&quot;</span></span><br><span class="line">              ]</span><br><span class="line">            &#125;, [</span><br><span class="line">              aiot.<span class="title function_">__ce__</span>(<span class="string">&quot;image&quot;</span>, &#123;</span><br><span class="line">                <span class="string">&quot;src&quot;</span>: <span class="string">&quot;/Common/logo.png&quot;</span>,</span><br><span class="line">                <span class="string">&quot;classList&quot;</span>: [</span><br><span class="line">                  <span class="string">&quot;logo&quot;</span></span><br><span class="line">                ]</span><br><span class="line">              &#125;),</span><br><span class="line">              aiot.<span class="title function_">__ce__</span>(<span class="string">&quot;text&quot;</span>, &#123;</span><br><span class="line">                <span class="string">&quot;classList&quot;</span>: [</span><br><span class="line">                  <span class="string">&quot;app-name&quot;</span></span><br><span class="line">                ],</span><br><span class="line">                <span class="string">&quot;value&quot;</span>: <span class="string">&quot;航旅纵横&quot;</span></span><br><span class="line">              &#125;)</span><br><span class="line">            ])</span><br><span class="line">          &#125;),</span><br><span class="line">        aiot.<span class="title function_">__ci__</span>(&#123;...&#125;),</span><br><span class="line">        aiot.<span class="title function_">__ci__</span>(&#123;...&#125;),</span><br><span class="line">        ....</span><br><span class="line">      ])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/***/</span></span><br><span class="line">&#125;),</span><br></pre></td></tr></table></figure><p>Template本身是一个嵌套结构，它被翻译成了对aiot.<strong>ce</strong>, aiot__cf__, aiot.__ci__等函数的嵌套调用，嵌套调用的过程就是在Native层完成整个dom树构建的过程。</p><p>我们来看__cf__对应的C++源码，它用于创建一个逻辑循环节点：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DomEntity* <span class="title">dom_create_for_fragment</span><span class="params">(jse_context_ref ctx, <span class="type">jse_value_t</span> options, <span class="type">jse_value_t</span> func)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">AIOTJS_LOG_DEBUG</span>(<span class="string">&quot;dom_create_for_fragment ==================== &quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   ....</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建DomForFragment节点</span></span><br><span class="line">    DomForFragment *frag = <span class="keyword">new</span> <span class="built_in">DomForFragment</span>();</span><br><span class="line">    page-&gt;<span class="built_in">addDomEntity</span>(frag);</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存JS端传入的表达式和render函数</span></span><br><span class="line">    <span class="type">jse_value_t</span> exp = <span class="built_in">jse_get_object_property</span>(ctx, options, <span class="string">&quot;exp&quot;</span>);</span><br><span class="line">    frag-&gt;<span class="built_in">setExpress</span>(<span class="built_in">jse_dup_value</span>(ctx, exp));</span><br><span class="line">    frag-&gt;<span class="built_in">setRenderFunction</span>(<span class="built_in">jse_dup_value</span>(ctx, func));</span><br><span class="line">    <span class="built_in">jse_free_value</span>(ctx, exp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置key或者$idx</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建effect函数</span></span><br><span class="line">    <span class="type">jse_value_t</span> eff = <span class="built_in">create_effect</span>(ctx, dom_update_for_fragment, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">AIOTJS_LOG_DEBUG</span>(<span class="string">&quot;AddEffect for %d&quot;</span>, frag-&gt;<span class="built_in">uid</span>());</span><br><span class="line">    <span class="comment">//调用framework的effectWrap函数将effect函数传递给JS层保存</span></span><br><span class="line">    frag-&gt;<span class="built_in">addEffect</span>(ctx, <span class="built_in">dom_effect</span>(ctx, eff, frag-&gt;<span class="built_in">uid</span>(), <span class="number">0</span>));</span><br><span class="line">    <span class="built_in">jse_free_value</span>(ctx, eff);</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回创建好的frag vdom节点</span></span><br><span class="line">    <span class="keyword">return</span> frag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dom_update_for_fragment是C++端的节点更新函数，它最终会触发节点的render函数更新子节点：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DomForFragment::render</span><span class="params">(jse_context_ref ctx)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 递归构造</span></span><br><span class="line">    <span class="type">jse_value_t</span> exp_obj = <span class="built_in">jse_call</span>(ctx, exp_, JSE_UNDEFINED, <span class="number">0</span>, &#123;&#125;);</span><br><span class="line">    <span class="type">jse_value_t</span> expValue = JSE_UNDEFINED;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* str_tid = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用JS端的求值函数获取for循环对应的list对象 expValue</span></span><br><span class="line">    expValue = <span class="built_in">get_from_js_expression</span>();</span><br><span class="line">    </span><br><span class="line">    ....</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历数组</span></span><br><span class="line">    <span class="type">jse_size_t</span> len = <span class="built_in">jse_get_array_length</span>(ctx, expValue);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">jse_size_t</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="comment">//为每个element分别调用render函数</span></span><br><span class="line">        <span class="type">jse_value_t</span> idx = <span class="built_in">jse_uint</span>(ctx, i);</span><br><span class="line">        <span class="type">jse_value_t</span> args[] = &#123;</span><br><span class="line">            idx,</span><br><span class="line">            item</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">jse_value_t</span> res = <span class="built_in">jse_call</span>(ctx, render_, JSE_UNDEFINED, <span class="number">2</span>, args);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">jse_is_number</span>(res)) &#123;</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">int</span> cid = <span class="built_in">jse_to_uint_def</span>(ctx, res, <span class="number">0</span>);</span><br><span class="line">            DomEntity* ent = p-&gt;<span class="built_in">entity</span>(cid);</span><br><span class="line">            <span class="built_in">AIOTJS_CHECK_NE</span>(ent, <span class="literal">nullptr</span>);</span><br><span class="line">            ent-&gt;<span class="built_in">setDiffOperationType</span>(DomEntityDiffOperationType::Add);</span><br><span class="line">            <span class="built_in">addChild</span>(ent);</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">jse_is_undefined</span>(tid_value)) &#123;</span><br><span class="line">                <span class="type">jse_value_t</span> v_tid = <span class="built_in">jse_dup_value</span>(ctx, tid_value);</span><br><span class="line">                ent-&gt;<span class="built_in">setTid</span>(v_tid);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">jse_is_array</span>(ctx, res)) &#123;</span><br><span class="line">            <span class="type">jse_size_t</span> childlen = <span class="built_in">jse_get_array_length</span>(ctx, res);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">size_t</span> j=<span class="number">0</span>; j&lt;childlen; j++) &#123;</span><br><span class="line">                <span class="type">unsigned</span> <span class="type">int</span> cid = <span class="built_in">jse_get_array_idx_uint</span>(ctx, res, j, <span class="number">0</span>);</span><br><span class="line">                DomEntity* ent = p-&gt;<span class="built_in">entity</span>(cid);</span><br><span class="line">                <span class="built_in">AIOTJS_CHECK_NE</span>(ent, <span class="literal">nullptr</span>);</span><br><span class="line">                ent-&gt;<span class="built_in">setDiffOperationType</span>(DomEntityDiffOperationType::Add);</span><br><span class="line">                <span class="built_in">addChild</span>(ent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">jse_free_value</span>(ctx, res);</span><br><span class="line">        <span class="built_in">jse_free_value</span>(ctx, idx);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">jse_free_value</span>(ctx, item);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">jse_free_value</span>(ctx, expValue);</span><br><span class="line">    <span class="built_in">AIOTJS_LOG_DEBUG</span>(<span class="string">&quot;DomForFragment::build finished - &lt;%u&gt;&quot;</span>, <span class="built_in">uid</span>());</span><br><span class="line">    <span class="comment">// 只有初始化的时候返回true表示需要flush，其它情况下延迟flush</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">isBindingEffect</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="框架线程模型"><a href="#框架线程模型" class="headerlink" title="框架线程模型"></a>框架线程模型</h1><p>框架采用多线程模式，主要有如下两类线程：</p><ul><li>主线程：负责渲染，只有一个</li><li>应用线程：负责执行JS代码，响应数据变更并更新vdom</li></ul><p>主线程和应用线程各启动一个uv loop进行消息处理，这两个线程通过libuv进行异步通信，主要有如下几种场景：</p><ol><li>应用线程退出后异步通知主线程退出</li><li>应用线程更新vdom后异步通知主线程刷新ui</li><li>系统消息（如应用后台，应用退出等）由主线程发出，通过libuv转到应用线程执行</li></ol><h1 id="渲染流程分析"><a href="#渲染流程分析" class="headerlink" title="渲染流程分析"></a>渲染流程分析</h1><h2 id="渲染流程图"><a href="#渲染流程图" class="headerlink" title="渲染流程图"></a>渲染流程图</h2><p><img src="https://raw.githubusercontent.com/why862555625/images/main/images/33f7e704-ec72-4782-b8ff-1e58df0bef2d.svg" alt="33f7e704-ec72-4782-b8ff-1e58df0bef2d"></p><h2 id="渲染流程"><a href="#渲染流程" class="headerlink" title="渲染流程"></a>渲染流程</h2><p><img src="https://raw.githubusercontent.com/why862555625/images/main/images/6e8b9b04-5afd-47aa-9263-d3a379c1ac5b.svg" alt="6e8b9b04-5afd-47aa-9263-d3a379c1ac5b"></p><h1 id="框架核心部分介绍"><a href="#框架核心部分介绍" class="headerlink" title="框架核心部分介绍"></a>框架核心部分介绍</h1><h2 id="核心类图"><a href="#核心类图" class="headerlink" title="核心类图"></a>核心类图</h2><p><img src="https://raw.githubusercontent.com/why862555625/images/main/images/a8dc8b49-a594-454c-9309-164e3269c5e9.svg" alt="a8dc8b49-a594-454c-9309-164e3269c5e9"></p><p>解释：</p><ol><li>Framework是内部使用的框架类表示，FrameworkExt从Framework继承并添加了对vela系统的消息集成，在vela中使用FrameworkExt表示唯一的框架实例</li><li>FrameworkExt中会维护多个app实例，框架支持多应用切换</li><li>每个app实例包含一个JS运行上下文环境和相关的libuv句柄，它们封装在RuntimeContxt中，作为Application的成员变量保存，即一个Application对象唯一对应一个js运行上下文。</li><li>一个Applicatoin对象可以拥有多个Page对象，一个Page对象表示一个可显示的页面，实际是一颗vdom树</li><li>Page对象的继承关系较为复杂，框架支持自定义组件，从逻辑上讲，一个Component包含一颗vdom子树，它可以被任意组合来形成最终的完整vdom树。Page是最顶层的Component组件，唯一。从继承关系上讲，DomDocument这一层应该去掉，在添加子组件支持后它的语义已被Component取代，这层抽象当前代码中没有意义但仍然存在。</li></ol>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> quickjs </tag>
            
            <tag> devtools </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
