---
title: 算法复习
tags:
  - JS
categories: 面试
keywords: JS
description: 算法总结
top_img: 'https://raw.githubusercontent.com/why862555625/images/main/images/112.jpg'
sticky: 数值越大越靠前
cover: 'https://raw.githubusercontent.com/why862555625/images/main/images/112.jpg'
comments: false评论
abbrlink: fa264d8c
date: 2023-05-31 20:18:34
updated: 2023-05-31 20:18:34
---



算法复习

<!-- more -->

# 链表

## 1. 



![image-20230531202054172](https://raw.githubusercontent.com/why862555625/images/main/images/image-20230531202054172.png)

由于会直接返回翻转链表，最后一个就是翻转后的链表头。因此只需要保留前一个链表，让后一个链表不停的指向前一个链表就可以。

```js
function ReverseList(pHead)
{
    let pred =null;
    while(pHead){
        [pHead.next,pred,pHead] = [pred,pHead,pHead.next]
    }
    return pred
}
```

## 2.



![image-20230531225422160](https://raw.githubusercontent.com/why862555625/images/main/images/image-20230531225422160.png)

首先将中间需要翻转的那段拿出来单独翻转，可以将这段的最后一个设为null作为翻转结束的标志。然后将这段在插回来就可以了



```js
function reverse(head) {
    let pre = null;
    let cur = head;
    let next;
    while(cur) {
        next = cur.next;
        cur.next = pre;
         
        pre = cur;
        cur = next;
    }
    return [pre, head];
}
function reverseBetween( head ,  m ,  n ) {
    // 增加一个origin方便返回最终结果 origin.next
    // 因为head也有可能被翻转了
    const origin = { next: head };
    head = origin;
    let left, right;
    let i = 0;
    for(; i < m - 1; i++) {
        head = head.next;
    }
    left = head;
    for(; i < n; i++) {
        head = head.next;
    }
    right = head.next;
    head.next = null;
    const [ start, end ] = reverse(left.next);
    left.next = start;
    end.next = right;
    return  origin.next
}
module.exports = {
    reverseBetween : reverseBetween
};
```



## 3. 

![image-20230531232244456](https://raw.githubusercontent.com/why862555625/images/main/images/image-20230531232244456.png)

和上一题类似 只需要翻转前记录下前一个节点 和后一个节点  然后拼接起来就可以

```js
function reverse(head) {
    let pre = null;
    let cur = head;
    while(cur) {
        [cur.next,pre,cur] = [pre,cur,cur.next]
    }
    return [pre, head];
}
function reverseKGroup(head, k) {
    if(!head||!head.next||k ==1) return head
    let result ={'next':head},
    num = 0,
    //记录前一个翻转列表的尾结点
    prev = result
    //记录下一个翻转开始节点
    nextNode = head
    while(head){
        if(num+1 == k){
            //此时head为这一次翻转列表的最后一个节点  需要记录一下下一个翻转周期的开始节点
            let temp = head.next
            head.next = null
            let [start,end] = reverse(nextNode)
            nextNode  = temp
            prev.next = start
            prev = end
            num = 0
            if(!nextNode){break}
            head = nextNode.next
        }else{
            head = head.next
        }
        num ++
    }
    if(num){
        //如果还有剩余 补充到末尾
        prev.next = nextNode
    }
    return result.next
}
module.exports = {
    reverseKGroup: reverseKGroup,
};

```

## 4.

![image-20230601125414404](https://raw.githubusercontent.com/why862555625/images/main/images/image-20230601125414404.png)

双指针遍历 小的放到新链表中、由于是引用不会增加额外空间

```ts
export function Merge(pHead1: ListNode, pHead2: ListNode): ListNode {
    // write code here
    let result = new ListNode(-1)
    let cur = result
    while(pHead1&&pHead2){
        if(pHead1.val>pHead2.val){
            cur .next = pHead2
            pHead2 =pHead2.next

        }else{
            cur .next = pHead1
            pHead1 =pHead1.next
        }
        cur = cur.next

    }
    if(pHead1) 
            cur .next = pHead1
    if(pHead2) 
            cur .next = pHead2
    return result.next
}
```

## 5.

